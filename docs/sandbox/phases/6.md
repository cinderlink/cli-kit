# Phase 6: Error Correction & Legacy Code Removal

## Overview

This phase focuses on fixing architectural inconsistencies, removing legacy code, consolidating duplicate APIs, and ensuring the codebase adheres to TUIX standards. The goal is to streamline the plugin system, unify hook mechanisms, and eliminate code duplication.

## Dependencies

**Requires Phases 1-5 Complete:**
- ✅ Scope system implementation
- ✅ Event-driven architecture  
- ✅ JSX runtime integration
- ✅ Plugin nesting support
- ✅ Basic component system

## Technical Implementation

### 1. Plugin System Consolidation

#### Supported Plugin Definition Methods

The following are the ONLY supported ways to define plugins:

1. **Function-based with `definePlugin`**:
```typescript
const myPlugin = definePlugin({
  name: 'my-plugin',
  version: '1.0.0',
  commands: {
    hello: {
      handler: async (args) => console.log('Hello!')
    }
  }
})
```

2. **Class-based extending `BasePlugin`**:
```typescript
class MyPlugin extends BasePlugin {
  name = 'my-plugin'
  version = '1.0.0'
  
  async initialize() {
    this.registerCommand('hello', {
      handler: async (args) => console.log('Hello!')
    })
  }
}
```

3. **Interface-based with `implements PluginInterface`**:
```typescript
class MyPlugin implements PluginInterface {
  name = 'my-plugin'
  version = '1.0.0'
  
  commands = {
    hello: {
      handler: async (args) => console.log('Hello!')
    }
  }
}
```

4. **JSX Component-based**:
```tsx
<Plugin name="my-plugin" version="1.0.0">
  <Command name="hello" handler={async () => console.log('Hello!')} />
</Plugin>
```

#### Plugin Instantiation in JSX

Plugins are instantiated (not defined) in JSX using:

1. **LoadPlugin component**:
```tsx
<LoadPlugin plugin={MyPlugin} as="custom-scope-name" />
```

2. **Direct plugin component rendering**:
```tsx
<MyPlugin />
```

#### Tasks to Complete:

- [ ] Remove `createPlugin()` function - redundant with `definePlugin()`
- [ ] Remove `PluginBuilder` class - adds unnecessary complexity
- [ ] Remove `createPluginFromBuilder()` - no longer needed
- [ ] Update all examples to use only the supported methods
- [ ] Add deprecation warnings for removed methods
- [ ] Update plugin documentation

### 2. Hook System Unification

#### Current State
Multiple overlapping hook systems exist:
- `CLIHooks`
- `CommandHooks`
- `PluginMiddleware`
- Direct event subscriptions
- Plugin lifecycle methods

#### Target State
Single unified hook system that wraps event subscriptions:

```typescript
// Core hook system
interface UnifiedHooks {
  // Lifecycle hooks
  onBeforeInit: Hook<BeforeInitEvent>
  onAfterInit: Hook<AfterInitEvent>
  
  // Command hooks  
  onBeforeCommand: Hook<BeforeCommandEvent>
  onAfterCommand: Hook<AfterCommandEvent>
  
  // Plugin hooks
  onPluginLoad: Hook<PluginLoadEvent>
  onPluginUnload: Hook<PluginUnloadEvent>
  
  // Custom hooks via event system
  on: <T extends BaseEvent>(channel: string) => Hook<T>
}

// Hook is just a wrapper around event subscription
type Hook<T extends BaseEvent> = {
  subscribe: (handler: (event: T) => Effect<void, never>) => Subscription
  once: (handler: (event: T) => Effect<void, never>) => Subscription
  filter: (predicate: (event: T) => boolean) => Hook<T>
}
```

#### Tasks to Complete:

- [ ] Create unified `Hooks` module wrapping event system
- [ ] Deprecate `CLIHooks` - migrate to unified system
- [ ] Deprecate `CommandHooks` - migrate to unified system
- [ ] Convert `PluginMiddleware` to use unified hooks
- [ ] Update all hook usage in codebase
- [ ] Add migration guide for hook users

### 3. Remove Legacy and Duplicate Code

#### Identified Issues:

1. **Multiple Router Implementations**
   - Legacy direct-import router
   - Event-driven router
   - Keep only event-driven implementation

2. **Duplicate Test Utilities**
   - `simple-harness.ts` vs `harness.ts`
   - Multiple test setup files
   - Consolidate to single test utility module

3. **Unused React-style Components**
   - Remove any React-inspired lifecycle methods
   - Remove React-style state management
   - Keep only TUIX patterns (runes, MVU)

4. **Development Artifacts**
   - `.bak` files in examples
   - Commented-out code blocks
   - Test scripts outside of test suite

#### Tasks to Complete:

- [ ] Remove legacy router implementation
- [ ] Consolidate test utilities into single module
- [ ] Remove all React-style code patterns
- [ ] Delete all `.bak` files
- [ ] Remove commented code blocks
- [ ] Delete one-off test scripts

### 4. Standards Compliance Audit

#### Code Quality Standards to Enforce:

1. **Single Implementation Principle**
   - No `-v2`, `-enhanced`, `-simple` suffixes
   - One version of each feature
   - Proper deprecation for removed features

2. **Type Safety**
   - No `any` types
   - All Effects properly typed
   - Discriminated unions for variants

3. **Documentation**
   - JSDoc on all exports
   - Examples for complex APIs
   - Migration guides for changes

4. **Testing**
   - All features have tests
   - No test scripts outside test suite
   - Coverage meets thresholds

#### Tasks to Complete:

- [ ] Run full TypeScript strict check
- [ ] Audit for `any` type usage
- [ ] Ensure all exports have JSDoc
- [ ] Verify test coverage thresholds
- [ ] Remove duplicate implementations

### 5. Missing Test Coverage

#### Areas Needing Tests:

1. **Event-Driven Architecture**
   - Event bus performance under load
   - Module communication edge cases
   - Event ordering guarantees

2. **Plugin System**
   - Plugin isolation
   - Dependency resolution
   - Hot reload functionality

3. **Scope System**
   - Hierarchical command routing
   - Scope lifecycle management
   - Collision detection

4. **JSX Runtime**
   - Component lifecycle
   - State management with runes
   - Error boundaries

#### Tasks to Complete:

- [ ] Write event bus stress tests
- [ ] Add plugin isolation tests
- [ ] Test scope hierarchy edge cases
- [ ] Add JSX component lifecycle tests
- [ ] Ensure 80% code coverage minimum

### 6. API Simplification

#### Current Complexity Issues:

1. **Too Many Ways to Do Things**
   - 4+ ways to create plugins
   - Multiple hook systems
   - Duplicate utilities

2. **Unclear Boundaries**
   - When to use events vs direct calls
   - Plugin vs component responsibilities
   - Core vs module functionality

3. **Inconsistent Naming**
   - Mix of camelCase and kebab-case
   - Inconsistent event names
   - Unclear module names

#### Target Simplified API:

```typescript
// Clear, minimal API surface
export {
  // Plugin definition
  definePlugin,
  BasePlugin,
  PluginInterface,
  
  // Hooks (unified)
  hooks,
  
  // Core runtime
  createApp,
  
  // JSX components
  Plugin,
  LoadPlugin,
  Command,
  
  // Utilities
  Effect,
  runes
}
```

#### Tasks to Complete:

- [ ] Create clear public API exports
- [ ] Mark internal APIs as private
- [ ] Standardize naming conventions
- [ ] Document when to use each API
- [ ] Create API migration guide

## Implementation Order

1. **Week 1: Plugin System Consolidation**
   - Remove deprecated plugin creation methods
   - Update all examples and tests
   - Document final plugin API

2. **Week 2: Hook System Unification**
   - Implement unified hooks wrapper
   - Migrate existing hook usage
   - Remove deprecated hook systems

3. **Week 3: Legacy Code Removal**
   - Delete duplicate implementations
   - Remove development artifacts
   - Clean up commented code

4. **Week 4: Standards & Testing**
   - Fix all type safety issues
   - Add missing documentation
   - Write missing tests

## Success Criteria

✅ **Single Plugin API**: Only 4 ways to define plugins (function, class, interface, JSX)
✅ **Unified Hooks**: One hook system wrapping events
✅ **No Duplication**: All duplicate code removed
✅ **Standards Compliance**: No `any` types, all exports documented
✅ **Test Coverage**: Minimum 80% coverage on all modules
✅ **Clean Codebase**: No .bak files, commented code, or dev artifacts
✅ **Clear API**: Minimal, well-documented public API

## Migration Guide

For users upgrading from the old API:

### Plugin Creation
```typescript
// OLD - DEPRECATED
const plugin = createPlugin({ name: 'my-plugin' })
const plugin = new PluginBuilder().name('my-plugin').build()

// NEW - USE THESE
const plugin = definePlugin({ name: 'my-plugin' })
class MyPlugin extends BasePlugin { }
```

### Hook Usage
```typescript
// OLD - DEPRECATED
CLIHooks.beforeCommand(() => { })
CommandHooks.afterExecute(() => { })

// NEW - UNIFIED
hooks.onBeforeCommand(event => Effect.sync(() => { }))
hooks.onAfterCommand(event => Effect.sync(() => { }))
```

### Plugin Instantiation
```typescript
// OLD - DEPRECATED
<RegisterPlugin plugin={MyPlugin} />
app.registerPlugin(MyPlugin)

// NEW - USE THESE
<LoadPlugin plugin={MyPlugin} />
<MyPlugin />
```

## Notes

This phase is about cleaning up technical debt and ensuring the codebase is maintainable, consistent, and follows TUIX principles. It's not about adding new features but rather consolidating and simplifying what already exists.