# Phase 5: Component System Integration

## ARCHITECTURAL DESIGN PROPOSAL
### Status: ✅ Implemented
This document describes the reactive component system integration for TUIX. The reactive component architecture, advanced lifecycle management, and component coordination patterns have been successfully implemented in Phase 5.

### Learnings from Phase 1 (Added Post-Implementation)
Phase 1 was successfully completed using the existing direct-import architecture. Before implementing this phase, evaluate whether the complexity of reactive component coordination is justified by actual requirements. The current architecture has proven robust for plugin management and may be sufficient.

## Overview

Integrate the component system with the event-driven architecture, implementing reactive UI updates, advanced component lifecycle management, and sophisticated component coordination patterns.

## Dependencies

**Requires Phase 4 Complete:**
- ✅ Advanced cross-module coordination patterns
- ✅ Performance monitoring and optimization
- ✅ Error recovery and workflow orchestration
- ✅ Event choreography for complex workflows

## Technical Implementation

### 1. Reactive Component Architecture

**File to Create:** `src/components/reactive/reactive-component.tsx`

```typescript
import React, { useEffect, useState, useRef, useMemo } from 'react'
import { Effect, Stream, Ref } from 'effect'
import { EventBus, BaseEvent } from '../../core/bus'
import { ScopeContext } from '../../core/scope'

// Base reactive component that responds to events
export abstract class ReactiveComponent<P = {}, S = {}> extends React.Component<P, S> {
  private eventSubscriptions: Effect.Effect<void, never>[] = []
  private eventBus: EventBus
  private scope?: ScopeContext
  
  constructor(props: P, eventBus: EventBus) {
    super(props)
    this.eventBus = eventBus
  }
  
  componentDidMount() {
    this.setupEventSubscriptions()
    this.onComponentReactive()
  }
  
  componentWillUnmount() {
    this.cleanupEventSubscriptions()
    this.onComponentUnreactive()
  }
  
  // Abstract methods for subclasses
  abstract getEventChannels(): string[]
  abstract handleEvent(event: BaseEvent): Effect<void, never>
  
  // Optional lifecycle hooks
  protected onComponentReactive(): void {}
  protected onComponentUnreactive(): void {}
  
  private setupEventSubscriptions(): void {
    for (const channel of this.getEventChannels()) {
      const subscription = Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<BaseEvent>(channel),
          event => this.handleEvent(event)
        )
      )
      
      this.eventSubscriptions.push(subscription)
    }
  }
  
  private cleanupEventSubscriptions(): void {
    for (const subscription of this.eventSubscriptions) {
      Effect.runSync(subscription)
    }
    this.eventSubscriptions = []
  }
  
  // Emit events from component
  protected emitEvent<T extends BaseEvent>(channel: string, event: Omit<T, 'id' | 'source' | 'timestamp'>): Effect<void, never> {
    const fullEvent = {
      ...event,
      source: this.constructor.name,
      timestamp: new Date(),
      id: `${this.constructor.name}-${Date.now()}-${Math.random().toString(36).slice(2)}`
    } as T
    
    return this.eventBus.publish(channel, fullEvent)
  }
  
  // Update component state from events
  protected updateStateFromEvent(updater: (prevState: S) => S): void {
    this.setState(updater)
  }
}

// Hook-based reactive component
export function useReactiveEvents<T extends BaseEvent>(
  eventBus: EventBus,
  channel: string,
  handler: (event: T) => void,
  deps: React.DependencyList = []
): void {
  useEffect(() => {
    const subscription = Effect.runSync(
      Effect.fork(
        Stream.runForeach(
          eventBus.subscribe<T>(channel),
          event => Effect.sync(() => handler(event))
        )
      )
    )
    
    return () => {
      Effect.runSync(subscription)
    }
  }, deps)
}

// Hook for emitting events from functional components
export function useEventEmitter(
  eventBus: EventBus,
  componentName: string
): <T extends BaseEvent>(channel: string, event: Omit<T, 'id' | 'source' | 'timestamp'>) => void {
  return useMemo(
    () => <T extends BaseEvent>(channel: string, event: Omit<T, 'id' | 'source' | 'timestamp'>) => {
      const fullEvent = {
        ...event,
        source: componentName,
        timestamp: new Date(),
        id: `${componentName}-${Date.now()}-${Math.random().toString(36).slice(2)}`
      } as T
      
      Effect.runSync(eventBus.publish(channel, fullEvent))
    },
    [eventBus, componentName]
  )
}

// Hook for reactive state management
export function useReactiveState<T>(
  eventBus: EventBus,
  channel: string,
  initialValue: T,
  selector?: (event: BaseEvent) => T | undefined
): [T, (value: T) => void] {
  const [state, setState] = useState<T>(initialValue)
  const emit = useEventEmitter(eventBus, 'useReactiveState')
  
  useReactiveEvents(
    eventBus,
    channel,
    (event) => {
      const newValue = selector ? selector(event) : event.payload as T
      if (newValue !== undefined) {
        setState(newValue)
      }
    }
  )
  
  const setValue = useMemo(
    () => (newValue: T) => {
      setState(newValue)
      emit(channel, {
        type: 'state-changed',
        payload: newValue
      })
    },
    [channel, emit]
  )
  
  return [state, setValue]
}
```

### 2. Advanced Component Lifecycle

**File to Create:** `src/components/lifecycle/lifecycle-manager.ts`

```typescript
import { Effect, Ref, Duration } from 'effect'
import { EventBus } from '../../core/bus'
import { ScopeContext } from '../../core/scope'

// Advanced lifecycle management for components
export class ComponentLifecycleManager {
  private components = new Map<string, ComponentInstance>()
  private lifecycleHooks = new Map<string, LifecycleHook[]>()
  
  constructor(private eventBus: EventBus) {}
  
  // Register a component with advanced lifecycle management
  registerComponent(
    componentId: string,
    element: JSX.Element,
    scope?: ScopeContext,
    config?: ComponentConfig
  ): Effect<void, ComponentError> {
    return Effect.gen(function* () {
      const instance: ComponentInstance = {
        id: componentId,
        element,
        scope,
        config: config || {},
        state: 'initializing',
        mountTime: new Date(),
        updateCount: 0,
        errorCount: 0
      }
      
      this.components.set(componentId, instance)
      
      // Execute pre-mount hooks
      yield* this.executeHooks('pre-mount', instance)
      
      // Set up automatic lifecycle monitoring
      yield* this.setupLifecycleMonitoring(instance)
      
      // Execute post-mount hooks
      yield* this.executeHooks('post-mount', instance)
      
      instance.state = 'mounted'
      
      // Emit component mounted event
      yield* this.eventBus.publish('component-lifecycle', {
        type: 'component-mounted',
        source: 'lifecycle-manager',
        timestamp: new Date(),
        id: generateId(),
        payload: {
          componentId,
          elementType: element.type,
          scope: scope?.path
        }
      })
    }.bind(this))
  }
  
  // Update component with change detection
  updateComponent(
    componentId: string,
    newProps: Record<string, unknown>,
    reason: 'props-change' | 'state-change' | 'force-update'
  ): Effect<void, ComponentError> {
    return Effect.gen(function* () {
      const instance = this.components.get(componentId)
      if (!instance) {
        yield* Effect.fail(new ComponentNotFoundError(componentId))
      }
      
      const oldProps = instance!.element.props
      const hasPropsChanged = this.hasPropsChanged(oldProps, newProps)
      
      if (!hasPropsChanged && reason !== 'force-update') {
        return // Skip unnecessary update
      }
      
      // Execute pre-update hooks
      yield* this.executeHooks('pre-update', instance!, { oldProps, newProps, reason })
      
      // Update the instance
      instance!.element = { ...instance!.element, props: newProps }
      instance!.updateCount++
      instance!.lastUpdate = new Date()
      
      // Execute post-update hooks
      yield* this.executeHooks('post-update', instance!, { oldProps, newProps, reason })
      
      // Emit component updated event
      yield* this.eventBus.publish('component-lifecycle', {
        type: 'component-updated',
        source: 'lifecycle-manager',
        timestamp: new Date(),
        id: generateId(),
        payload: {
          componentId,
          reason,
          updateCount: instance!.updateCount,
          propsChanged: hasPropsChanged
        }
      })
    }.bind(this))
  }
  
  // Get component metrics
  getComponentMetrics(componentId: string): Effect<ComponentMetrics | null, never> {
    return Effect.sync(() => {
      const instance = this.components.get(componentId)
      if (!instance) return null
      
      return {
        componentId,
        state: instance.state,
        lifetime: Date.now() - instance.mountTime.getTime(),
        updateCount: instance.updateCount,
        errorCount: instance.errorCount,
        lastUpdate: instance.lastUpdate,
        memoryUsage: this.estimateComponentMemoryUsage(instance)
      }
    })
  }
  
  private executeHooks(
    phase: LifecyclePhase,
    instance: ComponentInstance,
    context?: Record<string, unknown>
  ): Effect<void, never> {
    const hooks = this.lifecycleHooks.get(phase) || []
    
    return Effect.all(
      hooks.map(hook => 
        hook(instance, context).pipe(
          Effect.catchAll(error => 
            Effect.sync(() => {
              instance.errorCount++
              console.error(`Lifecycle hook error in ${phase}:`, error)
            })
          )
        )
      )
    ).pipe(Effect.asVoid)
  }
}

type LifecyclePhase = 'pre-mount' | 'post-mount' | 'pre-update' | 'post-update' | 'pre-unmount' | 'post-unmount'
type LifecycleHook = (instance: ComponentInstance, context?: Record<string, unknown>) => Effect<void, never>

interface ComponentInstance {
  id: string
  element: JSX.Element
  scope?: ScopeContext
  config: ComponentConfig
  state: 'initializing' | 'mounted' | 'unmounting' | 'unmounted'
  mountTime: Date
  lastUpdate?: Date
  updateCount: number
  errorCount: number
}

interface ComponentConfig {
  enableHealthMonitoring?: boolean
  updateBatchingEnabled?: boolean
  errorRecoveryEnabled?: boolean
}

interface ComponentMetrics {
  componentId: string
  state: ComponentInstance['state']
  lifetime: number
  updateCount: number
  errorCount: number
  lastUpdate?: Date
  memoryUsage: number
}
```

### 3. Event-Driven Component Coordination

**File to Create:** `src/components/coordination/component-coordinator.ts`

```typescript
// Coordinate complex interactions between components
export class ComponentCoordinator {
  private coordinationPatterns = new Map<string, CoordinationPattern>()
  private activeCoordinations = new Map<string, ActiveCoordination>()
  
  constructor(private eventBus: EventBus) {}
  
  // Register coordination pattern
  registerPattern(pattern: CoordinationPattern): Effect<void, never> {
    return Effect.sync(() => {
      this.coordinationPatterns.set(pattern.id, pattern)
    })
  }
  
  // Start coordination between components
  startCoordination(
    coordinationId: string,
    patternId: string,
    participants: string[],
    config?: Record<string, unknown>
  ): Effect<void, CoordinationError> {
    return Effect.gen(function* () {
      const pattern = this.coordinationPatterns.get(patternId)
      if (!pattern) {
        yield* Effect.fail(new CoordinationPatternNotFoundError(patternId))
      }
      
      const coordination: ActiveCoordination = {
        id: coordinationId,
        pattern: pattern!,
        participants,
        config: config || {},
        startTime: new Date(),
        state: 'active',
        eventHandlers: []
      }
      
      // Set up event handlers for this coordination
      for (const eventType of pattern!.eventTypes) {
        const handler = Effect.fork(
          Stream.runForeach(
            this.eventBus.subscribe<BaseEvent>(eventType),
            event => this.handleCoordinationEvent(coordination, event)
          )
        )
        
        coordination.eventHandlers.push(handler)
      }
      
      this.activeCoordinations.set(coordinationId, coordination)
      
      // Execute pattern initialization
      yield* pattern!.initialize(coordination)
    }.bind(this))
  }
  
  // Stop coordination
  stopCoordination(coordinationId: string): Effect<void, never> {
    return Effect.gen(function* () {
      const coordination = this.activeCoordinations.get(coordinationId)
      if (!coordination) return
      
      coordination.state = 'stopping'
      
      // Clean up event handlers
      yield* Effect.all(
        coordination.eventHandlers.map(handler => Fiber.interrupt(handler))
      )
      
      // Execute pattern cleanup
      yield* coordination.pattern.cleanup(coordination).pipe(
        Effect.catchAll(() => Effect.void)
      )
      
      coordination.state = 'stopped'
      this.activeCoordinations.delete(coordinationId)
    }.bind(this))
  }
}

interface CoordinationPattern {
  id: string
  name: string
  eventTypes: string[]
  initialize: (coordination: ActiveCoordination) => Effect<void, never>
  handleEvent: (event: BaseEvent, coordination: ActiveCoordination) => Effect<void, never>
  isEventRelevant: (event: BaseEvent, coordination: ActiveCoordination) => boolean
  cleanup: (coordination: ActiveCoordination) => Effect<void, never>
}

interface ActiveCoordination {
  id: string
  pattern: CoordinationPattern
  participants: string[]
  config: Record<string, unknown>
  startTime: Date
  state: 'active' | 'stopping' | 'stopped'
  eventHandlers: Effect.Effect<void, never>[]
}
```

### 4. Performance-Optimized Component Rendering

**File to Create:** `src/components/performance/optimized-renderer.ts`

```typescript
// Performance-optimized rendering with intelligent batching
export class OptimizedRenderer {
  private renderQueue = new Map<string, RenderTask>()
  private batchTimer: NodeJS.Timeout | null = null
  private renderCache = new Map<string, CachedRender>()
  
  constructor(
    private eventBus: EventBus,
    private lifecycleManager: ComponentLifecycleManager
  ) {}
  
  // Queue component for rendering with batching
  queueRender(
    componentId: string,
    element: JSX.Element,
    priority: RenderPriority = 'normal',
    reason: RenderReason = 'update'
  ): Effect<void, never> {
    return Effect.sync(() => {
      const task: RenderTask = {
        componentId,
        element,
        priority,
        reason,
        timestamp: Date.now()
      }
      
      this.renderQueue.set(componentId, task)
      
      // Schedule batch processing
      this.scheduleBatchRender()
    })
  }
  
  // Force immediate render (bypasses batching)
  forceRender(
    componentId: string,
    element: JSX.Element
  ): Effect<RenderResult, RenderError> {
    return Effect.gen(function* () {
      const startTime = Date.now()
      
      try {
        // Check cache first
        const cached = this.getCachedRender(componentId, element)
        if (cached) {
          yield* this.emitRenderEvent('render-cache-hit', componentId, element, startTime)
          return cached.result
        }
        
        // Perform actual render
        const result = yield* this.performRender(componentId, element)
        const renderTime = Date.now() - startTime
        
        // Cache result if cacheable
        if (this.isCacheable(element, renderTime)) {
          this.cacheRender(componentId, element, result, renderTime)
        }
        
        yield* this.emitRenderEvent('render-complete', componentId, element, renderTime)
        return result
        
      } catch (error) {
        const renderTime = Date.now() - startTime
        yield* this.emitRenderEvent('render-error', componentId, element, renderTime, error as Error)
        return yield* Effect.fail(error as RenderError)
      }
    }.bind(this))
  }
  
  private scheduleBatchRender(): void {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer)
    }
    
    this.batchTimer = setTimeout(() => {
      Effect.runSync(this.processBatchRender())
    }, 16) // 60fps
  }
  
  private processBatchRender(): Effect<void, never> {
    return Effect.gen(function* () {
      if (this.renderQueue.size === 0) return
      
      // Sort tasks by priority and timestamp
      const tasks = Array.from(this.renderQueue.values()).sort((a, b) => {
        const priorityOrder = { 'high': 0, 'normal': 1, 'low': 2 }
        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority]
        if (priorityDiff !== 0) return priorityDiff
        
        return a.timestamp - b.timestamp
      })
      
      // Clear queue
      this.renderQueue.clear()
      
      // Group tasks for batch processing
      const batches = this.groupTasksIntoBatches(tasks)
      
      for (const batch of batches) {
        yield* this.processBatch(batch)
      }
    }.bind(this))
  }
}

type RenderPriority = 'high' | 'normal' | 'low'
type RenderReason = 'mount' | 'update' | 'force' | 'batch'

interface RenderTask {
  componentId: string
  element: JSX.Element
  priority: RenderPriority
  reason: RenderReason
  timestamp: number
}

interface RenderResult {
  componentId: string
  output: string
  metrics: {
    renderTime: number
    nodeCount: number
    memoryUsage: number
  }
}
```

### 5. Component System Module Integration

**File to Create:** `src/components/module.ts`

```typescript
// Main component system module
export class ComponentSystemModule extends ModuleBase {
  private lifecycleManager: ComponentLifecycleManager
  private coordinator: ComponentCoordinator
  private renderer: OptimizedRenderer
  private performanceMonitor: ComponentPerformanceMonitor
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'component-system')
    
    this.lifecycleManager = new ComponentLifecycleManager(eventBus)
    this.coordinator = new ComponentCoordinator(eventBus)
    this.renderer = new OptimizedRenderer(eventBus, this.lifecycleManager)
    this.performanceMonitor = new ComponentPerformanceMonitor(eventBus)
  }
  
  initialize(): Effect<void, ComponentSystemError> {
    return Effect.gen(function* () {
      // Initialize subsystems
      yield* this.performanceMonitor.initialize()
      
      // Register default coordination patterns
      yield* this.registerDefaultCoordinationPatterns()
      
      // Set up component event monitoring
      yield* this.setupComponentEventMonitoring()
      
      // Register lifecycle hooks
      yield* this.registerDefaultLifecycleHooks()
      
      yield* this.emitEvent('component-system-events', {
        type: 'component-system-initialized',
        timestamp: new Date()
      })
    }.bind(this))
  }
  
  // Main API for component management
  createComponent(
    componentId: string,
    element: JSX.Element,
    config?: ComponentConfig
  ): Effect<ComponentHandle, ComponentError> {
    return Effect.gen(function* () {
      // Register with lifecycle manager
      yield* this.lifecycleManager.registerComponent(componentId, element, undefined, config)
      
      // Queue for initial render
      yield* this.renderer.queueRender(componentId, element, 'high', 'mount')
      
      // Create component handle
      const handle: ComponentHandle = {
        id: componentId,
        update: (newProps: Record<string, unknown>, reason = 'update') =>
          this.updateComponent(componentId, newProps, reason),
        destroy: () => this.destroyComponent(componentId),
        getMetrics: () => this.lifecycleManager.getComponentMetrics(componentId),
        forceRender: () => this.renderer.forceRender(componentId, element)
      }
      
      return handle
    }.bind(this))
  }
  
  // Performance API
  getSystemPerformanceMetrics(): Effect<ComponentSystemMetrics, never> {
    return Effect.gen(function* () {
      const performanceMetrics = yield* this.performanceMonitor.getMetrics()
      const activeComponents = yield* this.getActiveComponentCount()
      const memoryUsage = yield* this.estimateSystemMemoryUsage()
      
      return {
        timestamp: new Date(),
        performance: performanceMetrics,
        activeComponents,
        memoryUsage,
        renderingStats: yield* this.renderer.getRenderingStats()
      }
    }.bind(this))
  }
}

interface ComponentHandle {
  id: string
  update: (newProps: Record<string, unknown>, reason?: string) => Effect<void, ComponentError>
  destroy: () => Effect<void, never>
  getMetrics: () => Effect<ComponentMetrics | null, never>
  forceRender: () => Effect<RenderResult, RenderError>
}

interface ComponentSystemMetrics {
  timestamp: Date
  performance: PerformanceMetrics
  activeComponents: number
  memoryUsage: number
  renderingStats: RenderingStats
}
```

### 6. Example Component System Usage

**File to Create:** `examples/component-system-demo.tsx`

```tsx
import React, { useEffect, useState } from 'react'
import { Effect } from 'effect'
import { 
  ReactiveComponent, 
  useReactiveEvents, 
  useEventEmitter, 
  useReactiveState 
} from '../src/components/reactive/reactive-component'

// Example: Process monitoring dashboard with reactive components
export function ProcessMonitoringDashboard({ eventBus }: { eventBus: EventBus }) {
  const [selectedProcess, setSelectedProcess] = useReactiveState(
    eventBus,
    'process-selection',
    null as ProcessInfo | null
  )
  
  const [processes, setProcesses] = useReactiveState(
    eventBus,
    'process-events',
    [] as ProcessInfo[],
    (event) => {
      if (event.type === 'process-started') {
        return event.payload as ProcessInfo
      }
    }
  )
  
  const emit = useEventEmitter(eventBus, 'ProcessMonitoringDashboard')
  
  // Set up component coordination
  useEffect(() => {
    const coordination = Effect.runSync(
      ComponentSystemModule.startComponentCoordination(
        'process-dashboard',
        'master-detail',
        ['process-list', 'process-details'],
        {
          masterId: 'process-list',
          detailId: 'process-details'
        }
      )
    )
    
    return () => {
      Effect.runSync(
        ComponentSystemModule.stopComponentCoordination('process-dashboard')
      )
    }
  }, [])
  
  return (
    <div className="process-dashboard">
      <div className="dashboard-header">
        <h1>Process Monitor</h1>
        <ProcessStatusSummary processes={processes} />
      </div>
      
      <div className="dashboard-content">
        <ProcessList
          componentId="process-list"
          processes={processes}
          selectedProcess={selectedProcess}
          onSelectProcess={(process) => {
            setSelectedProcess(process)
            emit('process-selection', {
              type: 'component-selection',
              componentId: 'process-list',
              selectedItem: process
            })
          }}
        />
        
        <ProcessDetails
          componentId="process-details"
          process={selectedProcess}
          eventBus={eventBus}
        />
      </div>
    </div>
  )
}
```

## Files Modified

### New Component System Files
- `src/components/reactive/reactive-component.tsx` - Base reactive component architecture
- `src/components/reactive/reactive-ui.tsx` - Reactive UI component examples
- `src/components/lifecycle/lifecycle-manager.ts` - Advanced lifecycle management
- `src/components/coordination/component-coordinator.ts` - Component coordination patterns
- `src/components/performance/optimized-renderer.ts` - Performance-optimized rendering
- `src/components/module.ts` - Main component system module

### Enhanced Core Files
- `src/core/module-registry.ts` - Add component system module
- `src/core/events.ts` - Add component system event types

### Example Files
- `examples/component-system-demo.tsx` - Process monitoring dashboard
- `examples/reactive-components-demo.tsx` - Reactive component patterns
- `examples/component-coordination-demo.tsx` - Component coordination examples

### Integration Files
- `src/jsx/runtime.ts` - Integration with component system
- `src/reactivity/lifecycle.ts` - Integration with component lifecycle
- `src/styling/module.ts` - Integration with component rendering

### Test Files
- `src/components/reactive/reactive-component.test.tsx`
- `src/components/lifecycle/lifecycle-manager.test.ts`
- `src/components/coordination/component-coordinator.test.ts`
- `src/components/performance/optimized-renderer.test.ts`
- `tests/e2e/component-system-integration.test.ts`
- `tests/performance/component-rendering-benchmarks.test.ts`

## Success Criteria

✅ **Reactive Component Architecture**: Components respond to events automatically
✅ **Advanced Lifecycle Management**: Sophisticated component lifecycle with performance monitoring
✅ **Component Coordination**: Complex component interactions through coordination patterns
✅ **Performance-Optimized Rendering**: Intelligent batching and caching for optimal performance
✅ **Event-Driven UI Updates**: Real-time UI updates based on system events
✅ **Memory Management**: Automatic memory leak detection and cleanup
✅ **Component Metrics**: Comprehensive performance and health metrics for all components
✅ **Developer Experience**: Easy-to-use hooks and patterns for reactive development

## Dependencies for Next Phase

**Phase 5 Provides for Phase 6:**
- ✅ Reactive component foundation for plugin UI development
- ✅ Advanced component coordination for plugin interactions
- ✅ Performance monitoring for plugin performance optimization
- ✅ Component lifecycle management for plugin lifecycle integration
- ✅ Event-driven component architecture for plugin event handling