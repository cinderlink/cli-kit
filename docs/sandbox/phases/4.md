# Phase 4: Advanced Cross-Module Coordination

## ARCHITECTURAL DESIGN PROPOSAL
### Status: ✅ Implemented
This phase has been successfully implemented. The advanced cross-module coordination system is now active in TUIX, including event choreography, workflow orchestration, stream optimization, performance monitoring, error recovery, and integration patterns.

### Learnings from Phase 1 (Added Post-Implementation)
Phase 1 was successfully completed using the existing direct-import architecture. Before implementing this phase, evaluate whether the complexity of event choreography is justified by actual requirements. The current architecture has proven robust for plugin management and may be sufficient.

## Overview

Implement advanced event choreography and cross-module coordination patterns. Establish complex workflows that span multiple domains, event stream optimization, and sophisticated integration patterns for real-world use cases.

## Dependencies

**Requires Phase 3 Complete:**
- ✅ All service modules integrated with event system
- ✅ Config, Process, Logger, and Styling modules event-enabled
- ✅ Domain-specific emitters and listeners working
- ✅ Basic cross-module communication established

## Technical Implementation

### 1. Event Choreography Patterns

**File to Create:** `src/core/coordination/choreography.ts`
```typescript
import { Effect, Stream, Duration } from 'effect'
import { EventBus, BaseEvent } from '../bus'
import { ModuleBase } from '../module-base'

// Event choreography for complex multi-module workflows
export class EventChoreographer extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'choreographer')
  }
  
  // Coordinate process manager + logging workflow
  coordinateProcessWithLogging(): Effect<void, ChoreographyError> {
    return Effect.gen(function* () {
      // Create coordinated subscription to process events
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<ProcessEvent>('process-events'),
          event => this.handleProcessEventForLogging(event)
        )
      )
      
      // Subscribe to process output for structured logging
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<ProcessOutputEvent>('process-output'),
          event => this.handleProcessOutput(event)
        )
      )
      
      // Monitor process health and trigger notifications
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<ProcessHealthEvent>('process-health'),
          event => this.handleHealthEvent(event)
        )
      )
    }.bind(this))
  }
  
  // Coordinate CLI execution with real-time UI updates
  coordinateCLIWithUI(): Effect<void, ChoreographyError> {
    return Effect.gen(function* () {
      // Stream CLI execution events to UI components
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<CLICommandEvent>('cli-command'),
          event => this.updateUIForCLIEvent(event)
        )
      )
      
      // Handle parse errors with user-friendly feedback
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<CLIParseEvent>('cli-parse'),
          event => this.handleParseEventForUI(event)
        )
      )
    }.bind(this))
  }
  
  // Coordinate config changes across all modules
  coordinateConfigUpdates(): Effect<void, ChoreographyError> {
    return Effect.gen(function* () {
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<ConfigEvent>('config-events'),
          event => this.propagateConfigChange(event)
        )
      )
    }.bind(this))
  }
  
  private handleProcessEventForLogging(event: ProcessEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'process-started':
          yield* this.emitEvent('log-events', {
            type: 'log-entry',
            level: 'info',
            message: `Process ${event.processName} started with PID ${event.pid}`,
            context: {
              processId: event.processId,
              config: event.config
            }
          })
          break
          
        case 'process-crashed':
          yield* this.emitEvent('log-events', {
            type: 'log-entry',
            level: 'error',
            message: `Process ${event.processName} crashed with exit code ${event.exitCode}`,
            context: {
              processId: event.processId,
              exitCode: event.exitCode
            }
          })
          
          // Also trigger notification
          yield* this.emitEvent('notification-events', {
            type: 'notification-error',
            title: 'Process Crashed',
            message: `${event.processName} has stopped unexpectedly`,
            processId: event.processId
          })
          break
      }
    }.bind(this))
  }
  
  private updateUIForCLIEvent(event: CLICommandEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'cli-command-executed':
          // Update UI with command execution status
          yield* this.emitEvent('ui-update', {
            type: 'command-status-update',
            commandPath: event.path,
            status: 'completed',
            executionTime: event.executionTime,
            result: event.result
          })
          break
          
        case 'cli-command-failed':
          // Show error in UI
          yield* this.emitEvent('ui-update', {
            type: 'command-error',
            commandPath: event.path,
            error: event.error
          })
          break
      }
    }.bind(this))
  }
  
  private propagateConfigChange(event: ConfigEvent): Effect<void, never> {
    return Effect.gen(function* () {
      if (event.type === 'config-updated') {
        // Notify all relevant modules of config changes
        const affectedModules = this.getModulesAffectedByConfig(event.section)
        
        for (const module of affectedModules) {
          yield* this.emitEvent(`${module}-config`, {
            type: 'config-change-notification',
            section: event.section,
            value: event.value,
            module
          })
        }
      }
    }.bind(this))
  }
  
  private getModulesAffectedByConfig(section?: string): string[] {
    if (!section) return ['jsx', 'cli', 'services', 'process-manager', 'logger', 'styling']
    
    // Map config sections to affected modules
    const sectionMapping: Record<string, string[]> = {
      'theme': ['styling', 'jsx'],
      'logging': ['logger', 'process-manager'],
      'terminal': ['services', 'jsx'],
      'processes': ['process-manager', 'cli']
    }
    
    return sectionMapping[section] || []
  }
}
```

**File to Create:** `src/core/coordination/orchestrator.ts`
```typescript
// High-level orchestration for complex workflows
export class WorkflowOrchestrator extends ModuleBase {
  private choreographer: EventChoreographer
  private activeWorkflows = new Map<string, WorkflowInstance>()
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'orchestrator')
    this.choreographer = new EventChoreographer(eventBus)
  }
  
  // Start complex workflow with multiple coordination patterns
  startComplexWorkflow(workflowId: string, config: WorkflowConfig): Effect<WorkflowResult, WorkflowError> {
    return Effect.gen(function* () {
      const workflow: WorkflowInstance = {
        id: workflowId,
        config,
        startTime: new Date(),
        status: 'running',
        steps: []
      }
      
      this.activeWorkflows.set(workflowId, workflow)
      
      try {
        // Step 1: Initialize all required modules
        yield* this.initializeWorkflowModules(config.requiredModules)
        
        // Step 2: Set up cross-module coordination
        yield* this.choreographer.coordinateProcessWithLogging()
        yield* this.choreographer.coordinateCLIWithUI()
        yield* this.choreographer.coordinateConfigUpdates()
        
        // Step 3: Execute workflow steps in sequence
        for (const step of config.steps) {
          yield* this.executeWorkflowStep(workflowId, step)
        }
        
        // Step 4: Finalize and cleanup
        workflow.status = 'completed'
        workflow.endTime = new Date()
        
        return {
          workflowId,
          status: 'completed',
          duration: workflow.endTime.getTime() - workflow.startTime.getTime(),
          steps: workflow.steps
        }
        
      } catch (error) {
        workflow.status = 'failed'
        workflow.error = error as Error
        
        return yield* Effect.fail(new WorkflowError(workflowId, error as Error))
      }
    }.bind(this))
  }
  
  private executeWorkflowStep(workflowId: string, step: WorkflowStep): Effect<void, WorkflowError> {
    return Effect.gen(function* () {
      const workflow = this.activeWorkflows.get(workflowId)!
      const stepInstance: WorkflowStepInstance = {
        ...step,
        startTime: new Date(),
        status: 'running'
      }
      
      workflow.steps.push(stepInstance)
      
      switch (step.type) {
        case 'process-management':
          yield* this.executeProcessStep(step)
          break
        case 'cli-execution':
          yield* this.executeCLIStep(step)
          break
        case 'config-update':
          yield* this.executeConfigStep(step)
          break
        case 'ui-update':
          yield* this.executeUIStep(step)
          break
      }
      
      stepInstance.status = 'completed'
      stepInstance.endTime = new Date()
    }.bind(this))
  }
}
```

```tsx
import React, { useId, useEffect, useLayoutEffect } from 'react'
import { Effect } from 'effect'
import { Scope } from '../../components/system/Scope'
import { ScopeDef } from '../../core/scope-def'
import { CoreModule, CLIModule } from '../../core/interop/module-interfaces'

// Base props for all CLI components
export interface CLIComponentProps {
  name: string
  description?: string
  hidden?: boolean
  aliases?: string[]
  children?: React.ReactNode
}

// HOC for CLI component scope integration
export function withCLIScope<P extends CLIComponentProps>(
  Component: React.ComponentType<P>,
  scopeType: ScopeDef['type'],
  options: {
    executable?: boolean
    autoRegister?: boolean
    requireHandler?: boolean
  } = {}
) {
  return function CLIScopeWrapper(props: P) {
    const scopeId = useId()
    const { executable = false, autoRegister = true, requireHandler = false } = options
    
    // Validate required handler for executable scopes
    if (requireHandler && executable && !('handler' in props)) {
      throw new Error(`${scopeType} "${props.name}" is executable but no handler provided`)
    }
    
    const def: ScopeDef = {
      id: scopeId,
      type: scopeType,
      name: props.name,
      path: [], // Will be computed by ScopeStack
      executable,
      description: props.description,
      hidden: props.hidden,
      aliases: props.aliases,
      children: [],
      
      // Extract handler if component has one
      handler: 'handler' in props ? (props as any).handler : undefined,
      
      // Extract argument/flag definitions
      args: 'args' in props ? (props as any).args : undefined,
      flags: 'flags' in props ? (props as any).flags : undefined,
      options: 'options' in props ? (props as any).options : undefined,
      
      // Default content for non-executable scopes
      defaultContent: !executable && props.children ? (
        <div>{props.children}</div>
      ) : undefined,
      
      // Lifecycle hooks
      onEnter: autoRegister ? ({ scope }) => Effect.gen(function* () {
        // Auto-register executable scopes with CLI
        if (scope.executable && scope.handler) {
          yield* CLIModule.registerCommand({
            path: scope.path,
            handler: scope.handler,
            description: scope.description,
            args: scope.args,
            flags: scope.flags,
            options: scope.options,
            aliases: scope.aliases
          })
        }
      }) : undefined,
      
      onExit: autoRegister ? ({ scope }) => Effect.gen(function* () {
        // Cleanup CLI registration
        if (scope.executable) {
          yield* CLIModule.unregisterCommand(scope.path)
        }
      }) : undefined
    }
    
    return (
      <Scope def={def}>
        <Component {...props} />
      </Scope>
    )
  }
}

// Hook for accessing current scope in CLI components
export function useCLIScope(): ScopeDef | null {
  const [scope, setScope] = React.useState<ScopeDef | null>(null)
  
  useEffect(() => {
    Effect.runPromise(
      CoreModule.getCurrentScope()
    ).then(setScope).catch(() => setScope(null))
  }, [])
  
  return scope
}

// Hook for registering additional commands dynamically
export function useCLICommand(
  path: string[],
  handler: Handler,
  deps: React.DependencyList
) {
  useEffect(() => {
    const cleanup = Effect.runSync(
      CLIModule.registerCommand({
        path,
        handler,
        dynamicallyRegistered: true
      }).pipe(
        Effect.map(() => () => Effect.runSync(CLIModule.unregisterCommand(path)))
      )
    )
    
    return cleanup
  }, deps)
}
```

### 2. Event Stream Optimization

**File to Create:** `src/core/coordination/stream-optimizer.ts`
```typescript
import { Stream, Effect, Queue, Duration } from 'effect'

// Optimize event streams for performance and memory usage
export class EventStreamOptimizer {
  private bufferSizes = new Map<string, number>()
  private rateLimits = new Map<string, number>()
  
  // Optimize high-frequency event streams
  optimizeProcessOutputStreams(): Stream<ProcessOutputEvent> {
    return this.subscribe<ProcessOutputEvent>('process-output').pipe(
      // Buffer output events to reduce frequency
      Stream.buffer(50),
      
      // Batch by time window
      Stream.bufferTime(Duration.millis(100)),
      
      // Flatten batched events
      Stream.flatMap(batch => Stream.fromIterable(batch)),
      
      // Rate limit to prevent overwhelming consumers
      Stream.throttle(Duration.millis(10))
    )
  }
  
  // Optimize CLI command events with deduplication
  optimizeCLICommandStreams(): Stream<CLICommandEvent> {
    return this.subscribe<CLICommandEvent>('cli-command').pipe(
      // Deduplicate rapid successive events
      Stream.debounce(Duration.millis(50)),
      
      // Filter out redundant events
      Stream.filterMap(event => {
        if (this.isRedundantEvent(event)) {
          return Option.none()
        }
        return Option.some(event)
      })
    )
  }
  
  // Optimize UI update events with smart batching
  optimizeUIUpdateStreams(): Stream<UIUpdateEvent> {
    return this.subscribe<UIUpdateEvent>('ui-update').pipe(
      // Group by component ID
      Stream.groupBy(event => event.componentId || 'global'),
      
      // For each group, apply batching
      Stream.mergeMap(([componentId, stream]) =>
        stream.pipe(
          Stream.bufferTime(Duration.millis(16)), // 60fps
          Stream.map(batch => this.mergeBatchedUIUpdates(componentId, batch))
        )
      )
    )
  }
  
  // Smart event filtering based on relevance
  createRelevantEventStream<T extends BaseEvent>(
    channel: string,
    relevanceCriteria: RelevanceCriteria<T>
  ): Stream<T> {
    return this.subscribe<T>(channel).pipe(
      Stream.filter(event => this.isEventRelevant(event, relevanceCriteria)),
      Stream.takeUntil(
        Stream.fromEffect(
          Effect.sleep(relevanceCriteria.maxAge || Duration.hours(1))
        )
      )
    )
  }
  
  // Memory-efficient event archiving
  archiveOldEvents(): Effect<void, never> {
    return Effect.gen(function* () {
      const cutoffTime = new Date(Date.now() - Duration.toMillis(Duration.days(7)))
      
      // Archive events older than 7 days
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribe<BaseEvent>('*'),
          event => {
            if (event.timestamp < cutoffTime) {
              return this.archiveEvent(event)
            }
            return Effect.void
          }
        )
      )
    })
  }
  
  private isRedundantEvent(event: CLICommandEvent): boolean {
    // Implementation for detecting redundant events
    return false
  }
  
  private mergeBatchedUIUpdates(componentId: string, batch: UIUpdateEvent[]): UIUpdateEvent {
    // Merge multiple UI updates for the same component
    return batch[batch.length - 1] // Simple: take latest
  }
  
  private isEventRelevant<T extends BaseEvent>(event: T, criteria: RelevanceCriteria<T>): boolean {
    return criteria.filter ? criteria.filter(event) : true
  }
  
  private archiveEvent(event: BaseEvent): Effect<void, never> {
    // Archive old events to storage
    return Effect.void
  }
}

interface RelevanceCriteria<T extends BaseEvent> {
  filter?: (event: T) => boolean
  maxAge?: Duration.Duration
  priority?: 'low' | 'medium' | 'high'
}

interface UIUpdateEvent extends BaseEvent {
  readonly type: 'ui-update'
  readonly componentId?: string
  readonly updateType: 'state' | 'props' | 'style'
  readonly payload: unknown
}
```

```tsx
import React from 'react'
import { Handler } from '../../core/scope-def'
import { withCLIScope, CLIComponentProps } from './base'

interface PluginProps extends CLIComponentProps {
  // Plugin can have a default handler for when invoked directly
  handler?: Handler
  
  // Plugin-specific configuration
  config?: Record<string, unknown>
  
  children?: React.ReactNode
}

function PluginComponent({ name, description, children, config }: PluginProps) {
  return (
    <plugin-intrinsic name={name} config={config}>
      {children}
    </plugin-intrinsic>
  )
}

// Plugin is executable if it has a handler, shows help/children otherwise
export const Plugin = withCLIScope(PluginComponent, 'plugin', {
  executable: true, // Always executable to show help or default content
  autoRegister: true
})
```

**File to Create:** `src/cli/components/Command.tsx`

```tsx
import React from 'react'
import { Handler, ArgDef, FlagDef, OptionDef } from '../../core/scope-def'
import { withCLIScope, CLIComponentProps } from './base'

interface CommandProps extends CLIComponentProps {
  // Required handler for commands
  handler: Handler
  
  // Argument, flag, and option definitions
  args?: Record<string, ArgDef>
  flags?: Record<string, FlagDef>
  options?: Record<string, OptionDef>
  
  // Commands typically don't have children in the UI sense
  children?: never
}

function CommandComponent({ name, description, handler }: CommandProps) {
  return <command-intrinsic name={name} />
}

export const Command = withCLIScope(CommandComponent, 'command', {
  executable: true,
  autoRegister: true,
  requireHandler: true
})
```

**File to Create:** `src/cli/components/Arg.tsx`

```tsx
import React from 'react'
import { ArgDef } from '../../core/scope-def'
import { withCLIScope, CLIComponentProps } from './base'

interface ArgProps extends CLIComponentProps {
  type: ArgDef['type']
  required?: boolean
  default?: unknown
  
  // Args are not executable
  children?: never
}

function ArgComponent({ name, type, required, default: defaultValue }: ArgProps) {
  return <arg-intrinsic name={name} type={type} required={required} default={defaultValue} />
}

export const Arg = withCLIScope(ArgComponent, 'arg', {
  executable: false,
  autoRegister: false // Args are registered as part of their parent command
})
```

**File to Create:** `src/cli/components/Flag.tsx`

```tsx
import React from 'react'
import { FlagDef } from '../../core/scope-def'
import { withCLIScope, CLIComponentProps } from './base'

interface FlagProps extends CLIComponentProps {
  shortName?: string
  conflicts?: string[]
  
  children?: never
}

function FlagComponent({ name, shortName, conflicts }: FlagProps) {
  return <flag-intrinsic name={name} shortName={shortName} conflicts={conflicts} />
}

export const Flag = withCLIScope(FlagComponent, 'flag', {
  executable: false,
  autoRegister: false
})
```

**File to Create:** `src/cli/components/Option.tsx`

```tsx
import React from 'react'
import { OptionDef } from '../../core/scope-def'
import { withCLIScope, CLIComponentProps } from './base'

interface OptionProps extends CLIComponentProps {
  type: OptionDef['type']
  shortName?: string
  required?: boolean
  default?: unknown
  choices?: unknown[]
  
  children?: never
}

function OptionComponent({ 
  name, 
  type, 
  shortName, 
  required, 
  default: defaultValue, 
  choices 
}: OptionProps) {
  return (
    <option-intrinsic 
      name={name} 
      type={type} 
      shortName={shortName}
      required={required}
      default={defaultValue}
      choices={choices}
    />
  )
}

export const Option = withCLIScope(OptionComponent, 'option', {
  executable: false,
  autoRegister: false
})
```

### 3. Complex Integration Patterns

**File to Create:** `src/core/coordination/integration-patterns.ts`
```typescript
// Pre-built patterns for common integration scenarios
export class IntegrationPatterns {
  constructor(private eventBus: EventBus) {}
  
  // Pattern: Process monitoring with real-time dashboard
  createProcessMonitoringPattern(): Effect<PatternHandle, PatternError> {
    return Effect.gen(function* () {
      // Set up process event monitoring
      const processMonitor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ProcessEvent>('process-events'),
          event => this.handleProcessEventForDashboard(event)
        )
      )
      
      // Set up health monitoring
      const healthMonitor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ProcessHealthEvent>('process-health'),
          event => this.updateHealthDashboard(event)
        )
      )
      
      // Set up performance monitoring
      const performanceMonitor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ProcessOutputEvent>('process-output'),
          event => this.analyzeProcessPerformance(event)
        )
      )
      
      return {
        id: 'process-monitoring',
        fibers: [processMonitor, healthMonitor, performanceMonitor],
        shutdown: () => Effect.all([
          Fiber.interrupt(processMonitor),
          Fiber.interrupt(healthMonitor),
          Fiber.interrupt(performanceMonitor)
        ])
      }
    }.bind(this))
  }
  
  // Pattern: CLI with live feedback and autocompletion
  createInteractiveCLIPattern(): Effect<PatternHandle, PatternError> {
    return Effect.gen(function* () {
      // Set up command prediction
      const commandPredictor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<CLIParseEvent>('cli-parse'),
          event => this.updateCommandPredictions(event)
        )
      )
      
      // Set up live feedback
      const feedbackProvider = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<CLICommandEvent>('cli-command'),
          event => this.provideLiveFeedback(event)
        )
      )
      
      // Set up help integration
      const helpIntegrator = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ScopeEvent>('scope-events'),
          event => this.updateContextualHelp(event)
        )
      )
      
      return {
        id: 'interactive-cli',
        fibers: [commandPredictor, feedbackProvider, helpIntegrator],
        shutdown: () => Effect.all([
          Fiber.interrupt(commandPredictor),
          Fiber.interrupt(feedbackProvider),
          Fiber.interrupt(helpIntegrator)
        ])
      }
    }.bind(this))
  }
  
  // Pattern: Config-driven dynamic UI updates
  createDynamicUIPattern(): Effect<PatternHandle, PatternError> {
    return Effect.gen(function* () {
      // Listen for config changes
      const configWatcher = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ConfigEvent>('config-events'),
          event => this.handleConfigChangeForUI(event)
        )
      )
      
      // Listen for theme changes
      const themeWatcher = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ThemeEvent>('theme-events'),
          event => this.handleThemeChangeForUI(event)
        )
      )
      
      // Listen for terminal resize
      const terminalWatcher = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<TerminalEvent>('terminal-events'),
          event => this.handleTerminalResizeForUI(event)
        )
      )
      
      return {
        id: 'dynamic-ui',
        fibers: [configWatcher, themeWatcher, terminalWatcher],
        shutdown: () => Effect.all([
          Fiber.interrupt(configWatcher),
          Fiber.interrupt(themeWatcher),
          Fiber.interrupt(terminalWatcher)
        ])
      }
    }.bind(this))
  }
  
  // Pattern: Comprehensive logging and audit trail
  createAuditPattern(): Effect<PatternHandle, PatternError> {
    return Effect.gen(function* () {
      // Audit all command executions
      const commandAuditor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<CLICommandEvent>('cli-command'),
          event => this.auditCommandExecution(event)
        )
      )
      
      // Audit all config changes
      const configAuditor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ConfigEvent>('config-events'),
          event => this.auditConfigChange(event)
        )
      )
      
      // Audit all process operations
      const processAuditor = yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribe<ProcessEvent>('process-events'),
          event => this.auditProcessOperation(event)
        )
      )
      
      return {
        id: 'audit-trail',
        fibers: [commandAuditor, configAuditor, processAuditor],
        shutdown: () => Effect.all([
          Fiber.interrupt(commandAuditor),
          Fiber.interrupt(configAuditor),
          Fiber.interrupt(processAuditor)
        ])
      }
    }.bind(this))
  }
  
  // Helper methods for pattern implementations
  private handleProcessEventForDashboard(event: ProcessEvent): Effect<void, never> {
    return this.eventBus.publish('dashboard-update', {
      type: 'dashboard-update',
      source: 'process-monitoring',
      timestamp: new Date(),
      id: generateId(),
      payload: {
        processId: event.processId,
        status: event.type,
        config: event.config
      }
    })
  }
  
  private updateCommandPredictions(event: CLIParseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      if (event.type === 'cli-parse-start') {
        // Analyze input to provide predictions
        const predictions = yield* this.generateCommandPredictions(event.input)
        
        yield* this.eventBus.publish('cli-predictions', {
          type: 'predictions-updated',
          source: 'interactive-cli',
          timestamp: new Date(),
          id: generateId(),
          payload: { predictions, input: event.input }
        })
      }
    }.bind(this))
  }
  
  private auditCommandExecution(event: CLICommandEvent): Effect<void, never> {
    return this.eventBus.publish('audit-log', {
      type: 'audit-entry',
      source: 'audit-trail',
      timestamp: new Date(),
      id: generateId(),
      payload: {
        action: 'command-execution',
        commandPath: event.path,
        status: event.type,
        timestamp: event.timestamp,
        duration: event.executionTime
      }
    })
  }
}

interface PatternHandle {
  id: string
  fibers: Fiber.Fiber<void, never>[]
  shutdown: () => Effect<void[], never>
}
```

**Add Scope Intrinsic Processing:**
```typescript
// Add to JSXPluginRegistry class
class JSXPluginRegistry {
  // ... existing code ...
  
  // Process scope intrinsics
  processScopeIntrinsic(element: JSX.Element): Effect<void, JSXError> {
    return Effect.gen(function* () {
      const { def } = element.props
      
      if (!def) {
        yield* Effect.fail(new JSXError("scope-intrinsic missing 'def' prop"))
      }
      
      // Register scope with core module
      yield* CoreModule.registerScope(def)
      
      // Process children if they exist
      if (element.props.children) {
        yield* this.processChildren(element.props.children)
      }
    }.bind(this))
  }
  
  // Process CLI component intrinsics
  processCLIIntrinsic(element: JSX.Element): Effect<void, JSXError> {
    return Effect.gen(function* () {
      const { type } = element
      const currentScope = this.scopeStack.current()
      
      if (!currentScope) {
        yield* Effect.fail(new JSXError(`${type}-intrinsic outside of scope context`))
      }
      
      // Update parent scope with component information
      switch (type) {
        case 'plugin-intrinsic':
          // Plugin intrinsics update the current scope's metadata
          yield* this.updateScopeMetadata(currentScope.id, {
            pluginConfig: element.props.config
          })
          break
          
        case 'command-intrinsic':
          // Command intrinsics are already registered via scope lifecycle
          break
          
        case 'arg-intrinsic':
        case 'flag-intrinsic':
        case 'option-intrinsic':
          // These update the parent command scope
          yield* this.addComponentToParent(currentScope, element)
          break
      }
    }.bind(this))
  }
  
  private addComponentToParent(currentScope: ScopeContext, element: JSX.Element): Effect<void, JSXError> {
    return Effect.gen(function* () {
      const parent = currentScope.parent
      if (!parent) {
        yield* Effect.fail(new JSXError(`${element.type} must be inside a command or plugin`))
      }
      
      // Update parent's argument/flag/option definitions
      const { type, props } = element
      const { name } = props
      
      switch (type) {
        case 'arg-intrinsic':
          if (!parent.args) parent.args = {}
          parent.args[name] = {
            type: props.type,
            required: props.required,
            default: props.default
          }
          break
          
        case 'flag-intrinsic':
          if (!parent.flags) parent.flags = {}
          parent.flags[name] = {
            shortName: props.shortName,
            description: props.description,
            conflicts: props.conflicts
          }
          break
          
        case 'option-intrinsic':
          if (!parent.options) parent.options = {}
          parent.options[name] = {
            type: props.type,
            shortName: props.shortName,
            required: props.required,
            default: props.default,
            choices: props.choices
          }
          break
      }
      
      // Re-register parent with updated configuration
      yield* CoreModule.updateScope(parent.id, {
        args: parent.args,
        flags: parent.flags,
        options: parent.options
      })
    })
  }
}
```

### 4. Performance Monitoring and Metrics

**File to Create:** `src/core/coordination/performance-monitor.ts`
```typescript
// Monitor performance across all modules and events
export class PerformanceMonitor extends ModuleBase {
  private metrics = new Map<string, PerformanceMetric>()
  private eventCounts = new Map<string, number>()
  private responseTimeTracker = new Map<string, number[]>()
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'performance-monitor')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.monitorEventThroughput(),
      this.monitorResponseTimes(),
      this.monitorMemoryUsage(),
      this.generatePerformanceReports()
    ]).pipe(Effect.asVoid)
  }
  
  private monitorEventThroughput(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<BaseEvent>('*'),
        event => this.trackEventThroughput(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private monitorResponseTimes(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<CLICommandEvent>('cli-command'),
        event => this.trackResponseTime(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private monitorMemoryUsage(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        Stream.fromInterval(Duration.seconds(30)),
        () => this.captureMemoryMetrics()
      )
    ).pipe(Effect.asVoid)
  }
  
  private generatePerformanceReports(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        Stream.fromInterval(Duration.minutes(5)),
        () => this.generateAndEmitReport()
      )
    ).pipe(Effect.asVoid)
  }
  
  private trackEventThroughput(event: BaseEvent): Effect<void, never> {
    return Effect.sync(() => {
      const channelKey = `${event.source}:${event.type}`
      const current = this.eventCounts.get(channelKey) || 0
      this.eventCounts.set(channelKey, current + 1)
    })
  }
  
  private trackResponseTime(event: CLICommandEvent): Effect<void, never> {
    return Effect.sync(() => {
      if (event.type === 'cli-command-executed' && event.executionTime) {
        const pathKey = event.path.join(':')
        const times = this.responseTimeTracker.get(pathKey) || []
        times.push(event.executionTime)
        
        // Keep only last 100 measurements
        if (times.length > 100) {
          times.shift()
        }
        
        this.responseTimeTracker.set(pathKey, times)
      }
    })
  }
  
  private captureMemoryMetrics(): Effect<void, never> {
    return Effect.sync(() => {
      const memUsage = process.memoryUsage()
      
      this.metrics.set('memory', {
        timestamp: new Date(),
        value: memUsage.heapUsed,
        metadata: {
          heapTotal: memUsage.heapTotal,
          external: memUsage.external,
          rss: memUsage.rss
        }
      })
    })
  }
  
  private generateAndEmitReport(): Effect<void, never> {
    return Effect.gen(function* () {
      const report = this.generatePerformanceReport()
      
      yield* this.emitEvent('performance-report', {
        type: 'performance-report',
        report,
        timestamp: new Date()
      })
      
      // Reset counters for next period
      this.eventCounts.clear()
    }.bind(this))
  }
  
  private generatePerformanceReport(): PerformanceReport {
    const eventThroughput = Array.from(this.eventCounts.entries()).map(
      ([channel, count]) => ({ channel, count, ratePerMinute: count / 5 })
    )
    
    const responseTimeStats = Array.from(this.responseTimeTracker.entries()).map(
      ([command, times]) => ({
        command,
        average: times.reduce((a, b) => a + b, 0) / times.length,
        min: Math.min(...times),
        max: Math.max(...times),
        p95: this.calculatePercentile(times, 95)
      })
    )
    
    const memoryMetric = this.metrics.get('memory')
    
    return {
      timestamp: new Date(),
      eventThroughput,
      responseTimeStats,
      memoryUsage: memoryMetric ? {
        heapUsed: memoryMetric.value,
        metadata: memoryMetric.metadata
      } : undefined
    }
  }
  
  private calculatePercentile(values: number[], percentile: number): number {
    const sorted = [...values].sort((a, b) => a - b)
    const index = Math.ceil((percentile / 100) * sorted.length) - 1
    return sorted[index]
  }
  
  // Public API for getting performance metrics
  getPerformanceMetrics(): Effect<PerformanceReport, never> {
    return Effect.sync(() => this.generatePerformanceReport())
  }
  
  getEventThroughput(channel?: string): Effect<ThroughputMetric[], never> {
    return Effect.sync(() => {
      const entries = Array.from(this.eventCounts.entries())
      const filtered = channel 
        ? entries.filter(([key]) => key.includes(channel))
        : entries
      
      return filtered.map(([key, count]) => ({
        channel: key,
        count,
        ratePerMinute: count / 5
      }))
    })
  }
}

interface PerformanceMetric {
  timestamp: Date
  value: number
  metadata?: Record<string, unknown>
}

interface PerformanceReport {
  timestamp: Date
  eventThroughput: ThroughputMetric[]
  responseTimeStats: ResponseTimeMetric[]
  memoryUsage?: MemoryUsageMetric
}

interface ThroughputMetric {
  channel: string
  count: number
  ratePerMinute: number
}

interface ResponseTimeMetric {
  command: string
  average: number
  min: number
  max: number
  p95: number
}

interface MemoryUsageMetric {
  heapUsed: number
  metadata?: Record<string, unknown>
}
```

```typescript
import { Effect } from 'effect'
import { ScopeDef } from '../core/scope-def'
import { CoreModule, CLIModule, JSXModule } from '../core/interop/module-interfaces'

// Manage component lifecycle with Effect integration
export class ComponentLifecycleManager {
  private mountedComponents = new Map<string, ComponentInstance>()
  
  // Called when JSX component mounts
  onComponentMount(
    element: JSX.Element, 
    scope: ScopeDef
  ): Effect<void, ComponentError> {
    return Effect.gen(function* () {
      const instance: ComponentInstance = {
        id: scope.id,
        element,
        scope,
        mountTime: new Date()
      }
      
      this.mountedComponents.set(scope.id, instance)
      
      // Trigger scope onEnter hook
      if (scope.onEnter) {
        yield* scope.onEnter({ scope, stack: CoreModule.getStack() })
      }
      
      // Publish mount event
      yield* EventBus.publish('component-lifecycle', {
        type: 'component-mount',
        component: element,
        scope,
        timestamp: new Date(),
        source: 'jsx-lifecycle',
        id: generateId()
      })
      
      // Set up scope-aware effects
      yield* this.setupScopeEffects(scope)
    }.bind(this))
  }
  
  // Called when JSX component unmounts
  onComponentUnmount(scopeId: string): Effect<void, never> {
    return Effect.gen(function* () {
      const instance = this.mountedComponents.get(scopeId)
      if (!instance) return
      
      // Trigger scope onExit hook
      if (instance.scope.onExit) {
        yield* instance.scope.onExit({ 
          scope: instance.scope, 
          stack: CoreModule.getStack() 
        }).pipe(
          Effect.catchAll(() => Effect.void) // Don't fail on cleanup
        )
      }
      
      // Cleanup scope registration
      yield* CoreModule.unregisterScope(scopeId)
      
      // Publish unmount event
      yield* EventBus.publish('component-lifecycle', {
        type: 'component-unmount',
        component: instance.element,
        scope: instance.scope,
        timestamp: new Date(),
        source: 'jsx-lifecycle',
        id: generateId()
      })
      
      this.mountedComponents.delete(scopeId)
    }.bind(this))
  }
  
  // Set up Effect-based hooks for scope
  private setupScopeEffects(scope: ScopeDef): Effect<void, never> {
    return Effect.gen(function* () {
      // Subscribe to relevant events for this scope
      yield* Effect.fork(
        Stream.runForeach(
          EventBus.filter('execution-events', 
            event => event.scope.id === scope.id
          ),
          event => this.handleExecutionEvent(scope, event)
        )
      )
      
      // Set up automatic cleanup
      yield* Effect.fork(
        Effect.gen(function* () {
          yield* Effect.sleep(Duration.hours(24)) // Cleanup after 24h if still mounted
          yield* this.onComponentUnmount(scope.id)
        }.bind(this))
      )
    }.bind(this))
  }
  
  private handleExecutionEvent(
    scope: ScopeDef, 
    event: ExecutionEvent
  ): Effect<void, never> {
    return Effect.gen(function* () {
      // Update component state based on execution events
      const instance = this.mountedComponents.get(scope.id)
      if (instance && instance.scope.onChild) {
        // Notify scope of execution activity
        yield* instance.scope.onChild(scope).pipe(
          Effect.catchAll(() => Effect.void)
        )
      }
    })
  }
}

interface ComponentInstance {
  id: string
  element: JSX.Element
  scope: ScopeDef
  mountTime: Date
}

// Global lifecycle manager
export const lifecycleManager = new ComponentLifecycleManager()
```

### 5. Advanced Error Handling and Recovery

**File to Create:** `src/core/coordination/error-recovery.ts`
```typescript
// Advanced error handling and recovery across module boundaries
export class ErrorRecoveryManager extends ModuleBase {
  private errorPatterns = new Map<string, ErrorPattern>()
  private recoveryStrategies = new Map<string, RecoveryStrategy>()
  private circuitBreakers = new Map<string, CircuitBreaker>()
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'error-recovery')
    this.initializeRecoveryStrategies()
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.monitorCrossModuleErrors(),
      this.implementCircuitBreakers(),
      this.setupAutomaticRecovery()
    ]).pipe(Effect.asVoid)
  }
  
  private monitorCrossModuleErrors(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<BaseEvent>('*'),
        event => this.analyzeEventForErrors(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private implementCircuitBreakers(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<CLICommandEvent>('cli-command'),
        event => this.updateCircuitBreaker(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private setupAutomaticRecovery(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<BaseEvent>('*'),
        event => this.attemptAutomaticRecovery(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  // Register error recovery patterns
  registerErrorPattern(pattern: ErrorPattern): Effect<void, never> {
    return Effect.sync(() => {
      this.errorPatterns.set(pattern.id, pattern)
    })
  }
  
  registerRecoveryStrategy(strategy: RecoveryStrategy): Effect<void, never> {
    return Effect.sync(() => {
      this.recoveryStrategies.set(strategy.id, strategy)
    })
  }
  
  private analyzeEventForErrors(event: BaseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      // Check if event indicates an error condition
      const errorIndicators = this.detectErrorIndicators(event)
      
      for (const indicator of errorIndicators) {
        const pattern = this.errorPatterns.get(indicator.patternId)
        if (pattern) {
          yield* this.handleDetectedError(indicator, pattern, event)
        }
      }
    }.bind(this))
  }
  
  private handleDetectedError(
    indicator: ErrorIndicator,
    pattern: ErrorPattern,
    event: BaseEvent
  ): Effect<void, never> {
    return Effect.gen(function* () {
      // Log the error detection
      yield* this.emitEvent('error-detection', {
        type: 'error-detected',
        pattern: pattern.id,
        event: event.type,
        source: event.source,
        severity: indicator.severity
      })
      
      // Apply recovery strategy if available
      const strategy = this.recoveryStrategies.get(pattern.recoveryStrategyId)
      if (strategy) {
        yield* this.executeRecoveryStrategy(strategy, event, indicator)
      }
    }.bind(this))
  }
  
  private executeRecoveryStrategy(
    strategy: RecoveryStrategy,
    event: BaseEvent,
    indicator: ErrorIndicator
  ): Effect<void, never> {
    return Effect.gen(function* () {
      try {
        switch (strategy.type) {
          case 'retry':
            yield* this.executeRetryStrategy(strategy, event)
            break
          case 'fallback':
            yield* this.executeFallbackStrategy(strategy, event)
            break
          case 'circuit-break':
            yield* this.executeCircuitBreakStrategy(strategy, event)
            break
          case 'notify-and-continue':
            yield* this.executeNotifyStrategy(strategy, event, indicator)
            break
        }
        
        yield* this.emitEvent('error-recovery', {
          type: 'recovery-successful',
          strategy: strategy.id,
          event: event.type
        })
        
      } catch (error) {
        yield* this.emitEvent('error-recovery', {
          type: 'recovery-failed',
          strategy: strategy.id,
          event: event.type,
          error: error as Error
        })
      }
    }.bind(this))
  }
  
  private executeRetryStrategy(strategy: RecoveryStrategy, event: BaseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      const retryConfig = strategy.config as RetryConfig
      
      yield* Effect.retry(
        this.retryOriginalAction(event),
        Schedule.exponential(Duration.millis(retryConfig.baseDelay))
          .pipe(Schedule.compose(Schedule.recurs(retryConfig.maxAttempts)))
      ).pipe(
        Effect.catchAll(() => Effect.void) // Don't fail the recovery process
      )
    }.bind(this))
  }
  
  private executeFallbackStrategy(strategy: RecoveryStrategy, event: BaseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      const fallbackConfig = strategy.config as FallbackConfig
      
      // Execute fallback action
      yield* this.emitEvent(fallbackConfig.fallbackChannel, {
        type: fallbackConfig.fallbackEventType,
        originalEvent: event,
        reason: 'fallback-recovery'
      })
    }.bind(this))
  }
  
  private initializeRecoveryStrategies(): void {
    // Register common recovery strategies
    this.recoveryStrategies.set('process-restart', {
      id: 'process-restart',
      type: 'retry',
      config: { maxAttempts: 3, baseDelay: 1000 }
    })
    
    this.recoveryStrategies.set('cli-fallback', {
      id: 'cli-fallback',
      type: 'fallback',
      config: {
        fallbackChannel: 'cli-fallback',
        fallbackEventType: 'show-help'
      }
    })
    
    this.recoveryStrategies.set('service-circuit-break', {
      id: 'service-circuit-break',
      type: 'circuit-break',
      config: {
        failureThreshold: 5,
        timeout: 30000
      }
    })
  }
}

interface ErrorPattern {
  id: string
  description: string
  eventTypes: string[]
  errorConditions: ErrorCondition[]
  recoveryStrategyId: string
}

interface ErrorCondition {
  field: string
  operator: 'equals' | 'contains' | 'matches'
  value: unknown
}

interface ErrorIndicator {
  patternId: string
  severity: 'low' | 'medium' | 'high' | 'critical'
  confidence: number
}

interface RecoveryStrategy {
  id: string
  type: 'retry' | 'fallback' | 'circuit-break' | 'notify-and-continue'
  config: RecoveryConfig
}

type RecoveryConfig = RetryConfig | FallbackConfig | CircuitBreakConfig | NotifyConfig

interface RetryConfig {
  maxAttempts: number
  baseDelay: number
}

interface FallbackConfig {
  fallbackChannel: string
  fallbackEventType: string
}

interface CircuitBreakConfig {
  failureThreshold: number
  timeout: number
}

interface NotifyConfig {
  notificationChannel: string
  continueExecution: boolean
}

interface CircuitBreaker {
  id: string
  state: 'closed' | 'open' | 'half-open'
  failureCount: number
  lastFailureTime: Date
  threshold: number
  timeout: number
}
```

```typescript
// Export all CLI components with scope integration
export { Plugin } from './Plugin'
export { Command } from './Command'
export { Arg } from './Arg'
export { Flag } from './Flag'
export { Option } from './Option'

// Export base utilities
export { withCLIScope, useCLIScope, useCLICommand } from './base'

// Export types
export type { CLIComponentProps } from './base'

// Re-export core scope types for convenience
export type { 
  ScopeDef, 
  Handler, 
  ArgDef, 
  FlagDef, 
  OptionDef 
} from '../../core/scope-def'
```

### 6. Coordination Module Integration

**File to Create:** `src/core/coordination/module.ts`
```typescript
// Main coordination module that brings everything together
export class CoordinationModule extends ModuleBase {
  private choreographer: EventChoreographer
  private orchestrator: WorkflowOrchestrator
  private streamOptimizer: EventStreamOptimizer
  private performanceMonitor: PerformanceMonitor
  private errorRecovery: ErrorRecoveryManager
  private integrationPatterns: IntegrationPatterns
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'coordination')
    
    this.choreographer = new EventChoreographer(eventBus)
    this.orchestrator = new WorkflowOrchestrator(eventBus)
    this.streamOptimizer = new EventStreamOptimizer()
    this.performanceMonitor = new PerformanceMonitor(eventBus)
    this.errorRecovery = new ErrorRecoveryManager(eventBus)
    this.integrationPatterns = new IntegrationPatterns(eventBus)
  }
  
  initialize(): Effect<void, CoordinationError> {
    return Effect.gen(function* () {
      // Initialize all coordination subsystems
      yield* this.performanceMonitor.initialize()
      yield* this.errorRecovery.initialize()
      
      // Set up core coordination patterns
      yield* this.choreographer.coordinateProcessWithLogging()
      yield* this.choreographer.coordinateCLIWithUI()
      yield* this.choreographer.coordinateConfigUpdates()
      
      // Start performance monitoring
      yield* this.performanceMonitor.initialize()
      
      // Set up error recovery patterns
      yield* this.setupDefaultErrorRecovery()
      
      // Initialize integration patterns
      yield* this.initializeCommonPatterns()
      
      yield* this.emitEvent('coordination-events', {
        type: 'coordination-initialized',
        timestamp: new Date()
      })
    }.bind(this))
  }
  
  // Start a complex workflow with full coordination
  startCoordinatedWorkflow(
    workflowId: string,
    config: WorkflowConfig
  ): Effect<WorkflowResult, WorkflowError> {
    return Effect.gen(function* () {
      // Start performance monitoring for this workflow
      yield* this.performanceMonitor.startWorkflowMonitoring(workflowId)
      
      // Execute the workflow with orchestration
      const result = yield* this.orchestrator.startComplexWorkflow(workflowId, config)
      
      // Generate performance report
      const metrics = yield* this.performanceMonitor.getWorkflowMetrics(workflowId)
      
      return {
        ...result,
        performanceMetrics: metrics
      }
    }.bind(this))
  }
  
  // Get comprehensive system health
  getSystemHealth(): Effect<SystemHealth, never> {
    return Effect.gen(function* () {
      const performanceMetrics = yield* this.performanceMonitor.getPerformanceMetrics()
      const errorStats = yield* this.errorRecovery.getErrorStatistics()
      const eventThroughput = yield* this.performanceMonitor.getEventThroughput()
      
      return {
        timestamp: new Date(),
        performance: performanceMetrics,
        errors: errorStats,
        throughput: eventThroughput,
        status: this.calculateOverallStatus(performanceMetrics, errorStats)
      }
    }.bind(this))
  }
  
  // Enable/disable specific coordination patterns
  configureCoordination(config: CoordinationConfig): Effect<void, CoordinationError> {
    return Effect.gen(function* () {
      if (config.enableProcessMonitoring) {
        yield* this.integrationPatterns.createProcessMonitoringPattern()
      }
      
      if (config.enableInteractiveCLI) {
        yield* this.integrationPatterns.createInteractiveCLIPattern()
      }
      
      if (config.enableDynamicUI) {
        yield* this.integrationPatterns.createDynamicUIPattern()
      }
      
      if (config.enableAuditTrail) {
        yield* this.integrationPatterns.createAuditPattern()
      }
    }.bind(this))
  }
  
  private setupDefaultErrorRecovery(): Effect<void, never> {
    return Effect.gen(function* () {
      // Register common error patterns
      yield* this.errorRecovery.registerErrorPattern({
        id: 'process-crash',
        description: 'Process unexpectedly terminated',
        eventTypes: ['process-crashed'],
        errorConditions: [{
          field: 'exitCode',
          operator: 'equals',
          value: null
        }],
        recoveryStrategyId: 'process-restart'
      })
      
      yield* this.errorRecovery.registerErrorPattern({
        id: 'cli-parse-error',
        description: 'Command line parsing failed',
        eventTypes: ['cli-parse-error'],
        errorConditions: [{
          field: 'type',
          operator: 'equals',
          value: 'cli-parse-error'
        }],
        recoveryStrategyId: 'cli-fallback'
      })
    }.bind(this))
  }
  
  private initializeCommonPatterns(): Effect<void, never> {
    return Effect.gen(function* () {
      // Start with basic patterns that most applications need
      yield* this.integrationPatterns.createProcessMonitoringPattern()
      yield* this.integrationPatterns.createInteractiveCLIPattern()
    }.bind(this))
  }
  
  private calculateOverallStatus(
    performance: PerformanceReport,
    errors: ErrorStatistics
  ): 'healthy' | 'degraded' | 'unhealthy' {
    // Simple heuristic for overall system health
    const avgResponseTime = performance.responseTimeStats.reduce(
      (sum, stat) => sum + stat.average,
      0
    ) / performance.responseTimeStats.length
    
    const errorRate = errors.totalErrors / errors.totalEvents
    
    if (avgResponseTime > 1000 || errorRate > 0.1) {
      return 'unhealthy'
    } else if (avgResponseTime > 500 || errorRate > 0.05) {
      return 'degraded'
    } else {
      return 'healthy'
    }
  }
}

interface CoordinationConfig {
  enableProcessMonitoring?: boolean
  enableInteractiveCLI?: boolean
  enableDynamicUI?: boolean
  enableAuditTrail?: boolean
  performanceReportingInterval?: Duration.Duration
  errorRecoveryEnabled?: boolean
}

interface SystemHealth {
  timestamp: Date
  performance: PerformanceReport
  errors: ErrorStatistics
  throughput: ThroughputMetric[]
  status: 'healthy' | 'degraded' | 'unhealthy'
}

interface ErrorStatistics {
  totalErrors: number
  totalEvents: number
  errorsByType: Record<string, number>
  errorsByModule: Record<string, number>
  recoverySuccessRate: number
}
```

```tsx
import React from 'react'
import { Effect } from 'effect'
import { Plugin, Command, Arg, Flag, Option } from '../src/cli/components'
import { useCLIScope, useCLICommand } from '../src/cli/components/base'

// Example of fully integrated CLI with automatic scope registration
export function IntegratedCLIDemo() {
  return (
    <Plugin name="demo" description="Integrated CLI demonstration">
      
      {/* Basic command with arguments */}
      <Command 
        name="greet" 
        description="Greet a user"
        handler={greetHandler}
      >
        <Arg name="name" type="string" required description="Name to greet" />
        <Flag name="loud" description="Use uppercase" />
        <Option name="times" type="number" default={1} description="Repeat count" />
      </Command>
      
      {/* Nested plugin */}
      <Plugin name="files" description="File operations">
        <Command name="list" handler={listHandler}>
          <Arg name="directory" type="string" default="." />
          <Flag name="all" shortName="a" description="Show hidden files" />
        </Command>
        
        <Command name="copy" handler={copyHandler}>
          <Arg name="source" type="string" required />
          <Arg name="destination" type="string" required />
          <Flag name="recursive" shortName="r" />
        </Command>
      </Plugin>
      
      {/* Dynamic command registration example */}
      <DynamicCommands />
      
    </Plugin>
  )
}

// Example of dynamic command registration
function DynamicCommands() {
  const currentScope = useCLIScope()
  
  // Register additional commands based on current scope context
  useCLICommand(
    ['demo', 'dynamic', 'status'],
    (args, scope) => Effect.gen(function* () {
      console.log(`Current scope: ${scope.path.join(' ')}`)
      return 0
    }),
    [currentScope?.id]
  )
  
  return (
    <Plugin name="dynamic" description="Dynamically registered commands">
      {/* The 'status' command is registered via the hook above */}
    </Plugin>
  )
}

// Command handlers with full Effect integration
const greetHandler = (args: ParsedArgs, scope: ScopeDef) =>
  Effect.gen(function* () {
    const name = args.args.name as string
    const loud = args.flags.loud as boolean
    const times = args.options.times as number
    
    const greeting = loud ? `HELLO ${name.toUpperCase()}!` : `Hello ${name}!`
    
    for (let i = 0; i < times; i++) {
      yield* TerminalService.writeLine(greeting)
    }
    
    return 0 as ExitCode
  })

const listHandler = (args: ParsedArgs) =>
  Effect.gen(function* () {
    const directory = args.args.directory as string
    const showAll = args.flags.all as boolean
    
    // Use Bun's file API through Effect
    const files = yield* Effect.tryPromise(() => 
      Bun.readdir(directory)
    ).pipe(
      Effect.mapError(error => new FileSystemError(`Cannot read directory: ${error}`))
    )
    
    const filtered = showAll ? files : files.filter(f => !f.startsWith('.'))
    
    for (const file of filtered) {
      yield* TerminalService.writeLine(file)
    }
    
    return 0 as ExitCode
  })

const copyHandler = (args: ParsedArgs) =>
  Effect.gen(function* () {
    const source = args.args.source as string
    const destination = args.args.destination as string
    const recursive = args.flags.recursive as boolean
    
    yield* Effect.tryPromise(() => 
      Bun.copy(source, destination, { recursive })
    ).pipe(
      Effect.mapError(error => new FileSystemError(`Copy failed: ${error}`))
    )
    
    yield* TerminalService.writeLine(`Copied ${source} to ${destination}`)
    return 0 as ExitCode
  })
```

## Testing Strategy

### Component Integration Tests
**File:** `tests/e2e/cli-components.test.ts`
```typescript
test("CLI components register scopes automatically", async () => {
  const TestCLI = () => (
    <Plugin name="test">
      <Command name="hello" handler={mockHandler} />
      <Command name="goodbye" handler={mockHandler}>
        <Arg name="name" type="string" required />
        <Flag name="formal" />
      </Command>
    </Plugin>
  )
  
  const runtime = await renderJSXCLI(TestCLI)
  
  // Check that scopes were registered
  const scopes = runtime.getRegisteredScopes()
  expect(scopes).toHaveLength(3) // test, test hello, test goodbye
  
  // Check command registration
  const commands = runtime.getRegisteredCommands()
  expect(commands).toHaveProperty('test')
  expect(commands).toHaveProperty('test hello')
  expect(commands).toHaveProperty('test goodbye')
  
  // Check argument/flag definitions
  const goodbyeCommand = commands['test goodbye']
  expect(goodbyeCommand.args).toHaveProperty('name')
  expect(goodbyeCommand.flags).toHaveProperty('formal')
})
```

### Lifecycle Integration Tests
**File:** `tests/e2e/component-lifecycle.test.ts`
```typescript
test("component lifecycle triggers scope hooks", async () => {
  let enterCalled = false
  let exitCalled = false
  
  const TestComponent = () => (
    <Plugin 
      name="lifecycle-test"
      onEnter={() => Effect.sync(() => { enterCalled = true })}
      onExit={() => Effect.sync(() => { exitCalled = true })}
    />
  )
  
  const { unmount } = await renderJSXCLI(TestComponent)
  
  expect(enterCalled).toBe(true)
  expect(exitCalled).toBe(false)
  
  unmount()
  
  expect(exitCalled).toBe(true)
})
```

## Files Modified

### New Coordination Files
- `src/core/coordination/choreography.ts` - Event choreography patterns
- `src/core/coordination/orchestrator.ts` - Workflow orchestration
- `src/core/coordination/stream-optimizer.ts` - Event stream optimization
- `src/core/coordination/integration-patterns.ts` - Pre-built integration patterns
- `src/core/coordination/performance-monitor.ts` - Performance monitoring
- `src/core/coordination/error-recovery.ts` - Error handling and recovery
- `src/core/coordination/module.ts` - Main coordination module

### Enhanced Core Files
- `src/core/module-registry.ts` - Add coordination module
- `src/core/events.ts` - Add coordination event types

### Modified Module Files
- `src/jsx/module.ts` - Integration with coordination patterns
- `src/cli/module.ts` - Performance monitoring integration
- `src/process-manager/module.ts` - Error recovery integration
- `src/logger/module.ts` - Audit pattern integration

### Example Files
- `examples/advanced-coordination-demo.tsx` - Complex workflow examples
- `examples/performance-monitoring-demo.tsx` - Performance monitoring setup
- `examples/error-recovery-demo.tsx` - Error recovery patterns

### Test Files
- `src/core/coordination/choreography.test.ts`
- `src/core/coordination/performance-monitor.test.ts`
- `src/core/coordination/error-recovery.test.ts`
- `tests/e2e/advanced-coordination.test.ts`
- `tests/performance/coordination-benchmarks.test.ts`

## Success Criteria

✅ **Advanced Event Choreography**: Complex multi-module workflows execute seamlessly
✅ **Performance Optimization**: Event streams are optimized for throughput and memory
✅ **Error Recovery**: Automatic error detection and recovery across module boundaries
✅ **Performance Monitoring**: Real-time performance metrics and reporting
✅ **Integration Patterns**: Pre-built patterns for common coordination scenarios
✅ **Workflow Orchestration**: Complex workflows with proper error handling and rollback
✅ **System Health Monitoring**: Comprehensive health metrics across all modules
✅ **Resource Management**: Proper cleanup and resource management for long-running processes

## Dependencies for Next Phase

**Phase 4 Provides for Phase 5:**
- ✅ Advanced coordination patterns for component system integration
- ✅ Performance monitoring foundation for component optimization
- ✅ Error recovery patterns for robust component lifecycle
- ✅ Event stream optimization for responsive UI updates
- ✅ Workflow orchestration for complex component interactions