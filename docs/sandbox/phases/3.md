# Phase 3: Service & Process Integration

## PHASE 3 IMPLEMENTATION STATUS
### Status: Completed (December 2024)
This phase has been successfully implemented with comprehensive service layer integration. All service modules now participate in the event-driven architecture.

### Implementation Summary
- ✅ **Service Module**: Terminal, input, renderer, and storage service coordination
- ✅ **Config Module**: Configuration management with validation and reactive updates
- ✅ **Process Manager**: Process lifecycle management with health monitoring
- ✅ **Logger Module**: Centralized logging with event aggregation from all modules
- ✅ **Styling Module**: Theme management and responsive layout computation
- ✅ **Bootstrap System**: Flexible initialization with optional module enabling
- ✅ **Integration Tests**: Comprehensive test coverage for cross-module communication

### Key Architectural Decisions
1. **Modular Bootstrap**: Created a flexible bootstrap system that allows enabling/disabling optional modules
2. **Event Aggregation**: Logger module subscribes to all known event channels for audit logging
3. **Cross-Module Communication**: Demonstrated with config changes triggering theme updates
4. **Service Lifecycle**: All service modules follow consistent lifecycle patterns with proper event emission

## Overview

Integrate service layer and process management with the event-driven architecture. Establish patterns for Config, Logger, Process Manager, and Styling modules to participate in the event bus system.

## Dependencies

**Requires Phase 2 Complete:**
- ✅ Event bus foundation with domain-specific emitters/listeners
- ✅ JSX, CLI, and Reactivity modules using event communication
- ✅ Module base class and registry system
- ✅ Auto-registration patterns established

## Technical Implementation

### 1. Service Layer Event Integration

**File to Create:** `src/services/events.ts`
```typescript
import { BaseEvent } from '../core/events'

export interface ServiceEvent extends BaseEvent {
  readonly type: 'service-started' | 'service-stopped' | 'service-error' | 'service-ready'
  readonly serviceName: string
  readonly serviceType: 'terminal' | 'input' | 'renderer' | 'storage'
  readonly status: 'starting' | 'running' | 'stopping' | 'stopped' | 'error'
  readonly error?: Error
}

export interface TerminalEvent extends BaseEvent {
  readonly type: 'terminal-resize' | 'terminal-output' | 'terminal-input'
  readonly dimensions?: { width: number; height: number }
  readonly data?: string
  readonly source?: 'user' | 'application'
}

export interface InputEvent extends BaseEvent {
  readonly type: 'key-press' | 'mouse-click' | 'mouse-move'
  readonly key?: string
  readonly mousePosition?: { x: number; y: number }
  readonly modifiers?: string[]
}

export interface RenderEvent extends BaseEvent {
  readonly type: 'render-requested' | 'render-completed' | 'render-failed'
  readonly component?: string
  readonly renderTime?: number
  readonly error?: Error
}
```

**File to Create:** `src/services/emitter.ts`
```typescript
import { ModuleBase } from '../core/module-base'
import { ServiceEvent, TerminalEvent, InputEvent, RenderEvent } from './events'

export class ServiceEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'services')
  }
  
  emitServiceStarted(serviceName: string, serviceType: ServiceEvent['serviceType']): Effect<void, never> {
    return this.emitEvent<ServiceEvent>('service-events', {
      type: 'service-started',
      serviceName,
      serviceType,
      status: 'running'
    })
  }
  
  emitTerminalResize(width: number, height: number): Effect<void, never> {
    return this.emitEvent<TerminalEvent>('terminal-events', {
      type: 'terminal-resize',
      dimensions: { width, height }
    })
  }
  
  emitKeyPress(key: string, modifiers: string[] = []): Effect<void, never> {
    return this.emitEvent<InputEvent>('input-events', {
      type: 'key-press',
      key,
      modifiers
    })
  }
  
  emitRenderCompleted(component: string, renderTime: number): Effect<void, never> {
    return this.emitEvent<RenderEvent>('render-events', {
      type: 'render-completed',
      component,
      renderTime
    })
  }
}
```

**File to Create:** `src/services/listener.ts`
```typescript
export class ServiceListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'services')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToJSXEvents(),
      this.subscribeToCLIEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToJSXEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<JSXRenderEvent>('jsx-render'),
        event => this.handleJSXRender(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleJSXRender(event: JSXRenderEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'jsx-render-start':
          // Prepare rendering context
          break
        case 'jsx-render-end':
          // Clean up rendering resources
          break
      }
    })
  }
}
```

```typescript
import { Effect, Stream } from "effect"
import { ScopeDef } from "../scope-def"

// Core Module Interface
export interface CoreModule {
  // Scope management
  registerScope: (scope: ScopeDef) => Effect<void, ScopeError>
  unregisterScope: (scopeId: string) => Effect<void, never>
  findScope: (path: string[]) => Effect<ScopeDef | null, never>
  checkScopeConflicts: (scope: ScopeDef) => Effect<ScopeConflict[], never>
  
  // Lifecycle
  initialize: () => Effect<void, InitError, AppServices>
  shutdown: () => Effect<void, never>
  
  // Events
  onScopeRegistered: Stream<ScopeEvent>
  onScopeUnregistered: Stream<ScopeEvent>
  onScopeConflict: Stream<ScopeConflictEvent>
}

// CLI Module Interface  
export interface CLIModule {
  // Command registration
  registerCommand: (spec: CommandSpec) => Effect<void, CommandError>
  unregisterCommand: (path: string[]) => Effect<void, never>
  updateCommandTree: (tree: CommandTree) => Effect<void, never>
  
  // Parsing and routing
  parseArgs: (argv: string[]) => Effect<ParsedArgs, ParseError>
  route: (args: ParsedArgs) => Effect<RouteResult, RouteError>
  execute: (route: RouteResult) => Effect<ExitCode, ExecutionError, AppServices>
  
  // Help system
  showHelp: (path: string[]) => Effect<void, never, TerminalService>
  generateCompletion: (partial: string[]) => Effect<string[], never>
  
  // Events
  onCommandRegistered: Stream<CommandEvent>
  onCommandConflict: Stream<CommandConflictEvent>
  onExecution: Stream<ExecutionEvent>
  onParseError: Stream<ParseErrorEvent>
}

// JSX Module Interface
export interface JSXModule {
  // Component lifecycle
  renderComponent: (element: JSX.Element) => Effect<RenderResult, RenderError, AppServices>
  updateScope: (scopeId: string, updates: Partial<ScopeDef>) => Effect<void, ScopeError>
  
  // Hook integration
  useScope: () => Effect<ScopeDef, ScopeError>
  useEffect: (effect: Effect<void>, deps: unknown[]) => Effect<void, never>
  
  // Runtime management
  initializeRuntime: () => Effect<void, JSXError, AppServices>
  shutdownRuntime: () => Effect<void, never>
  
  // Events
  onRender: Stream<RenderEvent>
  onScopeUpdate: Stream<ScopeUpdateEvent>
  onComponentMount: Stream<ComponentLifecycleEvent>
  onComponentUnmount: Stream<ComponentLifecycleEvent>
}

// Process Module Interface
export interface ProcessModule {
  // Process management
  spawn: (config: ProcessConfig) => Effect<ProcessHandle, ProcessError, ProcessService>
  kill: (handle: ProcessHandle) => Effect<void, ProcessError>
  list: () => Effect<ProcessInfo[], never>
  
  // Health monitoring
  checkHealth: (handle: ProcessHandle) => Effect<HealthStatus, ProcessError>
  restart: (handle: ProcessHandle) => Effect<ProcessHandle, ProcessError, ProcessService>
  
  // Events
  onProcessStart: Stream<ProcessEvent>
  onProcessExit: Stream<ProcessEvent>
  onProcessOutput: Stream<ProcessOutputEvent>
  onProcessError: Stream<ProcessErrorEvent>
}

// Style Module Interface
export interface StyleModule {
  // Style management
  registerStyles: (styles: StyleDef) => Effect<void, StyleError>
  applyStyles: (element: JSX.Element) => Effect<StyledElement, StyleError>
  computeLayout: (element: StyledElement) => Effect<LayoutInfo, LayoutError>
  
  // Theme management
  setTheme: (theme: ThemeDef) => Effect<void, ThemeError>
  getTheme: () => Effect<ThemeDef, never>
  
  // Events
  onStyleChange: Stream<StyleChangeEvent>
  onThemeChange: Stream<ThemeChangeEvent>
  onLayoutComputed: Stream<LayoutEvent>
}
```

### 2. Config Module Event Integration

**File to Create:** `src/config/events.ts`
```typescript
export interface ConfigEvent extends BaseEvent {
  readonly type: 'config-loaded' | 'config-updated' | 'config-validated' | 'config-error'
  readonly configPath?: string
  readonly section?: string
  readonly value?: unknown
  readonly previousValue?: unknown
  readonly error?: Error
}

export interface ConfigValidationEvent extends BaseEvent {
  readonly type: 'config-validation-passed' | 'config-validation-failed'
  readonly schema: string
  readonly errors?: ValidationError[]
}
```

**File to Create:** `src/config/emitter.ts`
```typescript
export class ConfigEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'config')
  }
  
  emitConfigLoaded(configPath: string): Effect<void, never> {
    return this.emitEvent<ConfigEvent>('config-events', {
      type: 'config-loaded',
      configPath
    })
  }
  
  emitConfigUpdated(section: string, value: unknown, previousValue: unknown): Effect<void, never> {
    return this.emitEvent<ConfigEvent>('config-events', {
      type: 'config-updated',
      section,
      value,
      previousValue
    })
  }
  
  emitValidationPassed(schema: string): Effect<void, never> {
    return this.emitEvent<ConfigValidationEvent>('config-validation', {
      type: 'config-validation-passed',
      schema
    })
  }
}
```

**File to Create:** `src/config/listener.ts`
```typescript
export class ConfigListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'config')
  }
  
  initialize(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<ScopeEvent>('scope-events'),
        event => this.handleScopeEvent(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleScopeEvent(event: ScopeEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'scope-entered':
          // Load scope-specific config if needed
          if (event.scope.metadata?.configPath) {
            yield* this.loadScopeConfig(event.scope.metadata.configPath as string)
          }
          break
      }
    }.bind(this))
  }
  
  private loadScopeConfig(configPath: string): Effect<void, never> {
    // Implementation for loading scope-specific config
    return Effect.void
  }
}
```

```typescript
import { Effect, Stream, Queue, Layer, Context } from "effect"

// Event base type
export interface BaseEvent {
  readonly type: string
  readonly timestamp: Date
  readonly source: string
  readonly id: string
}

// Core events
export interface ScopeEvent extends BaseEvent {
  readonly type: 'scope-registered' | 'scope-unregistered' | 'scope-updated'
  readonly scope: ScopeDef
}

export interface ScopeConflictEvent extends BaseEvent {
  readonly type: 'scope-conflict'
  readonly conflicts: ScopeConflict[]
}

// CLI events
export interface CommandEvent extends BaseEvent {
  readonly type: 'command-registered' | 'command-unregistered'
  readonly command: CommandSpec
  readonly path: string[]
}

export interface ExecutionEvent extends BaseEvent {
  readonly type: 'execution-start' | 'execution-end' | 'execution-error'
  readonly scope: ScopeDef
  readonly args: ParsedArgs
  readonly result?: unknown
  readonly error?: ExecutionError
  readonly duration?: number
}

// JSX events
export interface RenderEvent extends BaseEvent {
  readonly type: 'render-start' | 'render-end' | 'render-error'
  readonly component: JSX.Element
  readonly scope?: ScopeDef
  readonly result?: RenderResult
  readonly error?: RenderError
}

export interface ComponentLifecycleEvent extends BaseEvent {
  readonly type: 'component-mount' | 'component-unmount'
  readonly component: JSX.Element
  readonly scope: ScopeDef
}

// Process events
export interface ProcessEvent extends BaseEvent {
  readonly type: 'process-start' | 'process-exit' | 'process-restart'
  readonly processId: string
  readonly config: ProcessConfig
  readonly exitCode?: number
}

export interface ProcessOutputEvent extends BaseEvent {
  readonly type: 'process-output'
  readonly processId: string
  readonly stream: 'stdout' | 'stderr'
  readonly data: string
}

// Event Bus Service
export interface EventBus {
  // Publishing
  publish<T extends BaseEvent>(channel: string, event: T): Effect<void, never>
  
  // Subscribing
  subscribe<T extends BaseEvent>(channel: string): Stream<T>
  subscribeAll(): Stream<BaseEvent>
  
  // Filtering
  filter<T extends BaseEvent>(
    channel: string, 
    predicate: (event: T) => boolean
  ): Stream<T>
  
  // Lifecycle
  initialize: () => Effect<void, EventBusError>
  shutdown: () => Effect<void, never>
}

// Implementation
class EventBusImpl implements EventBus {
  private channels = new Map<string, Queue.Queue<BaseEvent>>()
  private globalQueue: Queue.Queue<BaseEvent>
  
  constructor() {
    this.globalQueue = Queue.unbounded<BaseEvent>()
  }
  
  publish<T extends BaseEvent>(channel: string, event: T): Effect<void, never> {
    return Effect.gen(function* () {
      // Add to channel-specific queue
      let channelQueue = this.channels.get(channel)
      if (!channelQueue) {
        channelQueue = Queue.unbounded<BaseEvent>()
        this.channels.set(channel, channelQueue)
      }
      yield* Queue.offer(channelQueue, event)
      
      // Add to global queue
      yield* Queue.offer(this.globalQueue, event)
    }.bind(this))
  }
  
  subscribe<T extends BaseEvent>(channel: string): Stream<T> {
    return Stream.fromEffect(
      Effect.sync(() => {
        let queue = this.channels.get(channel)
        if (!queue) {
          queue = Queue.unbounded<BaseEvent>()
          this.channels.set(channel, queue)
        }
        return queue
      })
    ).pipe(
      Stream.flatMap(queue => Stream.fromQueue(queue)),
      Stream.map(event => event as T)
    )
  }
  
  subscribeAll(): Stream<BaseEvent> {
    return Stream.fromQueue(this.globalQueue)
  }
  
  filter<T extends BaseEvent>(
    channel: string, 
    predicate: (event: T) => boolean
  ): Stream<T> {
    return this.subscribe<T>(channel).pipe(
      Stream.filter(predicate)
    )
  }
  
  initialize(): Effect<void, EventBusError> {
    return Effect.void
  }
  
  shutdown(): Effect<void, never> {
    return Effect.gen(function* () {
      // Shutdown all queues
      for (const queue of this.channels.values()) {
        yield* Queue.shutdown(queue)
      }
      yield* Queue.shutdown(this.globalQueue)
      this.channels.clear()
    }.bind(this))
  }
}

// Service definition
export const EventBus = Context.GenericTag<EventBus>("EventBus")

// Layer
export const EventBusLive = Layer.succeed(EventBus, new EventBusImpl())
```

### 3. Process Manager Event Integration

**File to Create:** `src/process-manager/events.ts`
```typescript
export interface ProcessEvent extends BaseEvent {
  readonly type: 'process-started' | 'process-stopped' | 'process-crashed' | 'process-restarted'
  readonly processId: string
  readonly processName: string
  readonly pid?: number
  readonly exitCode?: number
  readonly config: ProcessConfig
}

export interface ProcessOutputEvent extends BaseEvent {
  readonly type: 'process-stdout' | 'process-stderr'
  readonly processId: string
  readonly data: string
  readonly timestamp: Date
}

export interface ProcessHealthEvent extends BaseEvent {
  readonly type: 'process-health-check' | 'process-unhealthy' | 'process-recovered'
  readonly processId: string
  readonly healthStatus: 'healthy' | 'unhealthy' | 'unknown'
  readonly metrics?: HealthMetrics
}
```

**File to Create:** `src/process-manager/emitter.ts`
```typescript
export class ProcessEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'process-manager')
  }
  
  emitProcessStarted(processId: string, processName: string, pid: number, config: ProcessConfig): Effect<void, never> {
    return this.emitEvent<ProcessEvent>('process-events', {
      type: 'process-started',
      processId,
      processName,
      pid,
      config
    })
  }
  
  emitProcessOutput(processId: string, data: string, stream: 'stdout' | 'stderr'): Effect<void, never> {
    return this.emitEvent<ProcessOutputEvent>('process-output', {
      type: `process-${stream}` as const,
      processId,
      data,
      timestamp: new Date()
    })
  }
  
  emitHealthCheck(processId: string, status: 'healthy' | 'unhealthy', metrics?: HealthMetrics): Effect<void, never> {
    return this.emitEvent<ProcessHealthEvent>('process-health', {
      type: status === 'healthy' ? 'process-health-check' : 'process-unhealthy',
      processId,
      healthStatus: status,
      metrics
    })
  }
}
```

**File to Create:** `src/process-manager/listener.ts`
```typescript
export class ProcessListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'process-manager')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToCLIEvents(),
      this.subscribeToConfigEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToCLIEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<CLICommandEvent>('cli-command'),
        event => this.handleCLICommand(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleCLICommand(event: CLICommandEvent): Effect<void, never> {
    return Effect.gen(function* () {
      if (event.type === 'cli-command-executed' && event.path[0] === 'pm') {
        // Handle process management commands
        switch (event.path[1]) {
          case 'start':
            // Process start command was executed
            break
          case 'stop':
            // Process stop command was executed
            break
        }
      }
    })
  }
}
```

```typescript
import { Effect, Layer, Context } from "effect"
import { EventBus } from "./event-bus"

// Base class for modules
export abstract class ModuleBase {
  constructor(
    protected eventBus: EventBus,
    protected moduleName: string
  ) {}
  
  // Generate event IDs
  protected generateEventId(): string {
    return `${this.moduleName}-${Date.now()}-${Math.random().toString(36).slice(2)}`
  }
  
  // Publish event with module context
  protected publishEvent<T extends BaseEvent>(channel: string, event: Omit<T, 'id' | 'source' | 'timestamp'>): Effect<void, never> {
    const fullEvent = {
      ...event,
      id: this.generateEventId(),
      source: this.moduleName,
      timestamp: new Date()
    } as T
    
    return this.eventBus.publish(channel, fullEvent)
  }
  
  // Subscribe to events from other modules
  protected subscribeToEvents<T extends BaseEvent>(channel: string) {
    return this.eventBus.subscribe<T>(channel)
  }
  
  // Abstract methods each module must implement
  abstract initialize(): Effect<void, ModuleError, AppServices>
  abstract shutdown(): Effect<void, never>
}
```

### 4. Logger Event Integration

**File to Create:** `src/logger/events.ts`
```typescript
export interface LogEvent extends BaseEvent {
  readonly type: 'log-entry' | 'log-level-changed' | 'log-transport-added'
  readonly level: 'debug' | 'info' | 'warn' | 'error'
  readonly message: string
  readonly context?: Record<string, unknown>
  readonly transport?: string
}

export interface LogTransportEvent extends BaseEvent {
  readonly type: 'transport-connected' | 'transport-disconnected' | 'transport-error'
  readonly transportName: string
  readonly transportType: 'console' | 'file' | 'network'
  readonly error?: Error
}
```

**File to Create:** `src/logger/emitter.ts`
```typescript
export class LoggerEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'logger')
  }
  
  emitLogEntry(level: LogEvent['level'], message: string, context?: Record<string, unknown>): Effect<void, never> {
    return this.emitEvent<LogEvent>('log-events', {
      type: 'log-entry',
      level,
      message,
      context
    })
  }
  
  emitTransportConnected(transportName: string, transportType: LogTransportEvent['transportType']): Effect<void, never> {
    return this.emitEvent<LogTransportEvent>('log-transport', {
      type: 'transport-connected',
      transportName,
      transportType
    })
  }
}
```

**File to Create:** `src/logger/listener.ts`
```typescript
export class LoggerListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'logger')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToAllEvents(),
      this.subscribeToProcessEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToAllEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<BaseEvent>('*'), // Subscribe to all events
        event => this.logEvent(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private subscribeToProcessEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<ProcessOutputEvent>('process-output'),
        event => this.logProcessOutput(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private logEvent(event: BaseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      // Log structured event data
      yield* this.writeLog('debug', `Event: ${event.type}`, {
        source: event.source,
        timestamp: event.timestamp,
        payload: event.payload
      })
    }.bind(this))
  }
  
  private logProcessOutput(event: ProcessOutputEvent): Effect<void, never> {
    return this.writeLog('info', `Process ${event.processId}: ${event.data}`)
  }
}
```

```typescript
import { ModuleBase } from "./interop/module-base"
import { CoreModule as ICoreModule, ScopeEvent } from "./interop/module-interfaces"
import { ScopeRuntime } from "./scope-runtime"

class CoreModuleImpl extends ModuleBase implements ICoreModule {
  constructor(eventBus: EventBus) {
    super(eventBus, "core")
  }
  
  // Scope management with event publishing
  registerScope(scope: ScopeDef): Effect<void, ScopeError> {
    return Effect.gen(function* () {
      yield* ScopeRuntime.registerScope(scope)
      
      // Publish event
      yield* this.publishEvent<ScopeEvent>('scope-events', {
        type: 'scope-registered',
        scope
      })
    }.bind(this))
  }
  
  unregisterScope(scopeId: string): Effect<void, never> {
    return Effect.gen(function* () {
      const scope = yield* ScopeRuntime.findScope(scopeId)
      yield* ScopeRuntime.unregisterScope(scopeId)
      
      if (scope) {
        yield* this.publishEvent<ScopeEvent>('scope-events', {
          type: 'scope-unregistered',
          scope
        })
      }
    }.bind(this))
  }
  
  findScope(path: string[]): Effect<ScopeDef | null, never> {
    return ScopeRuntime.getStack().findByPath(path)
  }
  
  checkScopeConflicts(scope: ScopeDef): Effect<ScopeConflict[], never> {
    return Effect.sync(() => ScopeRuntime.getStack().checkConflicts(scope))
  }
  
  // Event streams
  get onScopeRegistered() {
    return this.subscribeToEvents<ScopeEvent>('scope-events').pipe(
      Stream.filter(event => event.type === 'scope-registered')
    )
  }
  
  get onScopeUnregistered() {
    return this.subscribeToEvents<ScopeEvent>('scope-events').pipe(
      Stream.filter(event => event.type === 'scope-unregistered')
    )
  }
  
  get onScopeConflict() {
    return this.subscribeToEvents<ScopeConflictEvent>('scope-events').pipe(
      Stream.filter(event => event.type === 'scope-conflict')
    )
  }
  
  initialize(): Effect<void, CoreModuleError, AppServices> {
    return Effect.gen(function* () {
      yield* ScopeRuntime.initialize()
      
      // Subscribe to cross-module events
      yield* Effect.fork(
        Stream.runForeach(
          this.eventBus.subscribeAll(),
          event => this.handleCrossModuleEvent(event)
        )
      )
    }.bind(this))
  }
  
  shutdown(): Effect<void, never> {
    return ScopeRuntime.shutdown()
  }
  
  private handleCrossModuleEvent(event: BaseEvent): Effect<void, never> {
    return Effect.gen(function* () {
      // Handle events from other modules that affect core
      switch (event.type) {
        case 'command-registered':
          // Update scope metadata when CLI registers commands
          break
        case 'component-mount':
          // Track component-scope relationships
          break
      }
    })
  }
}

// Service registration
export const CoreModule = Context.GenericTag<ICoreModule>("CoreModule")
export const CoreModuleLive = Layer.effect(
  CoreModule,
  Effect.gen(function* () {
    const eventBus = yield* EventBus
    return new CoreModuleImpl(eventBus)
  })
)
```

### 5. Styling Event Integration

**File to Create:** `src/styling/events.ts`
```typescript
export interface StyleEvent extends BaseEvent {
  readonly type: 'style-applied' | 'theme-changed' | 'layout-computed'
  readonly component?: string
  readonly styles?: ComputedStyles
  readonly theme?: ThemeConfig
  readonly layout?: LayoutInfo
}

export interface ThemeEvent extends BaseEvent {
  readonly type: 'theme-loaded' | 'theme-switched' | 'theme-customized'
  readonly themeName: string
  readonly themeConfig: ThemeConfig
  readonly previousTheme?: string
}
```

**File to Create:** `src/styling/emitter.ts`
```typescript
export class StylingEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'styling')
  }
  
  emitStyleApplied(component: string, styles: ComputedStyles): Effect<void, never> {
    return this.emitEvent<StyleEvent>('style-events', {
      type: 'style-applied',
      component,
      styles
    })
  }
  
  emitThemeChanged(themeName: string, themeConfig: ThemeConfig, previousTheme?: string): Effect<void, never> {
    return this.emitEvent<ThemeEvent>('theme-events', {
      type: 'theme-switched',
      themeName,
      themeConfig,
      previousTheme
    })
  }
  
  emitLayoutComputed(component: string, layout: LayoutInfo): Effect<void, never> {
    return this.emitEvent<StyleEvent>('style-events', {
      type: 'layout-computed',
      component,
      layout
    })
  }
}
```

**File to Create:** `src/styling/listener.ts`
```typescript
export class StylingListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'styling')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToJSXEvents(),
      this.subscribeToTerminalEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToJSXEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<JSXRenderEvent>('jsx-render'),
        event => this.handleJSXRender(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private subscribeToTerminalEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<TerminalEvent>('terminal-events'),
        event => this.handleTerminalResize(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleJSXRender(event: JSXRenderEvent): Effect<void, never> {
    return Effect.gen(function* () {
      if (event.type === 'jsx-render-start') {
        // Apply styles before rendering
        yield* this.applyComponentStyles(event.component)
      }
    }.bind(this))
  }
  
  private handleTerminalResize(event: TerminalEvent): Effect<void, never> {
    return Effect.gen(function* () {
      if (event.type === 'terminal-resize' && event.dimensions) {
        // Recompute layouts on terminal resize
        yield* this.recomputeLayouts(event.dimensions)
      }
    }.bind(this))
  }
}
```

```typescript
import { ModuleBase } from "../core/interop/module-base"
import { CLIModule as ICLIModule } from "../core/interop/module-interfaces"

class CLIModuleImpl extends ModuleBase implements ICLIModule {
  private router: CLIRouter
  private parser: CLIParser
  
  constructor(eventBus: EventBus) {
    super(eventBus, "cli")
    this.router = new CLIRouter()
    this.parser = new CLIParser()
  }
  
  registerCommand(spec: CommandSpec): Effect<void, CommandError> {
    return Effect.gen(function* () {
      yield* this.router.registerCommand(spec)
      
      // Publish event
      yield* this.publishEvent<CommandEvent>('command-events', {
        type: 'command-registered',
        command: spec,
        path: spec.path
      })
    }.bind(this))
  }
  
  execute(route: RouteResult): Effect<ExitCode, ExecutionError, AppServices> {
    return Effect.gen(function* () {
      // Publish start event
      yield* this.publishEvent<ExecutionEvent>('execution-events', {
        type: 'execution-start',
        scope: route.scope,
        args: route.args
      })
      
      const startTime = Date.now()
      
      try {
        const result = yield* route.handler(route.args, route.scope)
        const duration = Date.now() - startTime
        
        // Publish success event
        yield* this.publishEvent<ExecutionEvent>('execution-events', {
          type: 'execution-end',
          scope: route.scope,
          args: route.args,
          result,
          duration
        })
        
        return result
      } catch (error) {
        const duration = Date.now() - startTime
        
        // Publish error event
        yield* this.publishEvent<ExecutionEvent>('execution-events', {
          type: 'execution-error',
          scope: route.scope,
          args: route.args,
          error: error as ExecutionError,
          duration
        })
        
        return yield* Effect.fail(error as ExecutionError)
      }
    }.bind(this))
  }
  
  // Event streams
  get onCommandRegistered() {
    return this.subscribeToEvents<CommandEvent>('command-events').pipe(
      Stream.filter(event => event.type === 'command-registered')
    )
  }
  
  get onExecution() {
    return this.subscribeToEvents<ExecutionEvent>('execution-events')
  }
  
  initialize(): Effect<void, CLIModuleError, AppServices> {
    return Effect.gen(function* () {
      // Subscribe to scope events from core
      yield* Effect.fork(
        Stream.runForeach(
          this.subscribeToEvents<ScopeEvent>('scope-events'),
          event => this.handleScopeEvent(event)
        )
      )
    }.bind(this))
  }
  
  private handleScopeEvent(event: ScopeEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'scope-registered':
          if (event.scope.executable && event.scope.handler) {
            // Auto-register executable scopes as commands
            yield* this.registerCommand({
              path: event.scope.path,
              handler: event.scope.handler,
              description: event.scope.description,
              args: event.scope.args,
              flags: event.scope.flags,
              options: event.scope.options
            })
          }
          break
        case 'scope-unregistered':
          yield* this.unregisterCommand(event.scope.path)
          break
      }
    }.bind(this))
  }
}
```

### 6. Module Integration Layer

**File to Create:** `src/services/module.ts`
```typescript
export class ServiceModule extends ModuleBase {
  private emitter: ServiceEmitter
  private listener: ServiceListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'services')
    this.emitter = new ServiceEmitter(eventBus)
    this.listener = new ServiceListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  startService(serviceName: string, serviceType: ServiceEvent['serviceType']): Effect<void, ServiceError> {
    return Effect.gen(function* () {
      yield* this.performServiceStart(serviceName, serviceType)
      yield* this.emitter.emitServiceStarted(serviceName, serviceType)
    }.bind(this))
  }
}
```

**File to Create:** `src/config/module.ts`
```typescript
export class ConfigModule extends ModuleBase {
  private emitter: ConfigEmitter
  private listener: ConfigListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'config')
    this.emitter = new ConfigEmitter(eventBus)
    this.listener = new ConfigListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  loadConfig(path: string): Effect<ConfigData, ConfigError> {
    return Effect.gen(function* () {
      const config = yield* this.performConfigLoad(path)
      yield* this.emitter.emitConfigLoaded(path)
      return config
    }.bind(this))
  }
}
```

**File to Create:** `src/process-manager/module.ts`
```typescript
export class ProcessManagerModule extends ModuleBase {
  private emitter: ProcessEmitter
  private listener: ProcessListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'process-manager')
    this.emitter = new ProcessEmitter(eventBus)
    this.listener = new ProcessListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  startProcess(config: ProcessConfig): Effect<ProcessHandle, ProcessError> {
    return Effect.gen(function* () {
      const handle = yield* this.performProcessStart(config)
      yield* this.emitter.emitProcessStarted(handle.id, config.name, handle.pid, config)
      return handle
    }.bind(this))
  }
}
```

**File to Create:** `src/logger/module.ts`
```typescript
export class LoggerModule extends ModuleBase {
  private emitter: LoggerEmitter
  private listener: LoggerListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'logger')
    this.emitter = new LoggerEmitter(eventBus)
    this.listener = new LoggerListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  log(level: LogEvent['level'], message: string, context?: Record<string, unknown>): Effect<void, never> {
    return Effect.gen(function* () {
      yield* this.performLog(level, message, context)
      yield* this.emitter.emitLogEntry(level, message, context)
    }.bind(this))
  }
}
```

**File to Create:** `src/styling/module.ts`
```typescript
export class StylingModule extends ModuleBase {
  private emitter: StylingEmitter
  private listener: StylingListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'styling')
    this.emitter = new StylingEmitter(eventBus)
    this.listener = new StylingListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  applyTheme(themeName: string, themeConfig: ThemeConfig): Effect<void, ThemeError> {
    return Effect.gen(function* () {
      const previousTheme = yield* this.getCurrentTheme()
      yield* this.performThemeChange(themeName, themeConfig)
      yield* this.emitter.emitThemeChanged(themeName, themeConfig, previousTheme)
    }.bind(this))
  }
}
```

```typescript
// Example: Process Manager + Logging Integration
export const createProcessManagerWithLogging = () =>
  Effect.gen(function* () {
    const processModule = yield* ProcessModule
    const eventBus = yield* EventBus
    
    // Subscribe to process events for logging
    yield* Effect.fork(
      Stream.runForeach(
        processModule.onProcessOutput,
        (event) => Effect.gen(function* () {
          // Log process output to appropriate scope
          const scope = yield* CoreModule.findScope(['pm', 'logs'])
          if (scope) {
            yield* JSXModule.updateScope(scope.id, {
              runtimeData: { 
                logs: [...(scope.runtimeData?.logs || []), event.data]
              }
            })
          }
        })
      )
    )
    
    // Subscribe to process start/stop for notifications
    yield* Effect.fork(
      Stream.runForeach(
        processModule.onProcessStart,
        (event) => eventBus.publish('notifications', {
          type: 'notification',
          level: 'info',
          message: `Process ${event.config.name} started`,
          timestamp: new Date(),
          source: 'process-manager',
          id: generateId()
        })
      )
    )
  })

// Example: Style-aware Component Rendering
export const renderWithCrossModuleStyles = (element: JSX.Element) =>
  Effect.gen(function* () {
    const jsxModule = yield* JSXModule
    const styleModule = yield* StyleModule
    
    // Apply styles before rendering
    const styled = yield* styleModule.applyStyles(element)
    
    // Compute layout
    const layout = yield* styleModule.computeLayout(styled)
    
    // Render with applied styles
    const result = yield* jsxModule.renderComponent(styled)
    
    // Publish render event with style info
    yield* EventBus.publish('render-events', {
      type: 'render-end',
      component: element,
      result,
      metadata: { layout, styles: styled.computedStyles },
      timestamp: new Date(),
      source: 'jsx-style-integration',
      id: generateId()
    })
    
    return result
  })
```

## Testing Strategy

### Unit Tests
**File:** `src/core/interop/event-bus.test.ts`
```typescript
test("EventBus publishes and subscribes correctly", async () => {
  const eventBus = new EventBusImpl()
  const events: ScopeEvent[] = []
  
  // Subscribe before publishing
  const subscription = eventBus.subscribe<ScopeEvent>('scope-events')
  Effect.runFork(
    Stream.runForeach(subscription, event => Effect.sync(() => events.push(event)))
  )
  
  // Publish event
  const testScope: ScopeDef = { /* ... */ }
  await Effect.runPromise(
    eventBus.publish('scope-events', {
      type: 'scope-registered',
      scope: testScope,
      timestamp: new Date(),
      source: 'test',
      id: 'test-1'
    })
  )
  
  // Wait for processing
  await new Promise(resolve => setTimeout(resolve, 10))
  
  expect(events).toHaveLength(1)
  expect(events[0].type).toBe('scope-registered')
  expect(events[0].scope).toBe(testScope)
})
```

### Integration Tests
**File:** `tests/e2e/interop-layer.test.ts`
```typescript
test("modules communicate through event streams", async () => {
  const services = Layer.mergeAll(
    EventBusLive,
    CoreModuleLive,
    CLIModuleLive
  )
  
  const program = Effect.gen(function* () {
    const core = yield* CoreModule
    const cli = yield* CLIModule
    
    // Track events
    const commandEvents: CommandEvent[] = []
    yield* Effect.fork(
      Stream.runForeach(
        cli.onCommandRegistered,
        event => Effect.sync(() => commandEvents.push(event))
      )
    )
    
    // Register scope (should trigger command registration)
    const scope: ScopeDef = {
      id: 'test-scope',
      type: 'command',
      name: 'test',
      path: ['test'],
      executable: true,
      handler: () => Effect.succeed(0),
      children: []
    }
    
    yield* core.registerScope(scope)
    
    // Wait for events
    yield* Effect.sleep(Duration.millis(50))
    
    return commandEvents
  })
  
  const result = await Effect.runPromise(program.pipe(Effect.provide(services)))
  
  expect(result).toHaveLength(1)
  expect(result[0].command.path).toEqual(['test'])
})
```

## Files Modified

### New Service Files
- `src/services/events.ts` - Service event definitions
- `src/services/emitter.ts` - Service event emission
- `src/services/listener.ts` - Service event handling
- `src/services/module.ts` - Service module integration

### New Config Files
- `src/config/events.ts` - Config event definitions
- `src/config/emitter.ts` - Config event emission
- `src/config/listener.ts` - Config event handling
- `src/config/module.ts` - Config module integration

### New Process Manager Files
- `src/process-manager/events.ts` - Process event definitions
- `src/process-manager/emitter.ts` - Process event emission
- `src/process-manager/listener.ts` - Process event handling
- `src/process-manager/module.ts` - Process manager integration

### New Logger Files
- `src/logger/events.ts` - Logger event definitions
- `src/logger/emitter.ts` - Logger event emission
- `src/logger/listener.ts` - Logger event handling
- `src/logger/module.ts` - Logger module integration

### New Styling Files
- `src/styling/events.ts` - Styling event definitions
- `src/styling/emitter.ts` - Styling event emission
- `src/styling/listener.ts` - Styling event handling
- `src/styling/module.ts` - Styling module integration

### Modified Files
- `src/core/module-registry.ts` - Add service modules
- `src/services/impl/*.ts` - Integrate with event system
- `src/logger/logger.ts` - Emit events on log operations
- `src/process-manager/manager.ts` - Emit events on process operations

### Test Files
- `src/services/events.test.ts`
- `src/config/events.test.ts`
- `src/process-manager/events.test.ts`
- `src/logger/events.test.ts`
- `src/styling/events.test.ts`
- `tests/e2e/service-integration.test.ts`

## Success Criteria

✅ **Service Integration**: All service modules use event communication
✅ **Config Event Flow**: Configuration changes flow through event system
✅ **Process Event Coordination**: Process manager integrates with CLI and logging
✅ **Logger Event Aggregation**: Logger receives events from all modules
✅ **Styling Event Reactivity**: Styling responds to terminal and component events
✅ **Cross-Module Workflows**: Complex integrations (PM + logging + CLI) work seamlessly
✅ **Event Type Safety**: All service events are properly typed
✅ **Clean Module Boundaries**: No direct dependencies between service modules

## What Was Actually Implemented

### Service Layer Modules
1. **Service Module (`src/services/module.ts`)**
   - Manages terminal, input, renderer, and storage services
   - Service lifecycle events (started, ready, stopped, error)
   - Integration with JSX rendering and CLI commands

2. **Config Module (`src/config/module.ts`)**
   - Configuration loading and validation
   - Reactive configuration updates
   - Schema registration and validation events
   - Scope-based configuration support

3. **Process Manager Module (`src/process-manager/module.ts`)**
   - Process spawning and lifecycle management
   - Health monitoring with automatic restarts
   - Process groups for coordinated management
   - Output streaming events

4. **Logger Module (`src/logger/module.ts`)**
   - Centralized logging with multiple transports
   - Event aggregation from all modules
   - Log filtering and level management
   - Audit logging of all system events

5. **Styling Module (`src/styling/module.ts`)**
   - Theme management and switching
   - Responsive style computation
   - Layout calculation and invalidation
   - Terminal resize handling

### Bootstrap System (`src/core/bootstrap.ts`)
- Flexible module initialization
- Optional module enabling based on configuration
- Typed module access for better developer experience
- Minimal, standard, and full bootstrap options

### Integration Testing
- Comprehensive test suite demonstrating:
  - Service lifecycle management
  - Configuration-driven behavior
  - Cross-module event communication
  - Logger event aggregation
  - Theme updates from config changes

## Dependencies for Next Phase

**Phase 3 Provides for Phase 4:**
- ✅ Complete service layer event integration
- ✅ Config, Process, Logger, and Styling modules in event system
- ✅ Complex cross-module workflow patterns established
- ✅ Foundation for advanced component and plugin coordination
- ✅ Event-driven service orchestration ready for optimization
- ✅ Bootstrap system for flexible application initialization