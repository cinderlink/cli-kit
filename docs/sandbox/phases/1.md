# Phase 1: Complete Scope System Integration

## ARCHITECTURAL DESIGN PROPOSAL
### Status: ✅ COMPLETED
This document describes the completed scope system integration in TUIX. The core infrastructure has been successfully integrated with CLI components.

## Overview

Complete the scope system integration to enable proper plugin nesting in JSX applications. The core scope infrastructure already exists and the JSX runtime uses a unified scope stack. This phase focuses on integrating CLI components with the scope system to realize its full benefits.

## Current Status

✅ **Completed**: Core scope system (`src/core/scope.ts`) with comprehensive tests
✅ **Completed**: JSX scope integration (`src/core/jsx-scope-integration.ts`) 
✅ **Completed**: JSXPluginRegistry refactored to use unified `ScopeStack`
✅ **Completed**: Old `currentPluginName` approach removed
✅ **Completed**: CLI components now use scope wrapping (`src/cli/components/Plugin.tsx`, `Command.tsx`)
✅ **Completed**: Automatic command registration from JSX structure
✅ **Completed**: Two scope implementations documented (`docs/SCOPE_SYSTEM_ARCHITECTURE.md`)

## Current Technical Problems

### 1. CLI Components Don't Use Scope System
**Issue**: CLI components like Plugin and Command don't wrap their content in scope providers, preventing automatic scope-based command registration.

### 2. Two Separate Scope Implementations
**Issue**: The codebase has two scope systems that aren't fully integrated:
- `src/core/scope.ts` - Comprehensive, Effect-based scope system
- `src/jsx/scope.ts` - Simpler scope component for help rendering

### 3. No Automatic Command Registration
**Issue**: Commands are still manually registered rather than automatically derived from the JSX structure and scope hierarchy.

### 4. Missing Working Examples
**Issue**: No example demonstrates actual plugin-within-plugin usage with proper command scoping.

## Technical Solution

### 1. Complete CLI Component Integration

**Create scope-aware CLI components:**

```typescript
// src/cli/components/Plugin.tsx
import { useScope } from '../../core/scope-hooks'
import { ScopeContext } from '../../core/scope'
import { useEffect } from '../../jsx/hooks'

export interface PluginProps {
  name: string
  description?: string
  children: React.ReactNode
}

export function Plugin({ name, description, children }: PluginProps) {
  const scope = useScope({
    type: 'plugin',
    name,
    metadata: { description }
  })
  
  useEffect(() => {
    // Register plugin with scope system
    return () => {
      // Cleanup on unmount
    }
  }, [scope])
  
  return (
    <scope-provider value={scope}>
      <plugin name={name}>{children}</plugin>
    </scope-provider>
  )
}

// src/cli/components/Command.tsx
export interface CommandProps {
  name: string
  description?: string
  handler: CommandHandler
  children?: React.ReactNode
}

export function Command({ name, description, handler, children }: CommandProps) {
  const scope = useScope({
    type: 'command',
    name,
    metadata: { description, handler }
  })
  
  useEffect(() => {
    // Register command with full path from scope hierarchy
    const fullPath = scope.getPath()
    registerCommand(fullPath, handler)
    
    return () => {
      // Unregister on unmount
      unregisterCommand(fullPath)
    }
  }, [scope, handler])
  
  return (
    <scope-provider value={scope}>
      <command name={name}>{children}</command>
    </scope-provider>
  )
}
```

### 2. Unify Scope Implementations

**Option A: Merge into single implementation**
```typescript
// Move JSX-specific scope features into core scope system
// Add rendering-specific metadata to ScopeContext
interface ScopeContext {
  // ... existing fields
  renderMetadata?: {
    helpText?: string
    examples?: string[]
    // ... other UI-specific data
  }
}
```

**Option B: Document different purposes**
```typescript
// src/core/scope.ts - Runtime scope management
// src/jsx/scope.ts - UI rendering helpers
// Add clear documentation explaining the separation
```

### 3. Create Working Plugin Nesting Example

```tsx
// examples/nested-plugins-demo.tsx
import { Plugin, Command } from '../src/cli/components'

function App() {
  return (
    <Plugin name="dev" description="Development tools">
      <Command name="setup" handler={setupHandler} description="Setup development environment" />
      
      <Plugin name="db" description="Database tools">
        <Command name="migrate" handler={migrateHandler} description="Run database migrations" />
        <Command name="seed" handler={seedHandler} description="Seed the database" />
      </Plugin>
      
      <Plugin name="test" description="Testing tools">
        <Command name="run" handler={testHandler} description="Run tests" />
        <Command name="coverage" handler={coverageHandler} description="Generate coverage report" />
      </Plugin>
    </Plugin>
  )
}

// Should create these commands:
// - app dev setup
// - app dev db migrate  
// - app dev db seed
// - app dev test run
// - app dev test coverage
```

## Implementation Steps

### Step 1: Create Scope Hooks
```typescript
// src/core/scope-hooks.ts
import { useContext } from '../jsx/hooks'
import { ScopeContext } from './scope'

export function useScope(definition: Partial<ScopeContext>): ScopeContext {
  const parentScope = useContext(ScopeContext)
  
  return {
    id: generateId(),
    type: definition.type || 'component',
    name: definition.name || 'unnamed',
    path: [...(parentScope?.path || []), definition.name],
    parent: parentScope,
    children: [],
    metadata: definition.metadata || {}
  }
}
```

### Step 2: Update JSX Runtime Integration
The JSX runtime already uses the scope stack correctly. We just need to ensure CLI components participate in this system.

### Step 3: Create Integration Tests
```typescript
// tests/e2e/plugin-nesting-complete.test.ts
import { test, expect } from "bun:test"
import { renderJSXCLI } from "../e2e/component-test-utils"

test("nested plugins create proper command hierarchy", async () => {
  const app = (
    <Plugin name="pm">
      <Command name="start" handler={startHandler} />
      <Plugin name="logs">
        <Command name="show" handler={showHandler} />
      </Plugin>
    </Plugin>
  )
  
  const result = await renderJSXCLI(app)
  
  // Verify command paths
  expect(result.commands).toHaveProperty("pm start")
  expect(result.commands).toHaveProperty("pm logs show")
  
  // Verify scope isolation
  expect(result.commands["pm start"].scope.parent?.name).toBe("pm")
  expect(result.commands["pm logs show"].scope.parent?.parent?.name).toBe("pm")
})
```

## Success Criteria

✅ **CLI Components Use Scopes**: Plugin and Command components wrap content in scope providers
✅ **Automatic Command Registration**: Commands register with their full path from JSX structure
✅ **Working Examples**: Nested plugin example demonstrates proper command hierarchy
✅ **Tests Pass**: Integration tests verify scope isolation and command paths
✅ **Documentation Updated**: Clear docs on how to use plugin nesting

## Dependencies and Risks

### Dependencies
- Existing scope system implementation
- JSX runtime and hooks
- CLI command registration system

### Risks
- Breaking existing CLI applications that don't expect scope wrapping
- Performance impact of scope tracking (mitigate with careful implementation)

### Mitigation
- Make scope integration opt-in initially
- Profile performance before and after changes
- Comprehensive test coverage

## Next Steps After This Phase

Once scope integration is complete, evaluate whether the event-driven architecture proposed in phases 2-7 is actually needed. The current direct-import architecture may be sufficient for TUIX's needs.

## Completion Summary (Added Post-Implementation)

### What Was Built

1. **Scope Hooks System** (`src/core/scope-hooks.ts`)
   - React-style hooks for scope management
   - Global scope system initialization
   - Helper functions for common scope operations

2. **Scope-Aware Components**
   - `Plugin` component with full scope integration
   - Updated `Command` component with automatic path registration
   - `ScopeProvider` for manual scope management

3. **Working Examples**
   - `examples/nested-plugins-demo.tsx` demonstrating deep nesting
   - Clear command hierarchy examples

4. **Comprehensive Testing**
   - Integration tests in `tests/e2e/plugin-nesting-complete.test.ts`
   - All tests passing with good coverage

5. **Documentation**
   - `docs/SCOPE_SYSTEM_ARCHITECTURE.md` explaining the two systems
   - `docs/SCOPE_USAGE_GUIDE.md` with complete usage instructions

### Key Learnings

1. **Two Scope Systems Are Good**
   - Keeping core scope (runtime) and JSX scope (UI) separate provides better separation of concerns
   - Integration layer (`jsx-scope-integration.ts`) successfully bridges them

2. **JSX Runtime Considerations**
   - Need `jsx-runtime.ts` and `jsx-dev-runtime.ts` at project root for tests
   - TypeScript's `jsxImportSource` configuration is crucial

3. **Effect Pattern Success**
   - Effect-based operations provided excellent error handling
   - Scope lifecycle management benefits from Effect's resource management

4. **Testing Approach**
   - Testing at the integration level (without full JSX rendering) was most effective
   - Direct scope manipulation tests caught edge cases

### Challenges Overcome

1. **JSX in Tests**: Solved by creating proper jsx-runtime exports
2. **Scope Lifecycle**: Managed through careful push/pop in component render functions
3. **Path Registration**: Solved by computing full path from scope hierarchy

### Architecture Decisions

1. **Keep Direct Imports**: The event-driven architecture proposed in phases 2-7 may not be necessary
2. **Scope Stack Global**: Made scope stack global with initialization function for simplicity
3. **Metadata Flexibility**: Scope metadata as `Record<string, unknown>` provides extensibility

### Performance Notes

- Scope operations are O(1) for push/pop
- Path computation is O(depth) but depth is typically small (2-4 levels)
- No performance issues observed in testing