# Phase 2: Domain Event Systems

## PHASE 2 IMPLEMENTATION STATUS
### Status: Completed (December 2024)
This phase has been successfully implemented with a full event-driven architecture for TUIX. The event bus and domain event systems are now operational and tested.

### Implementation Summary
- ✅ **Event Bus**: Simple pub/sub implementation using Effect patterns
- ✅ **Domain Modules**: JSX, CLI, and Reactivity modules with event communication
- ✅ **Module Registry**: Central coordination for all domain modules
- ✅ **ScopeDef Type**: Enhanced scope definition with lifecycle hooks and metadata
- ✅ **Integration Tests**: Comprehensive test coverage for event system

### Key Architectural Decisions
1. **Simplified Event Bus**: Instead of using Effect Streams with Queues, implemented a direct pub/sub pattern for better performance and simplicity
2. **Optional Integration**: The event system is available but not required - modules can still use direct imports where appropriate
3. **Lifecycle Hooks**: ScopeDef includes onEnter/onExit/onChild hooks for extensibility
4. **Partial Integration**: Existing files (jsx/runtime.ts, cli/router.ts, reactivity/runes.ts) were modified to emit events while maintaining backward compatibility

## Overview

Implement domain-specific event emitters and listeners for JSX, CLI, and Reactivity modules. This phase establishes clean inter-domain communication patterns and removes remaining tight coupling.

## Dependencies

**Requires Phase 1 Complete:**
- ✅ Generic event bus foundation (`src/core/bus.ts`)
- ✅ Core event definitions (`src/core/events.ts`) 
- ✅ Module base class (`src/core/module-base.ts`)
- ✅ JSX integration moved to JSX domain
- ✅ Event-driven scope system working

## Technical Implementation

### 1. JSX Domain Event System

**File to Create:** `src/jsx/events.ts`
```typescript
import { BaseEvent } from '../core/events'
import { ScopeContext } from '../core/scope'

// JSX-specific events
export interface JSXRenderEvent extends BaseEvent {
  readonly type: 'jsx-render-start' | 'jsx-render-end' | 'jsx-render-error'
  readonly component: JSX.Element
  readonly scope?: ScopeContext
  readonly renderTime?: number
  readonly error?: Error
}

export interface JSXLifecycleEvent extends BaseEvent {
  readonly type: 'jsx-mount' | 'jsx-unmount' | 'jsx-update'
  readonly componentId: string
  readonly componentType: string
  readonly scope: ScopeContext
}

export interface JSXScopeEvent extends BaseEvent {
  readonly type: 'jsx-scope-created' | 'jsx-scope-destroyed'
  readonly scope: ScopeContext
  readonly parentScope?: ScopeContext
}
```

**File to Enhance:** `src/jsx/scope/emitter.ts`

```typescript
export interface ScopeDef {
  // Identity
  readonly id: string
  readonly type: 'cli' | 'plugin' | 'command' | 'arg' | 'flag' | 'option' | 'component'
  readonly name: string
  
  // Hierarchy (managed by ScopeStack)
  parent?: ScopeDef
  children: ScopeDef[]
  readonly path: string[]  // Computed: ['cli', 'pm', 'start']
  
  // Execution
  readonly executable: boolean
  handler?: Handler
  defaultContent?: JSX.Element
  
  // Configuration
  args?: Record<string, ArgDef>
  flags?: Record<string, FlagDef>
  options?: Record<string, OptionDef>
  
  // Metadata
  description?: string
  readonly hidden?: boolean
  readonly aliases?: string[]
  
  // Lifecycle hooks (Effect-based)
  onEnter?: (ctx: ScopeContext) => Effect<void, ScopeError>
  onExit?: (ctx: ScopeContext) => Effect<void, ScopeError>
  onChild?: (child: ScopeDef) => Effect<void, ScopeError>
}

export interface ArgDef {
  type: 'string' | 'number' | 'boolean'
  description?: string
  required?: boolean
  default?: unknown
}

export interface FlagDef {
  shortName?: string
  description?: string
  conflicts?: string[]
}

export interface OptionDef {
  type: 'string' | 'number' | 'boolean'
  shortName?: string
  description?: string
  required?: boolean
  default?: unknown
  choices?: unknown[]
}

export interface Handler {
  (args: ParsedArgs, scope: ScopeDef): Effect<ExitCode, ExecutionError, AppServices>
}
```

### 2. JSX Event Implementation

**File to Complete:** `src/jsx/scope/emitter.ts`
```typescript
import { Effect } from 'effect'
import { ModuleBase } from '../../core/module-base'
import { JSXRenderEvent, JSXLifecycleEvent, JSXScopeEvent } from '../events'
import { ScopeContext } from '../../core/scope'

export class JSXScopeEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'jsx')
  }
  
  emitRenderStart(component: JSX.Element, scope?: ScopeContext): Effect<void, never> {
    return this.emitEvent<JSXRenderEvent>('jsx-render', {
      type: 'jsx-render-start',
      component,
      scope
    })
  }
  
  emitRenderEnd(component: JSX.Element, scope?: ScopeContext, renderTime?: number): Effect<void, never> {
    return this.emitEvent<JSXRenderEvent>('jsx-render', {
      type: 'jsx-render-end',
      component,
      scope,
      renderTime
    })
  }
  
  emitScopeCreated(scope: ScopeContext, parentScope?: ScopeContext): Effect<void, never> {
    return this.emitEvent<JSXScopeEvent>('jsx-scope', {
      type: 'jsx-scope-created',
      scope,
      parentScope
    })
  }
  
  emitComponentMount(componentId: string, componentType: string, scope: ScopeContext): Effect<void, never> {
    return this.emitEvent<JSXLifecycleEvent>('jsx-lifecycle', {
      type: 'jsx-mount',
      componentId,
      componentType,
      scope
    })
  }
}
```

**File to Complete:** `src/jsx/scope/listener.ts`
```typescript
export class JSXScopeListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'jsx')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToCoreEvents(),
      this.subscribeToCLIEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToCoreEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<ScopeEvent>('scope-events'),
        event => this.handleCoreScope Event(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleCoreScopeEvent(event: ScopeEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'scope-entered':
          // Update JSX runtime context
          break
        case 'scope-exited':
          // Clean up JSX resources
          break
      }
    })
  }
}
```

**Add ScopeDef Integration:**
```typescript
export class ScopeStack {
  private stack: Array<ScopeDef> = []
  private registry: Map<string, ScopeDef> = new Map()
  private pathIndex: Map<string, ScopeDef> = new Map()
  
  push(scope: ScopeDef): Effect<void, ScopeError> {
    return Effect.gen(function* () {
      // Update parent/child relationships
      const parent = this.current()
      if (parent) {
        scope.parent = parent
        parent.children.push(scope)
        scope.path = [...parent.path, scope.name]
      } else {
        scope.path = [scope.name]
      }
      
      // Check for conflicts
      const existingAtPath = this.pathIndex.get(scope.path.join('.'))
      if (existingAtPath && existingAtPath.id !== scope.id) {
        yield* Effect.fail(new ScopeConflictError(scope.path, existingAtPath))
      }
      
      // Register
      this.stack.push(scope)
      this.registry.set(scope.id, scope)
      this.pathIndex.set(scope.path.join('.'), scope)
      
      // Trigger lifecycle
      if (scope.onEnter) {
        yield* scope.onEnter({ scope, stack: this })
      }
      
      // Notify parent
      if (parent?.onChild) {
        yield* parent.onChild(scope)
      }
    }.bind(this))
  }
  
  pop(): Effect<ScopeDef | null, never> {
    return Effect.gen(function* () {
      const scope = this.stack.pop()
      if (!scope) return null
      
      // Trigger lifecycle
      if (scope.onExit) {
        yield* scope.onExit({ scope, stack: this }).pipe(
          Effect.catchAll(() => Effect.void) // Don't fail on cleanup
        )
      }
      
      // Clean up indices
      this.pathIndex.delete(scope.path.join('.'))
      this.registry.delete(scope.id)
      
      return scope
    }.bind(this))
  }
  
  findByPath(path: string[]): Effect<ScopeDef | null, never> {
    return Effect.sync(() => this.pathIndex.get(path.join('.')) || null)
  }
  
  getExecutableScopes(): ScopeDef[] {
    return Array.from(this.registry.values()).filter(s => s.executable)
  }
  
  checkConflicts(scope: ScopeDef): ScopeConflict[] {
    const conflicts: ScopeConflict[] = []
    const pathKey = scope.path.join('.')
    
    // Name conflicts
    const existing = this.pathIndex.get(pathKey)
    if (existing && existing.id !== scope.id) {
      conflicts.push({
        type: 'name',
        scope,
        conflictsWith: existing,
        path: scope.path
      })
    }
    
    // Alias conflicts
    if (scope.aliases) {
      for (const alias of scope.aliases) {
        const aliasPath = [...scope.path.slice(0, -1), alias]
        const aliasConflict = this.pathIndex.get(aliasPath.join('.'))
        if (aliasConflict) {
          conflicts.push({
            type: 'alias',
            scope,
            conflictsWith: aliasConflict,
            path: aliasPath
          })
        }
      }
    }
    
    return conflicts
  }
}
```

### 3. CLI Domain Event System

**File to Create:** `src/cli/events.ts`
```typescript
export interface CLICommandEvent extends BaseEvent {
  readonly type: 'cli-command-registered' | 'cli-command-executed' | 'cli-command-failed'
  readonly path: string[]
  readonly args?: ParsedArgs
  readonly result?: unknown
  readonly error?: Error
  readonly executionTime?: number
}

export interface CLIParseEvent extends BaseEvent {
  readonly type: 'cli-parse-start' | 'cli-parse-success' | 'cli-parse-error'
  readonly input: string[]
  readonly result?: ParsedArgs
  readonly error?: ParseError
}

export interface CLIRouteEvent extends BaseEvent {
  readonly type: 'cli-route-found' | 'cli-route-not-found'
  readonly path: string[]
  readonly handler?: Function
}
```

**File to Create:** `src/cli/scope/emitter.ts`
```typescript
export class CLIScopeEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'cli')
  }
  
  emitCommandRegistered(path: string[], handler: Function): Effect<void, never> {
    return this.emitEvent<CLICommandEvent>('cli-command', {
      type: 'cli-command-registered',
      path,
      payload: { handler }
    })
  }
  
  emitCommandExecuted(path: string[], args: ParsedArgs, result: unknown, executionTime: number): Effect<void, never> {
    return this.emitEvent<CLICommandEvent>('cli-command', {
      type: 'cli-command-executed',
      path,
      args,
      result,
      executionTime
    })
  }
  
  emitParseSuccess(input: string[], result: ParsedArgs): Effect<void, never> {
    return this.emitEvent<CLIParseEvent>('cli-parse', {
      type: 'cli-parse-success',
      input,
      result
    })
  }
}
```

**File to Create:** `src/cli/scope/listener.ts`
```typescript
export class CLIScopeListener extends ModuleBase {
  constructor(eventBus: EventBus, private router: CLIRouter) {
    super(eventBus, 'cli')
  }
  
  initialize(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<ScopeEvent>('scope-events'),
        event => this.handleScopeEvent(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleScopeEvent(event: ScopeEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'scope-entered':
          if (event.scope.type === 'command' && event.scope.handler) {
            // Auto-register executable scopes as CLI commands
            yield* this.router.registerCommand({
              path: event.scope.path,
              handler: event.scope.handler,
              description: event.scope.metadata?.description
            })
          }
          break
        case 'scope-exited':
          if (event.scope.type === 'command') {
            yield* this.router.unregisterCommand(event.scope.path)
          }
          break
      }
    }.bind(this))
  }
}
```

```tsx
import { useEffect, useId } from 'react'
import { Effect } from 'effect'
import { ScopeRuntime } from '../../core/scope-runtime'
import { ScopeDef } from '../../core/scope-def'

interface ScopeProps {
  def: ScopeDef
  children?: React.ReactNode
}

export function Scope({ def, children }: ScopeProps) {
  const scopeId = useId()
  
  // Register scope with runtime on mount
  useEffect(() => {
    const scopeWithId = { ...def, id: scopeId }
    
    const cleanup = Effect.runSync(
      ScopeRuntime.registerScope(scopeWithId).pipe(
        Effect.map(() => () => Effect.runSync(ScopeRuntime.unregisterScope(scopeId)))
      )
    )
    
    return cleanup
  }, [def, scopeId])
  
  // Trigger lifecycle effects
  useLayoutEffect(() => {
    if (def.onEnter) {
      Effect.runPromise(
        def.onEnter({ scope: { ...def, id: scopeId }, stack: ScopeRuntime.getStack() })
      ).catch(console.error)
    }
    
    return () => {
      if (def.onExit) {
        Effect.runPromise(
          def.onExit({ scope: { ...def, id: scopeId }, stack: ScopeRuntime.getStack() })
        ).catch(console.error)
      }
    }
  }, [def, scopeId])
  
  return (
    <scope-intrinsic def={{ ...def, id: scopeId }}>
      {children}
    </scope-intrinsic>
  )
}
```

### 4. Reactivity Domain Event System

**File to Create:** `src/reactivity/events.ts`
```typescript
export interface RuneEvent extends BaseEvent {
  readonly type: 'rune-created' | 'rune-updated' | 'rune-destroyed'
  readonly runeId: string
  readonly runeName: string
  readonly value?: unknown
  readonly previousValue?: unknown
}

export interface LifecycleEvent extends BaseEvent {
  readonly type: 'lifecycle-mount' | 'lifecycle-unmount' | 'lifecycle-update'
  readonly componentId: string
  readonly hookName?: string
  readonly dependencies?: unknown[]
}

export interface StateEvent extends BaseEvent {
  readonly type: 'state-change' | 'state-invalidation'
  readonly stateId: string
  readonly value: unknown
  readonly source: 'user' | 'effect' | 'prop'
}
```

**File to Create:** `src/reactivity/emitter.ts`
```typescript
export class ReactivityEmitter extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'reactivity')
  }
  
  emitRuneCreated(runeId: string, runeName: string, value: unknown): Effect<void, never> {
    return this.emitEvent<RuneEvent>('rune-events', {
      type: 'rune-created',
      runeId,
      runeName,
      value
    })
  }
  
  emitRuneUpdated(runeId: string, runeName: string, value: unknown, previousValue: unknown): Effect<void, never> {
    return this.emitEvent<RuneEvent>('rune-events', {
      type: 'rune-updated',
      runeId,
      runeName,
      value,
      previousValue
    })
  }
  
  emitStateChange(stateId: string, value: unknown, source: 'user' | 'effect' | 'prop'): Effect<void, never> {
    return this.emitEvent<StateEvent>('state-events', {
      type: 'state-change',
      stateId,
      value,
      source
    })
  }
}
```

**File to Create:** `src/reactivity/listener.ts`
```typescript
export class ReactivityListener extends ModuleBase {
  constructor(eventBus: EventBus) {
    super(eventBus, 'reactivity')
  }
  
  initialize(): Effect<void, never> {
    return Effect.all([
      this.subscribeToJSXEvents(),
      this.subscribeToCLIEvents()
    ]).pipe(Effect.asVoid)
  }
  
  private subscribeToJSXEvents(): Effect<void, never> {
    return Effect.fork(
      Stream.runForeach(
        this.subscribe<JSXLifecycleEvent>('jsx-lifecycle'),
        event => this.handleJSXLifecycle(event)
      )
    ).pipe(Effect.asVoid)
  }
  
  private handleJSXLifecycle(event: JSXLifecycleEvent): Effect<void, never> {
    return Effect.gen(function* () {
      switch (event.type) {
        case 'jsx-mount':
          // Initialize reactive state for component
          break
        case 'jsx-unmount':
          // Clean up reactive subscriptions
          break
      }
    })
  }
}
```

```tsx
import { Scope } from '../../components/system/Scope'
import { ScopeDef } from '../../core/scope-def'

interface PluginProps {
  name: string
  description?: string
  hidden?: boolean
  aliases?: string[]
  children?: React.ReactNode
}

export function Plugin({ name, description, hidden, aliases, children }: PluginProps) {
  const def: ScopeDef = {
    id: '', // Will be set by Scope component
    type: 'plugin',
    name,
    path: [], // Will be computed by ScopeStack
    executable: true,
    defaultContent: children,
    description,
    hidden,
    aliases,
    children: [],
    
    // Plugin lifecycle hooks
    onEnter: ({ scope }) => Effect.gen(function* () {
      // Register as CLI command if executable
      if (scope.executable) {
        yield* CLIModule.registerCommand({
          path: scope.path,
          handler: scope.handler || showDefaultContent,
          description: scope.description
        })
      }
    }),
    
    onExit: ({ scope }) => Effect.gen(function* () {
      // Cleanup CLI command registration
      yield* CLIModule.unregisterCommand(scope.path)
    })
  }
  
  return (
    <Scope def={def}>
      {children}
    </Scope>
  )
}

// Default handler shows plugin's defaultContent
const showDefaultContent = (args: ParsedArgs, scope: ScopeDef) =>
  Effect.gen(function* () {
    if (scope.defaultContent) {
      yield* JSXModule.renderComponent(scope.defaultContent)
      return 0 as ExitCode
    }
    
    // Show help if no default content
    yield* CLIModule.showHelp(scope.path)
    return 0 as ExitCode
  })
```

**File to Create:** `src/cli/components/Command.tsx`

```tsx
import { Scope } from '../../components/system/Scope'
import { ScopeDef, Handler } from '../../core/scope-def'

interface CommandProps {
  name: string
  handler: Handler
  description?: string
  args?: Record<string, ArgDef>
  flags?: Record<string, FlagDef>
  options?: Record<string, OptionDef>
  aliases?: string[]
  hidden?: boolean
}

export function Command({ 
  name, 
  handler, 
  description, 
  args, 
  flags, 
  options, 
  aliases, 
  hidden 
}: CommandProps) {
  const def: ScopeDef = {
    id: '',
    type: 'command',
    name,
    path: [],
    executable: true,
    handler,
    description,
    args,
    flags,
    options,
    aliases,
    hidden,
    children: [],
    
    onEnter: ({ scope }) => Effect.gen(function* () {
      // Register command with full argument/flag/option spec
      yield* CLIModule.registerCommand({
        path: scope.path,
        handler: scope.handler!,
        description: scope.description,
        args: scope.args,
        flags: scope.flags,
        options: scope.options,
        aliases: scope.aliases
      })
    }),
    
    onExit: ({ scope }) => Effect.gen(function* () {
      yield* CLIModule.unregisterCommand(scope.path)
    })
  }
  
  return <Scope def={def} />
}
```

### 5. Domain Module Integration

**File to Create:** `src/jsx/module.ts`
```typescript
import { ModuleBase } from '../core/module-base'
import { JSXScopeEmitter } from './scope/emitter'
import { JSXScopeListener } from './scope/listener'

export class JSXModule extends ModuleBase {
  private emitter: JSXScopeEmitter
  private listener: JSXScopeListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'jsx')
    this.emitter = new JSXScopeEmitter(eventBus)
    this.listener = new JSXScopeListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return Effect.gen(function* () {
      yield* this.listener.initialize()
      // Initialize JSX runtime with event integration
    }.bind(this))
  }
  
  renderComponent(element: JSX.Element): Effect<RenderResult, RenderError> {
    return Effect.gen(function* () {
      yield* this.emitter.emitRenderStart(element)
      const startTime = Date.now()
      
      try {
        const result = yield* this.performRender(element)
        const renderTime = Date.now() - startTime
        
        yield* this.emitter.emitRenderEnd(element, undefined, renderTime)
        return result
      } catch (error) {
        yield* this.emitter.emitEvent('jsx-render', {
          type: 'jsx-render-error',
          component: element,
          error: error as Error
        })
        return yield* Effect.fail(error as RenderError)
      }
    }.bind(this))
  }
  
  getEmitter(): JSXScopeEmitter {
    return this.emitter
  }
}
```

**File to Create:** `src/cli/module.ts`
```typescript
export class CLIModule extends ModuleBase {
  private emitter: CLIScopeEmitter
  private listener: CLIScopeListener
  private router: CLIRouter
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'cli')
    this.router = new CLIRouter()
    this.emitter = new CLIScopeEmitter(eventBus)
    this.listener = new CLIScopeListener(eventBus, this.router)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  executeCommand(path: string[], args: ParsedArgs): Effect<ExitCode, ExecutionError> {
    return Effect.gen(function* () {
      const startTime = Date.now()
      
      try {
        const result = yield* this.router.execute(path, args)
        const executionTime = Date.now() - startTime
        
        yield* this.emitter.emitCommandExecuted(path, args, result, executionTime)
        return result
      } catch (error) {
        yield* this.emitter.emitEvent('cli-command', {
          type: 'cli-command-failed',
          path,
          args,
          error: error as Error
        })
        return yield* Effect.fail(error as ExecutionError)
      }
    }.bind(this))
  }
}
```

**File to Create:** `src/reactivity/module.ts`
```typescript
export class ReactivityModule extends ModuleBase {
  private emitter: ReactivityEmitter
  private listener: ReactivityListener
  
  constructor(eventBus: EventBus) {
    super(eventBus, 'reactivity')
    this.emitter = new ReactivityEmitter(eventBus)
    this.listener = new ReactivityListener(eventBus)
  }
  
  initialize(): Effect<void, never> {
    return this.listener.initialize()
  }
  
  createRune<T>(name: string, initialValue: T): Effect<RuneHandle<T>, RuneError> {
    return Effect.gen(function* () {
      const runeId = this.generateId()
      const rune = new RuneHandle<T>(runeId, name, initialValue, this.emitter)
      
      yield* this.emitter.emitRuneCreated(runeId, name, initialValue)
      return rune
    }.bind(this))
  }
}
```

```typescript
export class ScopeRuntime {
  private static instance: ScopeStack = new ScopeStack()
  
  static registerScope(scope: ScopeDef): Effect<void, ScopeError> {
    return this.instance.push(scope).pipe(
      Effect.tap(() => this.updateCommandHierarchy()),
      Effect.tap(() => this.notifyModules(scope))
    )
  }
  
  static unregisterScope(scopeId: string): Effect<void, never> {
    return Effect.gen(function* () {
      const scope = this.instance.registry.get(scopeId)
      if (scope) {
        yield* this.instance.pop()
        yield* this.updateCommandHierarchy()
      }
    }.bind(this))
  }
  
  static getStack(): ScopeStack {
    return this.instance
  }
  
  // Build command hierarchy from scope tree
  private static updateCommandHierarchy(): Effect<void, never> {
    return Effect.gen(function* () {
      const executableScopes = this.instance.getExecutableScopes()
      
      // Build command tree
      const commandTree = this.buildCommandTree(executableScopes)
      
      // Update CLI router
      yield* CLIModule.updateCommandTree(commandTree)
    }.bind(this))
  }
  
  private static buildCommandTree(scopes: ScopeDef[]): CommandTree {
    const tree: CommandTree = {}
    
    for (const scope of scopes) {
      let current = tree
      
      // Navigate to the right position in tree
      for (let i = 0; i < scope.path.length - 1; i++) {
        const segment = scope.path[i]
        if (!current[segment]) {
          current[segment] = { subcommands: {} }
        }
        current = current[segment].subcommands!
      }
      
      // Add the command
      const commandName = scope.path[scope.path.length - 1]
      current[commandName] = {
        handler: scope.handler,
        description: scope.description,
        args: scope.args,
        flags: scope.flags,
        options: scope.options,
        aliases: scope.aliases,
        subcommands: {}
      }
    }
    
    return tree
  }
  
  // Notify other modules about scope changes
  private static notifyModules(scope: ScopeDef): Effect<void, never> {
    return Effect.gen(function* () {
      // Notify CLI module
      if (scope.executable) {
        yield* CLIModule.onScopeRegistered(scope)
      }
      
      // Notify JSX module
      if (scope.type === 'component') {
        yield* JSXModule.onScopeRegistered(scope)
      }
      
      // Notify plugin modules
      yield* EventBus.publish('scope-registered', {
        type: 'scope-registered',
        scope,
        timestamp: new Date()
      })
    })
  }
}
```

### 6. Event-Driven Module Coordination

**File to Create:** `src/core/module-registry.ts`
```typescript
import { JSXModule } from '../jsx/module'
import { CLIModule } from '../cli/module'
import { ReactivityModule } from '../reactivity/module'

export class ModuleRegistry {
  private modules = new Map<string, ModuleBase>()
  
  constructor(private eventBus: EventBus) {}
  
  initialize(): Effect<void, ModuleError> {
    return Effect.gen(function* () {
      // Register core modules
      const jsx = new JSXModule(this.eventBus)
      const cli = new CLIModule(this.eventBus)
      const reactivity = new ReactivityModule(this.eventBus)
      
      this.modules.set('jsx', jsx)
      this.modules.set('cli', cli) 
      this.modules.set('reactivity', reactivity)
      
      // Initialize all modules
      yield* Effect.all([
        jsx.initialize(),
        cli.initialize(),
        reactivity.initialize()
      ])
    }.bind(this))
  }
  
  getModule<T extends ModuleBase>(name: string): T | undefined {
    return this.modules.get(name) as T
  }
  
  shutdown(): Effect<void, never> {
    return Effect.gen(function* () {
      yield* Effect.all(
        Array.from(this.modules.values()).map(module => module.shutdown())
      )
      this.modules.clear()
    }.bind(this))
  }
}
```

**Add Scope-based Routing:**
```typescript
export class CLIRouter {
  private commandTree: CommandTree = {}
  
  // Called by ScopeRuntime when command hierarchy changes
  updateCommandTree(tree: CommandTree): Effect<void, never> {
    return Effect.sync(() => {
      this.commandTree = tree
    })
  }
  
  route(parsedArgs: ParsedArgs): Effect<RouteResult, RouteError> {
    return Effect.gen(function* () {
      const commandPath = parsedArgs.command
      
      // Try exact path match
      const exactMatch = this.findCommand(commandPath)
      if (exactMatch) {
        return {
          scope: exactMatch.scope,
          handler: exactMatch.handler,
          args: parsedArgs
        }
      }
      
      // Try parent with defaultContent
      for (let i = commandPath.length - 1; i >= 0; i--) {
        const parentPath = commandPath.slice(0, i)
        const parent = this.findCommand(parentPath)
        
        if (parent?.scope?.defaultContent) {
          return {
            scope: parent.scope,
            handler: showDefaultContent,
            args: { ...parsedArgs, command: parentPath }
          }
        }
      }
      
      yield* Effect.fail(new CommandNotFoundError(commandPath))
    })
  }
  
  private findCommand(path: string[]): CommandEntry | null {
    let current = this.commandTree
    
    for (const segment of path) {
      const command = current[segment]
      if (!command) return null
      current = command.subcommands || {}
    }
    
    return current ? { 
      scope: ScopeRuntime.getStack().findByPath(path),
      handler: current.handler 
    } : null
  }
}
```

## Testing Strategy

### Unit Tests
**File:** `src/core/scope-def.test.ts`
```typescript
test("ScopeDef hierarchy builds correctly", () => {
  const stack = new ScopeStack()
  
  const plugin: ScopeDef = {
    id: "pm-plugin",
    type: "plugin",
    name: "pm",
    executable: true,
    // ...
  }
  
  const command: ScopeDef = {
    id: "start-cmd", 
    type: "command",
    name: "start",
    executable: true,
    handler: startHandler
    // ...
  }
  
  stack.push(plugin)
  stack.push(command)
  
  expect(command.path).toEqual(["pm", "start"])
  expect(command.parent).toBe(plugin)
  expect(plugin.children).toContain(command)
})
```

### Integration Tests
**File:** `tests/e2e/scope-system.test.ts`
```typescript
test("JSX components register scopes automatically", async () => {
  const app = (
    <Plugin name="pm">
      <Command name="start" handler={startHandler} />
      <Command name="stop" handler={stopHandler} />
    </Plugin>
  )
  
  const runtime = await renderJSXCLI(app)
  
  const scopes = runtime.getRegisteredScopes()
  expect(scopes).toHaveLength(3) // pm, pm start, pm stop
  
  const pmScope = scopes.find(s => s.path.join(' ') === 'pm')
  expect(pmScope?.type).toBe('plugin')
  expect(pmScope?.executable).toBe(true)
})
```

## Files Modified

### New JSX Files
- `src/jsx/events.ts` - JSX-specific event definitions
- `src/jsx/scope/emitter.ts` - JSX event emission (enhanced)
- `src/jsx/scope/listener.ts` - JSX event handling (enhanced)
- `src/jsx/module.ts` - JSX module with event integration

### New CLI Files
- `src/cli/events.ts` - CLI-specific event definitions
- `src/cli/scope/emitter.ts` - CLI event emission
- `src/cli/scope/listener.ts` - CLI event handling
- `src/cli/module.ts` - CLI module with event integration

### New Reactivity Files
- `src/reactivity/events.ts` - Reactivity event definitions
- `src/reactivity/emitter.ts` - Reactivity event emission
- `src/reactivity/listener.ts` - Reactivity event handling 
- `src/reactivity/module.ts` - Reactivity module with event integration

### New Core Files
- `src/core/module-registry.ts` - Central module coordination

### Modified Files
- `src/jsx/runtime.ts` - Use JSXModule instead of direct integration
- `src/cli/router.ts` - Integrate with CLI event system
- `src/reactivity/runes.ts` - Emit events on state changes

### Test Files
- `src/jsx/events.test.ts`
- `src/cli/events.test.ts`
- `src/reactivity/events.test.ts`
- `tests/e2e/domain-events.test.ts`
- Update existing integration tests

## What Was Actually Implemented

### Core Infrastructure
1. **Event Bus (`src/core/event-bus.ts`)**
   - Simple pub/sub implementation without queues
   - Type-safe event channels and handlers
   - Statistics and pattern-based subscriptions

2. **Module Base (`src/core/module-base.ts`)**
   - Base class for all domain modules
   - Lifecycle management (initialize, shutdown)
   - Event emission and subscription helpers

3. **Module Registry (`src/core/module-registry.ts`)**
   - Central coordination for all modules
   - Dependency ordering and initialization
   - Module lookup and statistics

### Domain Modules
1. **JSX Module (`src/jsx/module.ts`)**
   - Render event tracking
   - Component lifecycle events
   - Scope integration events

2. **CLI Module (`src/cli/module.ts`)**
   - Command registration/execution events
   - Parse and route events
   - Help system events

3. **Reactivity Module (`src/reactivity/module.ts`)**
   - Rune lifecycle events
   - State change tracking
   - Effect scheduling events

### Enhanced Scope System
1. **ScopeDef Type (`src/core/scope-def.ts`)**
   - Rich metadata for commands (args, flags, options)
   - Lifecycle hooks (onEnter, onExit, onChild)
   - Executable scope tracking

2. **Enhanced Scope Stack (`src/core/scope-stack-enhanced.ts`)**
   - Uses ScopeDef instead of basic ScopeContext
   - Conflict detection and path indexing
   - Command tree generation

3. **Scope Component (`src/components/system/Scope.tsx`)**
   - React component for scope lifecycle
   - Automatic scope registration/cleanup
   - JSX intrinsic element support

## Success Criteria

✅ **Domain Event Systems**: Each domain has clean event emitter/listener pairs
✅ **Event-Driven Communication**: Modules can communicate through events (optional)
✅ **Type-Safe Events**: All events are properly typed and validated
✅ **Module Isolation**: Modules can operate independently
✅ **ScopeDef Enhancement**: Rich metadata and lifecycle support
✅ **Testing**: Comprehensive test coverage (all tests passing)
✅ **Documentation**: Phase documentation updated with implementation details

## What Was NOT Implemented

1. **Forced Event-Only Communication**: Modules can still use direct imports where appropriate
2. **Auto-Registration Flow**: The full automatic CLI command registration from JSX components needs additional integration
3. **Full Existing Codebase Integration**: The enhanced scope system exists alongside the current implementation

## Integration with Existing Codebase

### Modified Files
1. **`src/jsx/runtime.ts`**
   - Added JSXModule initialization in constructor
   - Emits plugin start/end and command registration events
   - Maintains backward compatibility with existing API

2. **`src/cli/router.ts`**
   - Added CLIModule initialization
   - Emits route found/not found events
   - Works alongside existing routing logic

3. **`src/reactivity/runes.ts`**
   - Added ReactivityModule initialization
   - Emits state change events for $state, $bindable, and toBindable
   - Added 'sync' as a valid state change source

### Test Results
- All domain event tests passing
- All scope-related tests passing
- Integration maintained with existing functionality

## Dependencies for Next Phase

**Phase 2 Provides for Phase 3:**
- ✅ Domain-specific event systems for all core modules
- ✅ Enhanced ScopeDef type with rich metadata
- ✅ Module coordination infrastructure
- ✅ Foundation for service integration via events
- ✅ Lifecycle hooks for extensibility