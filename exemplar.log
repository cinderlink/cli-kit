$ bun exemplar dev help
$ bun --bun run src/bin/exemplar-jsx.tsx dev help
[2025-07-20T20:14:35.295Z] [TUIX JSX] JSX Module initialized
[2025-07-20T20:14:35.298Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "type", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.298Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.298Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.298Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.298Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.299Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.300Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: auth
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "auth",
  description: "Authentication management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] Processing Plugin element with name: auth
[2025-07-20T20:14:35.301Z] [TUIX JSX] Registering plugin 'auth' with 0 commands
 Plugin registered: auth
[2025-07-20T20:14:35.301Z] [TUIX JSX] Plugin 'auth' registered successfully
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[TUIX JSX] render() called
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Processing element type: ({
  name = "pm",
  description = "Process management and monitoring",
  version = "1.0.0",
  as
} = {}) => {
  console.log(`[ProcessManagerPlugin] Called with name='${name}', as='${as}'`);
  const pluginName = as || name;
  console.log(`[ProcessManagerPlugin] Returning plugin JSX with name='${pluginName}'`);
  const getProcessManagerForHandlers = async (tuixConfig) => {
    return await getProcessManager(tuixConfig);
  };
  return jsxDEV_7x81h0kn("plugin", {
    name: pluginName,
    description,
    version,
    children: [
      jsxDEV_7x81h0kn("command", {
        name: "start",
        description: "Start a service or all services",
        args: {
          service: {
            description: "Service name (optional, starts all if not specified)",
            required: !1
          }
        },
        flags: {
          preset: {
            description: "Service preset (vitest, vite, tsc, eslint, bun)",
            alias: "p",
            type: "string",
            choices: ["vitest", "vite", "tsc", "eslint", "bun"]
          },
          command: {
            description: "Custom command to run",
            alias: "c",
            type: "string"
          },
          group: {
            description: "Service group",
            alias: "g",
            type: "string"
          },
          autorestart: {
            description: "Auto-restart on failure",
            alias: "r",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "No services configured yet."
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      bold: !0,
                      children: "\uD83D\uDCA1 Recommended: Add services to your config file"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Add this to your tuix.config.ts or ",
                        ctx.cliName,
                        ".config.ts:"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("panel", {
                      border: "single",
                      title: "Example Config",
                      children: jsxDEV_7x81h0kn("vstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "export default defineConfig(",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "  processManager: ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "    services: ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "      'dev-server': ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        command: 'npm run dev',"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        autorestart: true,"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        group: 'development'"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "      ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "    ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "  ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "}",
                              ")"
                            ]
                          }, void 0, !0, void 0, this)
                        ]
                      }, void 0, !0, void 0, this)
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Or add manually: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --command <cmd>"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Or use a preset: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --preset vite"
                      ]
                    }, void 0, !0, void 0, this)
                  ]
                }, void 0, !0, void 0, this);
              const stoppedServices = processes.filter((p) => p.status === "stopped");
              if (stoppedServices.length === 0)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: "\u2705 All services are already running!"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: processes[0]
                    }, void 0, !1, void 0, this)
                  ]
                }, void 0, !0, void 0, this);
              for (const service of stoppedServices)
                await pm.start(service.name);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Started ",
                      stoppedServices.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  stoppedServices.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            if (!pm.list().find((p) => p.name === serviceName)) {
              let config;
              if (ctx.flags.command)
                config = {
                  name: serviceName,
                  command: ctx.flags.command,
                  autorestart: ctx.flags.autorestart || !1,
                  group: ctx.flags.group || "default"
                };
              else {
                config = await getServiceConfig(serviceName, ctx.flags.preset);
                if (ctx.flags.group)
                  config.group = ctx.flags.group;
                if (ctx.flags.autorestart !== void 0)
                  config.autorestart = ctx.flags.autorestart;
              }
              await pm.add(config);
            }
            await pm.start(serviceName);
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "\u2705 Service started successfully!"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("panel", {
                  title: "Service Details",
                  border: "rounded",
                  children: jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("text", {
                        children: [
                          "Name: ",
                          serviceName
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.preset && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Preset: ",
                          ctx.flags.preset
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.command && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Command: ",
                          ctx.flags.command
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.group && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Group: ",
                          ctx.flags.group
                        ]
                      }, void 0, !0, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        children: [
                          "Auto-restart: ",
                          ctx.flags.autorestart ? "Yes" : "No"
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                }, void 0, !1, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "red",
                  children: [
                    "\u274C Failed to start service: ",
                    error.message
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "blue",
                  children: [
                    "Try: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start <service> --preset <preset>"
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "stop",
        description: "Stop a service or all services",
        args: {
          service: {
            description: "Service name (optional, stops all if not specified)",
            required: !1
          }
        },
        flags: {
          force: {
            description: "Force stop",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const runningServices = pm.list().filter((p) => p.status === "running");
              if (runningServices.length === 0)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No services are currently running."
                }, void 0, !1, void 0, this);
              for (const service of runningServices)
                await pm.stop(service.name);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Stopped ",
                      runningServices.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  runningServices.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            await pm.stop(serviceName);
            return jsxDEV_7x81h0kn("text", {
              color: "green",
              children: [
                "\u2705 Service stopped: ",
                serviceName
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to stop: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "restart",
        description: "Restart a service or all services",
        args: {
          service: {
            description: "Service name (optional, restarts all if not specified)",
            required: !1
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No services configured."
                }, void 0, !1, void 0, this);
              await Promise.all(processes.map((service) => pm.restart(service.name)));
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Restarted ",
                      processes.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  processes.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            await pm.restart(serviceName);
            return jsxDEV_7x81h0kn("text", {
              color: "green",
              children: [
                "\u2705 Service restarted: ",
                serviceName
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to restart: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "status",
        description: "Show process status",
        args: {
          service: {
            description: "Specific service name",
            required: !1
          }
        },
        flags: {
          watch: {
            description: "Watch status in real-time",
            alias: "w",
            type: "boolean"
          },
          detailed: {
            description: "Show detailed information",
            alias: "d",
            type: "boolean"
          }
        },
        interactive: (ctx) => ctx.flags.watch === !0,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            let processes;
            if (ctx.args.service) {
              const allProcesses = pm.list(), serviceProcess = allProcesses.find((p) => p.name === ctx.args.service);
              if (!serviceProcess)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "red",
                      children: [
                        "\u274C Service '",
                        ctx.args.service,
                        "' not found"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: "Available services:"
                    }, void 0, !1, void 0, this),
                    allProcesses.length === 0 ? jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "  No services configured"
                    }, void 0, !1, void 0, this) : allProcesses.map((proc) => jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      children: [
                        "  \u2022 ",
                        proc.name
                      ]
                    }, proc.name, !0, void 0, this))
                  ]
                }, void 0, !0, void 0, this);
              processes = [serviceProcess];
            } else
              processes = pm.list();
            return jsxDEV_7x81h0kn("vstack", {
              children: jsxDEV_7x81h0kn("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status Dashboard",
                style: { padding: "1" },
                children: processes.length === 0 ? jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "\u26A0\uFE0F  No processes configured or running"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: "Quick start options:"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <name> --preset vite"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        ' start <name> --command "npm run dev"'
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " config --init"
                      ]
                    }, void 0, !0, void 0, this)
                  ]
                }, void 0, !0, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("hstack", {
                      children: [
                        jsxDEV_7x81h0kn("text", {
                          color: "gray",
                          children: [
                            "Total: ",
                            processes.length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "green",
                          children: [
                            "Running: ",
                            processes.filter((p) => p.status === "running").length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "red",
                          children: [
                            "Stopped: ",
                            processes.filter((p) => p.status === "stopped").length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "yellow",
                          children: [
                            "Other: ",
                            processes.filter((p) => !["running", "stopped"].includes(p.status)).length
                          ]
                        }, void 0, !0, void 0, this)
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      children: "\u2500".repeat(80)
                    }, void 0, !1, void 0, this),
                    processes.map((proc) => jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: proc,
                      detailed: ctx.flags.detailed
                    }, proc.name, !1, void 0, this))
                  ]
                }, void 0, !0, void 0, this)
              }, void 0, !1, void 0, this)
            }, void 0, !1, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "logs",
        description: "Show process logs",
        args: {
          service: {
            description: "Service name",
            required: !1
          }
        },
        flags: {
          lines: {
            description: "Number of lines to show",
            alias: "n",
            type: "number",
            default: 50
          },
          follow: {
            description: "Follow log output",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (!ctx.args.service) {
              const processes = pm.list();
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "Process Logs"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  processes.length === 0 ? jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "No processes running."
                  }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("text", {
                        children: "Available services:"
                      }, void 0, !1, void 0, this),
                      processes.map((proc) => jsxDEV_7x81h0kn("text", {
                        color: "green",
                        children: [
                          "  \u2022 ",
                          proc.name
                        ]
                      }, proc.name, !0, void 0, this)),
                      jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        color: "gray",
                        children: [
                          "Usage: ",
                          ctx.cliName,
                          " ",
                          pluginName,
                          " logs <service>"
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            const logs = pm.getLogs(ctx.args.service, ctx.flags.lines);
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "blue",
                  bold: !0,
                  children: [
                    "\uD83D\uDCDD Logs: ",
                    ctx.args.service
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "gray",
                  children: [
                    "Showing ",
                    logs.length,
                    " entries"
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                logs.length === 0 ? jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No logs available for this service"
                }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    logs.map((log, i) => jsxDEV_7x81h0kn(LogEntryView, {
                      log,
                      service: ctx.args.service
                    }, i, !1, void 0, this)),
                    ctx.flags.follow && jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      children: "\uD83D\uDD04 Following logs... Press Ctrl+C to stop"
                    }, void 0, !1, void 0, this)
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get logs: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "dashboard",
        description: "Interactive process and log dashboard",
        flags: {
          logs: {
            description: "Show log dashboard instead of process dashboard",
            alias: "l",
            type: "boolean"
          },
          preset: {
            description: "Apply log filter preset",
            alias: "p",
            type: "string",
            choices: ["errors", "warnings", "debug", "vite", "vitest", "typescript", "production", "recent"]
          },
          refresh: {
            description: "Refresh interval in milliseconds",
            alias: "r",
            type: "number",
            default: 1000
          }
        },
        interactive: !0,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (ctx.flags.logs) {
              const processes = pm.list().map((proc) => ({
                name: proc.name,
                logs: pm.getLogs(proc.name, 100),
                status: proc.status
              }));
              return jsxDEV_7x81h0kn("vstack", {
                children: jsxDEV_7x81h0kn("panel", {
                  border: "double",
                  title: "\uD83D\uDCCA Live Log Dashboard",
                  style: { padding: "1" },
                  children: jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("hstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "gray",
                            children: [
                              "Monitoring: ",
                              processes.length,
                              " processes"
                            ]
                          }, void 0, !0, void 0, this),
                          ctx.flags.preset && jsxDEV_7x81h0kn("text", {
                            color: "cyan",
                            children: [
                              "Preset: ",
                              ctx.flags.preset
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "blue",
                            children: [
                              "Refresh: ",
                              ctx.flags.refresh,
                              "ms"
                            ]
                          }, void 0, !0, void 0, this)
                        ]
                      }, void 0, !0, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        children: "\u2500".repeat(80)
                      }, void 0, !1, void 0, this),
                      processes.length === 0 ? jsxDEV_7x81h0kn("panel", {
                        border: "single",
                        style: { padding: "1" },
                        children: jsxDEV_7x81h0kn("vstack", {
                          children: [
                            jsxDEV_7x81h0kn("text", {
                              color: "yellow",
                              children: "\u26A0\uFE0F  No processes running"
                            }, void 0, !1, void 0, this),
                            jsxDEV_7x81h0kn("text", {
                              color: "gray",
                              children: [
                                "Start some services first: ",
                                ctx.cliName,
                                " ",
                                pluginName,
                                " start <service>"
                              ]
                            }, void 0, !0, void 0, this)
                          ]
                        }, void 0, !0, void 0, this)
                      }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                        children: [
                          jsxDEV_7x81h0kn("panel", {
                            border: "rounded",
                            title: "Process Overview",
                            style: { padding: "1" },
                            children: jsxDEV_7x81h0kn("vstack", {
                              children: processes.map((proc) => {
                                const recentLogs = proc.logs.filter((log) => Date.now() - log.timestamp.getTime() < 60000), errorCount = recentLogs.filter((log) => log.level === "error").length, warnCount = recentLogs.filter((log) => log.level === "warn").length;
                                return jsxDEV_7x81h0kn("hstack", {
                                  children: [
                                    jsxDEV_7x81h0kn("text", {
                                      color: proc.status === "running" ? "green" : proc.status === "error" ? "red" : "gray",
                                      children: "\u25CF"
                                    }, void 0, !1, void 0, this),
                                    jsxDEV_7x81h0kn("text", {
                                      bold: !0,
                                      color: "cyan",
                                      children: proc.name.padEnd(20)
                                    }, void 0, !1, void 0, this),
                                    jsxDEV_7x81h0kn("text", {
                                      color: "blue",
                                      children: [
                                        proc.logs.length.toString().padStart(5),
                                        " logs"
                                      ]
                                    }, void 0, !0, void 0, this),
                                    errorCount > 0 && jsxDEV_7x81h0kn("text", {
                                      color: "red",
                                      children: [
                                        "  \u274C ",
                                        errorCount,
                                        " errors"
                                      ]
                                    }, void 0, !0, void 0, this),
                                    warnCount > 0 && jsxDEV_7x81h0kn("text", {
                                      color: "yellow",
                                      children: [
                                        "  \u26A0\uFE0F  ",
                                        warnCount,
                                        " warnings"
                                      ]
                                    }, void 0, !0, void 0, this)
                                  ]
                                }, proc.name, !0, void 0, this);
                              })
                            }, void 0, !1, void 0, this)
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("panel", {
                            border: "rounded",
                            title: "Recent Logs",
                            style: { padding: "1", maxHeight: "20" },
                            children: jsxDEV_7x81h0kn("vstack", {
                              children: (() => {
                                const allLogs = [];
                                processes.forEach((proc) => {
                                  proc.logs.forEach((log) => {
                                    allLogs.push({ ...log, processName: proc.name });
                                  });
                                });
                                allLogs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                                let filteredLogs = allLogs;
                                if (ctx.flags.preset) {
                                  const presetFilter = {
                                    errors: (log) => log.level === "error" || log.level === "fatal",
                                    warnings: (log) => ["warn", "error", "fatal"].includes(log.level),
                                    debug: (log) => log.level !== "trace",
                                    vite: (log) => /\b(vite|hmr|dev|build)\b/i.test(log.message),
                                    vitest: (log) => /\b(test|vitest|spec|pass|fail)\b/i.test(log.message),
                                    typescript: (log) => /\b(typescript|tsc|error ts)\b/i.test(log.message),
                                    production: (log) => !log.message.includes("[DEV]") && !log.message.includes("hmr"),
                                    recent: (log) => Date.now() - log.timestamp.getTime() < 300000
                                  }[ctx.flags.preset];
                                  if (presetFilter)
                                    filteredLogs = filteredLogs.filter(presetFilter);
                                }
                                return filteredLogs.slice(0, 20).map((log, i) => {
                                  const timestamp = log.timestamp.toLocaleTimeString(), color = {
                                    error: "red",
                                    warn: "yellow",
                                    info: "blue",
                                    debug: "gray"
                                  }[log.level] || "white";
                                  return jsxDEV_7x81h0kn("hstack", {
                                    children: [
                                      jsxDEV_7x81h0kn("text", {
                                        color: "gray",
                                        children: timestamp
                                      }, void 0, !1, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        color: "cyan",
                                        children: [
                                          "[",
                                          log.processName.padEnd(12),
                                          "]"
                                        ]
                                      }, void 0, !0, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        color,
                                        bold: !0,
                                        children: log.level.toUpperCase().padEnd(5)
                                      }, void 0, !1, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        children: [
                                          log.message.substring(0, 80),
                                          log.message.length > 80 ? "..." : ""
                                        ]
                                      }, void 0, !0, void 0, this)
                                    ]
                                  }, i, !0, void 0, this);
                                });
                              })()
                            }, void 0, !1, void 0, this)
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("panel", {
                            border: "single",
                            style: { padding: "0.5" },
                            children: jsxDEV_7x81h0kn("hstack", {
                              children: [
                                jsxDEV_7x81h0kn("text", {
                                  color: "yellow",
                                  children: "\uD83D\uDD04 Live updating..."
                                }, void 0, !1, void 0, this),
                                jsxDEV_7x81h0kn("text", {
                                  color: "gray",
                                  children: "Press Ctrl+C to exit"
                                }, void 0, !1, void 0, this),
                                jsxDEV_7x81h0kn("text", {
                                  color: "cyan",
                                  children: "Tip: Use --preset for filtering"
                                }, void 0, !1, void 0, this)
                              ]
                            }, void 0, !0, void 0, this)
                          }, void 0, !1, void 0, this)
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                }, void 0, !1, void 0, this)
              }, void 0, !1, void 0, this);
            } else {
              await Effect.runPromise(ProcessMonitor({ manager: pm }).pipe(Effect.provide(LiveServices)));
              return jsxDEV_7x81h0kn("text", {
                color: "green",
                children: "Process dashboard exited"
              }, void 0, !1, void 0, this);
            }
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to start dashboard: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "config",
        description: "Manage process manager configuration",
        flags: {
          init: {
            description: "Initialize config file with example services",
            type: "boolean"
          },
          show: {
            description: "Show current config",
            type: "boolean"
          },
          path: {
            description: "Show config file path",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            if (ctx.flags.init) {
              const configPath = `${ctx.cliName === "tuix" ? "tuix" : ctx.cliName}.config.ts`;
              await Bun.write(configPath, `import { defineConfig } from 'tuix'

export default defineConfig({
  // Process manager services
  processManager: {
    services: {
      // Example development server
      'dev-server': {
        command: 'npm run dev',
        autorestart: true,
        group: 'development',
        env: {
          NODE_ENV: 'development'
        }
      },
      
      // Example test watcher
      'test-watch': {
        command: 'npm run test:watch',
        autorestart: true,
        group: 'testing'
      },
      
      // Example type checker
      'typecheck': {
        command: 'npm run typecheck --watch',
        autorestart: false,
        group: 'quality'
      }
    },
    
    // Process manager settings
    logDir: './logs',
    autoSave: true
  },
  
  // Logger configuration
  logger: {
    level: 'info',
    format: 'json',
    outputs: ['console']
  }
})
`);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Created config file: ",
                      configPath
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    children: "\uD83D\uDCDD Example services added:"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 dev-server (npm run dev)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 test-watch (npm run test:watch)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 typecheck (npm run typecheck --watch)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "Edit the config file to customize your services!"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "Then run: ",
                      ctx.cliName,
                      " ",
                      pluginName,
                      " start"
                    ]
                  }, void 0, !0, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            if (ctx.flags.show) {
              const config = ctx.tuixConfig;
              if (!config)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No config loaded. Run with --init to create one."
                }, void 0, !1, void 0, this);
              const services = config.processManager?.services || {}, serviceCount = Object.keys(services).length;
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "\uD83D\uDCCB Current Configuration"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    children: [
                      "Services configured: ",
                      serviceCount
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  serviceCount > 0 && jsxDEV_7x81h0kn("panel", {
                    title: "Configured Services",
                    border: "rounded",
                    children: jsxDEV_7x81h0kn("vstack", {
                      children: Object.entries(services).map(([name, service]) => jsxDEV_7x81h0kn("hstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              name,
                              ":"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "gray",
                            children: service.command
                          }, void 0, !1, void 0, this),
                          service.group && jsxDEV_7x81h0kn("text", {
                            color: "purple",
                            children: [
                              "[",
                              service.group,
                              "]"
                            ]
                          }, void 0, !0, void 0, this),
                          service.autorestart && jsxDEV_7x81h0kn("text", {
                            color: "yellow",
                            children: "[auto-restart]"
                          }, void 0, !1, void 0, this)
                        ]
                      }, name, !0, void 0, this))
                    }, void 0, !1, void 0, this)
                  }, void 0, !1, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            if (ctx.flags.path) {
              const configName = ctx.cliName === "tuix" ? "tuix" : ctx.cliName, possiblePaths = [
                `${configName}.config.ts`,
                `${configName}.config.js`,
                "tuix.config.ts",
                "tuix.config.js",
                `.${configName}/config.ts`,
                `.${configName}/config.js`,
                ".tuix/config.ts",
                ".tuix/config.js"
              ];
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "\uD83D\uDCC1 Config File Locations"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "Config is loaded from first found file:"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  possiblePaths.map((path, i) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  ",
                      i + 1,
                      ". ",
                      path
                    ]
                  }, i, !0, void 0, this)),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "Use --init to create a config file"
                  }, void 0, !1, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "cyan",
                  bold: !0,
                  children: "\u2699\uFE0F Process Manager Config"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "gray",
                  children: "Available commands:"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --init    Create example config file"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --show    Show current configuration"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --path    Show config file search paths"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: [
                    "Example: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " config --init"
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Config command failed: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "ps",
        description: "Show process status (alias)",
        handler: async (ctx) => {
          try {
            const processes = (await getProcessManagerForHandlers(ctx.tuixConfig)).list();
            return jsxDEV_7x81h0kn("vstack", {
              children: jsxDEV_7x81h0kn("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status",
                style: { padding: "1" },
                children: processes.length === 0 ? jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: [
                    "No processes running. Use '",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start' to begin."
                  ]
                }, void 0, !0, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        processes.length,
                        " process",
                        processes.length > 1 ? "es" : "",
                        " monitored"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    processes.map((proc) => jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: proc
                    }, proc.name, !1, void 0, this))
                  ]
                }, void 0, !0, void 0, this)
              }, void 0, !1, void 0, this)
            }, void 0, !1, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "name" ],
  key: undefined,
}
[2025-07-20T20:14:35.301Z] [TUIX JSX] [RUNTIME] Calling function component: ProcessManagerPlugin
[ProcessManagerPlugin] Called with name='dev', as='undefined'
[ProcessManagerPlugin] Returning plugin JSX with name='dev'
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "interactive", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "flags", "interactive", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.302Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: dev
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "dev",
  description: "Process management and monitoring",
  version: "1.0.0",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] Processing Plugin element with name: dev
[2025-07-20T20:14:35.303Z] [TUIX JSX] Registering plugin 'dev' with 0 commands
 Plugin registered: dev
[2025-07-20T20:14:35.303Z] [TUIX JSX] Plugin 'dev' registered successfully
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component ProcessManagerPlugin returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: arg {
  props: [ "name", "description", "required" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.303Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: ai
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "ai",
  description: "AI assistant and model management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] Processing Plugin element with name: ai
[2025-07-20T20:14:35.304Z] [TUIX JSX] Registering plugin 'ai' with 0 commands
 Plugin registered: ai
[2025-07-20T20:14:35.304Z] [TUIX JSX] Plugin 'ai' registered successfully
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: websocket
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "websocket",
  description: "WebSocket server management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] Processing Plugin element with name: websocket
[2025-07-20T20:14:35.304Z] [TUIX JSX] Registering plugin 'websocket' with 0 commands
 Plugin registered: websocket
[2025-07-20T20:14:35.304Z] [TUIX JSX] Plugin 'websocket' registered successfully
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.304Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: user
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "user",
  description: "User account and settings management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] Processing Plugin element with name: user
[2025-07-20T20:14:35.305Z] [TUIX JSX] Registering plugin 'user' with 0 commands
 Plugin registered: user
[2025-07-20T20:14:35.305Z] [TUIX JSX] Plugin 'user' registered successfully
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "alias" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.305Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: workers
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "workers",
  description: "Background worker management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] Processing Plugin element with name: workers
[2025-07-20T20:14:35.306Z] [TUIX JSX] Registering plugin 'workers' with 0 commands
 Plugin registered: workers
[2025-07-20T20:14:35.306Z] [TUIX JSX] Plugin 'workers' registered successfully
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.306Z] [TUIX JSX] [RUNTIME] Processing element type: cli {
  props: [ "name", "alias", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "path", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "path", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.307Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[TUIX JSX] No CLI commands detected, running as regular app
[TUIX JSX] createJSXApp called
[TUIX JSX] Running app...
[TUIX JSX] Is already interactive: false
[TUIX JSX] Not in interactive context, rendering once and exiting
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: ({
  name = "pm",
  description = "Process management and monitoring",
  version = "1.0.0",
  as
} = {}) => {
  console.log(`[ProcessManagerPlugin] Called with name='${name}', as='${as}'`);
  const pluginName = as || name;
  console.log(`[ProcessManagerPlugin] Returning plugin JSX with name='${pluginName}'`);
  const getProcessManagerForHandlers = async (tuixConfig) => {
    return await getProcessManager(tuixConfig);
  };
  return jsxDEV_7x81h0kn("plugin", {
    name: pluginName,
    description,
    version,
    children: [
      jsxDEV_7x81h0kn("command", {
        name: "start",
        description: "Start a service or all services",
        args: {
          service: {
            description: "Service name (optional, starts all if not specified)",
            required: !1
          }
        },
        flags: {
          preset: {
            description: "Service preset (vitest, vite, tsc, eslint, bun)",
            alias: "p",
            type: "string",
            choices: ["vitest", "vite", "tsc", "eslint", "bun"]
          },
          command: {
            description: "Custom command to run",
            alias: "c",
            type: "string"
          },
          group: {
            description: "Service group",
            alias: "g",
            type: "string"
          },
          autorestart: {
            description: "Auto-restart on failure",
            alias: "r",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "No services configured yet."
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      bold: !0,
                      children: "\uD83D\uDCA1 Recommended: Add services to your config file"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Add this to your tuix.config.ts or ",
                        ctx.cliName,
                        ".config.ts:"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("panel", {
                      border: "single",
                      title: "Example Config",
                      children: jsxDEV_7x81h0kn("vstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "export default defineConfig(",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "  processManager: ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "    services: ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "      'dev-server': ",
                              "{"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        command: 'npm run dev',"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        autorestart: true,"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: "        group: 'development'"
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "      ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "    ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "  ",
                              "}"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              "}",
                              ")"
                            ]
                          }, void 0, !0, void 0, this)
                        ]
                      }, void 0, !0, void 0, this)
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Or add manually: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --command <cmd>"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        "Or use a preset: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --preset vite"
                      ]
                    }, void 0, !0, void 0, this)
                  ]
                }, void 0, !0, void 0, this);
              const stoppedServices = processes.filter((p) => p.status === "stopped");
              if (stoppedServices.length === 0)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: "\u2705 All services are already running!"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: processes[0]
                    }, void 0, !1, void 0, this)
                  ]
                }, void 0, !0, void 0, this);
              for (const service of stoppedServices)
                await pm.start(service.name);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Started ",
                      stoppedServices.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  stoppedServices.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            if (!pm.list().find((p) => p.name === serviceName)) {
              let config;
              if (ctx.flags.command)
                config = {
                  name: serviceName,
                  command: ctx.flags.command,
                  autorestart: ctx.flags.autorestart || !1,
                  group: ctx.flags.group || "default"
                };
              else {
                config = await getServiceConfig(serviceName, ctx.flags.preset);
                if (ctx.flags.group)
                  config.group = ctx.flags.group;
                if (ctx.flags.autorestart !== void 0)
                  config.autorestart = ctx.flags.autorestart;
              }
              await pm.add(config);
            }
            await pm.start(serviceName);
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "\u2705 Service started successfully!"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("panel", {
                  title: "Service Details",
                  border: "rounded",
                  children: jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("text", {
                        children: [
                          "Name: ",
                          serviceName
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.preset && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Preset: ",
                          ctx.flags.preset
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.command && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Command: ",
                          ctx.flags.command
                        ]
                      }, void 0, !0, void 0, this),
                      ctx.flags.group && jsxDEV_7x81h0kn("text", {
                        children: [
                          "Group: ",
                          ctx.flags.group
                        ]
                      }, void 0, !0, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        children: [
                          "Auto-restart: ",
                          ctx.flags.autorestart ? "Yes" : "No"
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                }, void 0, !1, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "red",
                  children: [
                    "\u274C Failed to start service: ",
                    error.message
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "blue",
                  children: [
                    "Try: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start <service> --preset <preset>"
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "stop",
        description: "Stop a service or all services",
        args: {
          service: {
            description: "Service name (optional, stops all if not specified)",
            required: !1
          }
        },
        flags: {
          force: {
            description: "Force stop",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const runningServices = pm.list().filter((p) => p.status === "running");
              if (runningServices.length === 0)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No services are currently running."
                }, void 0, !1, void 0, this);
              for (const service of runningServices)
                await pm.stop(service.name);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Stopped ",
                      runningServices.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  runningServices.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            await pm.stop(serviceName);
            return jsxDEV_7x81h0kn("text", {
              color: "green",
              children: [
                "\u2705 Service stopped: ",
                serviceName
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to stop: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "restart",
        description: "Restart a service or all services",
        args: {
          service: {
            description: "Service name (optional, restarts all if not specified)",
            required: !1
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig), serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No services configured."
                }, void 0, !1, void 0, this);
              await Promise.all(processes.map((service) => pm.restart(service.name)));
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Restarted ",
                      processes.length,
                      " service(s)"
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  processes.map((service) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service.name
                    ]
                  }, service.name, !0, void 0, this))
                ]
              }, void 0, !0, void 0, this);
            }
            await pm.restart(serviceName);
            return jsxDEV_7x81h0kn("text", {
              color: "green",
              children: [
                "\u2705 Service restarted: ",
                serviceName
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to restart: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "status",
        description: "Show process status",
        args: {
          service: {
            description: "Specific service name",
            required: !1
          }
        },
        flags: {
          watch: {
            description: "Watch status in real-time",
            alias: "w",
            type: "boolean"
          },
          detailed: {
            description: "Show detailed information",
            alias: "d",
            type: "boolean"
          }
        },
        interactive: (ctx) => ctx.flags.watch === !0,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            let processes;
            if (ctx.args.service) {
              const allProcesses = pm.list(), serviceProcess = allProcesses.find((p) => p.name === ctx.args.service);
              if (!serviceProcess)
                return jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "red",
                      children: [
                        "\u274C Service '",
                        ctx.args.service,
                        "' not found"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: "Available services:"
                    }, void 0, !1, void 0, this),
                    allProcesses.length === 0 ? jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "  No services configured"
                    }, void 0, !1, void 0, this) : allProcesses.map((proc) => jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      children: [
                        "  \u2022 ",
                        proc.name
                      ]
                    }, proc.name, !0, void 0, this))
                  ]
                }, void 0, !0, void 0, this);
              processes = [serviceProcess];
            } else
              processes = pm.list();
            return jsxDEV_7x81h0kn("vstack", {
              children: jsxDEV_7x81h0kn("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status Dashboard",
                style: { padding: "1" },
                children: processes.length === 0 ? jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "yellow",
                      children: "\u26A0\uFE0F  No processes configured or running"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: "Quick start options:"
                    }, void 0, !1, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <name> --preset vite"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        ' start <name> --command "npm run dev"'
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " config --init"
                      ]
                    }, void 0, !0, void 0, this)
                  ]
                }, void 0, !0, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("hstack", {
                      children: [
                        jsxDEV_7x81h0kn("text", {
                          color: "gray",
                          children: [
                            "Total: ",
                            processes.length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "green",
                          children: [
                            "Running: ",
                            processes.filter((p) => p.status === "running").length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "red",
                          children: [
                            "Stopped: ",
                            processes.filter((p) => p.status === "stopped").length
                          ]
                        }, void 0, !0, void 0, this),
                        jsxDEV_7x81h0kn("text", {
                          color: "yellow",
                          children: [
                            "Other: ",
                            processes.filter((p) => !["running", "stopped"].includes(p.status)).length
                          ]
                        }, void 0, !0, void 0, this)
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {
                      children: "\u2500".repeat(80)
                    }, void 0, !1, void 0, this),
                    processes.map((proc) => jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: proc,
                      detailed: ctx.flags.detailed
                    }, proc.name, !1, void 0, this))
                  ]
                }, void 0, !0, void 0, this)
              }, void 0, !1, void 0, this)
            }, void 0, !1, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "logs",
        description: "Show process logs",
        args: {
          service: {
            description: "Service name",
            required: !1
          }
        },
        flags: {
          lines: {
            description: "Number of lines to show",
            alias: "n",
            type: "number",
            default: 50
          },
          follow: {
            description: "Follow log output",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (!ctx.args.service) {
              const processes = pm.list();
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "Process Logs"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  processes.length === 0 ? jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "No processes running."
                  }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("text", {
                        children: "Available services:"
                      }, void 0, !1, void 0, this),
                      processes.map((proc) => jsxDEV_7x81h0kn("text", {
                        color: "green",
                        children: [
                          "  \u2022 ",
                          proc.name
                        ]
                      }, proc.name, !0, void 0, this)),
                      jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        color: "gray",
                        children: [
                          "Usage: ",
                          ctx.cliName,
                          " ",
                          pluginName,
                          " logs <service>"
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            const logs = pm.getLogs(ctx.args.service, ctx.flags.lines);
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "blue",
                  bold: !0,
                  children: [
                    "\uD83D\uDCDD Logs: ",
                    ctx.args.service
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "gray",
                  children: [
                    "Showing ",
                    logs.length,
                    " entries"
                  ]
                }, void 0, !0, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                logs.length === 0 ? jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No logs available for this service"
                }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    logs.map((log, i) => jsxDEV_7x81h0kn(LogEntryView, {
                      log,
                      service: ctx.args.service
                    }, i, !1, void 0, this)),
                    ctx.flags.follow && jsxDEV_7x81h0kn("text", {
                      color: "cyan",
                      children: "\uD83D\uDD04 Following logs... Press Ctrl+C to stop"
                    }, void 0, !1, void 0, this)
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get logs: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "dashboard",
        description: "Interactive process and log dashboard",
        flags: {
          logs: {
            description: "Show log dashboard instead of process dashboard",
            alias: "l",
            type: "boolean"
          },
          preset: {
            description: "Apply log filter preset",
            alias: "p",
            type: "string",
            choices: ["errors", "warnings", "debug", "vite", "vitest", "typescript", "production", "recent"]
          },
          refresh: {
            description: "Refresh interval in milliseconds",
            alias: "r",
            type: "number",
            default: 1000
          }
        },
        interactive: !0,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (ctx.flags.logs) {
              const processes = pm.list().map((proc) => ({
                name: proc.name,
                logs: pm.getLogs(proc.name, 100),
                status: proc.status
              }));
              return jsxDEV_7x81h0kn("vstack", {
                children: jsxDEV_7x81h0kn("panel", {
                  border: "double",
                  title: "\uD83D\uDCCA Live Log Dashboard",
                  style: { padding: "1" },
                  children: jsxDEV_7x81h0kn("vstack", {
                    children: [
                      jsxDEV_7x81h0kn("hstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "gray",
                            children: [
                              "Monitoring: ",
                              processes.length,
                              " processes"
                            ]
                          }, void 0, !0, void 0, this),
                          ctx.flags.preset && jsxDEV_7x81h0kn("text", {
                            color: "cyan",
                            children: [
                              "Preset: ",
                              ctx.flags.preset
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "blue",
                            children: [
                              "Refresh: ",
                              ctx.flags.refresh,
                              "ms"
                            ]
                          }, void 0, !0, void 0, this)
                        ]
                      }, void 0, !0, void 0, this),
                      jsxDEV_7x81h0kn("text", {
                        children: "\u2500".repeat(80)
                      }, void 0, !1, void 0, this),
                      processes.length === 0 ? jsxDEV_7x81h0kn("panel", {
                        border: "single",
                        style: { padding: "1" },
                        children: jsxDEV_7x81h0kn("vstack", {
                          children: [
                            jsxDEV_7x81h0kn("text", {
                              color: "yellow",
                              children: "\u26A0\uFE0F  No processes running"
                            }, void 0, !1, void 0, this),
                            jsxDEV_7x81h0kn("text", {
                              color: "gray",
                              children: [
                                "Start some services first: ",
                                ctx.cliName,
                                " ",
                                pluginName,
                                " start <service>"
                              ]
                            }, void 0, !0, void 0, this)
                          ]
                        }, void 0, !0, void 0, this)
                      }, void 0, !1, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                        children: [
                          jsxDEV_7x81h0kn("panel", {
                            border: "rounded",
                            title: "Process Overview",
                            style: { padding: "1" },
                            children: jsxDEV_7x81h0kn("vstack", {
                              children: processes.map((proc) => {
                                const recentLogs = proc.logs.filter((log) => Date.now() - log.timestamp.getTime() < 60000), errorCount = recentLogs.filter((log) => log.level === "error").length, warnCount = recentLogs.filter((log) => log.level === "warn").length;
                                return jsxDEV_7x81h0kn("hstack", {
                                  children: [
                                    jsxDEV_7x81h0kn("text", {
                                      color: proc.status === "running" ? "green" : proc.status === "error" ? "red" : "gray",
                                      children: "\u25CF"
                                    }, void 0, !1, void 0, this),
                                    jsxDEV_7x81h0kn("text", {
                                      bold: !0,
                                      color: "cyan",
                                      children: proc.name.padEnd(20)
                                    }, void 0, !1, void 0, this),
                                    jsxDEV_7x81h0kn("text", {
                                      color: "blue",
                                      children: [
                                        proc.logs.length.toString().padStart(5),
                                        " logs"
                                      ]
                                    }, void 0, !0, void 0, this),
                                    errorCount > 0 && jsxDEV_7x81h0kn("text", {
                                      color: "red",
                                      children: [
                                        "  \u274C ",
                                        errorCount,
                                        " errors"
                                      ]
                                    }, void 0, !0, void 0, this),
                                    warnCount > 0 && jsxDEV_7x81h0kn("text", {
                                      color: "yellow",
                                      children: [
                                        "  \u26A0\uFE0F  ",
                                        warnCount,
                                        " warnings"
                                      ]
                                    }, void 0, !0, void 0, this)
                                  ]
                                }, proc.name, !0, void 0, this);
                              })
                            }, void 0, !1, void 0, this)
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("panel", {
                            border: "rounded",
                            title: "Recent Logs",
                            style: { padding: "1", maxHeight: "20" },
                            children: jsxDEV_7x81h0kn("vstack", {
                              children: (() => {
                                const allLogs = [];
                                processes.forEach((proc) => {
                                  proc.logs.forEach((log) => {
                                    allLogs.push({ ...log, processName: proc.name });
                                  });
                                });
                                allLogs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                                let filteredLogs = allLogs;
                                if (ctx.flags.preset) {
                                  const presetFilter = {
                                    errors: (log) => log.level === "error" || log.level === "fatal",
                                    warnings: (log) => ["warn", "error", "fatal"].includes(log.level),
                                    debug: (log) => log.level !== "trace",
                                    vite: (log) => /\b(vite|hmr|dev|build)\b/i.test(log.message),
                                    vitest: (log) => /\b(test|vitest|spec|pass|fail)\b/i.test(log.message),
                                    typescript: (log) => /\b(typescript|tsc|error ts)\b/i.test(log.message),
                                    production: (log) => !log.message.includes("[DEV]") && !log.message.includes("hmr"),
                                    recent: (log) => Date.now() - log.timestamp.getTime() < 300000
                                  }[ctx.flags.preset];
                                  if (presetFilter)
                                    filteredLogs = filteredLogs.filter(presetFilter);
                                }
                                return filteredLogs.slice(0, 20).map((log, i) => {
                                  const timestamp = log.timestamp.toLocaleTimeString(), color = {
                                    error: "red",
                                    warn: "yellow",
                                    info: "blue",
                                    debug: "gray"
                                  }[log.level] || "white";
                                  return jsxDEV_7x81h0kn("hstack", {
                                    children: [
                                      jsxDEV_7x81h0kn("text", {
                                        color: "gray",
                                        children: timestamp
                                      }, void 0, !1, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        color: "cyan",
                                        children: [
                                          "[",
                                          log.processName.padEnd(12),
                                          "]"
                                        ]
                                      }, void 0, !0, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        color,
                                        bold: !0,
                                        children: log.level.toUpperCase().padEnd(5)
                                      }, void 0, !1, void 0, this),
                                      jsxDEV_7x81h0kn("text", {
                                        children: [
                                          log.message.substring(0, 80),
                                          log.message.length > 80 ? "..." : ""
                                        ]
                                      }, void 0, !0, void 0, this)
                                    ]
                                  }, i, !0, void 0, this);
                                });
                              })()
                            }, void 0, !1, void 0, this)
                          }, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                          jsxDEV_7x81h0kn("panel", {
                            border: "single",
                            style: { padding: "0.5" },
                            children: jsxDEV_7x81h0kn("hstack", {
                              children: [
                                jsxDEV_7x81h0kn("text", {
                                  color: "yellow",
                                  children: "\uD83D\uDD04 Live updating..."
                                }, void 0, !1, void 0, this),
                                jsxDEV_7x81h0kn("text", {
                                  color: "gray",
                                  children: "Press Ctrl+C to exit"
                                }, void 0, !1, void 0, this),
                                jsxDEV_7x81h0kn("text", {
                                  color: "cyan",
                                  children: "Tip: Use --preset for filtering"
                                }, void 0, !1, void 0, this)
                              ]
                            }, void 0, !0, void 0, this)
                          }, void 0, !1, void 0, this)
                        ]
                      }, void 0, !0, void 0, this)
                    ]
                  }, void 0, !0, void 0, this)
                }, void 0, !1, void 0, this)
              }, void 0, !1, void 0, this);
            } else {
              await Effect.runPromise(ProcessMonitor({ manager: pm }).pipe(Effect.provide(LiveServices)));
              return jsxDEV_7x81h0kn("text", {
                color: "green",
                children: "Process dashboard exited"
              }, void 0, !1, void 0, this);
            }
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to start dashboard: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "config",
        description: "Manage process manager configuration",
        flags: {
          init: {
            description: "Initialize config file with example services",
            type: "boolean"
          },
          show: {
            description: "Show current config",
            type: "boolean"
          },
          path: {
            description: "Show config file path",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            if (ctx.flags.init) {
              const configPath = `${ctx.cliName === "tuix" ? "tuix" : ctx.cliName}.config.ts`;
              await Bun.write(configPath, `import { defineConfig } from 'tuix'

export default defineConfig({
  // Process manager services
  processManager: {
    services: {
      // Example development server
      'dev-server': {
        command: 'npm run dev',
        autorestart: true,
        group: 'development',
        env: {
          NODE_ENV: 'development'
        }
      },
      
      // Example test watcher
      'test-watch': {
        command: 'npm run test:watch',
        autorestart: true,
        group: 'testing'
      },
      
      // Example type checker
      'typecheck': {
        command: 'npm run typecheck --watch',
        autorestart: false,
        group: 'quality'
      }
    },
    
    // Process manager settings
    logDir: './logs',
    autoSave: true
  },
  
  // Logger configuration
  logger: {
    level: 'info',
    format: 'json',
    outputs: ['console']
  }
})
`);
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "green",
                    children: [
                      "\u2705 Created config file: ",
                      configPath
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    children: "\uD83D\uDCDD Example services added:"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 dev-server (npm run dev)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 test-watch (npm run test:watch)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "  \u2022 typecheck (npm run typecheck --watch)"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "Edit the config file to customize your services!"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "Then run: ",
                      ctx.cliName,
                      " ",
                      pluginName,
                      " start"
                    ]
                  }, void 0, !0, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            if (ctx.flags.show) {
              const config = ctx.tuixConfig;
              if (!config)
                return jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: "No config loaded. Run with --init to create one."
                }, void 0, !1, void 0, this);
              const services = config.processManager?.services || {}, serviceCount = Object.keys(services).length;
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "\uD83D\uDCCB Current Configuration"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    children: [
                      "Services configured: ",
                      serviceCount
                    ]
                  }, void 0, !0, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  serviceCount > 0 && jsxDEV_7x81h0kn("panel", {
                    title: "Configured Services",
                    border: "rounded",
                    children: jsxDEV_7x81h0kn("vstack", {
                      children: Object.entries(services).map(([name, service]) => jsxDEV_7x81h0kn("hstack", {
                        children: [
                          jsxDEV_7x81h0kn("text", {
                            color: "green",
                            children: [
                              name,
                              ":"
                            ]
                          }, void 0, !0, void 0, this),
                          jsxDEV_7x81h0kn("text", {
                            color: "gray",
                            children: service.command
                          }, void 0, !1, void 0, this),
                          service.group && jsxDEV_7x81h0kn("text", {
                            color: "purple",
                            children: [
                              "[",
                              service.group,
                              "]"
                            ]
                          }, void 0, !0, void 0, this),
                          service.autorestart && jsxDEV_7x81h0kn("text", {
                            color: "yellow",
                            children: "[auto-restart]"
                          }, void 0, !1, void 0, this)
                        ]
                      }, name, !0, void 0, this))
                    }, void 0, !1, void 0, this)
                  }, void 0, !1, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            if (ctx.flags.path) {
              const configName = ctx.cliName === "tuix" ? "tuix" : ctx.cliName, possiblePaths = [
                `${configName}.config.ts`,
                `${configName}.config.js`,
                "tuix.config.ts",
                "tuix.config.js",
                `.${configName}/config.ts`,
                `.${configName}/config.js`,
                ".tuix/config.ts",
                ".tuix/config.js"
              ];
              return jsxDEV_7x81h0kn("vstack", {
                children: [
                  jsxDEV_7x81h0kn("text", {
                    color: "cyan",
                    bold: !0,
                    children: "\uD83D\uDCC1 Config File Locations"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: "Config is loaded from first found file:"
                  }, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  possiblePaths.map((path, i) => jsxDEV_7x81h0kn("text", {
                    color: "gray",
                    children: [
                      "  ",
                      i + 1,
                      ". ",
                      path
                    ]
                  }, i, !0, void 0, this)),
                  jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                  jsxDEV_7x81h0kn("text", {
                    color: "yellow",
                    children: "Use --init to create a config file"
                  }, void 0, !1, void 0, this)
                ]
              }, void 0, !0, void 0, this);
            }
            return jsxDEV_7x81h0kn("vstack", {
              children: [
                jsxDEV_7x81h0kn("text", {
                  color: "cyan",
                  bold: !0,
                  children: "\u2699\uFE0F Process Manager Config"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "gray",
                  children: "Available commands:"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --init    Create example config file"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --show    Show current configuration"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "green",
                  children: "  --path    Show config file search paths"
                }, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: [
                    "Example: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " config --init"
                  ]
                }, void 0, !0, void 0, this)
              ]
            }, void 0, !0, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Config command failed: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this),
      jsxDEV_7x81h0kn("command", {
        name: "ps",
        description: "Show process status (alias)",
        handler: async (ctx) => {
          try {
            const processes = (await getProcessManagerForHandlers(ctx.tuixConfig)).list();
            return jsxDEV_7x81h0kn("vstack", {
              children: jsxDEV_7x81h0kn("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status",
                style: { padding: "1" },
                children: processes.length === 0 ? jsxDEV_7x81h0kn("text", {
                  color: "yellow",
                  children: [
                    "No processes running. Use '",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start' to begin."
                  ]
                }, void 0, !0, void 0, this) : jsxDEV_7x81h0kn("vstack", {
                  children: [
                    jsxDEV_7x81h0kn("text", {
                      color: "gray",
                      children: [
                        processes.length,
                        " process",
                        processes.length > 1 ? "es" : "",
                        " monitored"
                      ]
                    }, void 0, !0, void 0, this),
                    jsxDEV_7x81h0kn("text", {}, void 0, !1, void 0, this),
                    processes.map((proc) => jsxDEV_7x81h0kn(ProcessStatusView, {
                      process: proc
                    }, proc.name, !1, void 0, this))
                  ]
                }, void 0, !0, void 0, this)
              }, void 0, !1, void 0, this)
            }, void 0, !1, void 0, this);
          } catch (error) {
            return jsxDEV_7x81h0kn("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error.message
              ]
            }, void 0, !0, void 0, this);
          }
        }
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "name" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: ProcessManagerPlugin
[ProcessManagerPlugin] Called with name='dev', as='undefined'
[ProcessManagerPlugin] Returning plugin JSX with name='dev'
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "interactive", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "args", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "flags", "interactive", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.317Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "flags", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: dev
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "dev",
  description: "Process management and monitoring",
  version: "1.0.0",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] Processing Plugin element with name: dev
[2025-07-20T20:14:35.318Z] [TUIX JSX] Registering plugin 'dev' with 0 commands
 Plugin registered: dev
[2025-07-20T20:14:35.318Z] [TUIX JSX] Plugin 'dev' registered successfully
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component ProcessManagerPlugin returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: arg {
  props: [ "name", "description", "required" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.318Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: ai
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "ai",
  description: "AI assistant and model management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] Processing Plugin element with name: ai
[2025-07-20T20:14:35.319Z] [TUIX JSX] Registering plugin 'ai' with 0 commands
 Plugin registered: ai
[2025-07-20T20:14:35.319Z] [TUIX JSX] Plugin 'ai' registered successfully
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44", "45", "46", "47", "48", "49"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: websocket
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "websocket",
  description: "WebSocket server management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] Processing Plugin element with name: websocket
[2025-07-20T20:14:35.319Z] [TUIX JSX] Registering plugin 'websocket' with 0 commands
 Plugin registered: websocket
[2025-07-20T20:14:35.319Z] [TUIX JSX] Plugin 'websocket' registered successfully
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.319Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: user
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "user",
  description: "User account and settings management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] Processing Plugin element with name: user
[2025-07-20T20:14:35.320Z] [TUIX JSX] Registering plugin 'user' with 0 commands
 Plugin registered: user
[2025-07-20T20:14:35.320Z] [TUIX JSX] Plugin 'user' registered successfully
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "alias" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.320Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: flag {
  props: [ "name", "description", "type", "default" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: command {
  props: [ "name", "description", "handler", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "aliases", "handler", "args", "flags", "metadata", "children",
    "executable"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: help {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21",
    "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
    "42", "43", "44"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: example {
  props: [ "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Text(props) {
  const content = String(props.children), textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = !0;
    if (props.italic)
      baseStyle.italic = !0;
    if (props.underline)
      baseStyle.underline = !0;
    if (props.strikethrough)
      baseStyle.strikethrough = !0;
    if (props.dim)
      baseStyle.dim = !0;
    if (props.bright)
      baseStyle.bright = !0;
    if (props.inverse)
      baseStyle.inverse = !0;
    if (props.blink)
      baseStyle.blink = !0;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  }), processedText = $derived(() => {
    let text = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text) > maxWidth) {
        const ellipsis = props.ellipsis || "...", ellipsisWidth = stringWidth(ellipsis), availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text) > availableWidth && text.length > 0)
          text = text.slice(0, -1);
        text += ellipsis;
      }
    }
    if (props.wrap && props.width)
      ;
    return text;
  });
  if (props.rainbow)
    return jsxDEV_7x81h0kn(RainbowText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  if (props.pulse)
    return jsxDEV_7x81h0kn(PulsingText, {
      ...props,
      children: content
    }, void 0, !1, void 0, this);
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
} {
  props: [
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"
  ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Text
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "style", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Text returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "paddingX", "borderStyle", "borderColor" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Box(props) {
  const focused = $state(!1), hovering = $state(!1), boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== void 0)
      baseStyle.width = props.width;
    if (props.height !== void 0)
      baseStyle.height = props.height;
    if (props.minWidth !== void 0)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== void 0)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== void 0)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== void 0)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== void 0)
      if (typeof props.padding === "number")
        baseStyle.padding = props.padding;
      else
        baseStyle.padding = props.padding;
    if (props.margin !== void 0)
      if (typeof props.margin === "number")
        baseStyle.margin = props.margin;
      else
        baseStyle.margin = props.margin;
    if (props.border)
      baseStyle.border = props.border === !0 ? "single" : props.border;
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== void 0)
      baseStyle.gap = props.gap;
    if (props.wrap !== void 0)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== void 0)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick)
      baseStyle.brightness = 1.1;
    return style(baseStyle);
  }), Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick)
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = !0;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = !1;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = !0;
      },
      onMouseLeave: () => {
        hovering.value = !1;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
} {
  props: [ "flexDirection", "gap", "marginY" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Box
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: vstack {
  props: [ "style", "gap", "wrap", "className", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Box returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing lowercase 'plugin' element with name: workers
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: Plugin {
  props: [ "name", "description", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME]  Plugin element detected! Props: {
  name: "workers",
  description: "Background worker management",
  children: [
    {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }, {
      render: [Function: render],
      width: 0,
      height: 1,
    }
  ],
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] Processing Plugin element with name: workers
[2025-07-20T20:14:35.321Z] [TUIX JSX] Registering plugin 'workers' with 0 commands
 Plugin registered: workers
[2025-07-20T20:14:35.321Z] [TUIX JSX] Plugin 'workers' registered successfully
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: cli {
  props: [ "name", "alias", "description", "version", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function CommandLineScope(props) {
  const currentCommandPath = commandStore.currentPath, scopePath = props.path || [], isActive = currentCommandPath.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath[i]), isHelpRequested = isActive && currentCommandPath.length === scopePath.length + 1 && currentCommandPath[currentCommandPath.length - 1] === "help", childWillHandle = isActive && currentCommandPath.length > scopePath.length && !isHelpRequested, handler = isActive && (isHelpRequested || !childWillHandle) ? () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this) : props.handler;
  return jsxDEV_7x81h0kn(Scope, {
    ...props,
    executable: !0,
    handler,
    children: [
      props.children,
      jsxDEV_7x81h0kn(Scope, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => jsxDEV_7x81h0kn(CommandLineHelp, {}, void 0, !1, void 0, this)
      }, void 0, !1, void 0, this)
    ]
  }, void 0, !0, void 0, this);
} {
  props: [ "type", "name", "path", "description", "metadata", "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: CommandLineScope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "description", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.321Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Processing element type: function Scope(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`, willRenderContent = $state(!1), hasRenderedChildren = $state(!1), scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  }, parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0)
    scopeDef.path = [...parentScope.path, props.name];
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error) {
    Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive = scopeManager.isScopeActive(scopeId), childScopes = scopeManager.getChildScopes(scopeId), { children, defaultContent, layout } = props, hasScopeContent = (Array.isArray(children) ? children : children ? [children] : []).some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive)
    return jsx("text", { children: "" });
  if (props.executable && !hasRenderedContent(scopeId))
    content = jsxDEV_7x81h0kn(ScopeFallback, {
      scopeId
    }, void 0, !1, void 0, this);
  else if (hasScopeContent)
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else if (childScopes.length > 0 || defaultContent)
    content = defaultContent || jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  else
    content = jsxDEV_7x81h0kn(Fragment_8vg9x3sq, {
      children
    }, void 0, !1, void 0, this);
  if (layout && content)
    content = layout(content);
  return content;
} {
  props: [ "type", "name", "path", "description", "metadata", "children", "executable", "handler" ],
  key: undefined,
}
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Calling function component: Scope
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Processing element type: text {
  props: [ "children" ],
  key: undefined,
}
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Function component Scope returned: object
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Function component CommandLineScope returned: object
[2025-07-20T20:14:35.322Z] [TUIX JSX] [RUNTIME] Result details: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[TUIX JSX] Got app element: {
  render: [Function: render],
  width: 0,
  height: 1,
}
[TUIX JSX] App element type: object
[TUIX JSX] App element keys: [ "render", "width", "height" ]
[TUIX RENDER] renderToTerminal called
[TUIX RENDER] Element:
[TUIX RENDER] Element type:
[TUIX RENDER] Element is null?
[TUIX RENDER] Element is undefined?
[TUIX RENDER] Element validation passed
[TUIX RENDER]  Interactive context check: isInteractive=false
[TUIX RENDER]  Using non-interactive renderer (stdout only)
[TUIX RENDER]  Rendered content length: 0 chars

[TUIX RENDER]  Non-interactive render completed
[TUIX JSX] Finished rendering
