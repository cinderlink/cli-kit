// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;
// ../../node_modules/zod/dist/esm/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var init_util = __esm(() => {
  (function(util2) {
    util2.assertEqual = (_) => {};
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
});

// ../../node_modules/zod/dist/esm/v3/ZodError.js
var ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError;
var init_ZodError = __esm(() => {
  init_util();
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
});

// ../../node_modules/zod/dist/esm/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, en_default;
var init_en = __esm(() => {
  init_ZodError();
  init_util();
  en_default = errorMap;
});

// ../../node_modules/zod/dist/esm/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm(() => {
  init_en();
  overrideErrorMap = en_default;
});

// ../../node_modules/zod/dist/esm/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var init_parseUtil = __esm(() => {
  init_errors();
  init_en();
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
});

// ../../node_modules/zod/dist/esm/v3/helpers/typeAliases.js
var init_typeAliases = () => {};

// ../../node_modules/zod/dist/esm/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm(() => {
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
});

// ../../node_modules/zod/dist/esm/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER;
var init_types = __esm(() => {
  init_ZodError();
  init_errors();
  init_errorUtil();
  init_parseUtil();
  init_util();
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER = INVALID;
});

// ../../node_modules/zod/dist/esm/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});
var init_external = __esm(() => {
  init_errors();
  init_parseUtil();
  init_typeAliases();
  init_util();
  init_types();
  init_ZodError();
});

// ../../node_modules/zod/dist/esm/v3/index.js
var init_v3 = __esm(() => {
  init_external();
  init_external();
});

// ../../node_modules/zod/dist/esm/index.js
var init_esm = __esm(() => {
  init_v3();
});

// ../../src/core/schemas.ts
var exports_schemas = {};
__export(exports_schemas, {
  validateView: () => validateView,
  validateStyle: () => validateStyle,
  validateProcessConfig: () => validateProcessConfig,
  validateMouseEvent: () => validateMouseEvent,
  validateKeyEvent: () => validateKeyEvent,
  validateComponent: () => validateComponent,
  validateCLIConfig: () => validateCLIConfig,
  parseView: () => parseView,
  parseStyle: () => parseStyle,
  parseProcessConfig: () => parseProcessConfig,
  parseMouseEvent: () => parseMouseEvent,
  parseKeyEvent: () => parseKeyEvent,
  parseComponent: () => parseComponent,
  parseCLIConfig: () => parseCLIConfig,
  WindowSizeSchema: () => WindowSizeSchema,
  ViewportSchema: () => ViewportSchema,
  ViewSchema: () => ViewSchema,
  VerticalAlignSchema: () => VerticalAlignSchema,
  TerminalCapabilitiesSchema: () => TerminalCapabilitiesSchema,
  StyleSchema: () => StyleSchema,
  SizeSchema: () => SizeSchema,
  ProcessStatusSchema: () => ProcessStatusSchema,
  ProcessLogSchema: () => ProcessLogSchema,
  ProcessConfigSchema: () => ProcessConfigSchema,
  PositionSchema: () => PositionSchema,
  PaddingSchema: () => PaddingSchema,
  MouseEventTypeSchema: () => MouseEventTypeSchema,
  MouseEventSchema: () => MouseEventSchema,
  MouseButtonSchema: () => MouseButtonSchema,
  KeyTypeSchema: () => KeyTypeSchema,
  KeyEventSchema: () => KeyEventSchema,
  IPCChannelTypeSchema: () => IPCChannelTypeSchema,
  ErrorCodeSchema: () => ErrorCodeSchema,
  ComponentSchema: () => ComponentSchema,
  ColorSchema: () => ColorSchema,
  CmdSchema: () => CmdSchema,
  CLIOptionSchema: () => CLIOptionSchema,
  CLIConfigSchema: () => CLIConfigSchema,
  CLICommandSchema: () => CLICommandSchema,
  BoundsSchema: () => BoundsSchema,
  BorderCharactersSchema: () => BorderCharactersSchema,
  AppOptionsSchema: () => AppOptionsSchema,
  AppErrorSchema: () => AppErrorSchema,
  AlignSchema: () => AlignSchema
});
var ColorSchema, PositionSchema, SizeSchema, BoundsSchema, KeyTypeSchema, KeyEventSchema, MouseButtonSchema, MouseEventTypeSchema, MouseEventSchema, WindowSizeSchema, PaddingSchema, AlignSchema, VerticalAlignSchema, StyleSchema, BorderCharactersSchema, ViewSchema, CmdSchema, ComponentSchema, AppOptionsSchema, ViewportSchema, TerminalCapabilitiesSchema, CLIOptionSchema, CLICommandSchema, CLIConfigSchema, ErrorCodeSchema, AppErrorSchema, ProcessStatusSchema, IPCChannelTypeSchema, ProcessConfigSchema, ProcessLogSchema, validateKeyEvent = (data) => {
  return KeyEventSchema.safeParse(data).success;
}, validateMouseEvent = (data) => {
  return MouseEventSchema.safeParse(data).success;
}, validateStyle = (data) => {
  return StyleSchema.safeParse(data).success;
}, validateView = (data) => {
  return ViewSchema.safeParse(data).success;
}, validateComponent = (data) => {
  return ComponentSchema.safeParse(data).success;
}, validateCLIConfig = (data) => {
  return CLIConfigSchema.safeParse(data).success;
}, validateProcessConfig = (data) => {
  return ProcessConfigSchema.safeParse(data).success;
}, parseKeyEvent = (data) => {
  return KeyEventSchema.parse(data);
}, parseMouseEvent = (data) => {
  return MouseEventSchema.parse(data);
}, parseStyle = (data) => {
  return StyleSchema.parse(data);
}, parseView = (data) => {
  return ViewSchema.parse(data);
}, parseComponent = (data) => {
  return ComponentSchema.parse(data);
}, parseCLIConfig = (data) => {
  return CLIConfigSchema.parse(data);
}, parseProcessConfig = (data) => {
  return ProcessConfigSchema.parse(data);
};
var init_schemas = __esm(() => {
  init_esm();
  ColorSchema = exports_external.union([
    exports_external.string().regex(/^#[0-9a-fA-F]{6}$/),
    exports_external.string().regex(/^rgb\(\d+,\s*\d+,\s*\d+\)$/),
    exports_external.enum([
      "black",
      "red",
      "green",
      "yellow",
      "blue",
      "magenta",
      "cyan",
      "white",
      "brightBlack",
      "brightRed",
      "brightGreen",
      "brightYellow",
      "brightBlue",
      "brightMagenta",
      "brightCyan",
      "brightWhite",
      "gray",
      "grey",
      "darkGray",
      "darkGrey",
      "lightGray",
      "lightGrey"
    ])
  ]);
  PositionSchema = exports_external.object({
    x: exports_external.number().int().min(0),
    y: exports_external.number().int().min(0)
  });
  SizeSchema = exports_external.object({
    width: exports_external.number().int().min(0),
    height: exports_external.number().int().min(0)
  });
  BoundsSchema = PositionSchema.extend({
    width: exports_external.number().int().min(0),
    height: exports_external.number().int().min(0)
  });
  KeyTypeSchema = exports_external.enum([
    "character",
    "space",
    "tab",
    "enter",
    "escape",
    "backspace",
    "delete",
    "arrowUp",
    "arrowDown",
    "arrowLeft",
    "arrowRight",
    "home",
    "end",
    "pageUp",
    "pageDown",
    "insert",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "f10",
    "f11",
    "f12",
    "unknown"
  ]);
  KeyEventSchema = exports_external.object({
    key: exports_external.string(),
    runes: exports_external.string(),
    type: KeyTypeSchema,
    ctrl: exports_external.boolean(),
    alt: exports_external.boolean(),
    shift: exports_external.boolean(),
    meta: exports_external.boolean()
  });
  MouseButtonSchema = exports_external.enum([
    "left",
    "right",
    "middle",
    "wheel-up",
    "wheel-down"
  ]);
  MouseEventTypeSchema = exports_external.enum([
    "press",
    "release",
    "motion",
    "wheel"
  ]);
  MouseEventSchema = exports_external.object({
    type: MouseEventTypeSchema,
    x: exports_external.number().int().min(0),
    y: exports_external.number().int().min(0),
    button: MouseButtonSchema,
    ctrl: exports_external.boolean(),
    alt: exports_external.boolean(),
    shift: exports_external.boolean()
  });
  WindowSizeSchema = SizeSchema;
  PaddingSchema = exports_external.union([
    exports_external.number().int().min(0),
    exports_external.object({
      top: exports_external.number().int().min(0).optional(),
      right: exports_external.number().int().min(0).optional(),
      bottom: exports_external.number().int().min(0).optional(),
      left: exports_external.number().int().min(0).optional()
    })
  ]);
  AlignSchema = exports_external.enum(["left", "center", "right"]);
  VerticalAlignSchema = exports_external.enum(["top", "middle", "bottom"]);
  StyleSchema = exports_external.object({
    color: ColorSchema.optional(),
    background: ColorSchema.optional(),
    bold: exports_external.boolean().optional(),
    dim: exports_external.boolean().optional(),
    italic: exports_external.boolean().optional(),
    underline: exports_external.boolean().optional(),
    strikethrough: exports_external.boolean().optional(),
    blink: exports_external.boolean().optional(),
    reverse: exports_external.boolean().optional(),
    hidden: exports_external.boolean().optional(),
    padding: PaddingSchema.optional(),
    margin: PaddingSchema.optional(),
    align: AlignSchema.optional(),
    verticalAlign: VerticalAlignSchema.optional(),
    width: exports_external.number().int().min(0).optional(),
    height: exports_external.number().int().min(0).optional(),
    minWidth: exports_external.number().int().min(0).optional(),
    maxWidth: exports_external.number().int().min(0).optional(),
    minHeight: exports_external.number().int().min(0).optional(),
    maxHeight: exports_external.number().int().min(0).optional()
  });
  BorderCharactersSchema = exports_external.object({
    top: exports_external.string(),
    bottom: exports_external.string(),
    left: exports_external.string(),
    right: exports_external.string(),
    topLeft: exports_external.string(),
    topRight: exports_external.string(),
    bottomLeft: exports_external.string(),
    bottomRight: exports_external.string()
  });
  ViewSchema = exports_external.lazy(() => exports_external.object({
    render: exports_external.function().args().returns(exports_external.promise(exports_external.string())),
    width: exports_external.number().int().min(0).optional(),
    height: exports_external.number().int().min(0).optional(),
    handleKey: exports_external.function().args(KeyEventSchema).returns(exports_external.promise(exports_external.unknown())).optional(),
    handleMouse: exports_external.function().args(MouseEventSchema).returns(exports_external.promise(exports_external.unknown())).optional()
  }));
  CmdSchema = exports_external.function().returns(exports_external.promise(exports_external.unknown()));
  ComponentSchema = exports_external.object({
    init: exports_external.function().returns(exports_external.promise(exports_external.tuple([exports_external.unknown(), exports_external.array(CmdSchema)]))),
    update: exports_external.function().args(exports_external.unknown(), exports_external.unknown()).returns(exports_external.promise(exports_external.tuple([exports_external.unknown(), exports_external.array(CmdSchema)]))),
    view: exports_external.function().args(exports_external.unknown()).returns(ViewSchema),
    subscriptions: exports_external.function().args(exports_external.unknown()).returns(exports_external.array(exports_external.function())).optional()
  });
  AppOptionsSchema = exports_external.object({
    altScreen: exports_external.boolean().optional().default(true),
    mouseMode: exports_external.boolean().optional().default(false),
    debugMode: exports_external.boolean().optional().default(false),
    logLevel: exports_external.enum(["debug", "info", "warn", "error"]).optional().default("info"),
    refreshRate: exports_external.number().int().min(1).max(120).optional().default(60)
  });
  ViewportSchema = BoundsSchema;
  TerminalCapabilitiesSchema = exports_external.object({
    colors: exports_external.union([exports_external.literal("none"), exports_external.literal("basic"), exports_external.literal("256"), exports_external.literal("truecolor")]),
    unicode: exports_external.boolean(),
    mouse: exports_external.boolean(),
    clipboard: exports_external.boolean(),
    sixel: exports_external.boolean(),
    kitty: exports_external.boolean(),
    iterm2: exports_external.boolean(),
    windowTitle: exports_external.boolean(),
    columns: exports_external.number(),
    rows: exports_external.number(),
    alternateScreen: exports_external.boolean().optional(),
    cursorShapes: exports_external.boolean().optional()
  });
  CLIOptionSchema = exports_external.object({
    description: exports_external.string().optional(),
    type: exports_external.enum(["string", "number", "boolean"]),
    required: exports_external.boolean().optional().default(false),
    default: exports_external.unknown().optional(),
    choices: exports_external.array(exports_external.string()).optional(),
    validate: exports_external.function().args(exports_external.unknown()).returns(exports_external.boolean()).optional()
  });
  CLICommandSchema = exports_external.object({
    description: exports_external.string().optional(),
    args: exports_external.record(exports_external.string(), CLIOptionSchema).optional(),
    options: exports_external.record(exports_external.string(), CLIOptionSchema).optional(),
    handler: exports_external.function().args(exports_external.record(exports_external.string(), exports_external.unknown())).returns(exports_external.union([exports_external.string(), exports_external.promise(exports_external.string())]))
  });
  CLIConfigSchema = exports_external.object({
    name: exports_external.string(),
    version: exports_external.string(),
    description: exports_external.string().optional(),
    commands: exports_external.record(exports_external.string(), CLICommandSchema),
    options: exports_external.record(exports_external.string(), CLIOptionSchema).optional(),
    plugins: exports_external.array(exports_external.unknown()).optional(),
    hooks: exports_external.record(exports_external.string(), exports_external.function()).optional()
  });
  ErrorCodeSchema = exports_external.enum([
    "TERMINAL_ERROR",
    "INPUT_ERROR",
    "RENDER_ERROR",
    "STORAGE_ERROR",
    "CONFIG_ERROR",
    "COMPONENT_ERROR",
    "APPLICATION_ERROR",
    "VALIDATION_ERROR"
  ]);
  AppErrorSchema = exports_external.object({
    code: ErrorCodeSchema,
    message: exports_external.string(),
    cause: exports_external.unknown().optional(),
    timestamp: exports_external.number(),
    context: exports_external.record(exports_external.string(), exports_external.unknown()).optional()
  });
  ProcessStatusSchema = exports_external.enum([
    "stopped",
    "starting",
    "running",
    "stopping",
    "failed",
    "crashed"
  ]);
  IPCChannelTypeSchema = exports_external.enum([
    "unix-socket",
    "tcp",
    "named-pipe",
    "stdio"
  ]);
  ProcessConfigSchema = exports_external.object({
    name: exports_external.string(),
    command: exports_external.string(),
    args: exports_external.array(exports_external.string()).optional(),
    cwd: exports_external.string().optional(),
    env: exports_external.record(exports_external.string(), exports_external.string()).optional(),
    ipc: IPCChannelTypeSchema.optional(),
    autoRestart: exports_external.boolean().optional().default(false),
    maxRestarts: exports_external.number().int().min(0).optional(),
    restartDelay: exports_external.number().int().min(0).optional()
  });
  ProcessLogSchema = exports_external.object({
    timestamp: exports_external.number(),
    level: exports_external.enum(["info", "warn", "error", "debug"]),
    message: exports_external.string(),
    source: exports_external.enum(["stdout", "stderr", "system"])
  });
});

// ../../node_modules/effect/dist/esm/Function.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var isFunction = (input) => typeof input === "function", dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self) {
          return body(self, ...args);
        };
      };
  }
}, identity = (a) => a, constant = (value) => () => value, constTrue, constFalse, constNull, constUndefined, constVoid;
var init_Function = __esm(() => {
  constTrue = /* @__PURE__ */ constant(true);
  constFalse = /* @__PURE__ */ constant(false);
  constNull = /* @__PURE__ */ constant(null);
  constUndefined = /* @__PURE__ */ constant(undefined);
  constVoid = constUndefined;
});

// ../../node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that), isStrictEquivalent = (x, y) => x === y, strict = () => isStrictEquivalent, number, mapInput, Date2, array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0;i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});
var init_Equivalence = __esm(() => {
  init_Function();
  number = /* @__PURE__ */ strict();
  mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
  Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
});

// ../../node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map) => dual(3, (self, name, f) => map(self, (a) => ({
  ...a,
  [name]: f(a)
}))), bindTo = (map) => dual(2, (self, name) => map(self, (a) => ({
  [name]: a
}))), bind = (map, flatMap) => dual(3, (self, name, f) => flatMap(self, (a) => map(f(a), (b) => ({
  ...a,
  [name]: b
}))));
var init_doNotation = __esm(() => {
  init_Function();
});

// ../../node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.16.9", getCurrentVersion = () => moduleVersion;

// ../../node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId, globalStore, globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};
var init_GlobalValue = __esm(() => {
  globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
});

// ../../node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string", isNumber = (input) => typeof input === "number", isBoolean = (input) => typeof input === "boolean", isBigInt = (input) => typeof input === "bigint", isSymbol = (input) => typeof input === "symbol", isFunction2, isUndefined = (input) => input === undefined, isNever = (_) => false, isRecordOrArray = (input) => typeof input === "object" && input !== null, isObject = (input) => isRecordOrArray(input) || isFunction2(input), hasProperty, isTagged, isNullable = (input) => input === null || input === undefined, isNotNullable = (input) => input !== null && input !== undefined, isDate = (input) => input instanceof Date, isIterable = (input) => hasProperty(input, Symbol.iterator), isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input), isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var init_Predicate = __esm(() => {
  init_Function();
  isFunction2 = isFunction;
  hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && (property in self));
  isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
});

// ../../node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/effect/dist/esm/Utils.js
class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var GenKindTypeId, isGenKind = (u) => isObject(u) && (GenKindTypeId in u), GenKindImpl, SingleShotGen, adapter = () => function() {
  let x = arguments[0];
  for (let i = 1;i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
}, defaultIncHi = 335903614, defaultIncLo = 4150755663, MUL_HI, MUL_LO, BIT_53 = 9007199254740992, BIT_27 = 134217728, YieldWrapTypeId, YieldWrap, structuralRegionState, standard, forced, isNotOptimizedAway, internalCall, genConstructor, isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;
var init_Utils = __esm(() => {
  init_Function();
  init_GlobalValue();
  init_Predicate();
  GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
  GenKindImpl = class GenKindImpl {
    value;
    constructor(value) {
      this.value = value;
    }
    get _F() {
      return identity;
    }
    get _R() {
      return (_) => _;
    }
    get _O() {
      return (_) => _;
    }
    get _E() {
      return (_) => _;
    }
    [GenKindTypeId] = GenKindTypeId;
    [Symbol.iterator]() {
      return new SingleShotGen(this);
    }
  };
  SingleShotGen = class SingleShotGen {
    self;
    called = false;
    constructor(self) {
      this.self = self;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen(this.self);
    }
  };
  MUL_HI = 1481765933 >>> 0;
  MUL_LO = 1284865837 >>> 0;
  YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
  YieldWrap = class YieldWrap {
    #value;
    constructor(value) {
      this.#value = value;
    }
    [YieldWrapTypeId]() {
      return this.#value;
    }
  };
  structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
    enabled: false,
    tester: undefined
  }));
  standard = {
    effect_internal_function: (body) => {
      return body();
    }
  };
  forced = {
    effect_internal_function: (body) => {
      try {
        return body();
      } finally {}
    }
  };
  isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
  internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
  genConstructor = function* () {}.constructor;
});

// ../../node_modules/effect/dist/esm/Hash.js
var randomHashCache, symbol, hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
}, random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
}, combine = (b) => (self) => self * 53 ^ b, optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824, isHash = (u) => hasProperty(u, symbol), number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h2 = n | 0;
  if (h2 !== n) {
    h2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h2 ^= n /= 4294967295;
  }
  return optimize(h2);
}, string = (str) => {
  let h2 = 5381, i = str.length;
  while (i) {
    h2 = h2 * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h2);
}, structureKeys = (o, keys) => {
  let h2 = 12289;
  for (let i = 0;i < keys.length; i++) {
    h2 ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
  }
  return optimize(h2);
}, structure = (o) => structureKeys(o, Object.keys(o)), array2 = (arr) => {
  let h2 = 6151;
  for (let i = 0;i < arr.length; i++) {
    h2 = pipe(h2, combine(hash(arr[i])));
  }
  return optimize(h2);
}, cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};
var init_Hash = __esm(() => {
  init_Function();
  init_GlobalValue();
  init_Predicate();
  init_Utils();
  randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
  symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
});

// ../../node_modules/effect/dist/esm/Equal.js
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var symbol2, isEqual = (u) => hasProperty(u, symbol2), equivalence = () => equals;
var init_Equal = __esm(() => {
  init_Hash();
  init_Predicate();
  init_Utils();
  symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
});

// ../../node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol, toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
}, format = (x) => JSON.stringify(x, null, 2), BaseProto, toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
}, stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
}, symbolRedactable, isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u), redactableState, withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
}, redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};
var init_Inspectable = __esm(() => {
  init_GlobalValue();
  init_Predicate();
  NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
  BaseProto = {
    toJSON() {
      return toJSON(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
  redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
    fiberRefs: undefined
  }));
});

// ../../node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args) => {
  switch (args.length) {
    case 0:
      return self;
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args.length;i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};
var init_Pipeable = () => {};

// ../../node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async", OP_COMMIT = "Commit", OP_FAILURE = "Failure", OP_ON_FAILURE = "OnFailure", OP_ON_SUCCESS = "OnSuccess", OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure", OP_SUCCESS = "Success", OP_SYNC = "Sync", OP_TAG = "Tag", OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags", OP_WHILE = "While", OP_ITERATOR = "Iterator", OP_WITH_RUNTIME = "WithRuntime", OP_YIELD = "Yield", OP_REVERT_FLAGS = "RevertFlags";

// ../../node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId, StreamTypeId, SinkTypeId, ChannelTypeId, effectVariance, sinkVariance, channelVariance, EffectPrototype, StructuralPrototype, CommitPrototype, StructuralCommitPrototype, Base;
var init_effectable = __esm(() => {
  init_Equal();
  init_Hash();
  init_Pipeable();
  init_Utils();
  EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
  StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
  SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
  ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
  effectVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _,
    _V: /* @__PURE__ */ getCurrentVersion()
  };
  sinkVariance = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };
  channelVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  EffectPrototype = {
    [EffectTypeId]: effectVariance,
    [StreamTypeId]: effectVariance,
    [SinkTypeId]: sinkVariance,
    [ChannelTypeId]: channelVariance,
    [symbol2](that) {
      return this === that;
    },
    [symbol]() {
      return cached(this, random(this));
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  StructuralPrototype = {
    [symbol]() {
      return cached(this, structure(this));
    },
    [symbol2](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!((key in that) && equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  CommitPrototype = {
    ...EffectPrototype,
    _op: OP_COMMIT
  };
  StructuralCommitPrototype = {
    ...CommitPrototype,
    ...StructuralPrototype
  };
  Base = /* @__PURE__ */ function() {
    function Base2() {}
    Base2.prototype = CommitPrototype;
    return Base2;
  }();
});

// ../../node_modules/effect/dist/esm/internal/option.js
var TypeId, CommonProto, SomeProto, NoneHash, NoneProto, isOption = (input) => hasProperty(input, TypeId), isNone = (fa) => fa._tag === "None", isSome = (fa) => fa._tag === "Some", none, some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};
var init_option = __esm(() => {
  init_Equal();
  init_Hash();
  init_Inspectable();
  init_Predicate();
  init_effectable();
  TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
  CommonProto = {
    ...EffectPrototype,
    [TypeId]: {
      _A: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "Some",
    _op: "Some",
    [symbol2](that) {
      return isOption(that) && isSome(that) && equals(this.value, that.value);
    },
    [symbol]() {
      return cached(this, combine(hash(this._tag))(hash(this.value)));
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag,
        value: toJSON(this.value)
      };
    }
  });
  NoneHash = /* @__PURE__ */ hash("None");
  NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "None",
    _op: "None",
    [symbol2](that) {
      return isOption(that) && isNone(that);
    },
    [symbol]() {
      return NoneHash;
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag
      };
    }
  });
  none = /* @__PURE__ */ Object.create(NoneProto);
});

// ../../node_modules/effect/dist/esm/internal/either.js
var TypeId2, CommonProto2, RightProto, LeftProto, isEither = (input) => hasProperty(input, TypeId2), isLeft = (ma) => ma._tag === "Left", isRight = (ma) => ma._tag === "Right", left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
}, right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
}, getLeft = (self) => isRight(self) ? none : some(self.left), getRight = (self) => isLeft(self) ? none : some(self.right), fromOption;
var init_either = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Predicate();
  init_effectable();
  init_option();
  TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
  CommonProto2 = {
    ...EffectPrototype,
    [TypeId2]: {
      _R: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Right",
    _op: "Right",
    [symbol2](that) {
      return isEither(that) && isRight(that) && equals(this.right, that.right);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.right));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        right: toJSON(this.right)
      };
    }
  });
  LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Left",
    _op: "Left",
    [symbol2](that) {
      return isEither(that) && isLeft(that) && equals(this.left, that.left);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.left));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        left: toJSON(this.left)
      };
    }
  });
  fromOption = /* @__PURE__ */ dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));
});

// ../../node_modules/effect/dist/esm/Either.js
var right2, left2, fromOption2, isEither2, isLeft2, isRight2, mapLeft, map, match, merge, getOrThrowWith, getOrThrow, all = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
};
var init_Either = __esm(() => {
  init_Equivalence();
  init_Function();
  init_doNotation();
  init_either();
  init_option();
  init_Predicate();
  init_Utils();
  right2 = right;
  left2 = left;
  fromOption2 = fromOption;
  isEither2 = isEither;
  isLeft2 = isLeft;
  isRight2 = isRight;
  mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
  map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
  match = /* @__PURE__ */ dual(2, (self, {
    onLeft,
    onRight
  }) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
  merge = /* @__PURE__ */ match({
    onLeft: identity,
    onRight: identity
  });
  getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
    if (isRight2(self)) {
      return self.right;
    }
    throw onLeft(self.left);
  });
  getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));
});

// ../../node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that), number3, mapInput2, all2 = (collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
}, tuple = (...elements) => all2(elements), greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var init_Order = __esm(() => {
  init_Function();
  number3 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
  mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
});

// ../../node_modules/effect/dist/esm/Option.js
var exports_Option = {};
__export(exports_Option, {
  zipWith: () => zipWith,
  zipRight: () => zipRight,
  zipLeft: () => zipLeft,
  void: () => void_,
  toRefinement: () => toRefinement,
  toArray: () => toArray,
  tap: () => tap,
  some: () => some2,
  reduceCompact: () => reduceCompact,
  productMany: () => productMany,
  product: () => product,
  partitionMap: () => partitionMap,
  orElseSome: () => orElseSome,
  orElseEither: () => orElseEither,
  orElse: () => orElse,
  none: () => none2,
  mergeWith: () => mergeWith,
  match: () => match2,
  map: () => map2,
  liftThrowable: () => liftThrowable,
  liftPredicate: () => liftPredicate,
  liftNullable: () => liftNullable,
  lift2: () => lift2,
  let: () => let_2,
  isSome: () => isSome2,
  isOption: () => isOption2,
  isNone: () => isNone2,
  getRight: () => getRight2,
  getOrder: () => getOrder,
  getOrUndefined: () => getOrUndefined,
  getOrThrowWith: () => getOrThrowWith2,
  getOrThrow: () => getOrThrow2,
  getOrNull: () => getOrNull,
  getOrElse: () => getOrElse,
  getLeft: () => getLeft2,
  getEquivalence: () => getEquivalence,
  gen: () => gen,
  fromNullable: () => fromNullable,
  fromIterable: () => fromIterable,
  flatten: () => flatten,
  flatMapNullable: () => flatMapNullable,
  flatMap: () => flatMap,
  firstSomeOf: () => firstSomeOf,
  filterMap: () => filterMap,
  filter: () => filter,
  exists: () => exists,
  containsWith: () => containsWith,
  contains: () => contains,
  composeK: () => composeK,
  bindTo: () => bindTo2,
  bind: () => bind2,
  asVoid: () => asVoid,
  as: () => as,
  ap: () => ap,
  andThen: () => andThen,
  all: () => all3,
  TypeId: () => TypeId3,
  Do: () => Do
});
var TypeId3, none2 = () => none, some2, isOption2, isNone2, isSome2, match2, toRefinement = (f) => (a) => isSome2(f(a)), fromIterable = (collection) => {
  for (const a of collection) {
    return some2(a);
  }
  return none2();
}, getRight2, getLeft2, getOrElse, orElse, orElseSome, orElseEither, firstSomeOf = (collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
}, fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue), liftNullable = (f) => (...a) => fromNullable(f(...a)), getOrNull, getOrUndefined, liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
}, getOrThrowWith2, getOrThrow2, map2, as, asVoid, void_, flatMap, andThen, flatMapNullable, flatten, zipRight, zipLeft, composeK, tap, product = (self, that) => isSome2(self) && isSome2(that) ? some2([self.value, that.value]) : none2(), productMany = (self, collection) => {
  if (isNone2(self)) {
    return none2();
  }
  const out = [self.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some2(out);
}, all3 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some2(out);
}, zipWith, ap, reduceCompact, toArray = (self) => isNone2(self) ? [] : [self.value], partitionMap, filterMap, filter, getEquivalence = (isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value)), getOrder = (O) => make2((self, that) => isSome2(self) ? isSome2(that) ? O(self.value, that.value) : 1 : -1), lift2 = (f) => dual(2, (self, that) => zipWith(self, that, f)), liftPredicate, containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a)), _equivalence, contains, exists, bindTo2, let_2, bind2, Do, adapter2, gen = (...args) => {
  const f = args.length === 1 ? args[0] : args[1].bind(args[0]);
  const iterator = f(adapter2);
  let state = iterator.next();
  while (!state.done) {
    const current = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isNone2(current)) {
      return current;
    }
    state = iterator.next(current.value);
  }
  return some2(state.value);
}, mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};
var init_Option = __esm(() => {
  init_Equal();
  init_Equivalence();
  init_Function();
  init_doNotation();
  init_either();
  init_option();
  init_Order();
  init_Utils();
  TypeId3 = /* @__PURE__ */ Symbol.for("effect/Option");
  some2 = some;
  isOption2 = isOption;
  isNone2 = isNone;
  isSome2 = isSome;
  match2 = /* @__PURE__ */ dual(2, (self, {
    onNone,
    onSome
  }) => isNone2(self) ? onNone() : onSome(self.value));
  getRight2 = getRight;
  getLeft2 = getLeft;
  getOrElse = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
  orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
  orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
  orElseEither = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? map2(that(), right) : map2(self, left));
  getOrNull = /* @__PURE__ */ getOrElse(constNull);
  getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
  getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
    if (isSome2(self)) {
      return self.value;
    }
    throw onNone();
  });
  getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
  map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
  as = /* @__PURE__ */ dual(2, (self, b) => map2(self, () => b));
  asVoid = /* @__PURE__ */ as(undefined);
  void_ = /* @__PURE__ */ some2(undefined);
  flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
  andThen = /* @__PURE__ */ dual(2, (self, f) => flatMap(self, (a) => {
    const b = isFunction(f) ? f(a) : f;
    return isOption2(b) ? b : some2(b);
  }));
  flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
  flatten = /* @__PURE__ */ flatMap(identity);
  zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap(self, () => that));
  zipLeft = /* @__PURE__ */ dual(2, (self, that) => tap(self, () => that));
  composeK = /* @__PURE__ */ dual(2, (afb, bfc) => (a) => flatMap(afb(a), bfc));
  tap = /* @__PURE__ */ dual(2, (self, f) => flatMap(self, (a) => map2(f(a), () => a)));
  zipWith = /* @__PURE__ */ dual(3, (self, that, f) => map2(product(self, that), ([a, b]) => f(a, b)));
  ap = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
  reduceCompact = /* @__PURE__ */ dual(3, (self, b, f) => {
    let out = b;
    for (const oa of self) {
      if (isSome2(oa)) {
        out = f(out, oa.value);
      }
    }
    return out;
  });
  partitionMap = /* @__PURE__ */ dual(2, (self, f) => {
    if (isNone2(self)) {
      return [none2(), none2()];
    }
    const e = f(self.value);
    return isLeft(e) ? [some2(e.left), none2()] : [none2(), some2(e.right)];
  });
  filterMap = flatMap;
  filter = /* @__PURE__ */ dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
  liftPredicate = /* @__PURE__ */ dual(2, (b, predicate) => predicate(b) ? some2(b) : none2());
  _equivalence = /* @__PURE__ */ equivalence();
  contains = /* @__PURE__ */ containsWith(_equivalence);
  exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
  bindTo2 = /* @__PURE__ */ bindTo(map2);
  let_2 = /* @__PURE__ */ let_(map2);
  bind2 = /* @__PURE__ */ bind(map2, flatMap);
  Do = /* @__PURE__ */ some2({});
  adapter2 = /* @__PURE__ */ adapter();
});

// ../../node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;
var init_Tuple = __esm(() => {
  init_Equivalence();
  init_Function();
  init_Order();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
}, findFirst, constEmpty, constEmptyIterator, empty = () => constEmpty;
var init_Iterable = __esm(() => {
  init_Either();
  init_Equal();
  init_Function();
  init_Option();
  init_Predicate();
  init_Tuple();
  findFirst = /* @__PURE__ */ dual(2, (self, f) => {
    let i = 0;
    for (const a of self) {
      const o = f(a, i);
      if (isBoolean(o)) {
        if (o) {
          return some2(a);
        }
      } else {
        if (isSome2(o)) {
          return o;
        }
      }
      i++;
    }
    return none2();
  });
  constEmpty = {
    [Symbol.iterator]() {
      return constEmptyIterator;
    }
  };
  constEmptyIterator = {
    next() {
      return {
        done: true,
        value: undefined
      };
    }
  };
});

// ../../node_modules/effect/dist/esm/Record.js
var init_Record = __esm(() => {
  init_Either();
  init_Equal();
  init_Function();
  init_Option();
});

// ../../node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n), makeBy, fromIterable2 = (collection) => Array.isArray(collection) ? collection : Array.from(collection), ensure = (self) => Array.isArray(self) ? self : [self], matchLeft, prepend, append, appendAll, isArray, isEmptyArray = (self) => self.length === 0, isEmptyReadonlyArray, isNonEmptyArray2, isNonEmptyReadonlyArray, isOutOfBounds = (i, as2) => i < 0 || i >= as2.length, clamp = (i, as2) => Math.floor(Math.min(Math.max(0, i), as2.length)), get, unsafeGet, head, headNonEmpty, last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2(), lastNonEmpty = (self) => self[self.length - 1], tailNonEmpty = (self) => self.slice(1), spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
}, span, drop, findFirstIndex, findLastIndex, findFirst2, findLast, modify, remove, reverse = (self) => Array.from(self).reverse(), sort, zip, zipWith2, unzip = (self) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1;i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
}, containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
}), _equivalence2, contains2, splitAt, splitNonEmptyAt, copy = (self) => self.slice(), unionWith, union, intersectionWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => has(that, a)));
}, intersection, differenceWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => !has(that, a)));
}, difference, empty2 = () => [], of = (a) => [a], map3, flatMap2, flatten2, filterMap2, filterMapWhile, partitionMap2, getSomes, filter2, partition, separate, reduce, reduceRight, every, unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
}, getEquivalence2, dedupeWith, dedupe = (self) => dedupeWith(self, equivalence()), dedupeAdjacentWith, dedupeAdjacent, join, mapAccum;
var init_Array = __esm(() => {
  init_Either();
  init_Equal();
  init_Equivalence();
  init_Function();
  init_doNotation();
  init_Iterable();
  init_Option();
  init_Order();
  init_Predicate();
  init_Record();
  init_Tuple();
  makeBy = /* @__PURE__ */ dual(2, (n, f) => {
    const max2 = Math.max(1, Math.floor(n));
    const out = new Array(max2);
    for (let i = 0;i < max2; i++) {
      out[i] = f(i);
    }
    return out;
  });
  matchLeft = /* @__PURE__ */ dual(2, (self, {
    onEmpty,
    onNonEmpty
  }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
  prepend = /* @__PURE__ */ dual(2, (self, head) => [head, ...self]);
  append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
  appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable2(self).concat(fromIterable2(that)));
  isArray = Array.isArray;
  isEmptyReadonlyArray = isEmptyArray;
  isNonEmptyArray2 = isNonEmptyArray;
  isNonEmptyReadonlyArray = isNonEmptyArray;
  get = /* @__PURE__ */ dual(2, (self, index) => {
    const i = Math.floor(index);
    return isOutOfBounds(i, self) ? none2() : some2(self[i]);
  });
  unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
    const i = Math.floor(index);
    if (isOutOfBounds(i, self)) {
      throw new Error(`Index ${i} out of bounds`);
    }
    return self[i];
  });
  head = /* @__PURE__ */ get(0);
  headNonEmpty = /* @__PURE__ */ unsafeGet(0);
  span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
  drop = /* @__PURE__ */ dual(2, (self, n) => {
    const input = fromIterable2(self);
    return input.slice(clamp(n, input), input.length);
  });
  findFirstIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
    let i = 0;
    for (const a of self) {
      if (predicate(a, i)) {
        return some2(i);
      }
      i++;
    }
    return none2();
  });
  findLastIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
    const input = fromIterable2(self);
    for (let i = input.length - 1;i >= 0; i--) {
      if (predicate(input[i], i)) {
        return some2(i);
      }
    }
    return none2();
  });
  findFirst2 = findFirst;
  findLast = /* @__PURE__ */ dual(2, (self, f) => {
    const input = fromIterable2(self);
    for (let i = input.length - 1;i >= 0; i--) {
      const a = input[i];
      const o = f(a, i);
      if (isBoolean(o)) {
        if (o) {
          return some2(a);
        }
      } else {
        if (isSome2(o)) {
          return o;
        }
      }
    }
    return none2();
  });
  modify = /* @__PURE__ */ dual(3, (self, i, f) => {
    const out = Array.from(self);
    if (isOutOfBounds(i, out)) {
      return out;
    }
    const b = f(out[i]);
    out[i] = b;
    return out;
  });
  remove = /* @__PURE__ */ dual(2, (self, i) => {
    const out = Array.from(self);
    if (isOutOfBounds(i, out)) {
      return out;
    }
    out.splice(i, 1);
    return out;
  });
  sort = /* @__PURE__ */ dual(2, (self, O) => {
    const out = Array.from(self);
    out.sort(O);
    return out;
  });
  zip = /* @__PURE__ */ dual(2, (self, that) => zipWith2(self, that, make3));
  zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => {
    const as2 = fromIterable2(self);
    const bs = fromIterable2(that);
    if (isNonEmptyReadonlyArray(as2) && isNonEmptyReadonlyArray(bs)) {
      const out = [f(headNonEmpty(as2), headNonEmpty(bs))];
      const len = Math.min(as2.length, bs.length);
      for (let i = 1;i < len; i++) {
        out[i] = f(as2[i], bs[i]);
      }
      return out;
    }
    return [];
  });
  _equivalence2 = /* @__PURE__ */ equivalence();
  contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
  splitAt = /* @__PURE__ */ dual(2, (self, n) => {
    const input = Array.from(self);
    const _n = Math.floor(n);
    if (isNonEmptyReadonlyArray(input)) {
      if (_n >= 1) {
        return splitNonEmptyAt(input, _n);
      }
      return [[], input];
    }
    return [input, []];
  });
  splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
    const _n = Math.max(1, Math.floor(n));
    return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
  });
  unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
    const a = fromIterable2(self);
    const b = fromIterable2(that);
    if (isNonEmptyReadonlyArray(a)) {
      if (isNonEmptyReadonlyArray(b)) {
        const dedupe = dedupeWith(isEquivalent);
        return dedupe(appendAll(a, b));
      }
      return a;
    }
    return b;
  });
  union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
  intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
  difference = /* @__PURE__ */ differenceWith(_equivalence2);
  map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
  flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
    if (isEmptyReadonlyArray(self)) {
      return [];
    }
    const out = [];
    for (let i = 0;i < self.length; i++) {
      const inner = f(self[i], i);
      for (let j = 0;j < inner.length; j++) {
        out.push(inner[j]);
      }
    }
    return out;
  });
  flatten2 = /* @__PURE__ */ flatMap2(identity);
  filterMap2 = /* @__PURE__ */ dual(2, (self, f) => {
    const as2 = fromIterable2(self);
    const out = [];
    for (let i = 0;i < as2.length; i++) {
      const o = f(as2[i], i);
      if (isSome2(o)) {
        out.push(o.value);
      }
    }
    return out;
  });
  filterMapWhile = /* @__PURE__ */ dual(2, (self, f) => {
    let i = 0;
    const out = [];
    for (const a of self) {
      const b = f(a, i);
      if (isSome2(b)) {
        out.push(b.value);
      } else {
        break;
      }
      i++;
    }
    return out;
  });
  partitionMap2 = /* @__PURE__ */ dual(2, (self, f) => {
    const left3 = [];
    const right3 = [];
    const as2 = fromIterable2(self);
    for (let i = 0;i < as2.length; i++) {
      const e = f(as2[i], i);
      if (isLeft2(e)) {
        left3.push(e.left);
      } else {
        right3.push(e.right);
      }
    }
    return [left3, right3];
  });
  getSomes = /* @__PURE__ */ filterMap2(identity);
  filter2 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const as2 = fromIterable2(self);
    const out = [];
    for (let i = 0;i < as2.length; i++) {
      if (predicate(as2[i], i)) {
        out.push(as2[i]);
      }
    }
    return out;
  });
  partition = /* @__PURE__ */ dual(2, (self, predicate) => {
    const left3 = [];
    const right3 = [];
    const as2 = fromIterable2(self);
    for (let i = 0;i < as2.length; i++) {
      if (predicate(as2[i], i)) {
        right3.push(as2[i]);
      } else {
        left3.push(as2[i]);
      }
    }
    return [left3, right3];
  });
  separate = /* @__PURE__ */ partitionMap2(identity);
  reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable2(self).reduce((b2, a, i) => f(b2, a, i), b));
  reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable2(self).reduceRight((b2, a, i) => f(b2, a, i), b));
  every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
  getEquivalence2 = array;
  dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
    const input = fromIterable2(self);
    if (isNonEmptyReadonlyArray(input)) {
      const out = [headNonEmpty(input)];
      const rest = tailNonEmpty(input);
      for (const r of rest) {
        if (out.every((a) => !isEquivalent(r, a))) {
          out.push(r);
        }
      }
      return out;
    }
    return [];
  });
  dedupeAdjacentWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
    const out = [];
    let lastA = none2();
    for (const a of self) {
      if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
        out.push(a);
        lastA = some2(a);
      }
    }
    return out;
  });
  dedupeAdjacent = /* @__PURE__ */ dedupeAdjacentWith(/* @__PURE__ */ equivalence());
  join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable2(self).join(sep));
  mapAccum = /* @__PURE__ */ dual(3, (self, s, f) => {
    let i = 0;
    let s1 = s;
    const out = [];
    for (const a of self) {
      const r = f(s1, a, i);
      s1 = r[0];
      out.push(r[1]);
      i++;
    }
    return [s1, out];
  });
});

// ../../node_modules/fast-check/lib/esm/fast-check-default.js
var init_fast_check_default = () => {};

// ../../node_modules/fast-check/lib/esm/fast-check.js
var init_fast_check = __esm(() => {
  init_fast_check_default();
});

// ../../node_modules/effect/dist/esm/FastCheck.js
var init_FastCheck = __esm(() => {
  init_fast_check();
});

// ../../node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
}, ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o)), memoizeThunk = (f) => {
  let done = false;
  let a;
  return () => {
    if (done) {
      return a;
    }
    a = f();
    done = true;
    return a;
  };
}, formatDate = (date) => {
  try {
    return date.toISOString();
  } catch {
    return String(date);
  }
}, formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
}, formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name), isNonEmpty = (x) => Array.isArray(x), isSingle = (x) => !Array.isArray(x), formatPathKey = (key) => `[${formatPropertyKey(key)}]`, formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);
var init_util2 = __esm(() => {
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
}, getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`), getASTIndexSignatureParameterErrorMessage, getASTRequiredElementFollowinAnOptionalElementErrorMessage, getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);
var init_errors2 = __esm(() => {
  init_Array();
  init_util2();
  getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
  getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
});

// ../../node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId;
var init_schemaId = __esm(() => {
  DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
});

// ../../node_modules/effect/dist/esm/Number.js
var Order, nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var init_Number = __esm(() => {
  init_Equivalence();
  init_Function();
  init_option();
  init_Iterable();
  init_Order();
  init_Predicate();
  Order = number3;
});

// ../../node_modules/effect/dist/esm/RegExp.js
var escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");
var init_RegExp = __esm(() => {
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/SchemaAST.js
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class Union {
  types;
  annotations;
  static make = (types2, annotations) => {
    return isMembers(types2) ? new Union(types2, annotations) : types2.length === 1 ? types2[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten3(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types2, annotations = {}) {
    this.types = types2;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}

class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter3, annotations = {}) {
    this.from = from;
    this.filter = filter3;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
function changeMap(as2, f) {
  let changed = false;
  const out = allocate(as2.length);
  for (let i = 0;i < as2.length; i++) {
    const a = as2[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as2;
}
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var BrandAnnotationId, SchemaIdAnnotationId, MessageAnnotationId, MissingMessageAnnotationId, IdentifierAnnotationId, TitleAnnotationId, AutoTitleAnnotationId, DescriptionAnnotationId, ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId, DocumentationAnnotationId, ConcurrencyAnnotationId, BatchingAnnotationId, ParseIssueTitleAnnotationId, ParseOptionsAnnotationId, DecodingFallbackAnnotationId, SurrogateAnnotationId, StableFilterAnnotationId, getAnnotation, getBrandAnnotation, getMessageAnnotation, getMissingMessageAnnotation, getTitleAnnotation, getAutoTitleAnnotation, getIdentifierAnnotation, getDescriptionAnnotation, getConcurrencyAnnotation, getBatchingAnnotation, getParseIssueTitleAnnotation, getParseOptionsAnnotation, getDecodingFallbackAnnotation, getSurrogateAnnotation, getStableFilterAnnotation, hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true), JSONIdentifierAnnotationId, getJSONIdentifierAnnotation, getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated)), createASTGuard = (tag) => (ast) => ast._tag === tag, isLiteral, undefinedKeyword, voidKeyword, neverKeyword, unknownKeyword, anyKeyword, stringKeyword, isStringKeyword, numberKeyword, booleanKeyword, bigIntKeyword, symbolKeyword, isSymbolKeyword, objectKeyword, OptionalType, getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type), formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head2, tail) => {
      const formattedHead = String(head2);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
}, PropertySignature, isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
}, formatIndexSignatures = (iss) => iss.map(String).join("; "), formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
}, sortCandidates, literalMap, flatten3 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten3(ast.types) : [ast]), unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
}, isMembers = (as2) => as2.length > 1, isUnion, toJSONMemoMap, isRefinement, defaultParseOption, annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
}, STRING_KEYWORD_PATTERN = "[\\s\\S]*", NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?", getTemplateLiteralSpanTypePattern = (type, capture) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
  }
}, handleTemplateLiteralSpanTypeParens = (type, s, capture, top) => {
  if (isUnion(type)) {
    if (capture && !top) {
      return `(?:${s})`;
    }
  } else if (!capture || !top) {
    return s;
  }
  return `(${s})`;
}, getTemplateLiteralPattern = (ast, capture, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head2 = escape(ast.head);
    pattern += capture && top ? `(${head2})` : head2;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
    if (span2.literal !== "") {
      const literal = escape(span2.literal);
      pattern += capture && top ? `(${literal})` : literal;
    }
  }
  return pattern;
}, getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`), pickAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
      if (out === undefined) {
        out = {};
      }
      out[id] = annotated.annotations[id];
    }
  }
  return out;
}, preserveTransformationAnnotations, typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = typeAST(is.type);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types2 = changeMap(ast.types, typeAST);
      return types2 === ast.types ? ast : Union.make(types2, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
}, createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier) => ({
    [JSONIdentifierAnnotationId]: identifier
  })
}), getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
}, encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = encodedAST_(is.type, isBound);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types2 = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types2 === ast.types ? ast : Union.make(types2, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier = createJSONIdentifierAnnotation(ast);
      return identifier ? annotations(from, identifier) : from;
    }
    case "Transformation": {
      const identifier = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier ? annotations(ast.from, identifier) : ast.from, isBound);
    }
  }
  return ast;
}, encodedAST = (ast) => encodedAST_(ast, false), toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
}, getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
}, formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag), getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast))), getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var init_SchemaAST = __esm(() => {
  init_Array();
  init_Function();
  init_GlobalValue();
  init_errors2();
  init_util2();
  init_Number();
  init_Option();
  init_Order();
  init_Predicate();
  init_RegExp();
  BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
  SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
  MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
  MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
  IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
  TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
  AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
  DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
  ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
  DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
  JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
  ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
  PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
  EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
  DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
  ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
  BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
  ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
  ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
  DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
  SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
  StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
  getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
  getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
  getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
  getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
  getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
  getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
  getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
  getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
  getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
  getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
  getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
  getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
  getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
  getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
  getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
  JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
  getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
  isLiteral = /* @__PURE__ */ createASTGuard("Literal");
  undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
    [TitleAnnotationId]: "undefined"
  });
  voidKeyword = /* @__PURE__ */ new VoidKeyword({
    [TitleAnnotationId]: "void"
  });
  neverKeyword = /* @__PURE__ */ new NeverKeyword({
    [TitleAnnotationId]: "never"
  });
  unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
    [TitleAnnotationId]: "unknown"
  });
  anyKeyword = /* @__PURE__ */ new AnyKeyword({
    [TitleAnnotationId]: "any"
  });
  stringKeyword = /* @__PURE__ */ new StringKeyword({
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
  });
  isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
  numberKeyword = /* @__PURE__ */ new NumberKeyword({
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
  });
  booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
  });
  bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
    [TitleAnnotationId]: "bigint",
    [DescriptionAnnotationId]: "a bigint"
  });
  symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
    [TitleAnnotationId]: "symbol",
    [DescriptionAnnotationId]: "a symbol"
  });
  isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
  objectKeyword = /* @__PURE__ */ new ObjectKeyword({
    [TitleAnnotationId]: "object",
    [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
  });
  OptionalType = class OptionalType extends Type {
    isOptional;
    constructor(type, isOptional, annotations = {}) {
      super(type, annotations);
      this.isOptional = isOptional;
    }
    toJSON() {
      return {
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    toString() {
      return String(this.type) + (this.isOptional ? "?" : "");
    }
  };
  PropertySignature = class PropertySignature extends OptionalType {
    name;
    isReadonly;
    constructor(name, type, isOptional, isReadonly, annotations) {
      super(type, isOptional, annotations);
      this.name = name;
      this.isReadonly = isReadonly;
    }
    toString() {
      return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
    }
    toJSON() {
      return {
        name: String(this.name),
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  };
  sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
    switch (ast._tag) {
      case "AnyKeyword":
        return 0;
      case "UnknownKeyword":
        return 1;
      case "ObjectKeyword":
        return 2;
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        return 3;
    }
    return 4;
  }));
  literalMap = {
    string: "StringKeyword",
    number: "NumberKeyword",
    boolean: "BooleanKeyword",
    bigint: "BigIntKeyword"
  };
  isUnion = /* @__PURE__ */ createASTGuard("Union");
  toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);
  isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
  defaultParseOption = {};
  preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
});

// ../../node_modules/effect/dist/esm/Arbitrary.js
var init_Arbitrary = __esm(() => {
  init_Array();
  init_FastCheck();
  init_GlobalValue();
  init_errors2();
  init_schemaId();
  init_util2();
  init_Option();
  init_Predicate();
  init_SchemaAST();
});

// ../../node_modules/effect/dist/esm/BigDecimal.js
var TypeId4, BigDecimalProto, isBigDecimal = (u) => hasProperty(u, TypeId4), make4 = (value, scale) => {
  const o = Object.create(BigDecimalProto);
  o.value = value;
  o.scale = scale;
  return o;
}, unsafeMakeNormalized = (value, scale) => {
  if (value !== bigint0 && value % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make4(value, scale);
  o.normalized = o;
  return o;
}, bigint0, bigint10, zero, normalize = (self) => {
  if (self.normalized === undefined) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1;i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value = BigInt(digits.substring(0, digits.length - trail));
      const scale = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value, scale);
    }
  }
  return self.normalized;
}, scale, abs = (n) => n.value < bigint0 ? make4(-n.value, n.scale) : n, Equivalence, equals2, format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint0;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before;
  let after;
  if (normalized.scale >= absolute.length) {
    before = "0";
    after = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before = `${absolute}${"0".repeat(zeros)}`;
      after = "";
    } else {
      after = absolute.slice(location);
      before = absolute.slice(0, location);
    }
  }
  const complete = after === "" ? before : `${before}.${after}`;
  return negative ? `-${complete}` : complete;
}, toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head2 = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head2}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
}, isZero = (n) => n.value === bigint0, isNegative = (n) => n.value < bigint0;
var init_BigDecimal = __esm(() => {
  init_Equal();
  init_Equivalence();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Order();
  init_Pipeable();
  init_Predicate();
  TypeId4 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
  BigDecimalProto = {
    [TypeId4]: TypeId4,
    [symbol]() {
      const normalized = normalize(this);
      return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
    },
    [symbol2](that) {
      return isBigDecimal(that) && equals2(this, that);
    },
    toString() {
      return `BigDecimal(${format2(this)})`;
    },
    toJSON() {
      return {
        _id: "BigDecimal",
        value: String(this.value),
        scale: this.scale
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  bigint0 = /* @__PURE__ */ BigInt(0);
  bigint10 = /* @__PURE__ */ BigInt(10);
  zero = /* @__PURE__ */ unsafeMakeNormalized(bigint0, 0);
  scale = /* @__PURE__ */ dual(2, (self, scale2) => {
    if (scale2 > self.scale) {
      return make4(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
    }
    if (scale2 < self.scale) {
      return make4(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
    }
    return self;
  });
  Equivalence = /* @__PURE__ */ make((self, that) => {
    if (self.scale > that.scale) {
      return scale(that, self.scale).value === self.value;
    }
    if (self.scale < that.scale) {
      return scale(self, that.scale).value === that.value;
    }
    return self.value === that.value;
  });
  equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(self, that));
});

// ../../node_modules/effect/dist/esm/BigInt.js
var init_BigInt = __esm(() => {
  init_Equivalence();
  init_Function();
  init_Option();
  init_Order();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/Boolean.js
var not = (self) => !self;
var init_Boolean = __esm(() => {
  init_Equivalence();
  init_Function();
  init_Order();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/Brand.js
var init_Brand = __esm(() => {
  init_Array();
  init_Either();
  init_Function();
  init_Option();
});

// ../../node_modules/effect/dist/esm/internal/context.js
var TagTypeId, ReferenceTypeId, STMSymbolKey = "effect/STM", STMTypeId, TagProto, ReferenceProto, makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
}, Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
}, Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {}
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
}, TypeId5, ContextProto, makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
}, serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split(`
`);
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split(`
`);
    lines.splice(1, 3);
    error.stack = lines.join(`
`);
  }
  return error;
}, isContext = (u) => hasProperty(u, TypeId5), isTag = (u) => hasProperty(u, TagTypeId), isReference = (u) => hasProperty(u, ReferenceTypeId), _empty, empty3 = () => _empty, make5 = (tag, service) => makeContext(new Map([[tag.key, service]])), add, defaultValueCache, getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
}, unsafeGetReference = (self, tag) => {
  return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
}, unsafeGet2, get2, getOrElse2, getOption, merge2, mergeAll = (...ctxs) => {
  const map4 = new Map;
  for (const ctx of ctxs) {
    for (const [tag, s] of ctx.unsafeMap) {
      map4.set(tag, s);
    }
  }
  return makeContext(map4);
}, pick = (...tags) => (self) => {
  const tagSet = new Set(tags.map((_) => _.key));
  const newEnv = new Map;
  for (const [tag, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag)) {
      newEnv.set(tag, s);
    }
  }
  return makeContext(newEnv);
}, omit = (...tags) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};
var init_context = __esm(() => {
  init_Equal();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_Inspectable();
  init_Pipeable();
  init_Predicate();
  init_effectable();
  init_option();
  TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
  ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
  STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
  TagProto = {
    ...EffectPrototype,
    _op: "Tag",
    [STMTypeId]: effectVariance,
    [TagTypeId]: {
      _Service: (_) => _,
      _Identifier: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Tag",
        key: this.key,
        stack: this.stack
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    of(self) {
      return self;
    },
    context(self) {
      return make5(this, self);
    }
  };
  ReferenceProto = {
    ...TagProto,
    [ReferenceTypeId]: ReferenceTypeId
  };
  TypeId5 = /* @__PURE__ */ Symbol.for("effect/Context");
  ContextProto = {
    [TypeId5]: {
      _Services: (_) => _
    },
    [symbol2](that) {
      if (isContext(that)) {
        if (this.unsafeMap.size === that.unsafeMap.size) {
          for (const k of this.unsafeMap.keys()) {
            if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    },
    [symbol]() {
      return cached(this, number2(this.unsafeMap.size));
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Context",
        services: Array.from(this.unsafeMap).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
  add = /* @__PURE__ */ dual(3, (self, tag, service) => {
    const map4 = new Map(self.unsafeMap);
    map4.set(tag.key, service);
    return makeContext(map4);
  });
  defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
  unsafeGet2 = /* @__PURE__ */ dual(2, (self, tag) => {
    if (!self.unsafeMap.has(tag.key)) {
      if (ReferenceTypeId in tag)
        return getDefaultValue(tag);
      throw serviceNotFoundError(tag);
    }
    return self.unsafeMap.get(tag.key);
  });
  get2 = unsafeGet2;
  getOrElse2 = /* @__PURE__ */ dual(3, (self, tag, orElse2) => {
    if (!self.unsafeMap.has(tag.key)) {
      return isReference(tag) ? getDefaultValue(tag) : orElse2();
    }
    return self.unsafeMap.get(tag.key);
  });
  getOption = /* @__PURE__ */ dual(2, (self, tag) => {
    if (!self.unsafeMap.has(tag.key)) {
      return isReference(tag) ? some(getDefaultValue(tag)) : none;
    }
    return some(self.unsafeMap.get(tag.key));
  });
  merge2 = /* @__PURE__ */ dual(2, (self, that) => {
    const map4 = new Map(self.unsafeMap);
    for (const [tag, s] of that.unsafeMap) {
      map4.set(tag, s);
    }
    return makeContext(map4);
  });
});

// ../../node_modules/effect/dist/esm/Context.js
var exports_Context = {};
__export(exports_Context, {
  unsafeMake: () => unsafeMake,
  unsafeGet: () => unsafeGet3,
  pick: () => pick2,
  omit: () => omit2,
  mergeAll: () => mergeAll2,
  merge: () => merge3,
  make: () => make6,
  isTag: () => isTag2,
  isReference: () => isReference2,
  isContext: () => isContext2,
  getOrElse: () => getOrElse3,
  getOption: () => getOption2,
  get: () => get3,
  empty: () => empty4,
  add: () => add2,
  Tag: () => Tag2,
  Reference: () => Reference2,
  GenericTag: () => GenericTag
});
var GenericTag, unsafeMake, isContext2, isTag2, isReference2, empty4, make6, add2, get3, getOrElse3, unsafeGet3, getOption2, merge3, mergeAll2, pick2, omit2, Tag2, Reference2;
var init_Context = __esm(() => {
  init_context();
  GenericTag = makeGenericTag;
  unsafeMake = makeContext;
  isContext2 = isContext;
  isTag2 = isTag;
  isReference2 = isReference;
  empty4 = empty3;
  make6 = make5;
  add2 = add;
  get3 = get2;
  getOrElse3 = getOrElse2;
  unsafeGet3 = unsafeGet2;
  getOption2 = getOption;
  merge3 = merge2;
  mergeAll2 = mergeAll;
  pick2 = pick;
  omit2 = omit;
  Tag2 = Tag;
  Reference2 = Reference;
});

// ../../node_modules/effect/dist/esm/Chunk.js
var exports_Chunk = {};
__export(exports_Chunk, {
  zipWith: () => zipWith3,
  zip: () => zip2,
  unzip: () => unzip2,
  unsafeLast: () => unsafeLast,
  unsafeHead: () => unsafeHead2,
  unsafeGet: () => unsafeGet4,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeFromArray: () => unsafeFromArray,
  union: () => union2,
  toReadonlyArray: () => toReadonlyArray,
  toArray: () => toArray2,
  takeWhile: () => takeWhile,
  takeRight: () => takeRight,
  take: () => take,
  tailNonEmpty: () => tailNonEmpty2,
  tail: () => tail,
  splitWhere: () => splitWhere,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitAt: () => splitAt2,
  split: () => split,
  sortWith: () => sortWith,
  sort: () => sort2,
  some: () => some3,
  size: () => size,
  separate: () => separate2,
  reverse: () => reverse2,
  replaceOption: () => replaceOption,
  replace: () => replace,
  removeOption: () => removeOption,
  remove: () => remove2,
  reduceRight: () => reduceRight2,
  reduce: () => reduce3,
  range: () => range,
  prependAll: () => prependAll,
  prepend: () => prepend2,
  partitionMap: () => partitionMap3,
  partition: () => partition2,
  of: () => of2,
  modifyOption: () => modifyOption,
  modify: () => modify2,
  mapAccum: () => mapAccum2,
  map: () => map4,
  makeBy: () => makeBy2,
  make: () => make7,
  lastNonEmpty: () => lastNonEmpty2,
  last: () => last2,
  join: () => join2,
  isNonEmpty: () => isNonEmpty2,
  isEmpty: () => isEmpty,
  isChunk: () => isChunk,
  intersection: () => intersection2,
  headNonEmpty: () => headNonEmpty2,
  head: () => head2,
  getEquivalence: () => getEquivalence3,
  get: () => get4,
  fromIterable: () => fromIterable3,
  forEach: () => forEach,
  flatten: () => flatten4,
  flatMap: () => flatMap3,
  findLastIndex: () => findLastIndex2,
  findLast: () => findLast2,
  findFirstIndex: () => findFirstIndex2,
  findFirst: () => findFirst3,
  filterMapWhile: () => filterMapWhile2,
  filterMap: () => filterMap3,
  filter: () => filter3,
  every: () => every2,
  empty: () => empty5,
  dropWhile: () => dropWhile,
  dropRight: () => dropRight,
  drop: () => drop2,
  differenceWith: () => differenceWith2,
  difference: () => difference2,
  dedupeAdjacent: () => dedupeAdjacent2,
  dedupe: () => dedupe2,
  containsWith: () => containsWith3,
  contains: () => contains3,
  compact: () => compact,
  chunksOf: () => chunksOf,
  appendAll: () => appendAll2,
  append: () => append2
});
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var TypeId6, emptyArray, getEquivalence3 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet4(that, i)))), _equivalence3, ChunkProto, makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
}, isChunk = (u) => hasProperty(u, TypeId6), _empty2, empty5 = () => _empty2, make7 = (...as2) => unsafeFromNonEmptyArray(as2), of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
}), fromIterable3 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable2(self)), copyToArray = (self, array4, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array4, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array4, initial);
      copyToArray(self.right, array4, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array4[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array4[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
}, toArray_ = (self) => toReadonlyArray(self).slice(), toArray2, toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
}, toReadonlyArray, reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
}, reverse2, get4, unsafeFromArray = (self) => self.length === 0 ? empty5() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
}), unsafeFromNonEmptyArray = (self) => unsafeFromArray(self), unsafeGet4, append2, prepend2, take, drop2, dropRight, dropWhile, prependAll, appendAll2, filterMap3, filter3, filterMapWhile2, compact = (self) => filterMap3(self, identity), flatMap3, forEach, flatten4, chunksOf, intersection2, isEmpty = (self) => self.length === 0, isNonEmpty2 = (self) => self.length > 0, head2, unsafeHead2 = (self) => unsafeGet4(self, 0), headNonEmpty2, last2 = (self) => get4(self, self.length - 1), unsafeLast = (self) => unsafeGet4(self, self.length - 1), lastNonEmpty2, map4, mapAccum2, partition2, partitionMap3, separate2 = (self) => pipe(separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]), size = (self) => self.length, sort2, sortWith, splitAt2, splitNonEmptyAt2, split, splitWhere, tail = (self) => self.length > 0 ? some2(drop2(self, 1)) : none2(), tailNonEmpty2 = (self) => drop2(self, 1), takeRight, takeWhile, union2, dedupe2 = (self) => unsafeFromArray(dedupe(toReadonlyArray(self))), dedupeAdjacent2 = (self) => unsafeFromArray(dedupeAdjacent(self)), unzip2 = (self) => {
  const [left3, right3] = unzip(self);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
}, zipWith3, zip2, remove2, removeOption, modifyOption, modify2, replace, replaceOption, makeBy2, range = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : of2(start), contains3, containsWith3, findFirst3, findFirstIndex2, findLast2, findLastIndex2, every2, some3, join2, reduce3, reduceRight2, differenceWith2 = (isEquivalent) => {
  return dual(2, (self, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self)));
}, difference2;
var init_Chunk = __esm(() => {
  init_Array();
  init_Equal();
  init_Equivalence();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Order();
  init_Pipeable();
  init_Predicate();
  TypeId6 = /* @__PURE__ */ Symbol.for("effect/Chunk");
  emptyArray = [];
  _equivalence3 = /* @__PURE__ */ getEquivalence3(equals);
  ChunkProto = {
    [TypeId6]: {
      _A: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Chunk",
        values: toReadonlyArray(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isChunk(that) && _equivalence3(this, that);
    },
    [symbol]() {
      return cached(this, array2(toReadonlyArray(this)));
    },
    [Symbol.iterator]() {
      switch (this.backing._tag) {
        case "IArray": {
          return this.backing.array[Symbol.iterator]();
        }
        case "IEmpty": {
          return emptyArray[Symbol.iterator]();
        }
        default: {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
      }
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  _empty2 = /* @__PURE__ */ makeChunk({
    _tag: "IEmpty"
  });
  toArray2 = toArray_;
  toReadonlyArray = toReadonlyArray_;
  reverse2 = reverseChunk;
  get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
  unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
    switch (self.backing._tag) {
      case "IEmpty": {
        throw new Error(`Index out of bounds`);
      }
      case "ISingleton": {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.a;
      }
      case "IArray": {
        if (index >= self.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.array[index];
      }
      case "IConcat": {
        return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
      }
      case "ISlice": {
        return unsafeGet4(self.backing.chunk, index + self.backing.offset);
      }
    }
  });
  append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
  prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
  take = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return _empty2;
    } else if (n >= self.length) {
      return self;
    } else {
      switch (self.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            length: n,
            offset: self.backing.offset
          });
        }
        case "IConcat": {
          if (n > self.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self.left,
              right: take(self.right, n - self.left.length)
            });
          }
          return take(self.left, n);
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: 0,
            length: n
          });
        }
      }
    }
  });
  drop2 = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return self;
    } else if (n >= self.length) {
      return _empty2;
    } else {
      switch (self.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            offset: self.backing.offset + n,
            length: self.backing.length - n
          });
        }
        case "IConcat": {
          if (n > self.left.length) {
            return drop2(self.right, n - self.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop2(self.left, n),
            right: self.right
          });
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: n,
            length: self.length - n
          });
        }
      }
    }
  });
  dropRight = /* @__PURE__ */ dual(2, (self, n) => take(self, Math.max(0, self.length - n)));
  dropWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
    const arr = toReadonlyArray(self);
    const len = arr.length;
    let i = 0;
    while (i < len && predicate(arr[i])) {
      i++;
    }
    return drop2(self, i);
  });
  prependAll = /* @__PURE__ */ dual(2, (self, that) => appendAll2(that, self));
  appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self.backing._tag === "IEmpty") {
      return that;
    }
    if (that.backing._tag === "IEmpty") {
      return self;
    }
    const diff = that.depth - self.depth;
    if (Math.abs(diff) <= 1) {
      return makeChunk({
        _tag: "IConcat",
        left: self,
        right: that
      });
    } else if (diff < -1) {
      if (self.left.depth >= self.right.depth) {
        const nr = appendAll2(self.right, that);
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nrr = appendAll2(self.right.right, that);
        if (nrr.depth === self.depth - 3) {
          const nr = makeChunk({
            _tag: "IConcat",
            left: self.right.left,
            right: nrr
          });
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: nr
          });
        } else {
          const nl = makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: self.right.left
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: nrr
          });
        }
      }
    } else {
      if (that.right.depth >= that.left.depth) {
        const nl = appendAll2(self, that.left);
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nll = appendAll2(self, that.left.left);
        if (nll.depth === that.depth - 3) {
          const nl = makeChunk({
            _tag: "IConcat",
            left: nll,
            right: that.left.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
          });
        } else {
          const nr = makeChunk({
            _tag: "IConcat",
            left: that.left.right,
            right: that.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nll,
            right: nr
          });
        }
      }
    }
  });
  filterMap3 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMap2(self, f)));
  filter3 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter2(self, predicate)));
  filterMapWhile2 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMapWhile(self, f)));
  flatMap3 = /* @__PURE__ */ dual(2, (self, f) => {
    if (self.backing._tag === "ISingleton") {
      return f(self.backing.a, 0);
    }
    let out = _empty2;
    let i = 0;
    for (const k of self) {
      out = appendAll2(out, f(k, i++));
    }
    return out;
  });
  forEach = /* @__PURE__ */ dual(2, (self, f) => toReadonlyArray(self).forEach(f));
  flatten4 = /* @__PURE__ */ flatMap3(identity);
  chunksOf = /* @__PURE__ */ dual(2, (self, n) => {
    const gr = [];
    let current = [];
    toReadonlyArray(self).forEach((a) => {
      current.push(a);
      if (current.length >= n) {
        gr.push(unsafeFromArray(current));
        current = [];
      }
    });
    if (current.length > 0) {
      gr.push(unsafeFromArray(current));
    }
    return unsafeFromArray(gr);
  });
  intersection2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(intersection(toReadonlyArray(self), toReadonlyArray(that))));
  head2 = /* @__PURE__ */ get4(0);
  headNonEmpty2 = unsafeHead2;
  lastNonEmpty2 = unsafeLast;
  map4 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
  mapAccum2 = /* @__PURE__ */ dual(3, (self, s, f) => {
    const [s1, as2] = mapAccum(self, s, f);
    return [s1, unsafeFromArray(as2)];
  });
  partition2 = /* @__PURE__ */ dual(2, (self, predicate) => pipe(partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
  partitionMap3 = /* @__PURE__ */ dual(2, (self, f) => pipe(partitionMap2(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
  sort2 = /* @__PURE__ */ dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
  sortWith = /* @__PURE__ */ dual(3, (self, f, order) => sort2(self, mapInput2(order, f)));
  splitAt2 = /* @__PURE__ */ dual(2, (self, n) => [take(self, n), drop2(self, n)]);
  splitNonEmptyAt2 = /* @__PURE__ */ dual(2, (self, n) => {
    const _n = Math.max(1, Math.floor(n));
    return _n >= self.length ? [self, empty5()] : [take(self, _n), drop2(self, _n)];
  });
  split = /* @__PURE__ */ dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));
  splitWhere = /* @__PURE__ */ dual(2, (self, predicate) => {
    let i = 0;
    for (const a of toReadonlyArray(self)) {
      if (predicate(a)) {
        break;
      } else {
        i++;
      }
    }
    return splitAt2(self, i);
  });
  takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
  takeWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
    const out = [];
    for (const a of toReadonlyArray(self)) {
      if (predicate(a)) {
        out.push(a);
      } else {
        break;
      }
    }
    return unsafeFromArray(out);
  });
  union2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(union(toReadonlyArray(self), toReadonlyArray(that))));
  zipWith3 = /* @__PURE__ */ dual(3, (self, that, f) => unsafeFromArray(zipWith2(self, that, f)));
  zip2 = /* @__PURE__ */ dual(2, (self, that) => zipWith3(self, that, (a, b) => [a, b]));
  remove2 = /* @__PURE__ */ dual(2, (self, i) => {
    if (i < 0 || i >= self.length)
      return self;
    return unsafeFromArray(remove(toReadonlyArray(self), i));
  });
  removeOption = /* @__PURE__ */ dual(2, (self, i) => {
    if (i < 0 || i >= self.length)
      return none2();
    return some2(unsafeFromArray(remove(toReadonlyArray(self), i)));
  });
  modifyOption = /* @__PURE__ */ dual(3, (self, i, f) => {
    if (i < 0 || i >= self.length)
      return none2();
    return some2(unsafeFromArray(modify(toReadonlyArray(self), i, f)));
  });
  modify2 = /* @__PURE__ */ dual(3, (self, i, f) => getOrElse(modifyOption(self, i, f), () => self));
  replace = /* @__PURE__ */ dual(3, (self, i, b) => modify2(self, i, () => b));
  replaceOption = /* @__PURE__ */ dual(3, (self, i, b) => modifyOption(self, i, () => b));
  makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable3(makeBy(n, f)));
  contains3 = contains2;
  containsWith3 = containsWith2;
  findFirst3 = findFirst2;
  findFirstIndex2 = findFirstIndex;
  findLast2 = findLast;
  findLastIndex2 = findLastIndex;
  every2 = /* @__PURE__ */ dual(2, (self, refinement) => fromIterable2(self).every(refinement));
  some3 = /* @__PURE__ */ dual(2, (self, predicate) => fromIterable2(self).some(predicate));
  join2 = join;
  reduce3 = reduce;
  reduceRight2 = reduceRight;
  difference2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(difference(that, self)));
});

// ../../node_modules/effect/dist/esm/Duration.js
var TypeId7, bigint02, bigint24, bigint60, bigint1e3, bigint1e6, bigint1e9, DURATION_REGEX, decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match4 = DURATION_REGEX.exec(input);
    if (match4) {
      const [_, valueStr, unit] = match4;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
}, zeroValue, infinityValue, DurationProto, make8 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint02) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
}, isDuration = (u) => hasProperty(u, TypeId7), isZero2 = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint02;
    }
    case "Infinity": {
      return false;
    }
  }
}, zero2, infinity, nanos = (nanos2) => make8(nanos2), micros = (micros2) => make8(micros2 * bigint1e3), millis = (millis2) => make8(millis2), seconds = (seconds2) => make8(seconds2 * 1000), minutes = (minutes2) => make8(minutes2 * 60000), hours = (hours2) => make8(hours2 * 3600000), days = (days2) => make8(days2 * 86400000), weeks = (weeks2) => make8(weeks2 * 604800000), toMillis = (self) => match4(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
}), unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
}, toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
}, match4, matchWith, Equivalence2 = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
}), times, sum, lessThan2, lessThanOrEqualTo2, greaterThan2, greaterThanOrEqualTo2, equals3, parts = (self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min2 = sec / bigint60;
  const hr = min2 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min2 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
}, format3 = (self) => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};
var init_Duration = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Order();
  init_Pipeable();
  init_Predicate();
  TypeId7 = /* @__PURE__ */ Symbol.for("effect/Duration");
  bigint02 = /* @__PURE__ */ BigInt(0);
  bigint24 = /* @__PURE__ */ BigInt(24);
  bigint60 = /* @__PURE__ */ BigInt(60);
  bigint1e3 = /* @__PURE__ */ BigInt(1000);
  bigint1e6 = /* @__PURE__ */ BigInt(1e6);
  bigint1e9 = /* @__PURE__ */ BigInt(1e9);
  DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
  zeroValue = {
    _tag: "Millis",
    millis: 0
  };
  infinityValue = {
    _tag: "Infinity"
  };
  DurationProto = {
    [TypeId7]: TypeId7,
    [symbol]() {
      return cached(this, structure(this.value));
    },
    [symbol2](that) {
      return isDuration(that) && equals3(this, that);
    },
    toString() {
      return `Duration(${format3(this)})`;
    },
    toJSON() {
      switch (this.value._tag) {
        case "Millis":
          return {
            _id: "Duration",
            _tag: "Millis",
            millis: this.value.millis
          };
        case "Nanos":
          return {
            _id: "Duration",
            _tag: "Nanos",
            hrtime: toHrTime(this)
          };
        case "Infinity":
          return {
            _id: "Duration",
            _tag: "Infinity"
          };
      }
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  zero2 = /* @__PURE__ */ make8(0);
  infinity = /* @__PURE__ */ make8(Infinity);
  match4 = /* @__PURE__ */ dual(2, (self, options) => {
    const _self = decode(self);
    switch (_self.value._tag) {
      case "Nanos":
        return options.onNanos(_self.value.nanos);
      case "Infinity":
        return options.onMillis(Infinity);
      case "Millis":
        return options.onMillis(_self.value.millis);
    }
  });
  matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
    const _self = decode(self);
    const _that = decode(that);
    if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
      return options.onMillis(toMillis(_self), toMillis(_that));
    } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
      const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
      const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
      return options.onNanos(selfNanos, thatNanos);
    }
    return options.onMillis(_self.value.millis, _that.value.millis);
  });
  times = /* @__PURE__ */ dual(2, (self, times2) => match4(self, {
    onMillis: (millis2) => make8(millis2 * times2),
    onNanos: (nanos2) => make8(nanos2 * BigInt(times2))
  }));
  sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => make8(self2 + that2),
    onNanos: (self2, that2) => make8(self2 + that2)
  }));
  lessThan2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 < that2,
    onNanos: (self2, that2) => self2 < that2
  }));
  lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 <= that2,
    onNanos: (self2, that2) => self2 <= that2
  }));
  greaterThan2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 > that2,
    onNanos: (self2, that2) => self2 > that2
  }));
  greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 >= that2,
    onNanos: (self2, that2) => self2 >= that2
  }));
  equals3 = /* @__PURE__ */ dual(2, (self, that) => Equivalence2(decode(self), decode(that)));
});

// ../../node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5, BUCKET_SIZE, MASK, MAX_INDEX_NODE, MIN_ARRAY_NODE;
var init_config = __esm(() => {
  BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
  MASK = BUCKET_SIZE - 1;
  MAX_INDEX_NODE = BUCKET_SIZE / 2;
  MIN_ARRAY_NODE = BUCKET_SIZE / 4;
});

// ../../node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h2) {
  return h2 >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
var init_bitwise = __esm(() => {
  init_config();
});

// ../../node_modules/effect/dist/esm/internal/stack.js
var make9 = (value, previous) => ({
  value,
  previous
});

// ../../node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0;i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// ../../node_modules/effect/dist/esm/internal/hashMap/node.js
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size2) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode;
    ++size2.value;
    return new LeafNode(edit, hash2, key, v);
  }
}
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size2) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size2.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size2.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size2) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size2);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size2.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size2) {
    const len = list.length;
    for (let i = 0;i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size2.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size2.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size2) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists2 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists2) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size2);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size2);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size2, children) {
    this.edit = edit;
    this.size = size2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size2) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size2);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length;i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0;bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
var init_node = __esm(() => {
  init_Equal();
  init_Option();
  init_Predicate();
  init_bitwise();
  init_config();
});

// ../../node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap", HashMapTypeId, HashMapProto, makeImpl = (editable, edit, root, size2) => {
  const map5 = Object.create(HashMapProto);
  map5._editable = editable;
  map5._edit = edit;
  map5._root = root;
  map5._size = size2;
  return map5;
}, HashMapIterator, applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2(), visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}, visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
}, _empty3, empty6 = () => _empty3, make10 = (...entries) => fromIterable4(entries), fromIterable4 = (entries) => {
  const map5 = beginMutation(empty6());
  for (const entry of entries) {
    set(map5, entry[0], entry[1]);
  }
  return endMutation(map5);
}, isHashMap = (u) => hasProperty(u, HashMapTypeId), isEmpty2 = (self) => self && isEmptyNode(self._root), get5, getHash, unsafeGet5, has, hasHash, hasBy, set, setTree, keys = (self) => new HashMapIterator(self, (key) => key), values = (self) => new HashMapIterator(self, (_, value) => value), entries = (self) => new HashMapIterator(self, (key, value) => [key, value]), size2 = (self) => self._size, beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size), endMutation = (self) => {
  self._editable = false;
  return self;
}, mutate, modifyAt, modifyHash, modify3, union3, remove3, removeMany, map5, flatMap4, forEach2, reduce4, filter4, compact2 = (self) => filterMap4(self, identity), filterMap4, findFirst4, some4, every3;
var init_hashMap = __esm(() => {
  init_Equal();
  init_Function();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_bitwise();
  init_config();
  init_node();
  HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
  HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator]() {
      return new HashMapIterator(this, (k, v) => [k, v]);
    },
    [symbol]() {
      let hash2 = hash(HashMapSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
      }
      return cached(this, hash2);
    },
    [symbol2](that) {
      if (isHashMap(that)) {
        if (that._size !== this._size) {
          return false;
        }
        for (const item of this) {
          const elem = pipe(that, getHash(item[0], hash(item[0])));
          if (isNone2(elem)) {
            return false;
          } else {
            if (!equals(item[1], elem.value)) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  HashMapIterator = class HashMapIterator {
    map;
    f;
    v;
    constructor(map5, f) {
      this.map = map5;
      this.f = f;
      this.v = visitLazy(this.map._root, this.f, undefined);
    }
    next() {
      if (isNone2(this.v)) {
        return {
          done: true,
          value: undefined
        };
      }
      const v0 = this.v.value;
      this.v = applyCont(v0.cont);
      return {
        done: false,
        value: v0.value
      };
    }
    [Symbol.iterator]() {
      return new HashMapIterator(this.map, this.f);
    }
  };
  _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
  get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
  getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
    let node = self._root;
    let shift = 0;
    while (true) {
      switch (node._tag) {
        case "LeafNode": {
          return equals(key, node.key) ? node.value : none2();
        }
        case "CollisionNode": {
          if (hash2 === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length;i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals(key, child.key)) {
                return child.value;
              }
            }
          }
          return none2();
        }
        case "IndexedNode": {
          const frag = hashFragment(shift, hash2);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return none2();
        }
        case "ArrayNode": {
          node = node.children[hashFragment(shift, hash2)];
          if (node) {
            shift += SIZE;
            break;
          }
          return none2();
        }
        default:
          return none2();
      }
    }
  });
  unsafeGet5 = /* @__PURE__ */ dual(2, (self, key) => {
    const element = getHash(self, key, hash(key));
    if (isNone2(element)) {
      throw new Error("Expected map to contain key");
    }
    return element.value;
  });
  has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
  hasHash = /* @__PURE__ */ dual(3, (self, key, hash2) => isSome2(getHash(self, key, hash2)));
  hasBy = /* @__PURE__ */ dual(2, (self, predicate) => isSome2(findFirst4(self, predicate)));
  set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
  setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
    if (self._editable) {
      self._root = newRoot;
      self._size = newSize;
      return self;
    }
    return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
  });
  mutate = /* @__PURE__ */ dual(2, (self, f) => {
    const transient = beginMutation(self);
    f(transient);
    return endMutation(transient);
  });
  modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
  modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
    const size3 = {
      value: self._size
    };
    const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size3);
    return pipe(self, setTree(newRoot, size3.value));
  });
  modify3 = /* @__PURE__ */ dual(3, (self, key, f) => modifyAt(self, key, map2(f)));
  union3 = /* @__PURE__ */ dual(2, (self, that) => {
    const result = beginMutation(self);
    forEach2(that, (v, k) => set(result, k, v));
    return endMutation(result);
  });
  remove3 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
  removeMany = /* @__PURE__ */ dual(2, (self, keys2) => mutate(self, (map5) => {
    for (const key of keys2) {
      remove3(key)(map5);
    }
  }));
  map5 = /* @__PURE__ */ dual(2, (self, f) => reduce4(self, empty6(), (map6, value, key) => set(map6, key, f(value, key))));
  flatMap4 = /* @__PURE__ */ dual(2, (self, f) => reduce4(self, empty6(), (zero3, value, key) => mutate(zero3, (map6) => forEach2(f(value, key), (value2, key2) => set(map6, key2, value2)))));
  forEach2 = /* @__PURE__ */ dual(2, (self, f) => reduce4(self, undefined, (_, value, key) => f(value, key)));
  reduce4 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
    const root = self._root;
    if (root._tag === "LeafNode") {
      return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
    }
    if (root._tag === "EmptyNode") {
      return zero3;
    }
    const toVisit = [root.children];
    let children;
    while (children = toVisit.pop()) {
      for (let i = 0, len = children.length;i < len; ) {
        const child = children[i++];
        if (child && !isEmptyNode(child)) {
          if (child._tag === "LeafNode") {
            if (isSome2(child.value)) {
              zero3 = f(zero3, child.value.value, child.key);
            }
          } else {
            toVisit.push(child.children);
          }
        }
      }
    }
    return zero3;
  });
  filter4 = /* @__PURE__ */ dual(2, (self, f) => mutate(empty6(), (map6) => {
    for (const [k, a] of self) {
      if (f(a, k)) {
        set(map6, k, a);
      }
    }
  }));
  filterMap4 = /* @__PURE__ */ dual(2, (self, f) => mutate(empty6(), (map6) => {
    for (const [k, a] of self) {
      const option = f(a, k);
      if (isSome2(option)) {
        set(map6, k, option.value);
      }
    }
  }));
  findFirst4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    for (const ka of self) {
      if (predicate(ka[1], ka[0])) {
        return some2(ka);
      }
    }
    return none2();
  });
  some4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    for (const ka of self) {
      if (predicate(ka[1], ka[0])) {
        return true;
      }
    }
    return false;
  });
  every3 = /* @__PURE__ */ dual(2, (self, predicate) => !some4(self, (a, k) => !predicate(a, k)));
});

// ../../node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet", HashSetTypeId, HashSetProto, makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
}, isHashSet = (u) => hasProperty(u, HashSetTypeId), _empty4, empty7 = () => _empty4, fromIterable5 = (elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
}, make11 = (...elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
}, has2, some5, every4, size3 = (self) => size2(self._keyMap), beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap)), endMutation2 = (self) => {
  self._keyMap._editable = false;
  return self;
}, mutate2, add3, remove4, difference3, union4, forEach3, reduce5;
var init_hashSet = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Pipeable();
  init_Predicate();
  init_hashMap();
  HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
  HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator]() {
      return keys(this._keyMap);
    },
    [symbol]() {
      return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
    },
    [symbol2](that) {
      if (isHashSet(that)) {
        return size2(this._keyMap) === size2(that._keyMap) && equals(this._keyMap, that._keyMap);
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
  has2 = /* @__PURE__ */ dual(2, (self, value) => has(self._keyMap, value));
  some5 = /* @__PURE__ */ dual(2, (self, f) => {
    let found = false;
    for (const value of self) {
      found = f(value);
      if (found) {
        break;
      }
    }
    return found;
  });
  every4 = /* @__PURE__ */ dual(2, (self, refinement) => !some5(self, (a) => !refinement(a)));
  mutate2 = /* @__PURE__ */ dual(2, (self, f) => {
    const transient = beginMutation2(self);
    f(transient);
    return endMutation2(transient);
  });
  add3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
  remove4 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (remove3(value)(self._keyMap), self) : makeImpl2(remove3(value)(self._keyMap)));
  difference3 = /* @__PURE__ */ dual(2, (self, that) => mutate2(self, (set2) => {
    for (const value of that) {
      remove4(set2, value);
    }
  }));
  union4 = /* @__PURE__ */ dual(2, (self, that) => mutate2(empty7(), (set2) => {
    forEach3(self, (value) => add3(set2, value));
    for (const value of that) {
      add3(set2, value);
    }
  }));
  forEach3 = /* @__PURE__ */ dual(2, (self, f) => forEach2(self._keyMap, (_, k) => f(k)));
  reduce5 = /* @__PURE__ */ dual(3, (self, zero3, f) => reduce4(self._keyMap, zero3, (z, _, a) => f(z, a)));
});

// ../../node_modules/effect/dist/esm/HashSet.js
var empty8, fromIterable6, make12, has3, every5, size4, add4, remove5, difference4, union5, forEach4, reduce6;
var init_HashSet = __esm(() => {
  init_hashSet();
  empty8 = empty7;
  fromIterable6 = fromIterable5;
  make12 = make11;
  has3 = has2;
  every5 = every4;
  size4 = size3;
  add4 = add3;
  remove5 = remove4;
  difference4 = difference3;
  union5 = union4;
  forEach4 = forEach3;
  reduce6 = reduce5;
});

// ../../node_modules/effect/dist/esm/MutableRef.js
var TypeId8, MutableRefProto, make13 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
}, compareAndSet, get6 = (self) => self.current, set2;
var init_MutableRef = __esm(() => {
  init_Equal();
  init_Function();
  init_Inspectable();
  init_Pipeable();
  TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
  MutableRefProto = {
    [TypeId8]: TypeId8,
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableRef",
        current: toJSON(this.current)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
    if (equals(oldValue, self.current)) {
      self.current = newValue;
      return true;
    }
    return false;
  });
  set2 = /* @__PURE__ */ dual(2, (self, value) => {
    self.current = value;
    return self;
  });
});

// ../../node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId", FiberIdTypeId, OP_NONE = "None", OP_RUNTIME = "Runtime", OP_COMPOSITE = "Composite", emptyHash, None, Runtime, Composite, none3, isFiberId = (self) => hasProperty(self, FiberIdTypeId), isNone3 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every5((id) => isNone3(id)));
}, combine2, combineAll2 = (fiberIds) => {
  return pipe(fiberIds, reduce6(none3, (a, b) => combine2(b)(a)));
}, getOrElse4, ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make12(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union5(ids(self.right)));
    }
  }
}, _fiberCounter, threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
}, toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make12(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union5(toSet(self.right)));
    }
  }
}, unsafeMake2 = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id + 1));
  return new Runtime(id, Date.now());
};
var init_fiberId = __esm(() => {
  init_Equal();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_HashSet();
  init_Inspectable();
  init_MutableRef();
  init_Option();
  init_Predicate();
  FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
  emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
  None = class None {
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_NONE;
    id = -1;
    startTimeMillis = -1;
    [symbol]() {
      return emptyHash;
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_NONE;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  Runtime = class Runtime {
    id;
    startTimeMillis;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_RUNTIME;
    constructor(id, startTimeMillis) {
      this.id = id;
      this.startTimeMillis = startTimeMillis;
    }
    [symbol]() {
      return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        id: this.id,
        startTimeMillis: this.startTimeMillis
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  Composite = class Composite {
    left;
    right;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_COMPOSITE;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    _hash;
    [symbol]() {
      return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        left: toJSON(this.left),
        right: toJSON(this.right)
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  none3 = /* @__PURE__ */ new None;
  combine2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self._tag === OP_NONE) {
      return that;
    }
    if (that._tag === OP_NONE) {
      return self;
    }
    return new Composite(self, that);
  });
  getOrElse4 = /* @__PURE__ */ dual(2, (self, that) => isNone3(self) ? that : self);
  _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
});

// ../../node_modules/effect/dist/esm/FiberId.js
var none4, combine3, combineAll3, getOrElse5, ids2, threadName2, unsafeMake3;
var init_FiberId = __esm(() => {
  init_fiberId();
  none4 = none3;
  combine3 = combine2;
  combineAll3 = combineAll2;
  getOrElse5 = getOrElse4;
  ids2 = ids;
  threadName2 = threadName;
  unsafeMake3 = unsafeMake2;
});

// ../../node_modules/effect/dist/esm/internal/hashMap/keySet.js
function keySet(self) {
  return makeImpl2(self);
}
var init_keySet = __esm(() => {
  init_hashSet();
});

// ../../node_modules/effect/dist/esm/HashMap.js
var exports_HashMap = {};
__export(exports_HashMap, {
  values: () => values3,
  unsafeGet: () => unsafeGet6,
  union: () => union6,
  toValues: () => toValues,
  toEntries: () => toEntries2,
  some: () => some6,
  size: () => size5,
  set: () => set3,
  removeMany: () => removeMany2,
  remove: () => remove6,
  reduce: () => reduce7,
  mutate: () => mutate3,
  modifyHash: () => modifyHash2,
  modifyAt: () => modifyAt2,
  modify: () => modify4,
  map: () => map7,
  make: () => make15,
  keys: () => keys2,
  keySet: () => keySet2,
  isHashMap: () => isHashMap2,
  isEmpty: () => isEmpty3,
  hasHash: () => hasHash2,
  hasBy: () => hasBy2,
  has: () => has4,
  getHash: () => getHash2,
  get: () => get7,
  fromIterable: () => fromIterable7,
  forEach: () => forEach5,
  flatMap: () => flatMap6,
  findFirst: () => findFirst5,
  filterMap: () => filterMap5,
  filter: () => filter6,
  every: () => every6,
  entries: () => entries2,
  endMutation: () => endMutation3,
  empty: () => empty9,
  compact: () => compact3,
  beginMutation: () => beginMutation3
});
var isHashMap2, empty9, make15, fromIterable7, isEmpty3, get7, getHash2, unsafeGet6, has4, hasHash2, hasBy2, set3, keys2, keySet2, values3, toValues = (self) => Array.from(values3(self)), entries2, toEntries2 = (self) => Array.from(entries2(self)), size5, beginMutation3, endMutation3, mutate3, modifyAt2, modifyHash2, modify4, union6, remove6, removeMany2, map7, flatMap6, forEach5, reduce7, filter6, compact3, filterMap5, findFirst5, some6, every6;
var init_HashMap = __esm(() => {
  init_hashMap();
  init_keySet();
  isHashMap2 = isHashMap;
  empty9 = empty6;
  make15 = make10;
  fromIterable7 = fromIterable4;
  isEmpty3 = isEmpty2;
  get7 = get5;
  getHash2 = getHash;
  unsafeGet6 = unsafeGet5;
  has4 = has;
  hasHash2 = hasHash;
  hasBy2 = hasBy;
  set3 = set;
  keys2 = keys;
  keySet2 = keySet;
  values3 = values;
  entries2 = entries;
  size5 = size2;
  beginMutation3 = beginMutation;
  endMutation3 = endMutation;
  mutate3 = mutate;
  modifyAt2 = modifyAt;
  modifyHash2 = modifyHash;
  modify4 = modify3;
  union6 = union3;
  remove6 = remove3;
  removeMany2 = removeMany;
  map7 = map5;
  flatMap6 = flatMap4;
  forEach5 = forEach2;
  reduce7 = reduce4;
  filter6 = filter4;
  compact3 = compact2;
  filterMap5 = filterMap4;
  findFirst5 = findFirst4;
  some6 = some4;
  every6 = every3;
});

// ../../node_modules/effect/dist/esm/List.js
var TypeId9, toArray3 = (self) => fromIterable2(self), getEquivalence4 = (isEquivalent) => mapInput(getEquivalence2(isEquivalent), toArray3), _equivalence4, ConsProto, makeCons = (head3, tail2) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail2;
  return cons;
}, NilHash, NilProto, _Nil, isList = (u) => hasProperty(u, TypeId9), isNil = (self) => self._tag === "Nil", isCons = (self) => self._tag === "Cons", nil = () => _Nil, cons = (head3, tail2) => makeCons(head3, tail2), empty10, of3 = (value) => makeCons(value, _Nil), appendAll3, prepend3, prependAll2, reduce8, reverse3 = (self) => {
  let result = empty10();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};
var init_List = __esm(() => {
  init_Array();
  init_Chunk();
  init_Either();
  init_Equal();
  init_Equivalence();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  TypeId9 = /* @__PURE__ */ Symbol.for("effect/List");
  _equivalence4 = /* @__PURE__ */ getEquivalence4(equals);
  ConsProto = {
    [TypeId9]: TypeId9,
    _tag: "Cons",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Cons",
        values: toArray3(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag && _equivalence4(this, that);
    },
    [symbol]() {
      return cached(this, array2(toArray3(this)));
    },
    [Symbol.iterator]() {
      let done = false;
      let self = this;
      return {
        next() {
          if (done) {
            return this.return();
          }
          if (self._tag === "Nil") {
            done = true;
            return this.return();
          }
          const value = self.head;
          self = self.tail;
          return {
            done,
            value
          };
        },
        return(value) {
          if (!done) {
            done = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  NilHash = /* @__PURE__ */ string("Nil");
  NilProto = {
    [TypeId9]: TypeId9,
    _tag: "Nil",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Nil"
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol]() {
      return NilHash;
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag;
    },
    [Symbol.iterator]() {
      return {
        next() {
          return {
            done: true,
            value: undefined
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  _Nil = /* @__PURE__ */ Object.create(NilProto);
  empty10 = nil;
  appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll2(that, self));
  prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
  prependAll2 = /* @__PURE__ */ dual(2, (self, prefix) => {
    if (isNil(self)) {
      return prefix;
    } else if (isNil(prefix)) {
      return self;
    } else {
      const result = makeCons(prefix.head, self);
      let curr = result;
      let that = prefix.tail;
      while (!isNil(that)) {
        const temp = makeCons(that.head, self);
        curr.tail = temp;
        curr = temp;
        that = that.tail;
      }
      return result;
    }
  });
  reduce8 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
    let acc = zero3;
    let these = self;
    while (!isNil(these)) {
      acc = f(acc, these.head);
      these = these.tail;
    }
    return acc;
  });
});

// ../../node_modules/effect/dist/esm/internal/data.js
var ArrayProto, Structural, struct = (as2) => Object.assign(Object.create(StructuralPrototype), as2);
var init_data = __esm(() => {
  init_Equal();
  init_Hash();
  init_effectable();
  ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
    [symbol]() {
      return cached(this, array2(this));
    },
    [symbol2](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => equals(v, that[i]));
      } else {
        return false;
      }
    }
  });
  Structural = /* @__PURE__ */ function() {
    function Structural2(args) {
      if (args) {
        Object.assign(this, args);
      }
    }
    Structural2.prototype = StructuralPrototype;
    return Structural2;
  }();
});

// ../../node_modules/effect/dist/esm/internal/differ/chunkPatch.js
function variance(a) {
  return a;
}
var ChunkPatchTypeId, PatchProto;
var init_chunkPatch = __esm(() => {
  init_Chunk();
  init_Equal();
  init_Function();
  init_Function();
  init_data();
  ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
  PatchProto = {
    ...Structural.prototype,
    [ChunkPatchTypeId]: {
      _Value: variance,
      _Patch: variance
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/differ/contextPatch.js
function variance2(a) {
  return a;
}
var ContextPatchTypeId, PatchProto2, EmptyProto, _empty5, empty11 = () => _empty5, AndThenProto, makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
}, AddServiceProto, makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
}, RemoveServiceProto, makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
}, UpdateServiceProto, makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
}, diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty11();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
}, combine4, patch;
var init_contextPatch = __esm(() => {
  init_Chunk();
  init_Equal();
  init_Function();
  init_context();
  init_data();
  ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
  PatchProto2 = {
    ...Structural.prototype,
    [ContextPatchTypeId]: {
      _Value: variance2,
      _Patch: variance2
    }
  };
  EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Empty"
  });
  _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
  AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "AndThen"
  });
  AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "AddService"
  });
  RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "RemoveService"
  });
  UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "UpdateService"
  });
  combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
  patch = /* @__PURE__ */ dual(2, (self, context) => {
    if (self._tag === "Empty") {
      return context;
    }
    let wasServiceUpdated = false;
    let patches = of2(self);
    const updatedContext = new Map(context.unsafeMap);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail2 = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail2;
          break;
        }
        case "AddService": {
          updatedContext.set(head3.key, head3.service);
          patches = tail2;
          break;
        }
        case "AndThen": {
          patches = prepend2(prepend2(tail2, head3.second), head3.first);
          break;
        }
        case "RemoveService": {
          updatedContext.delete(head3.key);
          patches = tail2;
          break;
        }
        case "UpdateService": {
          updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
          wasServiceUpdated = true;
          patches = tail2;
          break;
        }
      }
    }
    if (!wasServiceUpdated) {
      return makeContext(updatedContext);
    }
    const map8 = new Map;
    for (const [tag] of context.unsafeMap) {
      if (updatedContext.has(tag)) {
        map8.set(tag, updatedContext.get(tag));
        updatedContext.delete(tag);
      }
    }
    for (const [tag, s] of updatedContext) {
      map8.set(tag, s);
    }
    return makeContext(map8);
  });
});

// ../../node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
function variance3(a) {
  return a;
}
var HashMapPatchTypeId, PatchProto3;
var init_hashMapPatch = __esm(() => {
  init_Chunk();
  init_Equal();
  init_Function();
  init_HashMap();
  init_data();
  HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
  PatchProto3 = {
    ...Structural.prototype,
    [HashMapPatchTypeId]: {
      _Value: variance3,
      _Key: variance3,
      _Patch: variance3
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
function variance4(a) {
  return a;
}
var HashSetPatchTypeId, PatchProto4, EmptyProto2, _empty6, empty12 = () => _empty6, AndThenProto2, makeAndThen2 = (first, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first;
  o.second = second;
  return o;
}, AddProto, makeAdd = (value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
}, RemoveProto, makeRemove = (value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
}, diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce6([oldValue, empty12()], ([set4, patch3], value) => {
    if (has3(value)(set4)) {
      return [remove5(value)(set4), patch3];
    }
    return [set4, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce6(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
}, combine5, patch2;
var init_hashSetPatch = __esm(() => {
  init_Chunk();
  init_Function();
  init_HashSet();
  init_data();
  HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
  PatchProto4 = {
    ...Structural.prototype,
    [HashSetPatchTypeId]: {
      _Value: variance4,
      _Key: variance4,
      _Patch: variance4
    }
  };
  EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
    _tag: "Empty"
  });
  _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
  AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
    _tag: "AndThen"
  });
  AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
    _tag: "Add"
  });
  RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
    _tag: "Remove"
  });
  combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
  patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
    if (self._tag === "Empty") {
      return oldValue;
    }
    let set4 = oldValue;
    let patches = of2(self);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail2 = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail2;
          break;
        }
        case "AndThen": {
          patches = prepend2(head3.first)(prepend2(head3.second)(tail2));
          break;
        }
        case "Add": {
          set4 = add4(head3.value)(set4);
          patches = tail2;
          break;
        }
        case "Remove": {
          set4 = remove5(head3.value)(set4);
          patches = tail2;
        }
      }
    }
    return set4;
  });
});

// ../../node_modules/effect/dist/esm/internal/differ/orPatch.js
function variance5(a) {
  return a;
}
var OrPatchTypeId, PatchProto5;
var init_orPatch = __esm(() => {
  init_Chunk();
  init_Either();
  init_Equal();
  init_Function();
  init_data();
  OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
  PatchProto5 = {
    ...Structural.prototype,
    [OrPatchTypeId]: {
      _Value: variance5,
      _Key: variance5,
      _Patch: variance5
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
function variance6(a) {
  return a;
}
var ReadonlyArrayPatchTypeId, PatchProto6, EmptyProto3, _empty7, empty13 = () => _empty7, AndThenProto3, makeAndThen3 = (first, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first;
  o.second = second;
  return o;
}, AppendProto, makeAppend = (values4) => {
  const o = Object.create(AppendProto);
  o.values = values4;
  return o;
}, SliceProto, makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
}, UpdateProto, makeUpdate = (index, patch3) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch3;
  return o;
}, diff3 = (options) => {
  let i = 0;
  let patch3 = empty13();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
  }
  return patch3;
}, combine6, patch3;
var init_readonlyArrayPatch = __esm(() => {
  init_Array();
  init_Equal();
  init_Function();
  init_data();
  ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
  PatchProto6 = {
    ...Structural.prototype,
    [ReadonlyArrayPatchTypeId]: {
      _Value: variance6,
      _Patch: variance6
    }
  };
  EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
    _tag: "Empty"
  });
  _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
  AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
    _tag: "AndThen"
  });
  AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
    _tag: "Append"
  });
  SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
    _tag: "Slice"
  });
  UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
    _tag: "Update"
  });
  combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
  patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ) => {
    if (self._tag === "Empty") {
      return oldValue;
    }
    let readonlyArray = oldValue.slice();
    let patches = of(self);
    while (isNonEmptyArray2(patches)) {
      const head3 = headNonEmpty(patches);
      const tail2 = tailNonEmpty(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail2;
          break;
        }
        case "AndThen": {
          tail2.unshift(head3.first, head3.second);
          patches = tail2;
          break;
        }
        case "Append": {
          for (const value of head3.values) {
            readonlyArray.push(value);
          }
          patches = tail2;
          break;
        }
        case "Slice": {
          readonlyArray = readonlyArray.slice(head3.from, head3.until);
          patches = tail2;
          break;
        }
        case "Update": {
          readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
          patches = tail2;
          break;
        }
      }
    }
    return readonlyArray;
  });
});

// ../../node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId, DifferProto, make16 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
}, environment = () => make16({
  empty: empty11(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch7, oldValue) => patch(oldValue)(patch7)
}), hashSet = () => make16({
  empty: empty12(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch7, oldValue) => patch2(oldValue)(patch7)
}), readonlyArray = (differ) => make16({
  empty: empty13(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch7, oldValue) => patch3(patch7, oldValue, differ)
}), update = () => updateWith((_, a) => a), updateWith = (f) => make16({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch7, oldValue) => f(oldValue, patch7(oldValue))
});
var init_differ = __esm(() => {
  init_Equal();
  init_Function();
  init_Function();
  init_Pipeable();
  init_chunkPatch();
  init_contextPatch();
  init_hashMapPatch();
  init_hashSetPatch();
  init_orPatch();
  init_readonlyArrayPatch();
  DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
  DifferProto = {
    [DifferTypeId]: {
      _P: identity,
      _V: identity
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255, BIT_SHIFT = 8, active = (patch7) => patch7 & BIT_MASK, enabled = (patch7) => patch7 >> BIT_SHIFT & BIT_MASK, make17 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT), empty17, enable = (flag) => make17(flag, flag), disable = (flag) => make17(flag, 0), exclude, andThen2, invert = (n) => ~n >>> 0 & BIT_MASK;
var init_runtimeFlagsPatch = __esm(() => {
  init_Function();
  empty17 = /* @__PURE__ */ make17(0, 0);
  exclude = /* @__PURE__ */ dual(2, (self, flag) => make17(active(self) & ~flag, enabled(self)));
  andThen2 = /* @__PURE__ */ dual(2, (self, that) => self | that);
});

// ../../node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding, cooperativeYielding = (self) => isEnabled(self, CooperativeYielding), disable2, enable2, interruptible = (self) => interruption(self) && !windDown(self), interruption = (self) => isEnabled(self, Interruption), isEnabled, make18 = (...flags) => flags.reduce((a, b) => a | b, 0), none5, runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics), windDown = (self) => isEnabled(self, WindDown), diff7, patch7, differ;
var init_runtimeFlags = __esm(() => {
  init_Function();
  init_differ();
  init_runtimeFlagsPatch();
  Interruption = 1 << 0;
  OpSupervision = 1 << 1;
  RuntimeMetrics = 1 << 2;
  WindDown = 1 << 4;
  CooperativeYielding = 1 << 5;
  disable2 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
  enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
  isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
  none5 = /* @__PURE__ */ make18(None2);
  diff7 = /* @__PURE__ */ dual(2, (self, that) => make17(self ^ that, that));
  patch7 = /* @__PURE__ */ dual(2, (self, patch8) => self & (invert(active(patch8)) | enabled(patch8)) | active(patch8) & enabled(patch8));
  differ = /* @__PURE__ */ make16({
    empty: empty17,
    diff: (oldValue, newValue) => diff7(oldValue, newValue),
    combine: (first, second) => andThen2(second)(first),
    patch: (_patch, oldValue) => patch7(oldValue, _patch)
  });
});

// ../../node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty18, enable3, disable3, exclude2;
var init_RuntimeFlagsPatch = __esm(() => {
  init_runtimeFlags();
  init_runtimeFlagsPatch();
  empty18 = empty17;
  enable3 = enable;
  disable3 = disable;
  exclude2 = exclude;
});

// ../../node_modules/effect/dist/esm/internal/blockedRequests.js
var empty19, par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
}), seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
}), single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
}), flatten5 = (self) => {
  let current = of3(self);
  let updated = empty10();
  while (true) {
    const [parallel, sequential] = reduce8(current, [parallelCollectionEmpty(), empty10()], ([parallel2, sequential2], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
    });
    updated = merge4(updated, parallel);
    if (isNil(sequential)) {
      return reverse3(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
}, step = (requests) => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty10();
  let sequential = empty10();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential = cons(right3, sequential);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel = parallelCollectionAdd(parallel, current);
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
}, merge4 = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of3(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
}, EntryTypeId, EntryImpl, blockedRequestVariance, makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state), RequestBlockParallelTypeId, parallelVariance, ParallelImpl, parallelCollectionEmpty = () => new ParallelImpl(empty9()), parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest)))), parallelCollectionCombine = (self, that) => new ParallelImpl(reduce7(self.map, that.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
})))), parallelCollectionIsEmpty = (self) => isEmpty3(self.map), parallelCollectionKeys = (self) => Array.from(keys2(self.map)), parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map7(self.map, (x) => of2(x))), SequentialCollectionTypeId, sequentialVariance, SequentialImpl, sequentialCollectionMake = (map8) => new SequentialImpl(map8), sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce7(that.map, self.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value)
})))), sequentialCollectionKeys = (self) => Array.from(keys2(self.map)), sequentialCollectionToChunk = (self) => Array.from(self.map);
var init_blockedRequests = __esm(() => {
  init_Chunk();
  init_Either();
  init_Equal();
  init_HashMap();
  init_List();
  init_Option();
  init_Predicate();
  empty19 = {
    _tag: "Empty"
  };
  EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
  EntryImpl = class EntryImpl {
    request;
    result;
    listeners;
    ownerId;
    state;
    [EntryTypeId] = blockedRequestVariance;
    constructor(request, result, listeners, ownerId, state) {
      this.request = request;
      this.result = result;
      this.listeners = listeners;
      this.ownerId = ownerId;
      this.state = state;
    }
  };
  blockedRequestVariance = {
    _R: (_) => _
  };
  RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
  parallelVariance = {
    _R: (_) => _
  };
  ParallelImpl = class ParallelImpl {
    map;
    [RequestBlockParallelTypeId] = parallelVariance;
    constructor(map8) {
      this.map = map8;
    }
  };
  SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
  sequentialVariance = {
    _R: (_) => _
  };
  SequentialImpl = class SequentialImpl {
    map;
    [SequentialCollectionTypeId] = sequentialVariance;
    constructor(map8) {
      this.map = map8;
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die", OP_EMPTY = "Empty", OP_FAIL = "Fail", OP_INTERRUPT = "Interrupt", OP_PARALLEL = "Parallel", OP_SEQUENTIAL = "Sequential";

// ../../node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause", CauseTypeId, variance7, proto, empty20, fail = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
}, die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
}, interrupt = (fiberId) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
}, parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
}, sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
}, isCause = (u) => hasProperty(u, CauseTypeId), isEmptyType = (self) => self._tag === OP_EMPTY, isFailType = (self) => self._tag === OP_FAIL, isDieType = (self) => self._tag === OP_DIE, isEmpty5 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce9(self, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
}, isInterrupted = (self) => isSome2(interruptOption(self)), isInterruptedOnly = (self) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self), failures = (self) => reverse2(reduce9(self, empty5(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2())), defects = (self) => reverse2(reduce9(self, empty5(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2())), interruptors = (self) => reduce9(self, empty8(), (set4, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set4, add4(cause.fiberId))) : none2()), failureOption = (self) => find(self, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2()), failureOrCause = (self) => {
  const option = failureOption(self);
  switch (option._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option.value);
    }
  }
}, flipCauseOption = (self) => match5(self, {
  onEmpty: some2(empty20),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId) => some2(interrupt(fiberId)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), interruptOption = (self) => find(self, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2()), keepDefects = (self) => match5(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), keepDefectsAndElectFailures = (self) => match5(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), stripFailures = (self) => match5(self, {
  onEmpty: empty20,
  onFail: () => empty20,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), electFailures = (self) => match5(self, {
  onEmpty: empty20,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), map9, flatMap8, flatten6 = (self) => flatMap8(self, identity), causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce9([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union5(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce9([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union5(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
}, flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty5());
}, flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty8(), empty5()], ([parallel3, sequential3], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return [pipe(parallel3, union5(par2)), pipe(sequential3, appendAll2(seq2))];
    }));
    const updated = size4(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
}, find, evaluateCause = (self) => {
  let cause = self;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
}, IsInterruptedOnlyCauseReducer, OP_SEQUENTIAL_CASE = "SequentialCase", OP_PARALLEL_CASE = "ParallelCase", match5, reduce9, reduceWithContext, pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join(`
`);
}, renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split(`
`);
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length;i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
}, PrettyError, prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {}
  return stringifyCircular(u);
}, locationRegex, spanToTrace, prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
  for (let i = 1;i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match6 = false;
          for (const [, location] of locationMatchAll) {
            match6 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match6) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join(`
`);
}, spanSymbol, prettyErrors = (cause) => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});
var init_cause = __esm(() => {
  init_Array();
  init_Chunk();
  init_Either();
  init_Equal();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_HashSet();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
  variance7 = {
    _E: (_) => _
  };
  proto = {
    [CauseTypeId]: variance7,
    [symbol]() {
      return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
    },
    [symbol2](that) {
      return isCause(that) && causeEquals(this, that);
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toJSON() {
      switch (this._tag) {
        case "Empty":
          return {
            _id: "Cause",
            _tag: this._tag
          };
        case "Die":
          return {
            _id: "Cause",
            _tag: this._tag,
            defect: toJSON(this.defect)
          };
        case "Interrupt":
          return {
            _id: "Cause",
            _tag: this._tag,
            fiberId: this.fiberId.toJSON()
          };
        case "Fail":
          return {
            _id: "Cause",
            _tag: this._tag,
            failure: toJSON(this.error)
          };
        case "Sequential":
        case "Parallel":
          return {
            _id: "Cause",
            _tag: this._tag,
            left: toJSON(this.left),
            right: toJSON(this.right)
          };
      }
    },
    toString() {
      return pretty(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  empty20 = /* @__PURE__ */ (() => {
    const o = /* @__PURE__ */ Object.create(proto);
    o._tag = OP_EMPTY;
    return o;
  })();
  map9 = /* @__PURE__ */ dual(2, (self, f) => flatMap8(self, (e) => fail(f(e))));
  flatMap8 = /* @__PURE__ */ dual(2, (self, f) => match5(self, {
    onEmpty: empty20,
    onFail: (error) => f(error),
    onDie: (defect) => die(defect),
    onInterrupt: (fiberId) => interrupt(fiberId),
    onSequential: (left3, right3) => sequential(left3, right3),
    onParallel: (left3, right3) => parallel(left3, right3)
  }));
  find = /* @__PURE__ */ dual(2, (self, pf) => {
    const stack = [self];
    while (stack.length > 0) {
      const item = stack.pop();
      const option = pf(item);
      switch (option._tag) {
        case "None": {
          switch (item._tag) {
            case OP_SEQUENTIAL:
            case OP_PARALLEL: {
              stack.push(item.right);
              stack.push(item.left);
              break;
            }
          }
          break;
        }
        case "Some": {
          return option;
        }
      }
    }
    return none2();
  });
  IsInterruptedOnlyCauseReducer = {
    emptyCase: constTrue,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: constTrue,
    sequentialCase: (_, left3, right3) => left3 && right3,
    parallelCase: (_, left3, right3) => left3 && right3
  };
  match5 = /* @__PURE__ */ dual(2, (self, {
    onDie,
    onEmpty,
    onFail,
    onInterrupt,
    onParallel,
    onSequential
  }) => {
    return reduceWithContext(self, undefined, {
      emptyCase: () => onEmpty,
      failCase: (_, error) => onFail(error),
      dieCase: (_, defect) => onDie(defect),
      interruptCase: (_, fiberId) => onInterrupt(fiberId),
      sequentialCase: (_, left3, right3) => onSequential(left3, right3),
      parallelCase: (_, left3, right3) => onParallel(left3, right3)
    });
  });
  reduce9 = /* @__PURE__ */ dual(3, (self, zero3, pf) => {
    let accumulator = zero3;
    let cause = self;
    const causes = [];
    while (cause !== undefined) {
      const option = pf(accumulator, cause);
      accumulator = isSome2(option) ? option.value : accumulator;
      switch (cause._tag) {
        case OP_SEQUENTIAL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        case OP_PARALLEL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        default: {
          cause = undefined;
          break;
        }
      }
      if (cause === undefined && causes.length > 0) {
        cause = causes.pop();
      }
    }
    return accumulator;
  });
  reduceWithContext = /* @__PURE__ */ dual(3, (self, context, reducer) => {
    const input = [self];
    const output = [];
    while (input.length > 0) {
      const cause = input.pop();
      switch (cause._tag) {
        case OP_EMPTY: {
          output.push(right2(reducer.emptyCase(context)));
          break;
        }
        case OP_FAIL: {
          output.push(right2(reducer.failCase(context, cause.error)));
          break;
        }
        case OP_DIE: {
          output.push(right2(reducer.dieCase(context, cause.defect)));
          break;
        }
        case OP_INTERRUPT: {
          output.push(right2(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
        case OP_SEQUENTIAL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
        case OP_PARALLEL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
      }
    }
    const accumulator = [];
    while (output.length > 0) {
      const either2 = output.pop();
      switch (either2._tag) {
        case "Left": {
          switch (either2.left._tag) {
            case OP_SEQUENTIAL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.sequentialCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
            case OP_PARALLEL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.parallelCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
          }
          break;
        }
        case "Right": {
          accumulator.push(either2.right);
          break;
        }
      }
    }
    if (accumulator.length === 0) {
      throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    return accumulator.pop();
  });
  PrettyError = class PrettyError extends globalThis.Error {
    span = undefined;
    constructor(originalError) {
      const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 1;
      super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
        cause: new PrettyError(originalError.cause)
      } : undefined);
      if (this.message === "") {
        this.message = "An error has occurred";
      }
      Error.stackTraceLimit = prevLimit;
      this.name = originalError instanceof Error ? originalError.name : "Error";
      if (originalErrorIsObject) {
        if (spanSymbol in originalError) {
          this.span = originalError[spanSymbol];
        }
        Object.keys(originalError).forEach((key) => {
          if (!(key in this)) {
            this[key] = originalError[key];
          }
        });
      }
      this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
    }
  };
  locationRegex = /\((.*)\)/g;
  spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
  spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
});

// ../../node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending", OP_STATE_DONE = "Done";

// ../../node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred", DeferredTypeId, deferredVariance, pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
}, done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};
var init_deferred = __esm(() => {
  DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
  deferredVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
});

// ../../node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2;
var init_singleShotGen = __esm(() => {
  SingleShotGen2 = class SingleShotGen2 {
    self;
    called = false;
    constructor(self) {
      this.self = self;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(this.self);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/core.js
class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch8, op) {
    this.patch = patch8;
    this.op = op;
  }
}
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
}, runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
}, EffectTypeId2, EffectPrimitive, EffectPrimitiveFailure, EffectPrimitiveSuccess, isEffect = (u) => hasProperty(u, EffectTypeId2), withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
}, acquireUseRelease, as2, asVoid2 = (self) => as2(self, undefined), custom2 = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
}, unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_2);
}, asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn)), async_ = (resume, blockingOn = none4) => {
  return custom2(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_2;
    }) : effect;
  });
}, catchAllCause, catchAll, catchIf, catchSome, checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags))), originalSymbol, capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
}, die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect)), dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message))), dieSync = (evaluate) => flatMap9(sync(evaluate), die2), either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
}), exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
}), fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error)), failSync = (evaluate) => flatMap9(sync(evaluate), fail2), failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
}, failCauseSync = (evaluate) => flatMap9(sync(evaluate), failCause), fiberId, fiberIdWith = (f) => withFiberRuntime((state) => f(state.id())), flatMap9, andThen3, step2 = (self) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self;
  return effect;
}, flatten7 = (self) => flatMap9(self, identity), flip = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
}), matchCause, matchCauseEffect, matchEffect, forEachSequential, forEachSequentialDiscard, if_, interrupt2, interruptWith = (fiberId2) => failCause(interrupt(fiberId2)), interruptible2 = (self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, interruptibleMask = (f) => custom2(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
}), intoDeferred, map10, mapBoth, mapError, onError, onExit, onInterrupt, orElse2, orDie = (self) => orDieWith(self, identity), orDieWith, partitionMap4, runtimeFlags, succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
}, suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
}, sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
}, tap2, transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
}), attemptOrElse, uninterruptible = (self) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self;
  return effect;
}, uninterruptibleMask = (f) => custom2(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
}), void_2, updateRuntimeFlags = (patch8) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch8;
  effect.effect_instruction_i1 = undefined;
  return effect;
}, whenEffect, whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
}, fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
}), gen2 = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
}, fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
  return fromIterator(() => body.apply(this, args));
} : function(...args) {
  let effect = fromIterator(() => body.apply(this, args));
  for (const x of pipeables) {
    effect = x(effect, ...args);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
}), withConcurrency, withRequestBatching, withRuntimeFlags, withTracerEnabled, withTracerTiming, yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
}, zip3, zipLeft2, zipRight2, zipWith4, never, interruptFiber = (self) => flatMap9(fiberId, (fiberId2) => pipe(self, interruptAsFiber(fiberId2))), interruptAsFiber, logLevelAll, logLevelFatal, logLevelError, logLevelWarning, logLevelInfo, logLevelDebug, logLevelTrace, logLevelNone, FiberRefSymbolKey = "effect/FiberRef", FiberRefTypeId, fiberRefVariance, fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self))), fiberRefGetAndSet, fiberRefGetAndUpdate, fiberRefGetAndUpdateSome, fiberRefGetWith, fiberRefSet, fiberRefDelete = (self) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self);
  return void_2;
}), fiberRefReset = (self) => fiberRefSet(self, self.initial), fiberRefModify, fiberRefModifySome = (self, def, f) => fiberRefModify(self, (v) => getOrElse(f(v), () => [def, v])), fiberRefUpdate, fiberRefUpdateSome, fiberRefUpdateAndGet, fiberRefUpdateSomeAndGet, fiberRefLocally, fiberRefLocallyWith, fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
}), fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
}, fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
}, fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
}, fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch8) => (oldValue) => options.differ.patch(patch8, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
}, fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
}), currentContext, currentSchedulingPriority, currentMaxOpsBeforeYield, currentLogAnnotations, currentLogLevel, currentLogSpan, withSchedulingPriority, withMaxOpsBeforeYield, currentConcurrency, currentRequestBatching, currentUnhandledErrorLogLevel, withUnhandledErrorLogLevel, currentMetricLabels, metricLabels, currentForkScopeOverride, currentInterruptedCause, currentTracerEnabled, currentTracerTimingEnabled, currentTracerSpanAnnotations, currentTracerSpanLinks, ScopeTypeId, CloseableScopeTypeId, scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid2(finalizer)), scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer), scopeClose = (self, exit2) => self.close(exit2), scopeFork = (self, strategy) => self.fork(strategy), causeSquash = (self) => {
  return causeSquashWith(identity)(self);
}, causeSquashWith, YieldableError, makeException = (proto2, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto2);
  Base2.prototype.name = tag;
  return Base2;
}, RuntimeExceptionTypeId, RuntimeException, isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId), InterruptedExceptionTypeId, InterruptedException, isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId), IllegalArgumentExceptionTypeId, IllegalArgumentException, NoSuchElementExceptionTypeId, NoSuchElementException, isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId), InvalidPubSubCapacityExceptionTypeId, InvalidPubSubCapacityException, ExceededCapacityExceptionTypeId, ExceededCapacityException, TimeoutExceptionTypeId, TimeoutException, timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format3(duration)}'`), UnknownExceptionTypeId, UnknownException, exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure"), exitIsFailure = (self) => self._tag === "Failure", exitIsSuccess = (self) => self._tag === "Success", exitAs, exitAsVoid = (self) => exitAs(self, undefined), exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential), exitDie = (defect) => exitFailCause(die(defect)), exitFail = (error) => exitFailCause(fail(error)), exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
}, exitFlatMap, exitFlatten = (self) => pipe(self, exitFlatMap(identity)), exitForEachEffect, exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2)), exitMap, exitMapBoth, exitMatch, exitMatchEffect, exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
}, exitVoid, exitZip, exitZipRight, exitZipWith, exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
}, deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
}, deferredMake = () => flatMap9(fiberId, (id) => deferredMakeAs(id)), deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2)), deferredAwait = (self) => asyncInterrupt((resume) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self, resume);
    }
  }
}, self.blockingOn), deferredComplete, deferredCompleteWith, deferredDone, deferredFail, deferredFailSync, deferredFailCause, deferredFailCauseSync, deferredDie, deferredDieSync, deferredInterrupt = (self) => flatMap9(fiberId, (fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2))), deferredInterruptWith, deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE), deferredPoll = (self) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
}), deferredSucceed, deferredSync, deferredUnsafeDone = (self, effect) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect));
    for (let i = 0, len = state.joiners.length;i < len; i++) {
      state.joiners[i](effect);
    }
  }
}, deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
}), constContext, context = () => constContext, contextWithEffect = (f) => flatMap9(context(), f), provideContext, provideSomeContext, mapInputContext, filterEffectOrElse, filterEffectOrFail, currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
}, NoopSpanProto, noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);
var init_core = __esm(() => {
  init_Array();
  init_Chunk();
  init_Context();
  init_Duration();
  init_Either();
  init_Equal();
  init_FiberId();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_HashMap();
  init_Inspectable();
  init_List();
  init_MutableRef();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_RuntimeFlagsPatch();
  init_Utils();
  init_blockedRequests();
  init_cause();
  init_deferred();
  init_differ();
  init_effectable();
  init_runtimeFlags();
  init_singleShotGen();
  EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
  EffectPrimitive = class EffectPrimitive {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Effect",
        _op: this._op,
        effect_instruction_i0: toJSON(this.effect_instruction_i0),
        effect_instruction_i1: toJSON(this.effect_instruction_i1),
        effect_instruction_i2: toJSON(this.effect_instruction_i2)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  };
  EffectPrimitiveFailure = class EffectPrimitiveFailure {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get cause() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        cause: this.cause.toJSON()
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  };
  EffectPrimitiveSuccess = class EffectPrimitiveSuccess {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get value() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        value: toJSON(this.value)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  };
  acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap9(acquire, (a) => flatMap9(exit(suspend(() => restore(use(a)))), (exit) => {
    return suspend(() => release(a, exit)).pipe(matchCauseEffect({
      onFailure: (cause) => {
        switch (exit._tag) {
          case OP_FAILURE:
            return failCause(sequential(exit.effect_instruction_i0, cause));
          case OP_SUCCESS:
            return failCause(cause);
        }
      },
      onSuccess: () => exit
    }));
  }))));
  as2 = /* @__PURE__ */ dual(2, (self, value) => flatMap9(self, () => succeed(value)));
  catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
    const effect = new EffectPrimitive(OP_ON_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
    onFailure: f,
    onSuccess: succeed
  }));
  catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return predicate(either2.left) ? f(either2.left) : failCause(cause);
      case "Right":
        return failCause(either2.right);
    }
  }));
  catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
      case "Right":
        return failCause(either2.right);
    }
  }));
  originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
  fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
  flatMap9 = /* @__PURE__ */ dual(2, (self, f) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  andThen3 = /* @__PURE__ */ dual(2, (self, f) => flatMap9(self, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return b;
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
      });
    }
    return succeed(b);
  }));
  matchCause = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
    onFailure: (cause) => succeed(options.onFailure(cause)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  matchCauseEffect = /* @__PURE__ */ dual(2, (self, options) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = options.onFailure;
    effect.effect_instruction_i2 = options.onSuccess;
    return effect;
  });
  matchEffect = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(electFailures(cause));
      }
      const failures2 = failures(cause);
      if (failures2.length > 0) {
        return options.onFailure(unsafeHead2(failures2));
      }
      return failCause(cause);
    },
    onSuccess: options.onSuccess
  }));
  forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
    const arr = fromIterable2(self);
    const ret = allocate(arr.length);
    let i = 0;
    return as2(whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: (b) => {
        ret[i++] = b;
      }
    }), ret);
  }));
  forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
    const arr = fromIterable2(self);
    let i = 0;
    return whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: () => {
        i++;
      }
    });
  }));
  if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self, options) => isEffect(self) ? flatMap9(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
  interrupt2 = /* @__PURE__ */ flatMap9(fiberId, (fiberId2) => interruptWith(fiberId2));
  intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap9(exit(restore(self)), (exit2) => deferredDone(deferred, exit2))));
  map10 = /* @__PURE__ */ dual(2, (self, f) => flatMap9(self, (a) => sync(() => f(a))));
  mapBoth = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
    onFailure: (e) => failSync(() => options.onFailure(e)),
    onSuccess: (a) => sync(() => options.onSuccess(a))
  }));
  mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const either3 = failureOrCause(cause);
      switch (either3._tag) {
        case "Left": {
          return failSync(() => f(either3.left));
        }
        case "Right": {
          return failCause(either3.right);
        }
      }
    },
    onSuccess: succeed
  }));
  onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit2) => exitIsSuccess(exit2) ? void_2 : cleanup(exit2.effect_instruction_i0)));
  onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
    onFailure: (cause1) => {
      const result = exitFailCause(cause1);
      return matchCauseEffect(cleanup(result), {
        onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
        onSuccess: () => result
      });
    },
    onSuccess: (success) => {
      const result = exitSucceed(success);
      return zipRight2(cleanup(result), result);
    }
  })));
  onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
    onFailure: (cause) => isInterruptedOnly(cause) ? asVoid2(cleanup(interruptors(cause))) : void_2,
    onSuccess: () => void_2
  })));
  orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
  orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
    onFailure: (e) => die2(f(e)),
    onSuccess: succeed
  }));
  partitionMap4 = partitionMap2;
  runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
  tap2 = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self, f) => flatMap9(self, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return as2(b, a);
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
      });
    }
    return succeed(a);
  }));
  attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
      }
      return that();
    },
    onSuccess
  }));
  void_2 = /* @__PURE__ */ succeed(undefined);
  whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap9(condition, (b) => {
    if (b) {
      return pipe(self, map10(some2));
    }
    return succeed(none2());
  }));
  withConcurrency = /* @__PURE__ */ dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
  withRequestBatching = /* @__PURE__ */ dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
  withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update2) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = update2;
    effect.effect_instruction_i1 = () => self;
    return effect;
  });
  withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
  withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
  zip3 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, (a) => map10(that, (b) => [a, b])));
  zipLeft2 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, (a) => as2(that, a)));
  zipRight2 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, () => that));
  zipWith4 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap9(self, (a) => map10(that, (b) => f(a, b))));
  never = /* @__PURE__ */ asyncInterrupt(() => {
    const interval = setInterval(() => {}, 2 ** 31 - 1);
    return sync(() => clearInterval(interval));
  });
  interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId2) => flatMap9(self.interruptAsFork(fiberId2), () => self.await));
  logLevelAll = {
    _tag: "All",
    syslog: 0,
    label: "ALL",
    ordinal: Number.MIN_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelFatal = {
    _tag: "Fatal",
    syslog: 2,
    label: "FATAL",
    ordinal: 50000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelError = {
    _tag: "Error",
    syslog: 3,
    label: "ERROR",
    ordinal: 40000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelWarning = {
    _tag: "Warning",
    syslog: 4,
    label: "WARN",
    ordinal: 30000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelInfo = {
    _tag: "Info",
    syslog: 6,
    label: "INFO",
    ordinal: 20000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelDebug = {
    _tag: "Debug",
    syslog: 7,
    label: "DEBUG",
    ordinal: 1e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelTrace = {
    _tag: "Trace",
    syslog: 7,
    label: "TRACE",
    ordinal: 0,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  logLevelNone = {
    _tag: "None",
    syslog: 7,
    label: "OFF",
    ordinal: Number.MAX_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
  fiberRefVariance = {
    _A: (_) => _
  };
  fiberRefGetAndSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, (v) => [v, value]));
  fiberRefGetAndUpdate = /* @__PURE__ */ dual(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)]));
  fiberRefGetAndUpdateSome = /* @__PURE__ */ dual(2, (self, pf) => fiberRefModify(self, (v) => [v, getOrElse(pf(v), () => v)]));
  fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap9(fiberRefGet(self), f));
  fiberRefSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, () => [undefined, value]));
  fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
    const [b, a] = f(state.getFiberRef(self));
    state.setFiberRef(self, a);
    return succeed(b);
  }));
  fiberRefUpdate = /* @__PURE__ */ dual(2, (self, f) => fiberRefModify(self, (v) => [undefined, f(v)]));
  fiberRefUpdateSome = /* @__PURE__ */ dual(2, (self, pf) => fiberRefModify(self, (v) => [undefined, getOrElse(pf(v), () => v)]));
  fiberRefUpdateAndGet = /* @__PURE__ */ dual(2, (self, f) => fiberRefModify(self, (v) => {
    const result = f(v);
    return [result, result];
  }));
  fiberRefUpdateSomeAndGet = /* @__PURE__ */ dual(2, (self, pf) => fiberRefModify(self, (v) => {
    const result = getOrElse(pf(v), () => v);
    return [result, result];
  }));
  fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value) => acquireUseRelease(zipLeft2(fiberRefGet(self), fiberRefSet(self, value)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
  fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
  currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
  currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
  currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
  currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
  currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
  currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
  withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
  withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
  currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
  currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
  currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
  withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
  currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
  metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
  currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
    fork: () => none2(),
    join: (parent, _) => parent
  }));
  currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty20, {
    fork: () => empty20,
    join: (parent, _) => parent
  }));
  currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
  currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
  currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
  currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
  ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
  CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
  causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
    const option = pipe(self, failureOption, map2(f));
    switch (option._tag) {
      case "None": {
        return pipe(defects(self), head2, match2({
          onNone: () => {
            const interrupts = fromIterable2(interruptors(self)).flatMap((fiberId2) => fromIterable2(ids2(fiberId2)).map((id) => `#${id}`));
            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
          },
          onSome: identity
        }));
      }
      case "Some": {
        return option.value;
      }
    }
  });
  YieldableError = /* @__PURE__ */ function() {

    class YieldableError2 extends globalThis.Error {
      commit() {
        return fail2(this);
      }
      toJSON() {
        const obj = {
          ...this
        };
        if (this.message)
          obj.message = this.message;
        if (this.cause)
          obj.cause = this.cause;
        return obj;
      }
      [NodeInspectSymbol]() {
        if (this.toString !== globalThis.Error.prototype.toString) {
          return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
        } else if ("Bun" in globalThis) {
          return pretty(fail(this), {
            renderErrorCause: true
          });
        }
        return this;
      }
    }
    Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
    return YieldableError2;
  }();
  RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
  RuntimeException = /* @__PURE__ */ makeException({
    [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
  }, "RuntimeException");
  InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
  InterruptedException = /* @__PURE__ */ makeException({
    [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
  }, "InterruptedException");
  IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
  IllegalArgumentException = /* @__PURE__ */ makeException({
    [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
  }, "IllegalArgumentException");
  NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
  NoSuchElementException = /* @__PURE__ */ makeException({
    [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
  }, "NoSuchElementException");
  InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
  InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
    [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
  }, "InvalidPubSubCapacityException");
  ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
  ExceededCapacityException = /* @__PURE__ */ makeException({
    [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
  }, "ExceededCapacityException");
  TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
  TimeoutException = /* @__PURE__ */ makeException({
    [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
  }, "TimeoutException");
  UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
  UnknownException = /* @__PURE__ */ function() {

    class UnknownException2 extends YieldableError {
      _tag = "UnknownException";
      error;
      constructor(cause, message) {
        super(message ?? "An unknown error occurred", {
          cause
        });
        this.error = cause;
      }
    }
    Object.assign(UnknownException2.prototype, {
      [UnknownExceptionTypeId]: UnknownExceptionTypeId,
      name: "UnknownException"
    });
    return UnknownException2;
  }();
  exitAs = /* @__PURE__ */ dual(2, (self, value) => {
    switch (self._tag) {
      case OP_FAILURE: {
        return exitFailCause(self.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return exitSucceed(value);
      }
    }
  });
  exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
    switch (self._tag) {
      case OP_FAILURE: {
        return exitFailCause(self.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return f(self.effect_instruction_i0);
      }
    }
  });
  exitForEachEffect = /* @__PURE__ */ dual(2, (self, f) => {
    switch (self._tag) {
      case OP_FAILURE: {
        return succeed(exitFailCause(self.effect_instruction_i0));
      }
      case OP_SUCCESS: {
        return exit(f(self.effect_instruction_i0));
      }
    }
  });
  exitMap = /* @__PURE__ */ dual(2, (self, f) => {
    switch (self._tag) {
      case OP_FAILURE:
        return exitFailCause(self.effect_instruction_i0);
      case OP_SUCCESS:
        return exitSucceed(f(self.effect_instruction_i0));
    }
  });
  exitMapBoth = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return exitFailCause(pipe(self.effect_instruction_i0, map9(onFailure)));
      case OP_SUCCESS:
        return exitSucceed(onSuccess(self.effect_instruction_i0));
    }
  });
  exitMatch = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return onFailure(self.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self.effect_instruction_i0);
    }
  });
  exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return onFailure(self.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self.effect_instruction_i0);
    }
  });
  exitVoid = /* @__PURE__ */ exitSucceed(undefined);
  exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
    onSuccess: (a, a2) => [a, a2],
    onFailure: sequential
  }));
  exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
    onSuccess: (_, a2) => a2,
    onFailure: sequential
  }));
  exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause(self.effect_instruction_i0);
          case OP_FAILURE: {
            return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
          }
        }
      }
      case OP_SUCCESS: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause(that.effect_instruction_i0);
        }
      }
    }
  });
  deferredComplete = /* @__PURE__ */ dual(2, (self, effect) => intoDeferred(effect, self));
  deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync(() => {
    const state = get6(self.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return false;
      }
      case OP_STATE_PENDING: {
        set2(self.state, done(effect));
        for (let i = 0, len = state.joiners.length;i < len; i++) {
          state.joiners[i](effect);
        }
        return true;
      }
    }
  }));
  deferredDone = /* @__PURE__ */ dual(2, (self, exit2) => deferredCompleteWith(self, exit2));
  deferredFail = /* @__PURE__ */ dual(2, (self, error) => deferredCompleteWith(self, fail2(error)));
  deferredFailSync = /* @__PURE__ */ dual(2, (self, evaluate) => deferredCompleteWith(self, failSync(evaluate)));
  deferredFailCause = /* @__PURE__ */ dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));
  deferredFailCauseSync = /* @__PURE__ */ dual(2, (self, evaluate) => deferredCompleteWith(self, failCauseSync(evaluate)));
  deferredDie = /* @__PURE__ */ dual(2, (self, defect) => deferredCompleteWith(self, die2(defect)));
  deferredDieSync = /* @__PURE__ */ dual(2, (self, evaluate) => deferredCompleteWith(self, dieSync(evaluate)));
  deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
  deferredSucceed = /* @__PURE__ */ dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));
  deferredSync = /* @__PURE__ */ dual(2, (self, evaluate) => deferredCompleteWith(self, sync(evaluate)));
  constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
  provideContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocally(currentContext, context2)(self));
  provideSomeContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self));
  mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context2) => provideContext(self, f(context2))));
  filterEffectOrElse = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => flatMap9(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
  filterEffectOrFail = /* @__PURE__ */ dual(2, (self, options) => filterEffectOrElse(self, {
    predicate: options.predicate,
    orElse: (a) => fail2(options.orFailWith(a))
  }));
  NoopSpanProto = {
    _tag: "Span",
    spanId: "noop",
    traceId: "noop",
    sampled: false,
    status: {
      _tag: "Ended",
      startTime: /* @__PURE__ */ BigInt(0),
      endTime: /* @__PURE__ */ BigInt(0),
      exit: exitVoid
    },
    attributes: /* @__PURE__ */ new Map,
    links: [],
    kind: "internal",
    attribute() {},
    event() {},
    end() {},
    addLinks() {}
  };
});

// ../../node_modules/effect/dist/esm/Deferred.js
var exports_Deferred = {};
__export(exports_Deferred, {
  unsafeMake: () => unsafeMake4,
  unsafeDone: () => unsafeDone,
  sync: () => sync2,
  succeed: () => succeed2,
  poll: () => poll,
  makeAs: () => makeAs,
  make: () => make19,
  isDone: () => isDone,
  interruptWith: () => interruptWith2,
  interrupt: () => interrupt3,
  failSync: () => failSync2,
  failCauseSync: () => failCauseSync2,
  failCause: () => failCause2,
  fail: () => fail3,
  done: () => done2,
  dieSync: () => dieSync2,
  die: () => die3,
  completeWith: () => completeWith,
  complete: () => complete,
  await: () => _await,
  DeferredTypeId: () => DeferredTypeId2
});
var DeferredTypeId2, make19, makeAs, _await, complete, completeWith, done2, fail3, failSync2, failCause2, failCauseSync2, die3, dieSync2, interrupt3, interruptWith2, isDone, poll, succeed2, sync2, unsafeMake4, unsafeDone;
var init_Deferred = __esm(() => {
  init_core();
  init_deferred();
  DeferredTypeId2 = DeferredTypeId;
  make19 = deferredMake;
  makeAs = deferredMakeAs;
  _await = deferredAwait;
  complete = deferredComplete;
  completeWith = deferredCompleteWith;
  done2 = deferredDone;
  fail3 = deferredFail;
  failSync2 = deferredFailSync;
  failCause2 = deferredFailCause;
  failCauseSync2 = deferredFailCauseSync;
  die3 = deferredDie;
  dieSync2 = deferredDieSync;
  interrupt3 = deferredInterrupt;
  interruptWith2 = deferredInterruptWith;
  isDone = deferredIsDone;
  poll = deferredPoll;
  succeed2 = deferredSucceed;
  sync2 = deferredSync;
  unsafeMake4 = deferredUnsafeMake;
  unsafeDone = deferredUnsafeDone;
});

// ../../node_modules/effect/dist/esm/Exit.js
var isExit, isFailure, isSuccess, all4, die4, fail4, failCause3, flatten8, forEachEffect, interrupt4, map11, mapBoth2, match6, succeed3, void_3, zip4, zipRight3, zipWith5;
var init_Exit = __esm(() => {
  init_core();
  isExit = exitIsExit;
  isFailure = exitIsFailure;
  isSuccess = exitIsSuccess;
  all4 = exitCollectAll;
  die4 = exitDie;
  fail4 = exitFail;
  failCause3 = exitFailCause;
  flatten8 = exitFlatten;
  forEachEffect = exitForEachEffect;
  interrupt4 = exitInterrupt;
  map11 = exitMap;
  mapBoth2 = exitMapBoth;
  match6 = exitMatch;
  succeed3 = exitSucceed;
  void_3 = exitVoid;
  zip4 = exitZip;
  zipRight3 = exitZipRight;
  zipWith5 = exitZipWith;
});

// ../../node_modules/effect/dist/esm/MutableHashMap.js
class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var TypeId10, MutableHashMapProto, MutableHashMapIterator, empty21 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = new Map;
  self.buckets = new Map;
  self.bucketsSize = 0;
  return self;
}, get8, getFromBucket = (self, bucket, key, remove7 = false) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove7) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
}, has5, set4, removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
}, remove7, size6 = (self) => {
  return self.referential.size + self.bucketsSize;
};
var init_MutableHashMap = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
  MutableHashMapProto = {
    [TypeId10]: TypeId10,
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableHashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  MutableHashMapIterator = class MutableHashMapIterator {
    self;
    referentialIterator;
    bucketIterator;
    constructor(self) {
      this.self = self;
      this.referentialIterator = self.referential[Symbol.iterator]();
    }
    next() {
      if (this.bucketIterator !== undefined) {
        return this.bucketIterator.next();
      }
      const result = this.referentialIterator.next();
      if (result.done) {
        this.bucketIterator = new BucketIterator(this.self.buckets.values());
        return this.next();
      }
      return result;
    }
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this.self);
    }
  };
  get8 = /* @__PURE__ */ dual(2, (self, key) => {
    if (isEqual(key) === false) {
      return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      return none2();
    }
    return getFromBucket(self, bucket, key);
  });
  has5 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get8(self, key)));
  set4 = /* @__PURE__ */ dual(3, (self, key, value) => {
    if (isEqual(key) === false) {
      self.referential.set(key, value);
      return self;
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      self.buckets.set(hash2, [[key, value]]);
      self.bucketsSize++;
      return self;
    }
    removeFromBucket(self, bucket, key);
    bucket.push([key, value]);
    self.bucketsSize++;
    return self;
  });
  remove7 = /* @__PURE__ */ dual(2, (self, key) => {
    if (isEqual(key) === false) {
      self.referential.delete(key);
      return self;
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      return self;
    }
    removeFromBucket(self, bucket, key);
    if (bucket.length === 0) {
      self.buckets.delete(hash2);
    }
    return self;
  });
});

// ../../node_modules/effect/dist/esm/MutableList.js
var TypeId11, MutableListProto, makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
}), empty22 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
}, isEmpty6 = (self) => length(self) === 0, length = (self) => self._length, append3, shift = (self) => {
  const head3 = self.head;
  if (head3 !== undefined) {
    remove8(self, head3);
    return head3.value;
  }
  return;
}, remove8 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self.head = node.next;
    node.next.prev = undefined;
  } else {
    self.tail = undefined;
    self.head = undefined;
  }
  if (self._length > 0) {
    self._length -= 1;
  }
};
var init_MutableList = __esm(() => {
  init_Function();
  init_Inspectable();
  init_Pipeable();
  TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableList");
  MutableListProto = {
    [TypeId11]: TypeId11,
    [Symbol.iterator]() {
      let done3 = false;
      let head3 = this.head;
      return {
        next() {
          if (done3) {
            return this.return();
          }
          if (head3 == null) {
            done3 = true;
            return this.return();
          }
          const value = head3.value;
          head3 = head3.next;
          return {
            done: done3,
            value
          };
        },
        return(value) {
          if (!done3) {
            done3 = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableList",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  append3 = /* @__PURE__ */ dual(2, (self, value) => {
    const node = makeNode(value);
    if (self.head === undefined) {
      self.head = node;
    }
    if (self.tail === undefined) {
      self.tail = node;
    } else {
      self.tail.next = node;
      node.prev = self.tail;
      self.tail = node;
    }
    self._length += 1;
    return self;
  });
});

// ../../node_modules/effect/dist/esm/MutableQueue.js
var TypeId12, EmptyMutableQueue, MutableQueueProto, make20 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty22();
  queue.capacity = capacity;
  return queue;
}, bounded = (capacity) => make20(capacity), unbounded = () => make20(undefined), length2 = (self) => length(self.queue), isEmpty7 = (self) => isEmpty6(self.queue), capacity = (self) => self.capacity === undefined ? Infinity : self.capacity, offer, offerAll, poll2, pollUpTo;
var init_MutableQueue = __esm(() => {
  init_Chunk();
  init_Function();
  init_Inspectable();
  init_MutableList();
  init_Pipeable();
  TypeId12 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
  EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
  MutableQueueProto = {
    [TypeId12]: TypeId12,
    [Symbol.iterator]() {
      return Array.from(this.queue)[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableQueue",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  offer = /* @__PURE__ */ dual(2, (self, value) => {
    const queueLength = length(self.queue);
    if (self.capacity !== undefined && queueLength === self.capacity) {
      return false;
    }
    append3(value)(self.queue);
    return true;
  });
  offerAll = /* @__PURE__ */ dual(2, (self, values4) => {
    const iterator = values4[Symbol.iterator]();
    let next;
    let remainder = empty5();
    let offering = true;
    while (offering && (next = iterator.next()) && !next.done) {
      offering = offer(next.value)(self);
    }
    while (next != null && !next.done) {
      remainder = prepend2(next.value)(remainder);
      next = iterator.next();
    }
    return reverse2(remainder);
  });
  poll2 = /* @__PURE__ */ dual(2, (self, def) => {
    if (isEmpty6(self.queue)) {
      return def;
    }
    return shift(self.queue);
  });
  pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
    let result = empty5();
    let count = 0;
    while (count < n) {
      const element = poll2(EmptyMutableQueue)(self);
      if (element === EmptyMutableQueue) {
        break;
      }
      result = prepend2(element)(result);
      count += 1;
    }
    return reverse2(result);
  });
});

// ../../node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock", ClockTypeId, clockTag, MAX_TIMER_MILLIS, globalClockScheduler, performanceNowNanos, processOrPerformanceNow, ClockImpl, make21 = () => new ClockImpl;
var init_clock = __esm(() => {
  init_Context();
  init_Duration();
  init_Function();
  init_core();
  ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
  clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
  MAX_TIMER_MILLIS = 2 ** 31 - 1;
  globalClockScheduler = {
    unsafeSchedule(task, duration) {
      const millis2 = toMillis(duration);
      if (millis2 > MAX_TIMER_MILLIS) {
        return constFalse;
      }
      let completed = false;
      const handle = setTimeout(() => {
        completed = true;
        task();
      }, millis2);
      return () => {
        clearTimeout(handle);
        return !completed;
      };
    }
  };
  performanceNowNanos = /* @__PURE__ */ function() {
    const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
    if (typeof performance === "undefined") {
      return () => BigInt(Date.now()) * bigint1e62;
    }
    let origin;
    return () => {
      if (origin === undefined) {
        origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
      }
      return origin + BigInt(Math.round(performance.now() * 1e6));
    };
  }();
  processOrPerformanceNow = /* @__PURE__ */ function() {
    const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
    if (!processHrtime) {
      return performanceNowNanos;
    }
    const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
    return () => origin + processHrtime.bigint();
  }();
  ClockImpl = class ClockImpl {
    [ClockTypeId] = ClockTypeId;
    unsafeCurrentTimeMillis() {
      return Date.now();
    }
    unsafeCurrentTimeNanos() {
      return processOrPerformanceNow();
    }
    currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
    currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
    scheduler() {
      return succeed(globalClockScheduler);
    }
    sleep(duration) {
      return async_((resume) => {
        const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_2), duration);
        return asVoid2(sync(canceler));
      });
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And", OP_OR = "Or", OP_INVALID_DATA = "InvalidData", OP_MISSING_DATA = "MissingData", OP_SOURCE_UNAVAILABLE = "SourceUnavailable", OP_UNSUPPORTED = "Unsupported";

// ../../node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError", ConfigErrorTypeId, proto2, And = (self, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, Or = (self, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
}, InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
}, prefixed;
var init_configError = __esm(() => {
  init_Array();
  init_Either();
  init_Function();
  init_Predicate();
  ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
  proto2 = {
    _tag: "ConfigError",
    [ConfigErrorTypeId]: ConfigErrorTypeId
  };
  prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
    switch (self._op) {
      case OP_AND: {
        return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
      case OP_OR: {
        return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
      case OP_INVALID_DATA: {
        return InvalidData([...prefix, ...self.path], self.message);
      }
      case OP_MISSING_DATA: {
        return MissingData([...prefix, ...self.path], self.message);
      }
      case OP_SOURCE_UNAVAILABLE: {
        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
      }
      case OP_UNSUPPORTED: {
        return Unsupported([...prefix, ...self.path], self.message);
      }
    }
  });
});

// ../../node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty23, patch8;
var init_pathPatch = __esm(() => {
  init_Array();
  init_Either();
  init_Function();
  init_List();
  init_Option();
  init_configError();
  empty23 = {
    _tag: "Empty"
  };
  patch8 = /* @__PURE__ */ dual(2, (path, patch9) => {
    let input = of3(patch9);
    let output = path;
    while (isCons(input)) {
      const patch10 = input.head;
      switch (patch10._tag) {
        case "Empty": {
          input = input.tail;
          break;
        }
        case "AndThen": {
          input = cons(patch10.first, cons(patch10.second, input.tail));
          break;
        }
        case "MapName": {
          output = map3(output, patch10.f);
          input = input.tail;
          break;
        }
        case "Nested": {
          output = prepend(output, patch10.name);
          input = input.tail;
          break;
        }
        case "Unnested": {
          const containsName = pipe(head(output), contains(patch10.name));
          if (containsName) {
            output = tailNonEmpty(output);
            input = input.tail;
          } else {
            return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
      }
    }
    return right2(output);
  });
});

// ../../node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant", OP_FAIL2 = "Fail", OP_FALLBACK = "Fallback", OP_DESCRIBED = "Described", OP_LAZY = "Lazy", OP_MAP_OR_FAIL = "MapOrFail", OP_NESTED = "Nested", OP_PRIMITIVE = "Primitive", OP_SEQUENCE = "Sequence", OP_HASHMAP = "HashMap", OP_ZIP_WITH = "ZipWith";

// ../../node_modules/effect/dist/esm/internal/string-utils.js
var init_string_utils = () => {};

// ../../node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r], ConfigProviderSymbolKey = "effect/ConfigProvider", ConfigProviderTypeId, configProviderTag, FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat", FlatConfigProviderTypeId, make23 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
}), makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split2 = true) => options.load(path, config, split2),
  enumerateChildren: options.enumerateChildren
}), fromFlat = (flat) => make23({
  load: (config) => flatMap9(fromFlatLoop(flat, empty2(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
}), fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split2 = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap9((value) => parsePrimitive(value, path, primitive, seqDelim, split2)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys3 = Object.keys(current);
    const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0;i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty23
  }));
}, extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
}, appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
}, fromFlatLoop = (flat, prefix, config, split2) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split2));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split2)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split2), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split2));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split2), flatMap9(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split2));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap9((prefix2) => pipe(flat.load(prefix2, op, split2), flatMap9((values4) => {
        if (values4.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values4);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap9((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap9(indicesFrom), flatMap9((indices) => {
        if (indices.length === 0) {
          return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
          const flattened = flatten2(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap9((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap9((keys3) => {
        return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split2)), map10((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map3((values4) => fromIterable7(zip(fromIterable2(keys3), values4))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split2), either2, flatMap9((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split2), either2, flatMap9((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail5 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail5, fail5, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip3(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
}, fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`)), splitPathString = (text, delim) => {
  const split2 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split2;
}, parsePrimitive = (text, path, primitive, delimiter, split2) => {
  if (!split2) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
}, transpose = (array4) => {
  return Object.keys(array4[0]).map((column) => array4.map((row) => row[column]));
}, indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map10(merge)), QUOTED_INDEX_REGEX, parseQuotedIndex = (str) => {
  const match7 = str.match(QUOTED_INDEX_REGEX);
  if (match7 !== null) {
    const matchedIndex = match7[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
}, parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};
var init_configProvider = __esm(() => {
  init_Array();
  init_Context();
  init_Either();
  init_Function();
  init_HashMap();
  init_HashSet();
  init_Number();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_RegExp();
  init_configError();
  init_pathPatch();
  init_core();
  init_string_utils();
  ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
  configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
  FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
  QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
});

// ../../node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId13, consoleTag, defaultConsole;
var init_console = __esm(() => {
  init_Context();
  init_core();
  TypeId13 = /* @__PURE__ */ Symbol.for("effect/Console");
  consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
  defaultConsole = {
    [TypeId13]: TypeId13,
    assert(condition, ...args) {
      return sync(() => {
        console.assert(condition, ...args);
      });
    },
    clear: /* @__PURE__ */ sync(() => {
      console.clear();
    }),
    count(label) {
      return sync(() => {
        console.count(label);
      });
    },
    countReset(label) {
      return sync(() => {
        console.countReset(label);
      });
    },
    debug(...args) {
      return sync(() => {
        console.debug(...args);
      });
    },
    dir(item, options) {
      return sync(() => {
        console.dir(item, options);
      });
    },
    dirxml(...args) {
      return sync(() => {
        console.dirxml(...args);
      });
    },
    error(...args) {
      return sync(() => {
        console.error(...args);
      });
    },
    group(options) {
      return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
    },
    groupEnd: /* @__PURE__ */ sync(() => {
      console.groupEnd();
    }),
    info(...args) {
      return sync(() => {
        console.info(...args);
      });
    },
    log(...args) {
      return sync(() => {
        console.log(...args);
      });
    },
    table(tabularData, properties) {
      return sync(() => {
        console.table(tabularData, properties);
      });
    },
    time(label) {
      return sync(() => console.time(label));
    },
    timeEnd(label) {
      return sync(() => console.timeEnd(label));
    },
    timeLog(label, ...args) {
      return sync(() => {
        console.timeLog(label, ...args);
      });
    },
    trace(...args) {
      return sync(() => {
        console.trace(...args);
      });
    },
    warn(...args) {
      return sync(() => {
        console.warn(...args);
      });
    },
    unsafe: console
  };
});

// ../../node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random", RandomTypeId, randomTag, RandomImpl, shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap9((buffer) => {
    const numbers = [];
    for (let i = buffer.length;i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer, n - 1, k)))), as2(fromIterable3(buffer)));
  })));
}, swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
}, make24 = (seed) => new RandomImpl(hash(seed));
var init_random = __esm(() => {
  init_Chunk();
  init_Context();
  init_Function();
  init_Hash();
  init_Utils();
  init_core();
  RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
  randomTag = /* @__PURE__ */ GenericTag("effect/Random");
  RandomImpl = class RandomImpl {
    seed;
    [RandomTypeId] = RandomTypeId;
    PRNG;
    constructor(seed) {
      this.seed = seed;
      this.PRNG = new PCGRandom(seed);
    }
    get next() {
      return sync(() => this.PRNG.number());
    }
    get nextBoolean() {
      return map10(this.next, (n) => n > 0.5);
    }
    get nextInt() {
      return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
    }
    nextRange(min2, max2) {
      return map10(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync(() => this.PRNG.integer(max2 - min2) + min2);
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/tracer.js
class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context2, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var TracerTypeId, make25 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
}), tracerTag, spanTag, randomHexString, nativeTracer, addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error;
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== undefined) {
        const stack = traceError.stack.split(`
`);
        if (stack[3] !== undefined) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
}, DisablePropagation;
var init_tracer = __esm(() => {
  init_Context();
  init_Function();
  TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
  tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
  spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
  randomHexString = /* @__PURE__ */ function() {
    const characters = "abcdef0123456789";
    const charactersLength = characters.length;
    return function(length3) {
      let result = "";
      for (let i = 0;i < length3; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
  }();
  nativeTracer = /* @__PURE__ */ make25({
    span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
    context: (f) => f()
  });
  DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
    defaultValue: constFalse
  });
});

// ../../node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices, currentServices, sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
}, defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices)), clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key))), currentTimeMillis, currentTimeNanos, withClock, withConfigProvider, configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key))), config = (config2) => configProviderWith((_) => _.load(config2)), randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key))), withRandom, next, tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key))), withTracer;
var init_defaultServices = __esm(() => {
  init_Array();
  init_Context();
  init_Duration();
  init_Function();
  init_GlobalValue();
  init_clock();
  init_configProvider();
  init_core();
  init_console();
  init_random();
  init_tracer();
  liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make21()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make24(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
  currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
  currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
  currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
  withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
  withConfigProvider = /* @__PURE__ */ dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
  withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
  next = /* @__PURE__ */ randomWith((random2) => random2.next);
  withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));
});

// ../../node_modules/effect/dist/esm/Clock.js
var sleep2, currentTimeMillis2, currentTimeNanos2, clockWith2, Clock;
var init_Clock = __esm(() => {
  init_clock();
  init_defaultServices();
  sleep2 = sleep;
  currentTimeMillis2 = currentTimeMillis;
  currentTimeNanos2 = currentTimeNanos;
  clockWith2 = clockWith;
  Clock = clockTag;
});

// ../../node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty24() {
  return unsafeMake5(new Map);
}
var FiberRefsSym, FiberRefsImpl, findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
}, joinAs, forkAs, unsafeForkAs = (self, map12, fiberId2) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map12.set(fiberRef, stack);
    } else {
      map12.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
}, fiberRefs = (self) => fromIterable6(self.locals.keys()), setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef))), delete_, get9, getOrDefault, updateAs, unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
}, updateManyAs;
var init_fiberRefs = __esm(() => {
  init_Array();
  init_Equal();
  init_Function();
  init_HashSet();
  init_Option();
  init_Pipeable();
  init_core();
  FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
  FiberRefsImpl = class FiberRefsImpl {
    locals;
    [FiberRefsSym] = FiberRefsSym;
    constructor(locals) {
      this.locals = locals;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  joinAs = /* @__PURE__ */ dual(3, (self, fiberId2, that) => {
    const parentFiberRefs = new Map(self.locals);
    that.locals.forEach((childStack, fiberRef) => {
      const childValue = childStack[0][1];
      if (!childStack[0][0][symbol2](fiberId2)) {
        if (!parentFiberRefs.has(fiberRef)) {
          if (equals(childValue, fiberRef.initial)) {
            return;
          }
          parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
          return;
        }
        const parentStack = parentFiberRefs.get(fiberRef);
        const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
        if (wasModified) {
          const patch9 = fiberRef.diff(ancestor, childValue);
          const oldValue = parentStack[0][1];
          const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
          if (!equals(oldValue, newValue)) {
            let newStack;
            const parentFiberId = parentStack[0][0];
            if (parentFiberId[symbol2](fiberId2)) {
              newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
            } else {
              newStack = [[fiberId2, newValue], ...parentStack];
            }
            parentFiberRefs.set(fiberRef, newStack);
          }
        }
      }
    });
    return new FiberRefsImpl(parentFiberRefs);
  });
  forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
    const map12 = new Map;
    unsafeForkAs(self, map12, childId);
    return new FiberRefsImpl(map12);
  });
  delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
    const locals = new Map(self.locals);
    locals.delete(fiberRef);
    return new FiberRefsImpl(locals);
  });
  get9 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
    if (!self.locals.has(fiberRef)) {
      return none2();
    }
    return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
  });
  getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get9(self, fiberRef), getOrElse(() => fiberRef.initial)));
  updateAs = /* @__PURE__ */ dual(2, (self, {
    fiberId: fiberId2,
    fiberRef,
    value
  }) => {
    if (self.locals.size === 0) {
      return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
    }
    const locals = new Map(self.locals);
    unsafeUpdateAs(locals, fiberId2, fiberRef, value);
    return new FiberRefsImpl(locals);
  });
  updateManyAs = /* @__PURE__ */ dual(2, (self, {
    entries: entries3,
    forkAs: forkAs2
  }) => {
    if (self.locals.size === 0) {
      return new FiberRefsImpl(new Map(entries3));
    }
    const locals = new Map(self.locals);
    if (forkAs2 !== undefined) {
      unsafeForkAs(self, locals, forkAs2);
    }
    entries3.forEach(([fiberRef, values4]) => {
      if (values4.length === 1) {
        unsafeUpdateAs(locals, values4[0][0], fiberRef, values4[0][1]);
      } else {
        values4.forEach(([fiberId2, value]) => {
          unsafeUpdateAs(locals, fiberId2, fiberRef, value);
        });
      }
    });
    return new FiberRefsImpl(locals);
  });
});

// ../../node_modules/effect/dist/esm/FiberRefs.js
var get10, getOrDefault2, joinAs2, setAll2, updateManyAs2, empty25;
var init_FiberRefs = __esm(() => {
  init_fiberRefs();
  get10 = get9;
  getOrDefault2 = getOrDefault;
  joinAs2 = joinAs;
  setAll2 = setAll;
  updateManyAs2 = updateManyAs;
  empty25 = empty24;
});

// ../../node_modules/effect/dist/esm/LogLevel.js
var All, Fatal, Error2, Warning, Info, Debug, Trace, None3, Order2, greaterThan3, fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};
var init_LogLevel = __esm(() => {
  init_Function();
  init_core();
  init_Number();
  init_Order();
  All = logLevelAll;
  Fatal = logLevelFatal;
  Error2 = logLevelError;
  Warning = logLevelWarning;
  Info = logLevelInfo;
  Debug = logLevelDebug;
  Trace = logLevelTrace;
  None3 = logLevelNone;
  Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
  greaterThan3 = /* @__PURE__ */ greaterThan(Order2);
});

// ../../node_modules/effect/dist/esm/internal/logSpan.js
var make26 = (label, startTime) => ({
  label,
  startTime
}), formatLabel = (key) => key.replace(/[\s="]/g, "_"), render = (now) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now - self.startTime}ms`;
};

// ../../node_modules/effect/dist/esm/LogSpan.js
var make27;
var init_LogSpan = __esm(() => {
  make27 = make26;
});

// ../../node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2, CommitPrototype2, Base2, Class;
var init_Effectable = __esm(() => {
  init_effectable();
  EffectPrototype2 = EffectPrototype;
  CommitPrototype2 = CommitPrototype;
  Base2 = Base;
  Class = class Class extends Base2 {
  };
});

// ../../node_modules/effect/dist/esm/Readable.js
var TypeId14, Proto;
var init_Readable = __esm(() => {
  init_Function();
  init_core();
  init_Pipeable();
  init_Predicate();
  TypeId14 = /* @__PURE__ */ Symbol.for("effect/Readable");
  Proto = {
    [TypeId14]: TypeId14,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/ref.js
var RefTypeId, refVariance, RefImpl, unsafeMake6 = (value) => new RefImpl(make13(value)), make28 = (value) => sync(() => unsafeMake6(value)), get11 = (self) => self.get, set5, getAndSet, getAndUpdate, getAndUpdateSome, setAndGet, modify5, modifySome, update2, updateAndGet, updateSome, updateSomeAndGet;
var init_ref = __esm(() => {
  init_Effectable();
  init_Function();
  init_MutableRef();
  init_Option();
  init_Readable();
  init_core();
  RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
  refVariance = {
    _A: (_) => _
  };
  RefImpl = class RefImpl extends Class {
    ref;
    commit() {
      return this.get;
    }
    [RefTypeId] = refVariance;
    [TypeId14] = TypeId14;
    constructor(ref) {
      super();
      this.ref = ref;
      this.get = sync(() => get6(this.ref));
    }
    get;
    modify(f) {
      return sync(() => {
        const current = get6(this.ref);
        const [b, a] = f(current);
        if (current !== a) {
          set2(a)(this.ref);
        }
        return b;
      });
    }
  };
  set5 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [undefined, value]));
  getAndSet = /* @__PURE__ */ dual(2, (self, value) => self.modify((a) => [a, value]));
  getAndUpdate = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [a, f(a)]));
  getAndUpdateSome = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [value, option.value];
      }
    }
  }));
  setAndGet = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [value, value]));
  modify5 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
  modifySome = /* @__PURE__ */ dual(3, (self, fallback, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [fallback, value];
      }
      case "Some": {
        return option.value;
      }
    }
  }));
  update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [undefined, f(a)]));
  updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
    const result = f(a);
    return [result, result];
  }));
  updateSome = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [undefined, match2(f(a), {
    onNone: () => a,
    onSome: (b) => b
  })]));
  updateSomeAndGet = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [option.value, option.value];
      }
    }
  }));
});

// ../../node_modules/effect/dist/esm/Ref.js
var exports_Ref = {};
__export(exports_Ref, {
  updateSomeAndGet: () => updateSomeAndGet2,
  updateSome: () => updateSome2,
  updateAndGet: () => updateAndGet2,
  update: () => update3,
  unsafeMake: () => unsafeMake7,
  setAndGet: () => setAndGet2,
  set: () => set6,
  modifySome: () => modifySome2,
  modify: () => modify6,
  make: () => make29,
  getAndUpdateSome: () => getAndUpdateSome2,
  getAndUpdate: () => getAndUpdate2,
  getAndSet: () => getAndSet2,
  get: () => get12,
  RefTypeId: () => RefTypeId2
});
var RefTypeId2, make29, get12, getAndSet2, getAndUpdate2, getAndUpdateSome2, modify6, modifySome2, set6, setAndGet2, update3, updateAndGet2, updateSome2, updateSomeAndGet2, unsafeMake7;
var init_Ref = __esm(() => {
  init_ref();
  RefTypeId2 = RefTypeId;
  make29 = make28;
  get12 = get11;
  getAndSet2 = getAndSet;
  getAndUpdate2 = getAndUpdate;
  getAndUpdateSome2 = getAndUpdateSome;
  modify6 = modify5;
  modifySome2 = modifySome;
  set6 = set5;
  setAndGet2 = setAndGet;
  update3 = update2;
  updateAndGet2 = updateAndGet;
  updateSome2 = updateSome;
  updateSomeAndGet2 = updateSomeAndGet;
  unsafeMake7 = unsafeMake6;
});

// ../../node_modules/effect/dist/esm/Tracer.js
var tracerWith2;
var init_Tracer = __esm(() => {
  init_defaultServices();
  init_tracer();
  tracerWith2 = tracerWith;
});

// ../../node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty", OP_ADD = "Add", OP_REMOVE = "Remove", OP_UPDATE = "Update", OP_AND_THEN = "AndThen", empty26, diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty26;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
}, combine10, patch9;
var init_patch = __esm(() => {
  init_Array();
  init_Equal();
  init_Function();
  init_fiberRefs();
  empty26 = {
    _tag: OP_EMPTY2
  };
  combine10 = /* @__PURE__ */ dual(2, (self, that) => ({
    _tag: OP_AND_THEN,
    first: self,
    second: that
  }));
  patch9 = /* @__PURE__ */ dual(3, (self, fiberId2, oldValue) => {
    let fiberRefs2 = oldValue;
    let patches = of(self);
    while (isNonEmptyReadonlyArray(patches)) {
      const head3 = headNonEmpty(patches);
      const tail2 = tailNonEmpty(patches);
      switch (head3._tag) {
        case OP_EMPTY2: {
          patches = tail2;
          break;
        }
        case OP_ADD: {
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.value
          });
          patches = tail2;
          break;
        }
        case OP_REMOVE: {
          fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
          patches = tail2;
          break;
        }
        case OP_UPDATE: {
          const value = getOrDefault(fiberRefs2, head3.fiberRef);
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.fiberRef.patch(head3.patch)(value)
          });
          patches = tail2;
          break;
        }
        case OP_AND_THEN: {
          patches = prepend(head3.first)(prepend(head3.second)(tail2));
          break;
        }
      }
    }
    return fiberRefs2;
  });
});

// ../../node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel", MetricLabelTypeId, MetricLabelImpl, make30 = (key, value) => {
  return new MetricLabelImpl(key, value);
}, isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);
var init_label = __esm(() => {
  init_Equal();
  init_Hash();
  init_Pipeable();
  init_Predicate();
  MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
  MetricLabelImpl = class MetricLabelImpl {
    key;
    value;
    [MetricLabelTypeId] = MetricLabelTypeId;
    _hash;
    constructor(key, value) {
      this.key = key;
      this.value = value;
      this._hash = string(MetricLabelSymbolKey + this.key + this.value);
    }
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isMetricLabel(that) && this.key === that.key && this.value === that.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs, asSome = (self) => map10(self, some2), asSomeError = (self) => mapError(self, some2), try_ = (arg) => {
  let evaluate;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
}, _catch, catchAllDefect, catchSomeCause, catchSomeDefect, catchTag, catchTags, cause = (self) => matchCause(self, {
  onFailure: identity,
  onSuccess: () => empty20
}), clockWith3, clock, delay, descriptorWith = (f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
})), allowInterrupt, descriptor, diffFiberRefs = (self) => summarized(self, fiberRefs2, diff8), diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip3(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]), Do2, bind3, bindTo3, let_3, dropUntil, dropWhile2, contextWith = (f) => map10(context(), f), eventually = (self) => orElse2(self, () => flatMap9(yieldNow(), () => eventually(self))), filterMap6, filterOrDie, filterOrDieMessage, filterOrElse, liftPredicate2, filterOrFail, findFirst6, findLoop = (iterator, index, f, value) => flatMap9(f(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next2 = iterator.next();
  if (!next2.done) {
    return findLoop(iterator, index + 1, f, next2.value);
  }
  return succeed(none2());
}), firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
}), flipWith, match7, every7, forAllLoop = (iterator, index, f) => {
  const next2 = iterator.next();
  return next2.done ? succeed(true) : flatMap9(f(next2.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
}, forever = (self) => {
  const loop = flatMap9(flatMap9(self, () => yieldNow()), () => loop);
  return loop;
}, fiberRefs2, head3 = (self) => flatMap9(self, (as3) => {
  const iterator = as3[Symbol.iterator]();
  const next2 = iterator.next();
  if (next2.done) {
    return fail2(new NoSuchElementException);
  }
  return succeed(next2.value);
}), ignore = (self) => match7(self, {
  onFailure: constVoid,
  onSuccess: constVoid
}), ignoreLogged = (self) => matchCauseEffect(self, {
  onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_2
}), inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs)), isFailure2 = (self) => match7(self, {
  onFailure: constTrue,
  onSuccess: constFalse
}), isSuccess2 = (self) => match7(self, {
  onFailure: constFalse,
  onSuccess: constTrue
}), iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap9(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
}), logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = undefined;
  for (let i = 0, len = message.length;i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== undefined) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === undefined) {
    cause2 = empty20;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_2;
  });
}, log, logTrace, logDebug, logInfo, logWarning, logError, logFatal, withLogSpan, logAnnotations, loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map10(loopInternal(initial, options.while, options.step, options.body), fromIterable2), loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), (a) => map10(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty10())), loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_2), mapAccum3, mapErrorCause, memoize = (self) => pipe(deferredMake(), flatMap9((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map10((complete2) => zipRight2(complete2, pipe(deferredAwait(deferred), flatMap9(([patch10, a]) => as2(zip3(patchFiberRefs(patch10[0]), updateRuntimeFlags(patch10[1])), a)))))))), merge5 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
}), negate = (self) => map10(self, (b) => !b), none6 = (self) => flatMap9(self, (option) => {
  switch (option._tag) {
    case "None":
      return void_2;
    case "Some":
      return fail2(new NoSuchElementException);
  }
}), once = (self) => map10(make29(true), (ref) => asVoid2(whenEffect(self, getAndSet2(ref, false)))), option = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
}), orElseFail, orElseSucceed, parallelErrors = (self) => matchCauseEffect(self, {
  onFailure: (cause2) => {
    const errors2 = fromIterable2(failures(cause2));
    return errors2.length === 0 ? failCause(cause2) : fail2(errors2);
  },
  onSuccess: succeed
}), patchFiberRefs = (patch10) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch10, patch9(fiberId2, fiberRefs3))), promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    evaluate().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}), provideService, provideServiceEffect, random2, reduce11, reduceRight3, reduceWhile, reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next2 = iterator.next();
  if (!next2.done && predicate(state)) {
    return flatMap9(f(state, next2.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
}, repeatN, repeatNLoop = (self, n) => flatMap9(self, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self, n - 1))), sandbox = (self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
}), setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3)), sleep3, succeedNone, succeedSome = (value) => succeed(some2(value)), summarized, tagMetrics, labelMetrics, takeUntil, takeWhile2, tapBoth, tapDefect, tapError, tapErrorTag, tapErrorCause, timed = (self) => timedWith(self, currentTimeNanos2), timedWith, tracerWith3, tracer, tryPromise = (arg) => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  const fail5 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail5(e)));
      } catch (e) {
        resolve(fail5(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail5(e)));
    } catch (e) {
      resolve(fail5(e));
    }
  });
}, tryMap, tryMapPromise, unless, unlessEffect, unsandbox = (self) => mapErrorCause(self, flatten6), updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_2;
}), updateService, when, whenFiberRef, whenRef, withMetric, serviceFunctionEffect = (getService, f) => (...args) => flatMap9(getService, (a) => f(a)(...args)), serviceFunction = (getService, f) => (...args) => map10(getService, (a) => f(a)(...args)), serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args) => flatMap9(getService, (s) => s[prop](...args));
  }
}), serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap9(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
}), serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
}), serviceOption = (tag) => map10(context(), getOption2(tag)), serviceOptional = (tag) => flatMap9(context(), getOption2(tag)), annotateCurrentSpan = function() {
  const args = arguments;
  return ignore(flatMap9(currentSpan, (span2) => sync(() => {
    if (typeof args[0] === "string") {
      span2.attribute(args[0], args[1]);
    } else {
      for (const key in args[0]) {
        span2.attribute(key, args[0][key]);
      }
    }
  })));
}, linkSpanCurrent = function() {
  const args = arguments;
  const links = Array.isArray(args[0]) ? args[0] : [{
    _tag: "SpanLink",
    span: args[0],
    attributes: args[1] ?? {}
  }];
  return ignore(flatMap9(currentSpan, (span2) => sync(() => span2.addLinks(links))));
}, annotateSpans, currentParentSpan, currentSpan, linkSpans, bigint03, filterDisablePropagation, unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context2 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty4(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get3(services, tracerTag);
    const clock2 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty2();
    span2 = tracer2.span(name, parent, options.context ?? empty4(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach5(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span2, options.captureStackTrace);
  }
  return span2;
}, makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
}, spanAnnotations, spanLinks, endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, exit2);
}), useSpan = (name, ...args) => {
  const options = addSpanStackTrace(args.length === 1 ? undefined : args[0]);
  const evaluate = args[args.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  });
}, withParentSpan, withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, (span2) => withParentSpan(self, span2));
  }
  return (self) => useSpan(name, options, (span2) => withParentSpan(self, span2));
}, functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split(`
`);
        cache = stack.slice(2).join(`
`).trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
}, fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value), optionFromOptional = (self) => catchAll(map10(self, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));
var init_core_effect = __esm(() => {
  init_Array();
  init_Chunk();
  init_Clock();
  init_Context();
  init_Duration();
  init_FiberRefs();
  init_Function();
  init_HashMap();
  init_HashSet();
  init_List();
  init_LogLevel();
  init_LogSpan();
  init_Option();
  init_Predicate();
  init_Ref();
  init_Tracer();
  init_Utils();
  init_cause();
  init_clock();
  init_core();
  init_defaultServices();
  init_doNotation();
  init_patch();
  init_label();
  init_runtimeFlags();
  init_tracer();
  annotateLogs = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  _catch = /* @__PURE__ */ dual(3, (self, tag, options) => catchAll(self, (e) => {
    if (hasProperty(e, tag) && e[tag] === options.failure) {
      return options.onFailure(e);
    }
    return fail2(e);
  }));
  catchAllDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return f(option.value.defect);
      }
    }
  }));
  catchSomeCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const option = f(cause);
      switch (option._tag) {
        case "None": {
          return failCause(cause);
        }
        case "Some": {
          return option.value;
        }
      }
    },
    onSuccess: succeed
  }));
  catchSomeDefect = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        const optionEffect = pf(option.value.defect);
        return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
      }
    }
  }));
  catchTag = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, ...args) => {
    const f = args[args.length - 1];
    let predicate;
    if (args.length === 2) {
      predicate = isTagged(args[0]);
    } else {
      predicate = (e) => {
        const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
        if (!tag)
          return false;
        for (let i = 0;i < args.length - 1; i++) {
          if (args[i] === tag)
            return true;
        }
        return false;
      };
    }
    return catchIf(self, predicate, f);
  });
  catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
    let keys3;
    return catchIf(self, (e) => {
      keys3 ??= Object.keys(cases);
      return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
    }, (e) => cases[e["_tag"]](e));
  });
  clockWith3 = clockWith2;
  clock = /* @__PURE__ */ clockWith3(succeed);
  delay = /* @__PURE__ */ dual(2, (self, duration) => zipRight2(sleep2(duration), self));
  allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size4(descriptor.interruptors) > 0 ? interrupt2 : void_2);
  descriptor = /* @__PURE__ */ descriptorWith(succeed);
  Do2 = /* @__PURE__ */ succeed({});
  bind3 = /* @__PURE__ */ bind(map10, flatMap9);
  bindTo3 = /* @__PURE__ */ bindTo(map10);
  let_3 = /* @__PURE__ */ let_(map10);
  dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next2;
    let dropping = succeed(false);
    let i = 0;
    while ((next2 = iterator.next()) && !next2.done) {
      const a = next2.value;
      const index = i++;
      dropping = flatMap9(dropping, (bool) => {
        if (bool) {
          builder.push(a);
          return succeed(true);
        }
        return predicate(a, index);
      });
    }
    return map10(dropping, () => builder);
  }));
  dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next2;
    let dropping = succeed(true);
    let i = 0;
    while ((next2 = iterator.next()) && !next2.done) {
      const a = next2.value;
      const index = i++;
      dropping = flatMap9(dropping, (d) => map10(d ? predicate(a, index) : succeed(false), (b) => {
        if (!b) {
          builder.push(a);
        }
        return b;
      }));
    }
    return map10(dropping, () => builder);
  }));
  filterMap6 = /* @__PURE__ */ dual(2, (elements, pf) => map10(forEachSequential(elements, identity), filterMap2(pf)));
  filterOrDie = /* @__PURE__ */ dual(3, (self, predicate, orDieWith2) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith2(a))));
  filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
  filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse3) => flatMap9(self, (a) => predicate(a) ? succeed(a) : orElse3(a)));
  liftPredicate2 = /* @__PURE__ */ dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
  filterOrFail = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
  findFirst6 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const next2 = iterator.next();
    if (!next2.done) {
      return findLoop(iterator, 0, predicate, next2.value);
    }
    return succeed(none2());
  }));
  flipWith = /* @__PURE__ */ dual(2, (self, f) => flip(f(flip(self))));
  match7 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
    onFailure: (e) => succeed(options.onFailure(e)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  every7 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
  fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
  log = /* @__PURE__ */ logWithLevel();
  logTrace = /* @__PURE__ */ logWithLevel(Trace);
  logDebug = /* @__PURE__ */ logWithLevel(Debug);
  logInfo = /* @__PURE__ */ logWithLevel(Info);
  logWarning = /* @__PURE__ */ logWithLevel(Warning);
  logError = /* @__PURE__ */ logWithLevel(Error2);
  logFatal = /* @__PURE__ */ logWithLevel(Fatal);
  withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap9(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make27(label, now)))));
  logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
  mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let result = succeed(initial);
    let next2;
    let i = 0;
    while (!(next2 = iterator.next()).done) {
      const index = i++;
      const value = next2.value;
      result = flatMap9(result, (state) => map10(f(state, value, index), ([z, b]) => {
        builder.push(b);
        return z;
      }));
    }
    return map10(result, (z) => [z, builder]);
  }));
  mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (c) => failCauseSync(() => f(c)),
    onSuccess: succeed
  }));
  orElseFail = /* @__PURE__ */ dual(2, (self, evaluate) => orElse2(self, () => failSync(evaluate)));
  orElseSucceed = /* @__PURE__ */ dual(2, (self, evaluate) => orElse2(self, () => sync(evaluate)));
  provideService = /* @__PURE__ */ dual(3, (self, tag, service) => contextWithEffect((env) => provideContext(self, add2(env, tag, service))));
  provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag, effect) => contextWithEffect((env) => flatMap9(effect, (service) => provideContext(self, pipe(env, add2(tag, service))))));
  random2 = /* @__PURE__ */ randomWith(succeed);
  reduce11 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap9(acc, (a) => f(a, el, i)), succeed(zero3)));
  reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap9(acc, (a) => f(el, a, i)), succeed(zero3)));
  reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap9(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
  repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
  sleep3 = sleep2;
  succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
  summarized = /* @__PURE__ */ dual(3, (self, summary, f) => flatMap9(summary, (start) => flatMap9(self, (value) => map10(summary, (end) => [f(start, end), value]))));
  tagMetrics = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make30(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make30(k, v)));
  });
  labelMetrics = /* @__PURE__ */ dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union(old, labels)));
  takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next2;
    let effect = succeed(false);
    let i = 0;
    while ((next2 = iterator.next()) && !next2.done) {
      const a = next2.value;
      const index = i++;
      effect = flatMap9(effect, (bool) => {
        if (bool) {
          return succeed(true);
        }
        builder.push(a);
        return predicate(a, index);
      });
    }
    return map10(effect, () => builder);
  }));
  takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next2;
    let taking = succeed(true);
    let i = 0;
    while ((next2 = iterator.next()) && !next2.done) {
      const a = next2.value;
      const index = i++;
      taking = flatMap9(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map10((bool) => {
        if (bool) {
          builder.push(a);
        }
        return bool;
      })));
    }
    return map10(taking, () => builder);
  }));
  tapBoth = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => matchCauseEffect(self, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left": {
          return zipRight2(onFailure(either3.left), failCause(cause2));
        }
        case "Right": {
          return failCause(cause2);
        }
      }
    },
    onSuccess: (a) => as2(onSuccess(a), a)
  }));
  tapDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause2) => match2(keepDefects(cause2), {
    onNone: () => failCause(cause2),
    onSome: (a) => zipRight2(f(a), failCause(cause2))
  })));
  tapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left":
          return zipRight2(f(either3.left), failCause(cause2));
        case "Right":
          return failCause(cause2);
      }
    },
    onSuccess: succeed
  }));
  tapErrorTag = /* @__PURE__ */ dual(3, (self, k, f) => tapError(self, (e) => {
    if (isTagged(e, k)) {
      return f(e);
    }
    return void_2;
  }));
  tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause2) => zipRight2(f(cause2), failCause(cause2)),
    onSuccess: succeed
  }));
  timedWith = /* @__PURE__ */ dual(2, (self, nanos2) => summarized(self, nanos2, (start, end) => nanos(end - start)));
  tracerWith3 = tracerWith2;
  tracer = /* @__PURE__ */ tracerWith3(succeed);
  tryMap = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => try_({
    try: () => options.try(a),
    catch: options.catch
  })));
  tryMapPromise = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => tryPromise({
    try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
    catch: options.catch
  })));
  unless = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
  unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap9(condition, (b) => b ? succeedNone : asSome(self)));
  updateService = /* @__PURE__ */ dual(3, (self, tag, f) => mapInputContext(self, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
  when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map10(self, some2) : succeed(none2())));
  whenFiberRef = /* @__PURE__ */ dual(3, (self, fiberRef, predicate) => flatMap9(fiberRefGet(fiberRef), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
  whenRef = /* @__PURE__ */ dual(3, (self, ref, predicate) => flatMap9(get12(ref), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
  withMetric = /* @__PURE__ */ dual(2, (self, metric) => metric(self));
  annotateSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
  currentSpan = /* @__PURE__ */ flatMap9(/* @__PURE__ */ context(), (context2) => {
    const span2 = context2.unsafeMap.get(spanTag.key);
    return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
  });
  linkSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, span2, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append2({
    _tag: "SpanLink",
    span: span2,
    attributes: attributes ?? {}
  })));
  bigint03 = /* @__PURE__ */ BigInt(0);
  filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
  spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
  spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
  withParentSpan = /* @__PURE__ */ dual(2, (self, span2) => provideService(self, spanTag, span2));
});

// ../../node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential", OP_PARALLEL2 = "Parallel", OP_PARALLEL_N = "ParallelN", sequential2, parallel2, parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
}), isSequential = (self) => self._tag === OP_SEQUENTIAL2, isParallel = (self) => self._tag === OP_PARALLEL2;
var init_executionStrategy = __esm(() => {
  init_Function();
  sequential2 = {
    _tag: OP_SEQUENTIAL2
  };
  parallel2 = {
    _tag: OP_PARALLEL2
  };
});

// ../../node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3, parallel3, parallelN2;
var init_ExecutionStrategy = __esm(() => {
  init_executionStrategy();
  sequential3 = sequential2;
  parallel3 = parallel2;
  parallelN2 = parallelN;
});

// ../../node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9, patch10;
var init_FiberRefsPatch = __esm(() => {
  init_patch();
  diff9 = diff8;
  patch10 = patch9;
});

// ../../node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus", FiberStatusTypeId, OP_DONE = "Done", OP_RUNNING = "Running", OP_SUSPENDED = "Suspended", DoneHash, Done, Running, Suspended, done3, running = (runtimeFlags2) => new Running(runtimeFlags2), suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn), isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId), isDone2 = (self) => self._tag === OP_DONE, isRunning = (self) => self._tag === OP_RUNNING, isSuspended = (self) => self._tag === OP_SUSPENDED;
var init_fiberStatus = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Predicate();
  FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
  DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
  Done = class Done {
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_DONE;
    [symbol]() {
      return DoneHash;
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_DONE;
    }
  };
  Running = class Running {
    runtimeFlags;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_RUNNING;
    constructor(runtimeFlags2) {
      this.runtimeFlags = runtimeFlags2;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
    }
  };
  Suspended = class Suspended {
    runtimeFlags;
    blockingOn;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_SUSPENDED;
    constructor(runtimeFlags2, blockingOn) {
      this.runtimeFlags = runtimeFlags2;
      this.blockingOn = blockingOn;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
    }
  };
  done3 = /* @__PURE__ */ new Done;
});

// ../../node_modules/effect/dist/esm/FiberStatus.js
var done4, running2, suspended2, isDone3, isRunning2, isSuspended2;
var init_FiberStatus = __esm(() => {
  init_fiberStatus();
  done4 = done3;
  running2 = running;
  suspended2 = suspended;
  isDone3 = isDone2;
  isRunning2 = isRunning;
  isSuspended2 = isSuspended;
});

// ../../node_modules/effect/dist/esm/Micro.js
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length;i < len; i++) {
      tasks[i]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var TypeId15, MicroExitTypeId, MicroCauseTypeId, microCauseVariance, MicroCauseImpl, Die, causeDie = (defect, traces = []) => new Die(defect, traces), Interrupt, causeInterrupt = (traces = []) => new Interrupt(traces), causeIsInterrupt = (self) => self._tag === "Interrupt", MicroFiberTypeId, fiberVariance, MicroFiberImpl, fiberMiddleware, identifier, args, evaluate, successCont, failureCont, ensureCont, Yield, microVariance, MicroProto, makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
}), makePrimitive = (options) => {
  const Proto2 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto2);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
}, makeExit = (options) => {
  const Proto2 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self = Object.create(Proto2);
    self[args] = value;
    self[successCont] = undefined;
    self[failureCont] = undefined;
    self[ensureCont] = undefined;
    return self;
  };
}, succeed4, failCause4, yieldNowWith, yieldNow2, void_4, withMicroFiber, flatMap10, OnSuccessProto, isMicroExit = (u) => hasProperty(u, MicroExitTypeId), exitSucceed2, exitFailCause2, exitInterrupt2, exitDie2 = (defect) => exitFailCause2(causeDie(defect)), exitVoid2, setImmediate, updateContext, provideContext2, MaxOpsBeforeYield, CurrentScheduler, matchCauseEffect2, OnSuccessAndFailureProto, onExit2, setInterruptible, interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self;
}), uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
}), runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};
var init_Micro = __esm(() => {
  init_Array();
  init_Context();
  init_Effectable();
  init_Either();
  init_Equal();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_Inspectable();
  init_context();
  init_doNotation();
  init_effectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Utils();
  TypeId15 = /* @__PURE__ */ Symbol.for("effect/Micro");
  MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
  MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
  microCauseVariance = {
    _E: identity
  };
  MicroCauseImpl = class MicroCauseImpl extends globalThis.Error {
    _tag;
    traces;
    [MicroCauseTypeId];
    constructor(_tag, originalError, traces) {
      const causeName = `MicroCause.${_tag}`;
      let name;
      let message;
      let stack;
      if (originalError instanceof globalThis.Error) {
        name = `(${causeName}) ${originalError.name}`;
        message = originalError.message;
        const messageLines = message.split(`
`).length;
        stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
      } else {
        name = causeName;
        message = toStringUnknown(originalError, 0);
        stack = `${name}: ${message}`;
      }
      if (traces.length > 0) {
        stack += `
    ${traces.join(`
    `)}`;
      }
      super(message);
      this._tag = _tag;
      this.traces = traces;
      this[MicroCauseTypeId] = microCauseVariance;
      this.name = name;
      this.stack = stack;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toString() {
      return this.stack;
    }
    [NodeInspectSymbol]() {
      return this.stack;
    }
  };
  Die = class Die extends MicroCauseImpl {
    defect;
    constructor(defect, traces = []) {
      super("Die", defect, traces);
      this.defect = defect;
    }
  };
  Interrupt = class Interrupt extends MicroCauseImpl {
    constructor(traces = []) {
      super("Interrupt", "interrupted", traces);
    }
  };
  MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
  fiberVariance = {
    _A: identity,
    _E: identity
  };
  MicroFiberImpl = class MicroFiberImpl {
    context;
    interruptible;
    [MicroFiberTypeId];
    _stack = [];
    _observers = [];
    _exit;
    _children;
    currentOpCount = 0;
    constructor(context2, interruptible3 = true) {
      this.context = context2;
      this.interruptible = interruptible3;
      this[MicroFiberTypeId] = fiberVariance;
    }
    getRef(ref) {
      return unsafeGetReference(this.context, ref);
    }
    addObserver(cb) {
      if (this._exit) {
        cb(this._exit);
        return constVoid;
      }
      this._observers.push(cb);
      return () => {
        const index = this._observers.indexOf(cb);
        if (index >= 0) {
          this._observers.splice(index, 1);
        }
      };
    }
    _interrupted = false;
    unsafeInterrupt() {
      if (this._exit) {
        return;
      }
      this._interrupted = true;
      if (this.interruptible) {
        this.evaluate(exitInterrupt2);
      }
    }
    unsafePoll() {
      return this._exit;
    }
    evaluate(effect) {
      if (this._exit) {
        return;
      } else if (this._yielded !== undefined) {
        const yielded = this._yielded;
        this._yielded = undefined;
        yielded();
      }
      const exit2 = this.runLoop(effect);
      if (exit2 === Yield) {
        return;
      }
      const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
      if (interruptChildren !== undefined) {
        return this.evaluate(flatMap10(interruptChildren, () => exit2));
      }
      this._exit = exit2;
      for (let i = 0;i < this._observers.length; i++) {
        this._observers[i](exit2);
      }
      this._observers.length = 0;
    }
    runLoop(effect) {
      let yielding = false;
      let current = effect;
      this.currentOpCount = 0;
      try {
        while (true) {
          this.currentOpCount++;
          if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
            yielding = true;
            const prev = current;
            current = flatMap10(yieldNow2, () => prev);
          }
          current = current[evaluate](this);
          if (current === Yield) {
            const yielded = this._yielded;
            if (MicroExitTypeId in yielded) {
              this._yielded = undefined;
              return yielded;
            }
            return Yield;
          }
        }
      } catch (error) {
        if (!hasProperty(current, evaluate)) {
          return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
        }
        return exitDie2(error);
      }
    }
    getCont(symbol3) {
      while (true) {
        const op = this._stack.pop();
        if (!op)
          return;
        const cont = op[ensureCont] && op[ensureCont](this);
        if (cont)
          return {
            [symbol3]: cont
          };
        if (op[symbol3])
          return op;
      }
    }
    _yielded = undefined;
    yieldWith(value) {
      this._yielded = value;
      return Yield;
    }
    children() {
      return this._children ??= new Set;
    }
  };
  fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
    interruptChildren: undefined
  }));
  identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
  args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
  evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
  successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
  failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
  ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
  Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
  microVariance = {
    _A: identity,
    _E: identity,
    _R: identity
  };
  MicroProto = {
    ...EffectPrototype2,
    _op: "Micro",
    [TypeId15]: microVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    toJSON() {
      return {
        _id: "Micro",
        op: this[identifier],
        ...args in this ? {
          args: this[args]
        } : undefined
      };
    },
    toString() {
      return format(this);
    },
    [NodeInspectSymbol]() {
      return format(this);
    }
  };
  succeed4 = /* @__PURE__ */ makeExit({
    op: "Success",
    prop: "value",
    eval(fiber) {
      const cont = fiber.getCont(successCont);
      return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  failCause4 = /* @__PURE__ */ makeExit({
    op: "Failure",
    prop: "cause",
    eval(fiber) {
      let cont = fiber.getCont(failureCont);
      while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
        cont = fiber.getCont(failureCont);
      }
      return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  yieldNowWith = /* @__PURE__ */ makePrimitive({
    op: "Yield",
    eval(fiber) {
      let resumed = false;
      fiber.getRef(CurrentScheduler).scheduleTask(() => {
        if (resumed)
          return;
        fiber.evaluate(exitVoid2);
      }, this[args] ?? 0);
      return fiber.yieldWith(() => {
        resumed = true;
      });
    }
  });
  yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
  void_4 = /* @__PURE__ */ succeed4(undefined);
  withMicroFiber = /* @__PURE__ */ makePrimitive({
    op: "WithMicroFiber",
    eval(fiber) {
      return this[args](fiber);
    }
  });
  flatMap10 = /* @__PURE__ */ dual(2, (self, f) => {
    const onSuccess = Object.create(OnSuccessProto);
    onSuccess[args] = self;
    onSuccess[successCont] = f;
    return onSuccess;
  });
  OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccess",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  exitSucceed2 = succeed4;
  exitFailCause2 = failCause4;
  exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
  exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
  setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
  updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
    const prev = fiber.context;
    fiber.context = f(prev);
    return onExit2(self, () => {
      fiber.context = prev;
      return void_4;
    });
  }));
  provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
  MaxOpsBeforeYield = class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
    defaultValue: () => 2048
  })) {
  };
  CurrentScheduler = class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
    defaultValue: () => new MicroSchedulerDefault
  })) {
  };
  matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options) => {
    const primitive = Object.create(OnSuccessAndFailureProto);
    primitive[args] = self;
    primitive[successCont] = options.onSuccess;
    primitive[failureCont] = options.onFailure;
    return primitive;
  });
  OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccessAndFailure",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
    onFailure: (cause2) => flatMap10(f(exitFailCause2(cause2)), () => failCause4(cause2)),
    onSuccess: (a) => flatMap10(f(exitSucceed2(a)), () => succeed4(a))
  })));
  setInterruptible = /* @__PURE__ */ makePrimitive({
    op: "SetInterruptible",
    ensure(fiber) {
      fiber.interruptible = this[args];
      if (fiber._interrupted && fiber.interruptible) {
        return () => exitInterrupt2;
      }
    }
  });
});

// ../../node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (;index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0;i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
var defaultScheduler, currentScheduler, withScheduler;
var init_Scheduler = __esm(() => {
  init_Function();
  init_GlobalValue();
  init_core();
  defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
  currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
  withScheduler = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));
});

// ../../node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap;
var init_completedRequestMap = __esm(() => {
  init_GlobalValue();
  init_core();
  currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));
});

// ../../node_modules/effect/dist/esm/internal/concurrency.js
var match9 = (concurrency, sequential4, unbounded2, bounded2) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded2();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded2(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded2(concurrency) : sequential4();
  }
}, matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};
var init_concurrency = __esm(() => {
  init_core();
});

// ../../node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal", OP_STATEFUL = "Stateful", OP_RESUME = "Resume", OP_YIELD_NOW = "YieldNow", interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
}), stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
}), resume = (effect) => ({
  _tag: OP_RESUME,
  effect
}), yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// ../../node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope", FiberScopeTypeId, Global, Local, unsafeMake8 = (fiber) => {
  return new Local(fiber.id(), fiber);
}, globalScope;
var init_fiberScope = __esm(() => {
  init_FiberId();
  init_GlobalValue();
  FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
  Global = class Global {
    [FiberScopeTypeId] = FiberScopeTypeId;
    fiberId = none4;
    roots = /* @__PURE__ */ new Set;
    add(_runtimeFlags, child) {
      this.roots.add(child);
      child.addObserver(() => {
        this.roots.delete(child);
      });
    }
  };
  Local = class Local {
    fiberId;
    parent;
    [FiberScopeTypeId] = FiberScopeTypeId;
    constructor(fiberId2, parent) {
      this.fiberId = fiberId2;
      this.parent = parent;
    }
    add(_runtimeFlags, child) {
      this.parent.tell(stateful((parentFiber) => {
        parentFiber.addChild(child);
        child.addObserver(() => {
          parentFiber.removeChild(child);
        });
      }));
    }
  };
  globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);
});

// ../../node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber", FiberTypeId, fiberVariance2, fiberProto, RuntimeFiberSymbolKey = "effect/Fiber", RuntimeFiberTypeId, Order3, isFiber = (u) => hasProperty(u, FiberTypeId), isRuntimeFiber = (self) => (RuntimeFiberTypeId in self), _await2 = (self) => self.await, children = (self) => self.children, done5 = (exit2) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit2),
    children: succeed([]),
    inheritAll: void_2,
    poll: succeed(some2(exit2)),
    interruptAsFork: () => void_2
  };
  return _fiber;
}, dump = (self) => map10(self.status, (status) => ({
  id: self.id(),
  status
})), dumpAll = (fibers) => forEachSequential(fibers, dump), fail5 = (error) => done5(fail4(error)), failCause5 = (cause2) => done5(failCause3(cause2)), fromEffect = (effect) => map10(exit(effect), done5), id = (self) => self.id(), inheritAll = (self) => self.inheritAll, interrupted = (fiberId2) => done5(interrupt4(fiberId2)), interruptAll = (fibers) => flatMap9(fiberId, (fiberId2) => pipe(fibers, interruptAllAs(fiberId2))), interruptAllAs, interruptAsFork, join3 = (self) => zipLeft2(flatten7(self.await), self.inheritAll), map12, mapEffect, mapFiber, match10, _never, never2, orElse3, orElseEither2, poll3 = (self) => self.poll, parseMs = (milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 86400000),
    hours: roundTowardsZero(milliseconds / 3600000) % 24,
    minutes: roundTowardsZero(milliseconds / 60000) % 60,
    seconds: roundTowardsZero(milliseconds / 1000) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1000,
    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000
  };
}, renderStatus = (status) => {
  if (isDone3(status)) {
    return "Done";
  }
  if (isRunning2(status)) {
    return "Running";
  }
  const isInterruptible = interruptible(status.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
}, pretty2 = (self) => flatMap9(currentTimeMillis2, (now) => map10(dump(self), (dump2) => {
  const time = now - dump2.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump2.status) ? (() => {
    const ids3 = ids2(dump2.status.blockingOn);
    return size4(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id2) => `${id2}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump2.status);
  return `[Fiber](#${dump2.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
})), unsafeRoots = () => Array.from(globalScope.roots), roots, status = (self) => self.status, succeed5 = (value) => done5(succeed3(value)), void_5, currentFiberURI = "effect/FiberCurrent", getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);
var init_fiber = __esm(() => {
  init_Clock();
  init_Either();
  init_Exit();
  init_FiberId();
  init_FiberStatus();
  init_Function();
  init_HashSet();
  init_Number();
  init_Option();
  init_Order();
  init_Pipeable();
  init_Predicate();
  init_core();
  init_effectable();
  init_fiberScope();
  init_runtimeFlags();
  FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
  fiberVariance2 = {
    _E: (_) => _,
    _A: (_) => _
  };
  fiberProto = {
    [FiberTypeId]: fiberVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
  Order3 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple(Order, Order), /* @__PURE__ */ mapInput2((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
  interruptAllAs = /* @__PURE__ */ dual(2, (fibers, fiberId2) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId2)), zipRight2(pipe(fibers, forEachSequentialDiscard(_await2)))));
  interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId2) => self.interruptAsFork(fiberId2));
  map12 = /* @__PURE__ */ dual(2, (self, f) => mapEffect(self, (a) => sync(() => f(a))));
  mapEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const _fiber = {
      ...CommitPrototype,
      commit() {
        return join3(this);
      },
      ...fiberProto,
      id: () => self.id(),
      await: flatMap9(self.await, forEachEffect(f)),
      children: self.children,
      inheritAll: self.inheritAll,
      poll: flatMap9(self.poll, (result) => {
        switch (result._tag) {
          case "None":
            return succeed(none2());
          case "Some":
            return pipe(forEachEffect(result.value, f), map10(some2));
        }
      }),
      interruptAsFork: (id2) => self.interruptAsFork(id2)
    };
    return _fiber;
  });
  mapFiber = /* @__PURE__ */ dual(2, (self, f) => map10(self.await, match6({
    onFailure: (cause2) => failCause5(cause2),
    onSuccess: (a) => f(a)
  })));
  match10 = /* @__PURE__ */ dual(2, (self, {
    onFiber,
    onRuntimeFiber
  }) => {
    if (isRuntimeFiber(self)) {
      return onRuntimeFiber(self);
    }
    return onFiber(self);
  });
  _never = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: never,
    children: /* @__PURE__ */ succeed([]),
    inheritAll: never,
    poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
    interruptAsFork: () => never
  };
  never2 = _never;
  orElse3 = /* @__PURE__ */ dual(2, (self, that) => ({
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => getOrElse5(self.id(), that.id()),
    await: zipWith4(self.await, that.await, (exit1, exit2) => isSuccess(exit1) ? exit1 : exit2),
    children: self.children,
    inheritAll: zipRight2(that.inheritAll, self.inheritAll),
    poll: zipWith4(self.poll, that.poll, (option1, option2) => {
      switch (option1._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          return isSuccess(option1.value) ? option1 : option2;
        }
      }
    }),
    interruptAsFork: (id2) => pipe(interruptAsFiber(self, id2), zipRight2(pipe(that, interruptAsFiber(id2))), asVoid2)
  }));
  orElseEither2 = /* @__PURE__ */ dual(2, (self, that) => orElse3(map12(self, left2), map12(that, right2)));
  roots = /* @__PURE__ */ sync(unsafeRoots);
  void_5 = /* @__PURE__ */ succeed5(undefined);
});

// ../../node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger", LoggerTypeId, loggerVariance, makeLogger = (log2) => ({
  [LoggerTypeId]: loggerVariance,
  log: log2,
  pipe() {
    return pipeArguments(this, arguments);
  }
}), none7, textOnly, format4 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format5 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append4 = (label, value) => " " + format5(label, value);
  let out = format5("timestamp", date.toISOString());
  out += append4("level", logLevel.label);
  out += append4("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0;i < messages.length; i++) {
    out += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out += " " + render(date.getTime())(span2);
  }
  for (const [label, value] of annotations2) {
    out += append4(label, toStringUnknown(value, whitespace));
  }
  return out;
}, escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, stringLogger, colors, logLevelColors, hasProcessStdout, processStdoutIsTTY, hasProcessStdoutOrDeno;
var init_logger = __esm(() => {
  init_Array();
  init_Context();
  init_FiberRefs();
  init_Function();
  init_GlobalValue();
  init_HashMap();
  init_Inspectable();
  init_List();
  init_Option();
  init_Pipeable();
  init_cause();
  init_defaultServices();
  init_console();
  init_fiberId();
  LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
  loggerVariance = {
    _Message: (_) => _,
    _Output: (_) => _
  };
  none7 = {
    [LoggerTypeId]: loggerVariance,
    log: constVoid,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  textOnly = /^[^\s"=]*$/;
  stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(escapeDoubleQuotes));
  colors = {
    bold: "1",
    red: "31",
    green: "32",
    yellow: "33",
    blue: "34",
    cyan: "36",
    white: "37",
    gray: "90",
    black: "30",
    bgBrightRed: "101"
  };
  logLevelColors = {
    None: [],
    All: [],
    Trace: [colors.gray],
    Debug: [colors.blue],
    Info: [colors.green],
    Warning: [colors.yellow],
    Error: [colors.red],
    Fatal: [colors.bgBrightRed, colors.black]
  };
  hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
  processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
  hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
});

// ../../node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries", MetricBoundariesTypeId, MetricBoundariesImpl, isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId), fromIterable8 = (iterable) => {
  const values4 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values4);
}, exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable8);
var init_boundaries = __esm(() => {
  init_Array();
  init_Chunk();
  init_Equal();
  init_Function();
  init_Hash();
  init_Pipeable();
  init_Predicate();
  MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
  MetricBoundariesImpl = class MetricBoundariesImpl {
    values;
    [MetricBoundariesTypeId] = MetricBoundariesTypeId;
    constructor(values4) {
      this.values = values4;
      this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricBoundaries(u) && equals(this.values, u.values);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType", MetricKeyTypeTypeId, CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter", CounterKeyTypeTypeId, FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency", FrequencyKeyTypeTypeId, GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge", GaugeKeyTypeTypeId, HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram", HistogramKeyTypeTypeId, SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary", SummaryKeyTypeTypeId, metricKeyTypeVariance, CounterKeyType, HistogramKeyType, counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false), histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
}, isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId), isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId), isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId), isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId), isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);
var init_keyType = __esm(() => {
  init_Duration();
  init_Equal();
  init_Function();
  init_Hash();
  init_Pipeable();
  init_Predicate();
  MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
  CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
  FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
  GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
  HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
  SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
  metricKeyTypeVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };
  CounterKeyType = class CounterKeyType {
    incremental;
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
    constructor(incremental, bigint3) {
      this.incremental = incremental;
      this.bigint = bigint3;
      this._hash = string(CounterKeyTypeSymbolKey);
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isCounterKey(that);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  HistogramKeyType = class HistogramKeyType {
    boundaries;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
    constructor(boundaries) {
      this.boundaries = boundaries;
      this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey", MetricKeyTypeId, metricKeyVariance, arrayEquivilence, MetricKeyImpl, isMetricKey = (u) => hasProperty(u, MetricKeyTypeId), counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description)), histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description)), taggedWithLabels;
var init_key = __esm(() => {
  init_Array();
  init_Equal();
  init_Function();
  init_Hash();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_keyType();
  init_label();
  MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
  metricKeyVariance = {
    _Type: (_) => _
  };
  arrayEquivilence = /* @__PURE__ */ getEquivalence2(equals);
  MetricKeyImpl = class MetricKeyImpl {
    name;
    keyType;
    description;
    tags;
    [MetricKeyTypeId] = metricKeyVariance;
    constructor(name, keyType, description, tags = []) {
      this.name = name;
      this.keyType = keyType;
      this.description = description;
      this.tags = tags;
      this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));
});

// ../../node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState", MetricStateTypeId, CounterStateSymbolKey = "effect/MetricState/Counter", CounterStateTypeId, FrequencyStateSymbolKey = "effect/MetricState/Frequency", FrequencyStateTypeId, GaugeStateSymbolKey = "effect/MetricState/Gauge", GaugeStateTypeId, HistogramStateSymbolKey = "effect/MetricState/Histogram", HistogramStateTypeId, SummaryStateSymbolKey = "effect/MetricState/Summary", SummaryStateTypeId, metricStateVariance, CounterState, arrayEquals, FrequencyState, GaugeState, HistogramState, SummaryState, counter3 = (count) => new CounterState(count), frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
}, gauge2 = (count) => new GaugeState(count), histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum), summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum), isCounterState = (u) => hasProperty(u, CounterStateTypeId), isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId), isGaugeState = (u) => hasProperty(u, GaugeStateTypeId), isHistogramState = (u) => hasProperty(u, HistogramStateTypeId), isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);
var init_state = __esm(() => {
  init_Array();
  init_Equal();
  init_Function();
  init_Hash();
  init_Pipeable();
  init_Predicate();
  MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
  CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
  FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
  GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
  HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
  SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
  metricStateVariance = {
    _A: (_) => _
  };
  CounterState = class CounterState {
    count;
    [MetricStateTypeId] = metricStateVariance;
    [CounterStateTypeId] = CounterStateTypeId;
    constructor(count) {
      this.count = count;
    }
    [symbol]() {
      return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
    }
    [symbol2](that) {
      return isCounterState(that) && this.count === that.count;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  arrayEquals = /* @__PURE__ */ getEquivalence2(equals);
  FrequencyState = class FrequencyState {
    occurrences;
    [MetricStateTypeId] = metricStateVariance;
    [FrequencyStateTypeId] = FrequencyStateTypeId;
    constructor(occurrences) {
      this.occurrences = occurrences;
    }
    _hash;
    [symbol]() {
      return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable2(this.occurrences.entries()))), cached(this));
    }
    [symbol2](that) {
      return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  GaugeState = class GaugeState {
    value;
    [MetricStateTypeId] = metricStateVariance;
    [GaugeStateTypeId] = GaugeStateTypeId;
    constructor(value) {
      this.value = value;
    }
    [symbol]() {
      return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
    }
    [symbol2](u) {
      return isGaugeState(u) && this.value === u.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  HistogramState = class HistogramState {
    buckets;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [HistogramStateTypeId] = HistogramStateTypeId;
    constructor(buckets, count, min2, max2, sum2) {
      this.buckets = buckets;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  SummaryState = class SummaryState {
    error;
    quantiles;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [SummaryStateTypeId] = SummaryStateTypeId;
    constructor(error, quantiles, count, min2, max2, sum2) {
      this.error = error;
      this.quantiles = quantiles;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook", MetricHookTypeId, metricHookVariance, make31 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
}), bigint04, counter4 = (key) => {
  let sum2 = key.keyType.bigint ? bigint04 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint04 : (value) => value >= 0 : (_value) => true;
  const update4 = (value) => {
    if (canUpdate(value)) {
      sum2 = sum2 + value;
    }
  };
  return make31({
    get: () => counter3(sum2),
    update: update4,
    modify: update4
  });
}, frequency3 = (key) => {
  const values4 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values4.set(word, 0);
  }
  const update4 = (word) => {
    const slotCount = values4.get(word) ?? 0;
    values4.set(word, slotCount + 1);
  };
  return make31({
    get: () => frequency2(values4),
    update: update4,
    modify: update4
  });
}, gauge3 = (_key, startAt) => {
  let value = startAt;
  return make31({
    get: () => gauge2(value),
    update: (v) => {
      value = v;
    },
    modify: (v) => {
      value = value + v;
    }
  });
}, histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size7 = bounds.length;
  const values4 = new Uint32Array(size7 + 1);
  const boundaries = new Float32Array(size7);
  let count = 0;
  let sum2 = 0;
  let min2 = Number.MAX_VALUE;
  let max2 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update4 = (value) => {
    let from = 0;
    let to = size7;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values4[from] = values4[from] + 1;
    count = count + 1;
    sum2 = sum2 + value;
    if (value < min2) {
      min2 = value;
    }
    if (value > max2) {
      max2 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size7);
    let cumulated = 0;
    for (let i = 0;i < size7; i++) {
      const boundary = boundaries[i];
      const value = values4[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make31({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: update4,
    modify: update4
  });
}, summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values4 = allocate(maxSize);
  let head4 = 0;
  let count = 0;
  let sum2 = 0;
  let min2 = 0;
  let max2 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values4[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo2(age, zero2) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head4 = head4 + 1;
      const target = head4 % maxSize;
      values4[target] = [timestamp, value];
    }
    min2 = count === 0 ? value : Math.min(min2, value);
    max2 = count === 0 ? value : Math.max(max2, value);
    count = count + 1;
    sum2 = sum2 + value;
  };
  return make31({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
}, calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head4 = sortedQuantiles[0];
  const tail2 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
  const resolved = of(resolvedHead);
  tail2.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
}, resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var init_hook = __esm(() => {
  init_Array();
  init_Duration();
  init_Function();
  init_Number();
  init_Option();
  init_Pipeable();
  init_state();
  MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
  metricHookVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };
  bigint04 = /* @__PURE__ */ BigInt(0);
});

// ../../node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair", MetricPairTypeId, metricPairVariance, unsafeMake9 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};
var init_pair = __esm(() => {
  init_Pipeable();
  MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
  metricPairVariance = {
    _Type: (_) => _
  };
});

// ../../node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry", MetricRegistryTypeId, MetricRegistryImpl, make32 = () => {
  return new MetricRegistryImpl;
};
var init_registry = __esm(() => {
  init_Function();
  init_MutableHashMap();
  init_Option();
  init_hook();
  init_keyType();
  init_pair();
  MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
  MetricRegistryImpl = class MetricRegistryImpl {
    [MetricRegistryTypeId] = MetricRegistryTypeId;
    map = /* @__PURE__ */ empty21();
    snapshot() {
      const result = [];
      for (const [key, hook] of this.map) {
        result.push(unsafeMake9(key, hook.get()));
      }
      return result;
    }
    get(key) {
      const hook = pipe(this.map, get8(key), getOrUndefined);
      if (hook == null) {
        if (isCounterKey(key.keyType)) {
          return this.getCounter(key);
        }
        if (isGaugeKey(key.keyType)) {
          return this.getGauge(key);
        }
        if (isFrequencyKey(key.keyType)) {
          return this.getFrequency(key);
        }
        if (isHistogramKey(key.keyType)) {
          return this.getHistogram(key);
        }
        if (isSummaryKey(key.keyType)) {
          return this.getSummary(key);
        }
        throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
      } else {
        return hook;
      }
    }
    getCounter(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const counter5 = counter4(key);
        if (!pipe(this.map, has5(key))) {
          pipe(this.map, set4(key, counter5));
        }
        value = counter5;
      }
      return value;
    }
    getFrequency(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const frequency4 = frequency3(key);
        if (!pipe(this.map, has5(key))) {
          pipe(this.map, set4(key, frequency4));
        }
        value = frequency4;
      }
      return value;
    }
    getGauge(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
        if (!pipe(this.map, has5(key))) {
          pipe(this.map, set4(key, gauge4));
        }
        value = gauge4;
      }
      return value;
    }
    getHistogram(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const histogram5 = histogram4(key);
        if (!pipe(this.map, has5(key))) {
          pipe(this.map, set4(key, histogram5));
        }
        value = histogram5;
      }
      return value;
    }
    getSummary(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const summary4 = summary3(key);
        if (!pipe(this.map, has5(key))) {
          pipe(this.map, set4(key, summary4));
        }
        value = summary4;
      }
      return value;
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric", MetricTypeId, metricVariance, globalMetricRegistry, make33 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap2(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
}, counter5 = (name, options) => fromMetricKey(counter2(name, options)), fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make33(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
}, histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description)), tagged, taggedWithLabels2, update4;
var init_metric = __esm(() => {
  init_Array();
  init_Clock();
  init_Duration();
  init_Function();
  init_GlobalValue();
  init_Pipeable();
  init_cause();
  init_core_effect();
  init_core();
  init_boundaries();
  init_key();
  init_keyType();
  init_label();
  init_registry();
  MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
  metricVariance = {
    _Type: (_) => _,
    _In: (_) => _,
    _Out: (_) => _
  };
  globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make32());
  tagged = /* @__PURE__ */ dual(3, (self, key, value) => taggedWithLabels2(self, [make30(key, value)]));
  taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
    return make33(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
  });
  update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self.unsafeUpdate(input, tags))));
});

// ../../node_modules/effect/dist/esm/internal/request.js
class Listeners {
  count = 0;
  observers = /* @__PURE__ */ new Set;
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
}
var RequestSymbolKey = "effect/Request", RequestTypeId, requestVariance, RequestPrototype, isRequest = (u) => hasProperty(u, RequestTypeId), complete2;
var init_request = __esm(() => {
  init_Function();
  init_Predicate();
  init_completedRequestMap();
  init_core();
  init_effectable();
  RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
  requestVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  RequestPrototype = {
    ...StructuralPrototype,
    [RequestTypeId]: requestVariance
  };
  complete2 = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map13) => sync(() => {
    if (map13.has(self)) {
      const entry = map13.get(self);
      if (!entry.state.completed) {
        entry.state.completed = true;
        deferredUnsafeDone(entry.result, result);
      }
    }
  })));
});

// ../../node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
class RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self, stack, direction) {
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2;s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
}
var Direction;
var init_iterator = __esm(() => {
  init_Array();
  init_Option();
  Direction = {
    Forward: 0,
    Backward: 1 << 0
  };
});

// ../../node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color;
var init_node2 = __esm(() => {
  Color = {
    Red: 0,
    Black: 1 << 0
  };
});

// ../../node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree", RedBlackTreeTypeId, redBlackTreeVariance, RedBlackTreeProto, isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId), keysForward = (self) => keys3(self, Direction.Forward), keys3 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys3(self, direction),
    next: () => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var init_redBlackTree = __esm(() => {
  init_Chunk();
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_iterator();
  init_node2();
  RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
  redBlackTreeVariance = {
    _Key: (_) => _,
    _Value: (_) => _
  };
  RedBlackTreeProto = {
    [RedBlackTreeTypeId]: redBlackTreeVariance,
    [symbol]() {
      let hash2 = hash(RedBlackTreeSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
      }
      return cached(this, hash2);
    },
    [symbol2](that) {
      if (isRedBlackTree(that)) {
        if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
          return false;
        }
        const entries3 = Array.from(that);
        return Array.from(this).every((itemSelf, i) => {
          const itemThat = entries3[i];
          return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
        });
      }
      return false;
    },
    [Symbol.iterator]() {
      const stack = [];
      let n = this._root;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
      return new RedBlackTreeIterator(this, stack, Direction.Forward);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "RedBlackTree",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/RedBlackTree.js
var keys4;
var init_RedBlackTree = __esm(() => {
  init_redBlackTree();
  init_iterator();
  keys4 = keysForward;
});

// ../../node_modules/effect/dist/esm/SortedSet.js
var TypeId16, SortedSetProto, isSortedSet = (u) => hasProperty(u, TypeId16);
var init_SortedSet = __esm(() => {
  init_Equal();
  init_Function();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Pipeable();
  init_Predicate();
  init_RedBlackTree();
  TypeId16 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
  SortedSetProto = {
    [TypeId16]: {
      _A: (_) => _
    },
    [symbol]() {
      return pipe(hash(this.keyTree), combine(hash(TypeId16)), cached(this));
    },
    [symbol2](that) {
      return isSortedSet(that) && equals(this.keyTree, that.keyTree);
    },
    [Symbol.iterator]() {
      return keys4(this.keyTree);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "SortedSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor", SupervisorTypeId, supervisorVariance, ProxySupervisor, Zip, isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip"), Track, Const, unsafeTrack = () => {
  return new Track;
}, track, fromEffect2 = (effect) => {
  return new Const(effect);
}, none8;
var init_supervisor = __esm(() => {
  init_Function();
  init_GlobalValue();
  init_MutableRef();
  init_Predicate();
  init_SortedSet();
  init_core();
  SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
  supervisorVariance = {
    _T: (_) => _
  };
  ProxySupervisor = class ProxySupervisor {
    underlying;
    value0;
    [SupervisorTypeId] = supervisorVariance;
    constructor(underlying, value0) {
      this.underlying = underlying;
      this.value0 = value0;
    }
    get value() {
      return this.value0;
    }
    onStart(context2, effect, parent, fiber) {
      this.underlying.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.underlying.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.underlying.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.underlying.onSuspend(fiber);
    }
    onResume(fiber) {
      this.underlying.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  };
  Zip = class Zip {
    left;
    right;
    _tag = "Zip";
    [SupervisorTypeId] = supervisorVariance;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    get value() {
      return zip3(this.left.value, this.right.value);
    }
    onStart(context2, effect, parent, fiber) {
      this.left.onStart(context2, effect, parent, fiber);
      this.right.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.left.onEnd(value, fiber);
      this.right.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.left.onEffect(fiber, effect);
      this.right.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.left.onSuspend(fiber);
      this.right.onSuspend(fiber);
    }
    onResume(fiber) {
      this.left.onResume(fiber);
      this.right.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  };
  Track = class Track {
    [SupervisorTypeId] = supervisorVariance;
    fibers = /* @__PURE__ */ new Set;
    get value() {
      return sync(() => Array.from(this.fibers));
    }
    onStart(_context, _effect, _parent, fiber) {
      this.fibers.add(fiber);
    }
    onEnd(_value, fiber) {
      this.fibers.delete(fiber);
    }
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  };
  Const = class Const {
    effect;
    [SupervisorTypeId] = supervisorVariance;
    constructor(effect) {
      this.effect = effect;
    }
    get value() {
      return this.effect;
    }
    onStart(_context, _effect, _parent, _fiber) {}
    onEnd(_value, _fiber) {}
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  };
  track = /* @__PURE__ */ sync(unsafeTrack);
  none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect2(void_2));
});

// ../../node_modules/effect/dist/esm/Differ.js
var make35;
var init_Differ = __esm(() => {
  init_Function();
  init_differ();
  init_chunkPatch();
  init_contextPatch();
  init_hashMapPatch();
  init_hashSetPatch();
  init_orPatch();
  init_readonlyArrayPatch();
  make35 = make16;
});

// ../../node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty", OP_ADD_SUPERVISOR = "AddSupervisor", OP_REMOVE_SUPERVISOR = "RemoveSupervisor", OP_AND_THEN2 = "AndThen", empty29, combine11 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
}, patch11 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
}, patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head4 = headNonEmpty2(patches);
    switch (head4._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
}, removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
}, toSet2 = (self) => {
  if (equals(self, none8)) {
    return empty8();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union5(toSet2(self.right)));
    } else {
      return make12(self);
    }
  }
}, diff10 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty29;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference4(oldSupervisors), reduce6(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference4(newSupervisors), reduce6(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine11(added, removed);
}, differ2;
var init_patch2 = __esm(() => {
  init_Chunk();
  init_Differ();
  init_Equal();
  init_Function();
  init_HashSet();
  init_supervisor();
  empty29 = {
    _tag: OP_EMPTY3
  };
  differ2 = /* @__PURE__ */ make35({
    empty: empty29,
    patch: patch11,
    combine: combine11,
    diff: diff10
  });
});

// ../../node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted, fiberActive, fiberSuccesses, fiberFailures, fiberLifetimes, EvaluationSignalContinue = "Continue", EvaluationSignalDone = "Done", EvaluationSignalYieldNow = "Yield", runtimeFiberVariance, absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
}, YieldedOp, yieldedOpChannel, contOpSuccess, drainQueueWhileRunningTable, runBlockedRequests = (self) => forEachSequentialDiscard(flatten5(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map13 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map13.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map13);
}, false, false)), _version, FiberRuntime, currentMinimumLogLevel, loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self.log(opts));
}), defaultLogger, tracerLogger, currentLoggers, annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
    for (let i = 0;i < entries3.length; i++) {
      const [key, value] = entries3[i];
      set3(annotations2, key, value);
    }
    return annotations2;
  }));
}, whenLogLevel, acquireRelease, acquireReleaseInterruptible, addFinalizer = (finalizer) => withFiberRuntime((runtime2) => {
  const acquireRefs = runtime2.getFiberRefs();
  const acquireFlags = disable2(runtime2.currentRuntimeFlags, Interruption);
  return flatMap9(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
}), daemonChildren = (self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self);
}, _existsParFound, exists2, existsLoop = (iterator, index, f) => {
  const next2 = iterator.next();
  if (next2.done) {
    return succeed(false);
  }
  return pipe(flatMap9(f(next2.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f)));
}, filter7, allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys5 = Object.keys(input);
  const size9 = keys5.length;
  return [keys5.map((k) => input[k]), some2((values4) => {
    const res = {};
    for (let i = 0;i < size9; i++) {
      res[keys5[i]] = values4[i];
    }
    return res;
  })];
}, allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap9(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none9 = none2();
    const size9 = eithers.length;
    const errors2 = new Array(size9);
    const successes = new Array(size9);
    let errored = false;
    for (let i = 0;i < size9; i++) {
      const either3 = eithers[i];
      if (either3._tag === "Left") {
        errors2[i] = some2(either3.left);
        errored = true;
      } else {
        successes[i] = either3.right;
        errors2[i] = none9;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors2)) : fail2(errors2);
    } else if (options?.discard) {
      return void_2;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
}, allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach8(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map10(forEach8(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
}, all5 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach8(effects, identity, options), reconcile.value) : forEach8(effects, identity, options);
}, allWith = (options) => (arg) => all5(arg, options), allSuccesses = (elements, options) => map10(all5(fromIterable2(elements).map(exit), options), filterMap2((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2())), replicate, replicateEffect, forEach8, forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as3 = fromIterable2(self);
  const array4 = new Array(as3.length);
  const fn = (a, i) => flatMap9(f(a, i), (b) => sync(() => array4[i] = b));
  return zipRight2(forEachConcurrentDiscard(as3, fn, batching, false), succeed(array4));
}), forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_2;
  }
  let counter6 = 0;
  let interrupted2 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll2 = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted2 = true;
    interruptAll2();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted2) {
          onInterruptSignal();
        }
      }
    };
    const next2 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap9(yieldNow(), () => flatMap9(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap9(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted2) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next2();
          }
        });
      }
    };
    for (let i = 0;i < fibersCount; i++) {
      next2();
    }
  }));
  return asVoid2(onExit(flatten7(restore(join3(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index2, hitNext) => (exit2) => {
          exits[index2] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next2();
          }
        };
        const next2 = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0;i < concurrency; i++) {
          next2();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
}))), forEachParN = (self, n, f, batching) => suspend(() => {
  const as3 = fromIterable2(self);
  const array4 = new Array(as3.length);
  const fn = (a, i) => map10(f(a, i), (b) => array4[i] = b);
  return zipRight2(forEachConcurrentDiscard(as3, fn, batching, false, n), succeed(array4));
}), fork = (self) => withFiberRuntime((state, status2) => succeed(unsafeFork(self, state, status2.runtimeFlags))), forkDaemon = (self) => forkWithScopeOverride(self, globalScope), forkWithErrorHandler, unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
}, unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
}, unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
}, forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride))), mergeAll3, partition4, validateAll, raceAll = (all6) => {
  const list = fromIterable3(all6);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll2 = (res) => pipe(inheritAll(res[1]), as2(res[0]));
  return pipe(deferredMake(), flatMap9((done6) => pipe(make29(effects.length), flatMap9((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self)), flatMap9((head4) => pipe(effects, forEachSequential((effect) => fork(interruptible2(effect))), map10((fibers) => unsafeFromArray(fibers)), map10((tail2) => pipe(tail2, prepend2(head4))), tap2((fibers) => pipe(fibers, reduce(void_2, (effect, fiber) => pipe(effect, zipRight2(pipe(_await2(fiber), flatMap9(raceAllArbiter(fibers, fiber, done6, fails)), fork, asVoid2)))))), flatMap9((fibers) => pipe(restore(pipe(_await(done6), flatMap9(inheritAll2))), onInterrupt(() => pipe(fibers, reduce(void_2, (effect, fiber) => pipe(effect, zipLeft2(interruptFiber(fiber))))))))))))))));
}, raceAllArbiter = (fibers, winner, deferred, fails) => (exit2) => exitMatchEffect(exit2, {
  onFailure: (cause2) => pipe(modify6(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause2), asVoid2) : void_2, fails2 - 1]), flatten7),
  onSuccess: (value) => pipe(deferredSucceed(deferred, [value, winner]), flatMap9((set7) => set7 ? pipe(fromIterable3(fibers), reduce(void_2, (effect, fiber) => fiber === winner ? effect : pipe(effect, zipLeft2(interruptFiber(fiber))))) : void_2))
}), reduceEffect, parallelFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap9(scopeFork(scope, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
})), parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap9(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
})), finalizersMask = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self), finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch12(self(parallelFinalizers));
        case "Sequential":
          return patch12(self(sequentialFinalizers));
        case "ParallelN":
          return patch12(self(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
})), scopeWith = (f) => flatMap9(scopeTag, f), scopedWith = (f) => flatMap9(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2))), scopedEffect = (effect) => flatMap9(scopeMake(), (scope) => scopeUse(effect, scope)), sequentialFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap9(scopeFork(scope, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
})), tagMetricsScoped = (key, value) => labelMetricsScoped([make30(key, value)]), labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels)), using, validate, validateWith, validateFirst, withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c)), withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value)), withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider)), withEarlyRelease = (self) => scopeWith((parent) => flatMap9(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map10((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value])))), zipOptions, zipLeftOptions, zipRightOptions, zipWithOptions, withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty18) {
    return void_2;
  }
  return pipe(runtimeFlags, flatMap9((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update5);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
}, scopeTag, scope, scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
}, ScopeImplProto, scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
}, scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy)), scopeExtend, scopeUse, fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty29
}), fiberRefLocallyScoped, fiberRefLocallyScopedWith, fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options)), fiberRefMakeWith = (ref) => acquireRelease(tap2(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef)), fiberRefMakeContext = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial)), fiberRefMakeRuntimeFlags = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial)), currentRuntimeFlags, currentSupervisor, fiberAwaitAll = (fibers) => forEach8(fibers, _await2), fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable2(fibers).reduce((id2, fiber) => combine3(id2, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten7(fiber.await), false)),
    children: map10(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten2),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map10(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk2) => [a, ...chunk2],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
  };
  return _fiberAll;
}, fiberInterruptFork = (self) => asVoid2(forkDaemon(interruptFiber(self))), fiberJoinAll = (fibers) => join3(fiberAll(fibers)), fiberScoped = (self) => acquireRelease(succeed(self), interruptFiber), raceWith, disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap9(forkDaemon(restore(self)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2))))))), race, raceFibersWith, completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
}, ensuring, invokeWithInterrupt = (self, entries3, onInterrupt2) => fiberIdWith((id2) => flatMap9(flatMap9(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = (count) => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id2)));
}))), makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as2(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
  }));
}, withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value)), withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap9(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self, spanTag, span2));
  }
  return (self) => flatMap9(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self, spanTag, span2));
};
var init_fiberRuntime = __esm(() => {
  init_Array();
  init_Boolean();
  init_Chunk();
  init_Context();
  init_Deferred();
  init_Effectable();
  init_ExecutionStrategy();
  init_FiberId();
  init_FiberRefs();
  init_FiberRefsPatch();
  init_FiberStatus();
  init_Function();
  init_GlobalValue();
  init_HashMap();
  init_HashSet();
  init_Inspectable();
  init_LogLevel();
  init_Micro();
  init_MutableRef();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Ref();
  init_RuntimeFlagsPatch();
  init_Scheduler();
  init_Utils();
  init_blockedRequests();
  init_cause();
  init_clock();
  init_completedRequestMap();
  init_concurrency();
  init_configProvider();
  init_core_effect();
  init_core();
  init_defaultServices();
  init_console();
  init_executionStrategy();
  init_fiber();
  init_fiberRefs();
  init_fiberScope();
  init_logger();
  init_metric();
  init_boundaries();
  init_label();
  init_random();
  init_request();
  init_runtimeFlags();
  init_runtimeFlags();
  init_supervisor();
  init_patch2();
  init_tracer();
  fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
    incremental: true
  });
  fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
  fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
    incremental: true
  });
  fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
    incremental: true
  });
  fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
    start: 0.5,
    factor: 2,
    count: 35
  })), "time_unit", "milliseconds");
  runtimeFiberVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
  yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
    currentOp: null
  }));
  contOpSuccess = {
    [OP_ON_SUCCESS]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i1(value));
    },
    ["OnStep"]: (_, _cont, value) => {
      return exitSucceed(exitSucceed(value));
    },
    [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i2(value));
    },
    [OP_REVERT_FLAGS]: (self, cont, value) => {
      self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
      if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
        return exitFailCause(self.getInterruptedCause());
      } else {
        return exitSucceed(value);
      }
    },
    [OP_WHILE]: (self, cont, value) => {
      internalCall(() => cont.effect_instruction_i2(value));
      if (internalCall(() => cont.effect_instruction_i0())) {
        self.pushStack(cont);
        return internalCall(() => cont.effect_instruction_i1());
      } else {
        return void_2;
      }
    },
    [OP_ITERATOR]: (self, cont, value) => {
      const state = internalCall(() => cont.effect_instruction_i0.next(value));
      if (state.done)
        return exitSucceed(state.value);
      self.pushStack(cont);
      return yieldWrapGet(state.value);
    }
  };
  drainQueueWhileRunningTable = {
    [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
      self.processNewInterruptSignal(message.cause);
      return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
    },
    [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
      throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
    },
    [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
      message.onFiber(self, running2(runtimeFlags2));
      return cur;
    },
    [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
      return flatMap9(yieldNow(), () => cur);
    }
  };
  _version = /* @__PURE__ */ getCurrentVersion();
  FiberRuntime = class FiberRuntime extends Class {
    [FiberTypeId] = fiberVariance2;
    [RuntimeFiberTypeId] = runtimeFiberVariance;
    _fiberRefs;
    _fiberId;
    _queue = /* @__PURE__ */ new Array;
    _children = null;
    _observers = /* @__PURE__ */ new Array;
    _running = false;
    _stack = [];
    _asyncInterruptor = null;
    _asyncBlockingOn = null;
    _exitValue = null;
    _steps = [];
    _isYielding = false;
    currentRuntimeFlags;
    currentOpCount = 0;
    currentSupervisor;
    currentScheduler;
    currentTracer;
    currentSpan;
    currentContext;
    currentDefaultServices;
    constructor(fiberId2, fiberRefs0, runtimeFlags0) {
      super();
      this.currentRuntimeFlags = runtimeFlags0;
      this._fiberId = fiberId2;
      this._fiberRefs = fiberRefs0;
      if (runtimeMetrics(runtimeFlags0)) {
        const tags = this.getFiberRef(currentMetricLabels);
        fiberStarted.unsafeUpdate(1, tags);
        fiberActive.unsafeUpdate(1, tags);
      }
      this.refreshRefCache();
    }
    commit() {
      return join3(this);
    }
    id() {
      return this._fiberId;
    }
    resume(effect) {
      this.tell(resume(effect));
    }
    get status() {
      return this.ask((_, status2) => status2);
    }
    get runtimeFlags() {
      return this.ask((state, status2) => {
        if (isDone3(status2)) {
          return state.currentRuntimeFlags;
        }
        return status2.runtimeFlags;
      });
    }
    scope() {
      return unsafeMake8(this);
    }
    get children() {
      return this.ask((fiber) => Array.from(fiber.getChildren()));
    }
    getChildren() {
      if (this._children === null) {
        this._children = new Set;
      }
      return this._children;
    }
    getInterruptedCause() {
      return this.getFiberRef(currentInterruptedCause);
    }
    fiberRefs() {
      return this.ask((fiber) => fiber.getFiberRefs());
    }
    ask(f) {
      return suspend(() => {
        const deferred = deferredUnsafeMake(this._fiberId);
        this.tell(stateful((fiber, status2) => {
          deferredUnsafeDone(deferred, sync(() => f(fiber, status2)));
        }));
        return deferredAwait(deferred);
      });
    }
    tell(message) {
      this._queue.push(message);
      if (!this._running) {
        this._running = true;
        this.drainQueueLaterOnExecutor();
      }
    }
    get await() {
      return async_((resume2) => {
        const cb = (exit2) => resume2(succeed(exit2));
        this.tell(stateful((fiber, _) => {
          if (fiber._exitValue !== null) {
            cb(this._exitValue);
          } else {
            fiber.addObserver(cb);
          }
        }));
        return sync(() => this.tell(stateful((fiber, _) => {
          fiber.removeObserver(cb);
        })));
      }, this.id());
    }
    get inheritAll() {
      return withFiberRuntime((parentFiber, parentStatus) => {
        const parentFiberId = parentFiber.id();
        const parentFiberRefs = parentFiber.getFiberRefs();
        const parentRuntimeFlags = parentStatus.runtimeFlags;
        const childFiberRefs = this.getFiberRefs();
        const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
        parentFiber.setFiberRefs(updatedFiberRefs);
        const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
        const patch12 = pipe(diff7(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
        return updateRuntimeFlags(patch12);
      });
    }
    get poll() {
      return sync(() => fromNullable(this._exitValue));
    }
    unsafePoll() {
      return this._exitValue;
    }
    interruptAsFork(fiberId2) {
      return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
    }
    unsafeInterruptAsFork(fiberId2) {
      this.tell(interruptSignal(interrupt(fiberId2)));
    }
    addObserver(observer) {
      if (this._exitValue !== null) {
        observer(this._exitValue);
      } else {
        this._observers.push(observer);
      }
    }
    removeObserver(observer) {
      this._observers = this._observers.filter((o) => o !== observer);
    }
    getFiberRefs() {
      this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
      return this._fiberRefs;
    }
    unsafeDeleteFiberRef(fiberRef) {
      this._fiberRefs = delete_(this._fiberRefs, fiberRef);
    }
    getFiberRef(fiberRef) {
      if (this._fiberRefs.locals.has(fiberRef)) {
        return this._fiberRefs.locals.get(fiberRef)[0][1];
      }
      return fiberRef.initial;
    }
    setFiberRef(fiberRef, value) {
      this._fiberRefs = updateAs(this._fiberRefs, {
        fiberId: this._fiberId,
        fiberRef,
        value
      });
      this.refreshRefCache();
    }
    refreshRefCache() {
      this.currentDefaultServices = this.getFiberRef(currentServices);
      this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
      this.currentSupervisor = this.getFiberRef(currentSupervisor);
      this.currentScheduler = this.getFiberRef(currentScheduler);
      this.currentContext = this.getFiberRef(currentContext);
      this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
    }
    setFiberRefs(fiberRefs3) {
      this._fiberRefs = fiberRefs3;
      this.refreshRefCache();
    }
    addChild(child) {
      this.getChildren().add(child);
    }
    removeChild(child) {
      this.getChildren().delete(child);
    }
    transferChildren(scope) {
      const children2 = this._children;
      this._children = null;
      if (children2 !== null && children2.size > 0) {
        for (const child of children2) {
          if (child._exitValue === null) {
            scope.add(this.currentRuntimeFlags, child);
          }
        }
      }
    }
    drainQueueOnCurrentThread() {
      let recurse = true;
      while (recurse) {
        let evaluationSignal = EvaluationSignalContinue;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          while (evaluationSignal === EvaluationSignalContinue) {
            evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
          }
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
        }
        if (this._queue.length > 0 && !this._running) {
          this._running = true;
          if (evaluationSignal === EvaluationSignalYieldNow) {
            this.drainQueueLaterOnExecutor();
            recurse = false;
          } else {
            recurse = true;
          }
        } else {
          recurse = false;
        }
      }
    }
    drainQueueLaterOnExecutor() {
      this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
    }
    drainQueueWhileRunning(runtimeFlags2, cur0) {
      let cur = cur0;
      while (this._queue.length > 0) {
        const message = this._queue.splice(0, 1)[0];
        cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
      }
      return cur;
    }
    isInterrupted() {
      return !isEmpty5(this.getFiberRef(currentInterruptedCause));
    }
    addInterruptedCause(cause2) {
      const oldSC = this.getFiberRef(currentInterruptedCause);
      this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
    }
    processNewInterruptSignal(cause2) {
      this.addInterruptedCause(cause2);
      this.sendInterruptSignalToAllChildren();
    }
    sendInterruptSignalToAllChildren() {
      if (this._children === null || this._children.size === 0) {
        return false;
      }
      let told = false;
      for (const child of this._children) {
        child.tell(interruptSignal(interrupt(this.id())));
        told = true;
      }
      return told;
    }
    interruptAllChildren() {
      if (this.sendInterruptSignalToAllChildren()) {
        const it = this._children.values();
        this._children = null;
        let isDone4 = false;
        const body = () => {
          const next2 = it.next();
          if (!next2.done) {
            return asVoid2(next2.value.await);
          } else {
            return sync(() => {
              isDone4 = true;
            });
          }
        };
        return whileLoop({
          while: () => !isDone4,
          body,
          step: () => {}
        });
      }
      return null;
    }
    reportExitValue(exit2) {
      if (runtimeMetrics(this.currentRuntimeFlags)) {
        const tags = this.getFiberRef(currentMetricLabels);
        const startTimeMillis = this.id().startTimeMillis;
        const endTimeMillis = Date.now();
        fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
        fiberActive.unsafeUpdate(-1, tags);
        switch (exit2._tag) {
          case OP_SUCCESS: {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
          case OP_FAILURE: {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
        }
      }
      if (exit2._tag === "Failure") {
        const level = this.getFiberRef(currentUnhandledErrorLogLevel);
        if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
          this.log("Fiber terminated with an unhandled error", exit2.cause, level);
        }
      }
    }
    setExitValue(exit2) {
      this._exitValue = exit2;
      this.reportExitValue(exit2);
      for (let i = this._observers.length - 1;i >= 0; i--) {
        this._observers[i](exit2);
      }
      this._observers = [];
    }
    getLoggers() {
      return this.getFiberRef(currentLoggers);
    }
    log(message, cause2, overrideLogLevel) {
      const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
      const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, logLevel)) {
        return;
      }
      const spans = this.getFiberRef(currentLogSpan);
      const annotations2 = this.getFiberRef(currentLogAnnotations);
      const loggers = this.getLoggers();
      const contextMap = this.getFiberRefs();
      if (size4(loggers) > 0) {
        const clockService = get3(this.getFiberRef(currentServices), clockTag);
        const date = new Date(clockService.unsafeCurrentTimeMillis());
        withRedactableContext(contextMap, () => {
          for (const logger of loggers) {
            logger.log({
              fiberId: this.id(),
              logLevel,
              message,
              cause: cause2,
              context: contextMap,
              spans,
              annotations: annotations2,
              date
            });
          }
        });
      }
    }
    evaluateMessageWhileSuspended(message) {
      switch (message._tag) {
        case OP_YIELD_NOW: {
          return EvaluationSignalYieldNow;
        }
        case OP_INTERRUPT_SIGNAL: {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
        case OP_RESUME: {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
        case OP_STATEFUL: {
          message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
        default: {
          return absurd(message);
        }
      }
    }
    evaluateEffect(effect0) {
      this.currentSupervisor.onResume(this);
      try {
        let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
        while (effect !== null) {
          const eff = effect;
          const exit2 = this.runLoop(eff);
          if (exit2 === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            yieldedOpChannel.currentOp = null;
            if (op._op === OP_YIELD) {
              if (cooperativeYielding(this.currentRuntimeFlags)) {
                this.tell(yieldNow3());
                this.tell(resume(exitVoid));
                effect = null;
              } else {
                effect = exitVoid;
              }
            } else if (op._op === OP_ASYNC) {
              effect = null;
            }
          } else {
            this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
            const interruption2 = this.interruptAllChildren();
            if (interruption2 !== null) {
              effect = flatMap9(interruption2, () => exit2);
            } else {
              if (this._queue.length === 0) {
                this.setExitValue(exit2);
              } else {
                this.tell(resume(exit2));
              }
              effect = null;
            }
          }
        }
      } finally {
        this.currentSupervisor.onSuspend(this);
      }
    }
    start(effect) {
      if (!this._running) {
        this._running = true;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          this.evaluateEffect(effect);
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
          if (this._queue.length > 0) {
            this.drainQueueLaterOnExecutor();
          }
        }
      } else {
        this.tell(resume(effect));
      }
    }
    startFork(effect) {
      this.tell(resume(effect));
    }
    patchRuntimeFlags(oldRuntimeFlags, patch12) {
      const newRuntimeFlags = patch7(oldRuntimeFlags, patch12);
      globalThis[currentFiberURI] = this;
      this.currentRuntimeFlags = newRuntimeFlags;
      return newRuntimeFlags;
    }
    initiateAsync(runtimeFlags2, asyncRegister) {
      let alreadyCalled = false;
      const callback = (effect) => {
        if (!alreadyCalled) {
          alreadyCalled = true;
          this.tell(resume(effect));
        }
      };
      if (interruptible(runtimeFlags2)) {
        this._asyncInterruptor = callback;
      }
      try {
        asyncRegister(callback);
      } catch (e) {
        callback(failCause(die(e)));
      }
    }
    pushStack(cont) {
      this._stack.push(cont);
      if (cont._op === "OnStep") {
        this._steps.push({
          refs: this.getFiberRefs(),
          flags: this.currentRuntimeFlags
        });
      }
    }
    popStack() {
      const item = this._stack.pop();
      if (item) {
        if (item._op === "OnStep") {
          this._steps.pop();
        }
        return item;
      }
      return;
    }
    getNextSuccessCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_FAILURE) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    getNextFailCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    [OP_TAG](op) {
      return sync(() => unsafeGet3(this.currentContext, op));
    }
    ["Left"](op) {
      return fail2(op.left);
    }
    ["None"](_) {
      return fail2(new NoSuchElementException);
    }
    ["Right"](op) {
      return exitSucceed(op.right);
    }
    ["Some"](op) {
      return exitSucceed(op.value);
    }
    ["Micro"](op) {
      return unsafeAsync((microResume) => {
        let resume2 = microResume;
        const fiber = runFork(provideContext2(op, this.currentContext));
        fiber.addObserver((exit2) => {
          if (exit2._tag === "Success") {
            return resume2(exitSucceed(exit2.value));
          }
          switch (exit2.cause._tag) {
            case "Interrupt": {
              return resume2(exitFailCause(interrupt(none4)));
            }
            case "Fail": {
              return resume2(fail2(exit2.cause.error));
            }
            case "Die": {
              return resume2(die2(exit2.cause.defect));
            }
          }
        });
        return unsafeAsync((abortResume) => {
          resume2 = (_) => {
            abortResume(void_2);
          };
          fiber.unsafeInterrupt();
        });
      });
    }
    [OP_SYNC](op) {
      const value = internalCall(() => op.effect_instruction_i0());
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, value);
      } else {
        yieldedOpChannel.currentOp = exitSucceed(value);
        return YieldedOp;
      }
    }
    [OP_SUCCESS](op) {
      const oldCur = op;
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
      } else {
        yieldedOpChannel.currentOp = oldCur;
        return YieldedOp;
      }
    }
    [OP_FAILURE](op) {
      const cause2 = op.effect_instruction_i0;
      const cont = this.getNextFailCont();
      if (cont !== undefined) {
        switch (cont._op) {
          case OP_ON_FAILURE:
          case OP_ON_SUCCESS_AND_FAILURE: {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return internalCall(() => cont.effect_instruction_i1(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case "OnStep": {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return exitSucceed(exitFailCause(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case OP_REVERT_FLAGS: {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
              return exitFailCause(sequential(cause2, this.getInterruptedCause()));
            } else {
              return exitFailCause(cause2);
            }
          }
          default: {
            absurd(cont);
          }
        }
      } else {
        yieldedOpChannel.currentOp = exitFailCause(cause2);
        return YieldedOp;
      }
    }
    [OP_WITH_RUNTIME](op) {
      return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
    }
    ["Blocked"](op) {
      const refs = this.getFiberRefs();
      const flags = this.currentRuntimeFlags;
      if (this._steps.length > 0) {
        const frames = [];
        const snap = this._steps[this._steps.length - 1];
        let frame = this.popStack();
        while (frame && frame._op !== "OnStep") {
          frames.push(frame);
          frame = this.popStack();
        }
        this.setFiberRefs(snap.refs);
        this.currentRuntimeFlags = snap.flags;
        const patchRefs = diff9(snap.refs, refs);
        const patchFlags = diff7(snap.flags, flags);
        return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
          while (frames.length > 0) {
            newFiber.pushStack(frames.pop());
          }
          newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
          newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
          return op.effect_instruction_i1;
        })));
      }
      return uninterruptibleMask((restore) => flatMap9(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
    }
    ["RunBlocked"](op) {
      return runBlockedRequests(op.effect_instruction_i0);
    }
    [OP_UPDATE_RUNTIME_FLAGS](op) {
      const updateFlags = op.effect_instruction_i0;
      const oldRuntimeFlags = this.currentRuntimeFlags;
      const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
      if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
        return exitFailCause(this.getInterruptedCause());
      } else {
        this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
        if (op.effect_instruction_i1) {
          const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
          this.pushStack(new RevertFlags(revertFlags, op));
          return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
        } else {
          return exitVoid;
        }
      }
    }
    [OP_ON_SUCCESS](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    ["OnStep"](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_SUCCESS_AND_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ASYNC](op) {
      this._asyncBlockingOn = op.effect_instruction_i1;
      this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_YIELD](op) {
      this._isYielding = false;
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_WHILE](op) {
      const check = op.effect_instruction_i0;
      const body = op.effect_instruction_i1;
      if (check()) {
        this.pushStack(op);
        return body();
      } else {
        return exitVoid;
      }
    }
    [OP_ITERATOR](op) {
      return contOpSuccess[OP_ITERATOR](this, op, undefined);
    }
    [OP_COMMIT](op) {
      return internalCall(() => op.commit());
    }
    runLoop(effect0) {
      let cur = effect0;
      this.currentOpCount = 0;
      while (true) {
        if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
          this.currentSupervisor.onEffect(this, cur);
        }
        if (this._queue.length > 0) {
          cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
        }
        if (!this._isYielding) {
          this.currentOpCount += 1;
          const shouldYield = this.currentScheduler.shouldYield(this);
          if (shouldYield !== false) {
            this._isYielding = true;
            this.currentOpCount = 0;
            const oldCur = cur;
            cur = flatMap9(yieldNow({
              priority: shouldYield
            }), () => oldCur);
          }
        }
        try {
          cur = this.currentTracer.context(() => {
            if (_version !== cur[EffectTypeId2]._V) {
              return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
            }
            return this[cur._op](cur);
          }, this);
          if (cur === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            if (op._op === OP_YIELD || op._op === OP_ASYNC) {
              return YieldedOp;
            }
            yieldedOpChannel.currentOp = null;
            return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
          }
        } catch (e) {
          if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
            cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
          } else if (isInterruptedException(e)) {
            cur = exitFailCause(sequential(die(e), interrupt(none4)));
          } else {
            cur = die2(e);
          }
        }
      }
    }
    run = () => {
      this.drainQueueOnCurrentThread();
    };
  };
  currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
  defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
  tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context2,
    fiberId: fiberId2,
    logLevel,
    message
  }) => {
    const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
    if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
      return;
    }
    const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
    const attributes = {};
    for (const [key, value] of annotations2) {
      attributes[key] = value;
    }
    attributes["effect.fiberId"] = threadName2(fiberId2);
    attributes["effect.logLevel"] = logLevel.label;
    if (cause2 !== null && cause2._tag !== "Empty") {
      attributes["effect.cause"] = pretty(cause2, {
        renderErrorCause: true
      });
    }
    span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
  }));
  currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make12(defaultLogger, tracerLogger)));
  whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
    const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
    return withFiberRuntime((fiberState) => {
      const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
        return succeed(none2());
      }
      return map10(effect, some2);
    });
  });
  acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap2(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
  acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
  _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
  exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach8(elements, (a, i) => if_(predicate(a, i), {
    onTrue: () => fail2(_existsParFound),
    onFalse: () => void_2
  }), options), {
    onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
    onSuccess: () => succeed(false)
  })));
  filter7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
    const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
    return matchSimple(options?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect, a, i) => zipWith4(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map10(forEach8(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
  });
  replicate = /* @__PURE__ */ dual(2, (self, n) => Array.from({
    length: n
  }, () => self));
  replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, n, options) => all5(replicate(self, n), options));
  forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self, f, options) => withFiberRuntime((r) => {
    const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
    if (options?.discard) {
      return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
    }
    return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
  }));
  forkWithErrorHandler = /* @__PURE__ */ dual(2, (self, handler) => fork(onError(self, (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return handler(either3.left);
      case "Right":
        return failCause(either3.right);
    }
  })));
  mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap9(make29(zero3), (acc) => flatMap9(forEach8(elements, (effect, i) => flatMap9(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
  partition4 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach8(elements, (a, i) => either2(f(a, i)), options), map10((chunk2) => partitionMap4(chunk2, identity))));
  validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap9(partition4(elements, f, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_2 : succeed(bs)));
  reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
    switch (acc._tag) {
      case "None": {
        return some2(elem);
      }
      case "Some": {
        return some2(f(acc.value, elem, i));
      }
    }
  }, options), map10((option2) => {
    switch (option2._tag) {
      case "None": {
        throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      case "Some": {
        return option2.value;
      }
    }
  })))));
  using = /* @__PURE__ */ dual(2, (self, use) => scopedWith((scope) => flatMap9(scopeExtend(self, scope), use)));
  validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
  validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => flatten7(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
    onSuccess: f,
    onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
  }), options)));
  validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach8(elements, (a, i) => flip(f(a, i)), options)));
  zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
  zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipLeft2(self, that);
    }
    return zipWithOptions(self, that, (a, _) => a, options);
  });
  zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipRight2(self, that);
    }
    return zipWithOptions(self, that, (_, b) => b, options);
  });
  zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => map10(all5([self, that], {
    concurrency: options?.concurrent ? 2 : 1,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([a, a2]) => f(a, a2)));
  scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
  scope = scopeTag;
  ScopeImplProto = {
    [ScopeTypeId]: ScopeTypeId,
    [CloseableScopeTypeId]: CloseableScopeTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    fork(strategy) {
      return sync(() => {
        const newScope = scopeUnsafeMake(strategy);
        if (this.state._tag === "Closed") {
          newScope.state = this.state;
          return newScope;
        }
        const key = {};
        const fin = (exit2) => newScope.close(exit2);
        this.state.finalizers.set(key, fin);
        scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
          if (this.state._tag === "Open") {
            this.state.finalizers.delete(key);
          }
        }));
        return newScope;
      });
    },
    close(exit2) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return void_2;
        }
        const finalizers = Array.from(this.state.finalizers.values()).reverse();
        this.state = {
          _tag: "Closed",
          exit: exit2
        };
        if (finalizers.length === 0) {
          return void_2;
        }
        return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap9((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap9((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap9((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid))));
      });
    },
    addFinalizer(fin) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return fin(this.state.exit);
        }
        this.state.finalizers.set({}, fin);
        return void_2;
      });
    }
  };
  scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make6(scopeTag, scope2))));
  scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
  fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self, value) => asVoid2(acquireRelease(flatMap9(fiberRefGet(self), (oldValue) => as2(fiberRefSet(self, value), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
  fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
  currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
  currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
  raceWith = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
    onSelfWin: (winner, loser) => flatMap9(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap9(winner.inheritAll, () => options.onSelfDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onSelfDone(exit2, loser);
        }
      }
    }),
    onOtherWin: (winner, loser) => flatMap9(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap9(winner.inheritAll, () => options.onOtherDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onOtherDone(exit2, loser);
        }
      }
    })
  }));
  race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
    onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join3(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
      onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as2(value))
    }),
    onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join3(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
      onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as2(value))
    })
  })));
  raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
    const parentRuntimeFlags = parentStatus.runtimeFlags;
    const raceIndicator = make13(true);
    const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
    const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
    return async_((cb) => {
      leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
      rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
      leftFiber.startFork(self);
      rightFiber.startFork(other);
    }, combine3(leftFiber.id(), rightFiber.id()));
  }));
  ensuring = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
    onFailure: (cause1) => matchCauseEffect(finalizer, {
      onFailure: (cause2) => failCause(sequential(cause1, cause2)),
      onSuccess: () => failCause(cause1)
    }),
    onSuccess: (a) => as2(finalizer, a)
  })));
});

// ../../node_modules/effect/dist/esm/internal/cache.js
class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next2 = key.next;
        if (next2 !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next2;
            next2.previous = previous;
          } else {
            this.head = next2;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next2 = key.next;
      if (next2 !== undefined) {
        key.next = undefined;
        this.head = next2;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
var complete3 = (key, exit2, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit2,
  entryStats,
  timeToLiveMillis
}), pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
}), refreshing = (deferred, complete4) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete4
}), MapKeyTypeId, MapKeyImpl, makeMapKey = (current) => new MapKeyImpl(current), isMapKey = (u) => hasProperty(u, MapKeyTypeId), makeKeySet = () => new KeySetImpl, makeCacheState = (map13, keys5, accesses, updating, hits, misses) => ({
  map: map13,
  keys: keys5,
  accesses,
  updating,
  hits,
  misses
}), initialCacheState = () => makeCacheState(empty21(), makeKeySet(), unbounded(), make13(false), 0, 0), CacheSymbolKey = "effect/Cache", CacheTypeId, cacheVariance, ConsumerCacheSymbolKey = "effect/ConsumerCache", ConsumerCacheTypeId, consumerCacheVariance, makeCacheStats = (options) => options, makeEntryStats = (loadedMillis) => ({
  loadedMillis
}), CacheImpl, unsafeMakeWith = (capacity2, lookup, timeToLive) => new CacheImpl(capacity2, empty4(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
var init_cache = __esm(() => {
  init_Context();
  init_Deferred();
  init_Duration();
  init_Either();
  init_Equal();
  init_Exit();
  init_Function();
  init_Hash();
  init_MutableHashMap();
  init_MutableQueue();
  init_MutableRef();
  init_Option();
  init_Predicate();
  init_core_effect();
  init_core();
  init_data();
  init_fiberId();
  init_fiberRuntime();
  MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
  MapKeyImpl = class MapKeyImpl {
    current;
    [MapKeyTypeId] = MapKeyTypeId;
    previous = undefined;
    next = undefined;
    constructor(current) {
      this.current = current;
    }
    [symbol]() {
      return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
    }
    [symbol2](that) {
      if (this === that) {
        return true;
      }
      return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
    }
  };
  CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
  cacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
  consumerCacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  CacheImpl = class CacheImpl {
    capacity;
    context;
    fiberId;
    lookup;
    timeToLive;
    [CacheTypeId] = cacheVariance;
    [ConsumerCacheTypeId] = consumerCacheVariance;
    cacheState;
    constructor(capacity2, context2, fiberId2, lookup, timeToLive) {
      this.capacity = capacity2;
      this.context = context2;
      this.fiberId = fiberId2;
      this.lookup = lookup;
      this.timeToLive = timeToLive;
      this.cacheState = initialCacheState();
    }
    get(key) {
      return map10(this.getEither(key), merge);
    }
    get cacheStats() {
      return sync(() => makeCacheStats({
        hits: this.cacheState.hits,
        misses: this.cacheState.misses,
        size: size6(this.cacheState.map)
      }));
    }
    getOption(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value)
      }));
    }
    getOptionComplete(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value, true)
      }));
    }
    contains(key) {
      return sync(() => has5(this.cacheState.map, key));
    }
    entryStats(key) {
      return sync(() => {
        const option2 = get8(this.cacheState.map, key);
        if (isSome2(option2)) {
          switch (option2.value._tag) {
            case "Complete": {
              const loaded = option2.value.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
            case "Pending": {
              return none2();
            }
            case "Refreshing": {
              const loaded = option2.value.complete.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
          }
        }
        return none2();
      });
    }
    getEither(key) {
      return suspend(() => {
        const k = key;
        let mapKey = undefined;
        let deferred = undefined;
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          deferred = unsafeMake4(this.fiberId);
          mapKey = makeMapKey(k);
          if (has5(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(mapKey, deferred));
          }
        }
        if (value === undefined) {
          this.trackAccess(mapKey);
          this.trackMiss();
          return map10(this.lookupValueOf(key, deferred), right2);
        } else {
          return flatMap9(this.resolveMapValue(value), match2({
            onNone: () => this.getEither(key),
            onSome: (value2) => succeed(left2(value2))
          }));
        }
      });
    }
    invalidate(key) {
      return sync(() => {
        remove7(this.cacheState.map, key);
      });
    }
    invalidateWhen(key, when2) {
      return sync(() => {
        const value = get8(this.cacheState.map, key);
        if (isSome2(value) && value.value._tag === "Complete") {
          if (value.value.exit._tag === "Success") {
            if (when2(value.value.exit.value)) {
              remove7(this.cacheState.map, key);
            }
          }
        }
      });
    }
    get invalidateAll() {
      return sync(() => {
        this.cacheState.map = empty21();
      });
    }
    refresh(key) {
      return clockWith3((clock2) => suspend(() => {
        const k = key;
        const deferred = unsafeMake4(this.fiberId);
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          if (has5(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
          }
        }
        if (value === undefined) {
          return asVoid2(this.lookupValueOf(key, deferred));
        } else {
          switch (value._tag) {
            case "Complete": {
              if (this.hasExpired(clock2, value.timeToLiveMillis)) {
                const found = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(found, value)) {
                  remove7(this.cacheState.map, k);
                }
                return asVoid2(this.get(key));
              }
              return pipe(this.lookupValueOf(key, deferred), when(() => {
                const current = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(current, value)) {
                  const mapValue = refreshing(deferred, value);
                  set4(this.cacheState.map, k, mapValue);
                  return true;
                }
                return false;
              }), asVoid2);
            }
            case "Pending": {
              return _await(value.deferred);
            }
            case "Refreshing": {
              return _await(value.deferred);
            }
          }
        }
      }));
    }
    set(key, value) {
      return clockWith3((clock2) => sync(() => {
        const now = clock2.unsafeCurrentTimeMillis();
        const k = key;
        const lookupResult = succeed3(value);
        const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
        set4(this.cacheState.map, k, mapValue);
      }));
    }
    get size() {
      return sync(() => {
        return size6(this.cacheState.map);
      });
    }
    get values() {
      return sync(() => {
        const values4 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values4.push(entry[1].exit.value);
          }
        }
        return values4;
      });
    }
    get entries() {
      return sync(() => {
        const values4 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values4.push([entry[0], entry[1].exit.value]);
          }
        }
        return values4;
      });
    }
    get keys() {
      return sync(() => {
        const keys5 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            keys5.push(entry[0]);
          }
        }
        return keys5;
      });
    }
    resolveMapValue(value, ignorePending = false) {
      return clockWith3((clock2) => {
        switch (value._tag) {
          case "Complete": {
            this.trackAccess(value.key);
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              remove7(this.cacheState.map, value.key.current);
              return succeed(none2());
            }
            this.trackHit();
            return map10(value.exit, some2);
          }
          case "Pending": {
            this.trackAccess(value.key);
            this.trackHit();
            if (ignorePending) {
              return succeed(none2());
            }
            return map10(_await(value.deferred), some2);
          }
          case "Refreshing": {
            this.trackAccess(value.complete.key);
            this.trackHit();
            if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
              if (ignorePending) {
                return succeed(none2());
              }
              return map10(_await(value.deferred), some2);
            }
            return map10(value.complete.exit, some2);
          }
        }
      });
    }
    trackHit() {
      this.cacheState.hits = this.cacheState.hits + 1;
    }
    trackMiss() {
      this.cacheState.misses = this.cacheState.misses + 1;
    }
    trackAccess(key) {
      offer(this.cacheState.accesses, key);
      if (compareAndSet(this.cacheState.updating, false, true)) {
        let loop2 = true;
        while (loop2) {
          const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
          if (key2 === EmptyMutableQueue) {
            loop2 = false;
          } else {
            this.cacheState.keys.add(key2);
          }
        }
        let size9 = size6(this.cacheState.map);
        loop2 = size9 > this.capacity;
        while (loop2) {
          const key2 = this.cacheState.keys.remove();
          if (key2 !== undefined) {
            if (has5(this.cacheState.map, key2.current)) {
              remove7(this.cacheState.map, key2.current);
              size9 = size9 - 1;
              loop2 = size9 > this.capacity;
            }
          } else {
            loop2 = false;
          }
        }
        set2(this.cacheState.updating, false);
      }
    }
    hasExpired(clock2, timeToLiveMillis) {
      return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
    }
    lookupValueOf(input, deferred) {
      return clockWith3((clock2) => suspend(() => {
        const key = input;
        return pipe(this.lookup(input), provideContext(this.context), exit, flatMap9((exit2) => {
          const now = clock2.unsafeCurrentTimeMillis();
          const stats = makeEntryStats(now);
          const value = complete3(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
          set4(this.cacheState.map, key, value);
          return zipRight2(done2(deferred, exit2), exit2);
        }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
          remove7(this.cacheState.map, key);
        }))));
      }));
    }
  };
});

// ../../node_modules/effect/dist/esm/Cache.js
var init_Cache = __esm(() => {
  init_cache();
});

// ../../node_modules/effect/dist/esm/Cause.js
var fail6, die5, interrupt5, isFailType2, isDieType2, isInterrupted2, isInterruptedOnly2, interruptors2, failureOrCause2, flipCauseOption2, map13, squash, IllegalArgumentException2, NoSuchElementException2, RuntimeException2, isRuntimeException2, pretty3;
var init_Cause = __esm(() => {
  init_cause();
  init_core();
  fail6 = fail;
  die5 = die;
  interrupt5 = interrupt;
  isFailType2 = isFailType;
  isDieType2 = isDieType;
  isInterrupted2 = isInterrupted;
  isInterruptedOnly2 = isInterruptedOnly;
  interruptors2 = interruptors;
  failureOrCause2 = failureOrCause;
  flipCauseOption2 = flipCauseOption;
  map13 = map9;
  squash = causeSquash;
  IllegalArgumentException2 = IllegalArgumentException;
  NoSuchElementException2 = NoSuchElementException;
  RuntimeException2 = RuntimeException;
  isRuntimeException2 = isRuntimeException;
  pretty3 = pretty;
});

// ../../node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval", IntervalTypeId, empty30, make37 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty30;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
}, lessThan3, min2, isEmpty8 = (self) => {
  return self.startMillis >= self.endMillis;
}, intersect, size10 = (self) => {
  return millis(self.endMillis - self.startMillis);
}, after = (startMilliseconds) => {
  return make37(startMilliseconds, Number.POSITIVE_INFINITY);
};
var init_interval = __esm(() => {
  init_Duration();
  init_Function();
  init_Option();
  IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
  empty30 = {
    [IntervalTypeId]: IntervalTypeId,
    startMillis: 0,
    endMillis: 0
  };
  lessThan3 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
  min2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self.endMillis <= that.startMillis)
      return self;
    if (that.endMillis <= self.startMillis)
      return that;
    if (self.startMillis < that.startMillis)
      return self;
    if (that.startMillis < self.startMillis)
      return that;
    if (self.endMillis <= that.endMillis)
      return self;
    return that;
  });
  intersect = /* @__PURE__ */ dual(2, (self, that) => {
    const start = Math.max(self.startMillis, that.startMillis);
    const end = Math.min(self.endMillis, that.endMillis);
    return make37(start, end);
  });
});

// ../../node_modules/effect/dist/esm/ScheduleInterval.js
var make38, empty31, lessThan4, isEmpty9, intersect2, size11, after2;
var init_ScheduleInterval = __esm(() => {
  init_interval();
  make38 = make37;
  empty31 = empty30;
  lessThan4 = lessThan3;
  isEmpty9 = isEmpty8;
  intersect2 = intersect;
  size11 = size10;
  after2 = after;
});

// ../../node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals", IntervalsTypeId, make39 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
}, union8, unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty2(self) || isNonEmpty2(that)) {
    if (!isNonEmpty2(self) && isNonEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty5();
      } else {
        interval = make38(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty5();
      }
    } else if (isNonEmpty2(self) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(self);
        that = empty5();
        self = tailNonEmpty2(self);
      } else {
        interval = make38(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty5();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty2(self) && isNonEmpty2(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend2(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make38(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make38(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make39(pipe(acc, prepend2(interval), reverse2));
}, intersect3, intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan4(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make39(reverse2(acc));
}, start = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty31)).startMillis;
}, end = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty31)).endMillis;
}, lessThan5, isNonEmpty4 = (self) => {
  return isNonEmpty2(self.intervals);
}, max3;
var init_intervals = __esm(() => {
  init_Chunk();
  init_Function();
  init_Option();
  init_ScheduleInterval();
  IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
  union8 = /* @__PURE__ */ dual(2, (self, that) => {
    if (!isNonEmpty2(that.intervals)) {
      return self;
    }
    if (!isNonEmpty2(self.intervals)) {
      return that;
    }
    if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
      return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty5());
    }
    return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty5());
  });
  intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty5()));
  lessThan5 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
  max3 = /* @__PURE__ */ dual(2, (self, that) => lessThan5(self, that) ? that : self);
});

// ../../node_modules/effect/dist/esm/ScheduleIntervals.js
var make40, union9, intersect4, start2, end2, lessThan6, isNonEmpty5, max4;
var init_ScheduleIntervals = __esm(() => {
  init_intervals();
  make40 = make39;
  union9 = union8;
  intersect4 = intersect3;
  start2 = start;
  end2 = end;
  lessThan6 = lessThan5;
  isNonEmpty5 = isNonEmpty4;
  max4 = max3;
});

// ../../node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue", OP_DONE2 = "Done", _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
}, continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make40(of2(interval))
  };
}, done6, isContinue = (self) => {
  return self._tag === OP_CONTINUE;
}, isDone4 = (self) => {
  return self._tag === OP_DONE2;
};
var init_decision = __esm(() => {
  init_Chunk();
  init_ScheduleIntervals();
  done6 = {
    _tag: OP_DONE2
  };
});

// ../../node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2, continueWith2, done7, isContinue2, isDone5;
var init_ScheduleDecision = __esm(() => {
  init_decision();
  _continue2 = _continue;
  continueWith2 = continueWith;
  done7 = done6;
  isContinue2 = isContinue;
  isDone5 = isDone4;
});

// ../../node_modules/effect/dist/esm/Scope.js
var Scope, addFinalizer2, addFinalizerExit, close, extend2, fork2, make41;
var init_Scope = __esm(() => {
  init_core();
  init_fiberRuntime();
  Scope = scopeTag;
  addFinalizer2 = scopeAddFinalizer;
  addFinalizerExit = scopeAddFinalizerExit;
  close = scopeClose;
  extend2 = scopeExtend;
  fork2 = scopeFork;
  make41 = scopeMake;
});

// ../../node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap9(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits))));
  withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits), makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits)), Latch, unsafeMakeLatch = (open) => new Latch(open ?? false), makeLatch = (open) => sync(() => unsafeMakeLatch(open)), awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll), cached2, cachedInvalidateWithTTL, computeCachedValue = (self, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self, deferred)), map10((deferred) => some2([start3 + timeToLiveMillis, deferred])));
}, getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap9((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
  switch (option2._tag) {
    case "None": {
      return some2(computeCachedValue(self, timeToLive, time));
    }
    case "Some": {
      const [end3] = option2.value;
      return end3 - time <= 0 ? some2(computeCachedValue(self, timeToLive, time)) : none2();
    }
  }
})), flatMap9((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1]))))), invalidateCache = (cache) => set5(cache, none2()), ensuringChild, ensuringChildren, forkAll, forkIn, forkScoped = (self) => scopeWith((scope2) => forkIn(self, scope2)), fromFiber = (fiber) => join3(fiber), fromFiberEffect = (fiber) => suspend(() => flatMap9(fiber, join3)), memoKeySymbol, Key, cachedFunction = (f, eq) => {
  return pipe(sync(() => empty21()), flatMap9(makeSynchronized), map10((ref) => (a) => pipe(ref.modifyEffect((map14) => {
    const result = pipe(map14, get8(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map10((deferred) => [deferred, pipe(map14, set4(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map14]);
  }), flatMap9(deferredAwait), flatMap9(([patch12, b]) => pipe(patchFiberRefs(patch12), as2(b))))));
}, raceFirst, supervised, timeout, timeoutFail, timeoutFailCause, timeoutOption, timeoutTo, SynchronizedSymbolKey = "effect/Ref/SynchronizedRef", SynchronizedTypeId, synchronizedVariance, SynchronizedImpl, makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value)), unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake6(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
}, updateSomeAndGetEffectSynchronized, zipFiber, zipLeftFiber, zipRightFiber, zipWithFiber, bindAll;
var init_circular = __esm(() => {
  init_Duration();
  init_Effectable();
  init_Equal();
  init_Exit();
  init_FiberId();
  init_Function();
  init_Hash();
  init_MutableHashMap();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Readable();
  init_Scheduler();
  init_cause();
  init_core_effect();
  init_core();
  init_fiber();
  init_fiberRuntime();
  init_fiberScope();
  init_ref();
  init_supervisor();
  Latch = class Latch extends Class {
    isOpen;
    waiters = [];
    scheduled = false;
    constructor(isOpen) {
      super();
      this.isOpen = isOpen;
    }
    commit() {
      return this.await;
    }
    unsafeSchedule(fiber) {
      if (this.scheduled || this.waiters.length === 0) {
        return void_2;
      }
      this.scheduled = true;
      fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
      return void_2;
    }
    flushWaiters = () => {
      this.scheduled = false;
      const waiters = this.waiters;
      this.waiters = [];
      for (let i = 0;i < waiters.length; i++) {
        waiters[i](exitVoid);
      }
    };
    open = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_2;
      }
      this.isOpen = true;
      return this.unsafeSchedule(fiber);
    });
    unsafeOpen() {
      if (this.isOpen)
        return;
      this.isOpen = true;
      this.flushWaiters();
    }
    release = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_2;
      }
      return this.unsafeSchedule(fiber);
    });
    await = /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.isOpen) {
        return resume2(void_2);
      }
      this.waiters.push(resume2);
      return sync(() => {
        const index = this.waiters.indexOf(resume2);
        if (index !== -1) {
          this.waiters.splice(index, 1);
        }
      });
    });
    unsafeClose() {
      this.isOpen = false;
    }
    close = /* @__PURE__ */ sync(() => {
      this.isOpen = false;
    });
    whenOpen = (self) => {
      return zipRight2(this.await, self);
    };
  };
  cached2 = /* @__PURE__ */ dual(2, (self, timeToLive) => map10(cachedInvalidateWithTTL(self, timeToLive), (tuple3) => tuple3[0]));
  cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self, timeToLive) => {
    const duration = decode(timeToLive);
    return flatMap9(context(), (env) => map10(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
  });
  ensuringChild = /* @__PURE__ */ dual(2, (self, f) => ensuringChildren(self, (children2) => f(fiberAll(children2))));
  ensuringChildren = /* @__PURE__ */ dual(2, (self, children2) => flatMap9(track, (supervisor) => pipe(supervised(self, supervisor), ensuring(flatMap9(supervisor.value, children2)))));
  forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map10(forEachSequential(effects, fork), fiberAll));
  forkIn = /* @__PURE__ */ dual(2, (self, scope2) => withFiberRuntime((parent, parentStatus) => {
    const scopeImpl = scope2;
    const fiber = unsafeFork(self, parent, parentStatus.runtimeFlags, globalScope);
    if (scopeImpl.state._tag === "Open") {
      const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_2 : asVoid2(interruptFiber(fiber)));
      const key = {};
      scopeImpl.state.finalizers.set(key, finalizer);
      fiber.addObserver(() => {
        if (scopeImpl.state._tag === "Closed")
          return;
        scopeImpl.state.finalizers.delete(key);
      });
    } else {
      fiber.unsafeInterruptAsFork(parent.id());
    }
    return succeed(fiber);
  }));
  memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
  Key = class Key {
    a;
    eq;
    [memoKeySymbol] = memoKeySymbol;
    constructor(a, eq) {
      this.a = a;
      this.eq = eq;
    }
    [symbol2](that) {
      if (hasProperty(that, memoKeySymbol)) {
        if (this.eq) {
          return this.eq(this.a, that.a);
        } else {
          return equals(this.a, that.a);
        }
      }
      return false;
    }
    [symbol]() {
      return this.eq ? 0 : cached(this, hash(this.a));
    }
  };
  raceFirst = /* @__PURE__ */ dual(2, (self, that) => pipe(exit(self), race(exit(that)), (effect) => flatten7(effect)));
  supervised = /* @__PURE__ */ dual(2, (self, supervisor) => {
    const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
    return supervise(self);
  });
  timeout = /* @__PURE__ */ dual(2, (self, duration) => timeoutFail(self, {
    onTimeout: () => timeoutExceptionFromDuration(duration),
    duration
  }));
  timeoutFail = /* @__PURE__ */ dual(2, (self, {
    duration,
    onTimeout
  }) => flatten7(timeoutTo(self, {
    onTimeout: () => failSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  timeoutFailCause = /* @__PURE__ */ dual(2, (self, {
    duration,
    onTimeout
  }) => flatten7(timeoutTo(self, {
    onTimeout: () => failCauseSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  timeoutOption = /* @__PURE__ */ dual(2, (self, duration) => timeoutTo(self, {
    duration,
    onSuccess: some2,
    onTimeout: none2
  }));
  timeoutTo = /* @__PURE__ */ dual(2, (self, {
    duration,
    onSuccess,
    onTimeout
  }) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration)), {
    onSelfWin: (winner, loser) => flatMap9(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap9(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
      } else {
        return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    onOtherWin: (winner, loser) => flatMap9(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap9(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onTimeout()));
      } else {
        return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    otherScope: globalScope
  }))));
  SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
  synchronizedVariance = {
    _A: (_) => _
  };
  SynchronizedImpl = class SynchronizedImpl extends Class {
    ref;
    withLock;
    [SynchronizedTypeId] = synchronizedVariance;
    [RefTypeId] = refVariance;
    [TypeId14] = TypeId14;
    constructor(ref, withLock) {
      super();
      this.ref = ref;
      this.withLock = withLock;
      this.get = get11(this.ref);
    }
    get;
    commit() {
      return this.get;
    }
    modify(f) {
      return this.modifyEffect((a) => succeed(f(a)));
    }
    modifyEffect(f) {
      return this.withLock(pipe(flatMap9(get11(this.ref), f), flatMap9(([b, a]) => as2(set5(this.ref, a), b))));
    }
  };
  updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self, pf) => self.modifyEffect((value) => {
    const result = pf(value);
    switch (result._tag) {
      case "None": {
        return succeed([value, value]);
      }
      case "Some": {
        return map10(result.value, (a) => [a, a]);
      }
    }
  }));
  zipFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
  zipLeftFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
  zipRightFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
  zipWithFiber = /* @__PURE__ */ dual(3, (self, that, f) => ({
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => pipe(self.id(), getOrElse5(that.id())),
    await: pipe(self.await, flatten7, zipWithOptions(flatten7(that.await), f, {
      concurrent: true
    }), exit),
    children: self.children,
    inheritAll: zipRight2(that.inheritAll, self.inheritAll),
    poll: zipWith4(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap((exitA) => pipe(optionB, map2((exitB) => zipWith5(exitA, exitB, {
      onSuccess: f,
      onFailure: parallel
    })))))),
    interruptAsFork: (id2) => zipRight2(self.interruptAsFork(id2), that.interruptAsFork(id2)),
    pipe() {
      return pipeArguments(this, arguments);
    }
  }));
  bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, f, options) => flatMap9(self, (a) => all5(f(a), options).pipe(map10((record) => Object.assign({}, a, record)))));
});

// ../../node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId17;
var init_circular2 = __esm(() => {
  TypeId17 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");
});

// ../../node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope", OP_FOLD = "Fold", OP_FRESH = "Fresh", OP_FROM_EFFECT = "FromEffect", OP_SCOPED = "Scoped", OP_SUSPEND = "Suspend", OP_PROVIDE = "Provide", OP_PROVIDE_MERGE = "ProvideMerge", OP_ZIP_WITH2 = "ZipWith";

// ../../node_modules/effect/dist/esm/Fiber.js
var exports_Fiber = {};
__export(exports_Fiber, {
  zipWith: () => zipWith6,
  zipRight: () => zipRight4,
  zipLeft: () => zipLeft3,
  zip: () => zip6,
  void: () => void_6,
  unsafeRoots: () => unsafeRoots2,
  succeed: () => succeed6,
  status: () => status2,
  scoped: () => scoped,
  roots: () => roots2,
  pretty: () => pretty4,
  poll: () => poll4,
  orElseEither: () => orElseEither4,
  orElse: () => orElse4,
  never: () => never3,
  match: () => match11,
  mapFiber: () => mapFiber2,
  mapEffect: () => mapEffect2,
  map: () => map14,
  joinAll: () => joinAll,
  join: () => join4,
  isRuntimeFiber: () => isRuntimeFiber2,
  isFiber: () => isFiber2,
  interrupted: () => interrupted2,
  interruptFork: () => interruptFork,
  interruptAsFork: () => interruptAsFork2,
  interruptAs: () => interruptAs,
  interruptAllAs: () => interruptAllAs2,
  interruptAll: () => interruptAll2,
  interrupt: () => interrupt6,
  inheritAll: () => inheritAll2,
  id: () => id2,
  getCurrentFiber: () => getCurrentFiber2,
  fromEffect: () => fromEffect3,
  failCause: () => failCause6,
  fail: () => fail7,
  dumpAll: () => dumpAll2,
  dump: () => dump2,
  done: () => done8,
  children: () => children2,
  awaitAll: () => awaitAll,
  await: () => _await3,
  all: () => all6,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  Order: () => Order4,
  FiberTypeId: () => FiberTypeId2
});
var FiberTypeId2, RuntimeFiberTypeId2, Order4, isFiber2, isRuntimeFiber2, id2, _await3, awaitAll, children2, all6, done8, dump2, dumpAll2, fail7, failCause6, fromEffect3, getCurrentFiber2, inheritAll2, interrupt6, interrupted2, interruptAs, interruptAsFork2, interruptAll2, interruptAllAs2, interruptFork, join4, joinAll, map14, mapEffect2, mapFiber2, match11, never3, orElse4, orElseEither4, poll4, pretty4, roots2, unsafeRoots2, scoped, status2, succeed6, void_6, zip6, zipLeft3, zipRight4, zipWith6;
var init_Fiber = __esm(() => {
  init_core();
  init_circular();
  init_fiber();
  init_fiberRuntime();
  FiberTypeId2 = FiberTypeId;
  RuntimeFiberTypeId2 = RuntimeFiberTypeId;
  Order4 = Order3;
  isFiber2 = isFiber;
  isRuntimeFiber2 = isRuntimeFiber;
  id2 = id;
  _await3 = _await2;
  awaitAll = fiberAwaitAll;
  children2 = children;
  all6 = fiberAll;
  done8 = done5;
  dump2 = dump;
  dumpAll2 = dumpAll;
  fail7 = fail5;
  failCause6 = failCause5;
  fromEffect3 = fromEffect;
  getCurrentFiber2 = getCurrentFiber;
  inheritAll2 = inheritAll;
  interrupt6 = interruptFiber;
  interrupted2 = interrupted;
  interruptAs = interruptAsFiber;
  interruptAsFork2 = interruptAsFork;
  interruptAll2 = interruptAll;
  interruptAllAs2 = interruptAllAs;
  interruptFork = fiberInterruptFork;
  join4 = join3;
  joinAll = fiberJoinAll;
  map14 = map12;
  mapEffect2 = mapEffect;
  mapFiber2 = mapFiber;
  match11 = match10;
  never3 = never2;
  orElse4 = orElse3;
  orElseEither4 = orElseEither2;
  poll4 = poll3;
  pretty4 = pretty2;
  roots2 = roots;
  unsafeRoots2 = unsafeRoots;
  scoped = fiberScoped;
  status2 = status;
  succeed6 = succeed5;
  void_6 = void_5;
  zip6 = zipFiber;
  zipLeft3 = zipLeftFiber;
  zipRight4 = zipRightFiber;
  zipWith6 = zipWithFiber;
});

// ../../node_modules/effect/dist/esm/internal/runtime.js
class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime2 = arguments[0];
    return (effect, ...args2) => f(runtime2, effect, ...args2);
  }
  return f.apply(this, arguments);
}, unsafeFork2, unsafeRunCallback, unsafeRunSync, AsyncFiberExceptionImpl, asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
}, FiberFailureId, FiberFailureCauseId, FiberFailureImpl, fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error;
}, fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
}, unsafeRunSyncExit, unsafeRunPromise, unsafeRunPromiseExit, make42 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs), runtime2 = () => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs()))), defaultRuntimeFlags, defaultRuntime, unsafeRunEffect, unsafeForkEffect, unsafeRunPromiseEffect, unsafeRunPromiseExitEffect, unsafeRunSyncEffect, unsafeRunSyncExitEffect, asyncEffect = (register) => suspend(() => {
  let cleanup = undefined;
  return flatMap9(deferredMake(), (deferred) => flatMap9(runtime2(), (runtime3) => uninterruptibleMask((restore) => zipRight2(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime3)(intoDeferred(cb, deferred))), {
    onFailure: (cause2) => deferredFailCause(deferred, cause2),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_2;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_2))))));
});
var init_runtime = __esm(() => {
  init_Context();
  init_Equal();
  init_Exit();
  init_Fiber();
  init_FiberId();
  init_FiberRefs();
  init_Function();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Scheduler();
  init_Scope();
  init_cause();
  init_core();
  init_executionStrategy();
  init_fiberRuntime();
  init_fiberScope();
  init_runtimeFlags();
  init_supervisor();
  unsafeFork2 = /* @__PURE__ */ makeDual((runtime2, self, options) => {
    const fiberId2 = unsafeMake3();
    const fiberRefUpdates = [[currentContext, [[fiberId2, runtime2.context]]]];
    if (options?.scheduler) {
      fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
    }
    let fiberRefs3 = updateManyAs2(runtime2.fiberRefs, {
      entries: fiberRefUpdates,
      forkAs: fiberId2
    });
    if (options?.updateRefs) {
      fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
    }
    const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime2.runtimeFlags);
    let effect = self;
    if (options?.scope) {
      effect = flatMap9(fork2(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_2 : interruptAsFiber(fiberRuntime, id3))), onExit(self, (exit2) => close(closeableScope, exit2))));
    }
    const supervisor = fiberRuntime.currentSupervisor;
    if (supervisor !== none8) {
      supervisor.onStart(runtime2.context, effect, none2(), fiberRuntime);
      fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
    }
    globalScope.add(runtime2.runtimeFlags, fiberRuntime);
    if (options?.immediate === false) {
      fiberRuntime.resume(effect);
    } else {
      fiberRuntime.start(effect);
    }
    return fiberRuntime;
  });
  unsafeRunCallback = /* @__PURE__ */ makeDual((runtime2, effect, options = {}) => {
    const fiberRuntime = unsafeFork2(runtime2, effect, options);
    if (options.onExit) {
      fiberRuntime.addObserver((exit2) => {
        options.onExit(exit2);
      });
    }
    return (id3, cancelOptions) => unsafeRunCallback(runtime2)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
      ...cancelOptions,
      onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten8(exit2)) : undefined
    });
  });
  unsafeRunSync = /* @__PURE__ */ makeDual((runtime2, effect) => {
    const result = unsafeRunSyncExit(runtime2)(effect);
    if (result._tag === "Failure") {
      throw fiberFailure(result.effect_instruction_i0);
    }
    return result.effect_instruction_i0;
  });
  AsyncFiberExceptionImpl = class AsyncFiberExceptionImpl extends Error {
    fiber;
    _tag = "AsyncFiberException";
    constructor(fiber) {
      super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
      this.fiber = fiber;
      this.name = this._tag;
      this.stack = this.message;
    }
  };
  FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
  FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
  FiberFailureImpl = class FiberFailureImpl extends Error {
    [FiberFailureId];
    [FiberFailureCauseId];
    constructor(cause2) {
      const head4 = prettyErrors(cause2)[0];
      super(head4?.message || "An error has occurred");
      this[FiberFailureId] = FiberFailureId;
      this[FiberFailureCauseId] = cause2;
      this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
      if (head4?.stack) {
        this.stack = head4.stack;
      }
    }
    toJSON() {
      return {
        _id: "FiberFailure",
        cause: this[FiberFailureCauseId].toJSON()
      };
    }
    toString() {
      return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
        renderErrorCause: true
      });
    }
    [NodeInspectSymbol]() {
      return this.toString();
    }
  };
  unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime2, effect) => {
    const op = fastPath(effect);
    if (op) {
      return op;
    }
    const scheduler = new SyncScheduler;
    const fiberRuntime = unsafeFork2(runtime2)(effect, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      return result;
    }
    return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
  });
  unsafeRunPromise = /* @__PURE__ */ makeDual((runtime2, effect, options) => unsafeRunPromiseExit(runtime2, effect, options).then((result) => {
    switch (result._tag) {
      case OP_SUCCESS: {
        return result.effect_instruction_i0;
      }
      case OP_FAILURE: {
        throw fiberFailure(result.effect_instruction_i0);
      }
    }
  }));
  unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime2, effect, options) => new Promise((resolve) => {
    const op = fastPath(effect);
    if (op) {
      resolve(op);
    }
    const fiber = unsafeFork2(runtime2)(effect);
    fiber.addObserver((exit2) => {
      resolve(exit2);
    });
    if (options?.signal !== undefined) {
      if (options.signal.aborted) {
        fiber.unsafeInterruptAsFork(fiber.id());
      } else {
        options.signal.addEventListener("abort", () => {
          fiber.unsafeInterruptAsFork(fiber.id());
        }, {
          once: true
        });
      }
    }
  }));
  defaultRuntimeFlags = /* @__PURE__ */ make18(Interruption, CooperativeYielding, RuntimeMetrics);
  defaultRuntime = /* @__PURE__ */ make42({
    context: /* @__PURE__ */ empty4(),
    runtimeFlags: defaultRuntimeFlags,
    fiberRefs: /* @__PURE__ */ empty25()
  });
  unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
  unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
  unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
  unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
  unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
  unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
});

// ../../node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect;
var init_synchronizedRef = __esm(() => {
  init_Function();
  init_Option();
  init_core();
  modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));
});

// ../../node_modules/effect/dist/esm/internal/layer.js
function fromEffectContext(effect) {
  const fromEffect5 = Object.create(proto3);
  fromEffect5._op_layer = OP_FROM_EFFECT;
  fromEffect5.effect = effect;
  return fromEffect5;
}
var LayerSymbolKey = "effect/Layer", LayerTypeId, layerVariance, proto3, MemoMapTypeIdKey = "effect/Layer/MemoMap", MemoMapTypeId, CurrentMemoMap, isLayer = (u) => hasProperty(u, LayerTypeId), isFresh = (self) => {
  return self._op_layer === OP_FRESH;
}, MemoMapImpl, makeMemoMap, unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map)), build = (self) => scopeWith((scope2) => buildWithScope(self, scope2)), buildWithScope, buildWithMemoMap, makeBuilder = (self, scope2, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap9((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith4(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
        concurrent: true
      })));
    }
  }
}, catchAll2, catchAllCause2, die6 = (defect) => failCause7(die5(defect)), dieSync3 = (evaluate2) => failCauseSync3(() => die5(evaluate2())), discard = (self) => map15(self, () => empty4()), context2 = () => fromEffectContext(context()), extendScope = (self) => {
  const extendScope2 = Object.create(proto3);
  extendScope2._op_layer = OP_EXTEND_SCOPE;
  extendScope2.layer = self;
  return extendScope2;
}, fail8 = (error) => failCause7(fail6(error)), failSync3 = (evaluate2) => failCauseSync3(() => fail6(evaluate2())), failCause7 = (cause2) => fromEffectContext(failCause(cause2)), failCauseSync3 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2)), flatMap11, flatten9, fresh = (self) => {
  const fresh2 = Object.create(proto3);
  fresh2._op_layer = OP_FRESH;
  fresh2.layer = self;
  return fresh2;
}, fromEffect4, fromEffectDiscard = (effect) => fromEffectContext(map10(effect, () => empty4())), fiberRefLocally2, locallyEffect, fiberRefLocallyWith2, fiberRefLocallyScoped2 = (self, value) => scopedDiscard(fiberRefLocallyScoped(self, value)), fiberRefLocallyScopedWith2 = (self, value) => scopedDiscard(fiberRefLocallyScopedWith(self, value)), fromFunction = (tagA, tagB, f) => fromEffectContext(map10(tagA, (a) => make6(tagB, f(a)))), launch = (self) => scopedEffect(zipRight2(scopeWith((scope2) => pipe(self, buildWithScope(scope2))), never)), map15, mapError2, matchCause2, match12, memoize2 = (self) => scopeWith((scope2) => map10(memoize(buildWithScope(self, scope2)), fromEffectContext)), merge6, mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i = 1;i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
}, orDie2 = (self) => catchAll2(self, (defect) => die6(defect)), orElse5, passthrough = (self) => merge6(context2(), self), project, retry, retryLoop = (self, schedule, stateTag, state) => {
  return pipe(self, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap11((env) => fresh(retryLoop(self, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
}, retryUpdate = (schedule, stateTag, error, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap9((now) => pipe(schedule.step(now, error, state), flatMap9(([state2, _, decision]) => isDone5(decision) ? fail2(error) : pipe(sleep2(millis(start2(decision.intervals) - now)), as2({
    state: state2
  })))))));
}, scoped2, scopedDiscard = (effect) => scopedContext(pipe(effect, as2(empty4()))), scopedContext = (effect) => {
  const scoped3 = Object.create(proto3);
  scoped3._op_layer = OP_SCOPED;
  scoped3.effect = effect;
  return scoped3;
}, scope2, service = (tag) => fromEffect4(tag, tag), succeed7, succeedContext = (context3) => {
  return fromEffectContext(succeed(context3));
}, empty33, suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
}, sync3, syncContext = (evaluate2) => {
  return fromEffectContext(sync(evaluate2));
}, tap3, tapError2, tapErrorCause2, toRuntime = (self) => pipe(scopeWith((scope3) => buildWithScope(self, scope3)), flatMap9((context3) => pipe(runtime2(), provideContext(context3)))), toRuntimeWithMemoMap, provide, provideMerge, zipWith7, unwrapEffect = (self) => {
  const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap11(fromEffect4(tag, self), (context3) => get3(context3, tag));
}, unwrapScoped = (self) => {
  const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap11(scoped2(tag, self), (context3) => get3(context3, tag));
}, annotateLogs2, annotateSpans2, withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return unwrapScoped(map10(options?.onEnd ? tap2(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self, span2)));
  }
  return (self) => unwrapScoped(map10(options?.onEnd ? tap2(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self, span2)));
}, withParentSpan2, provideSomeLayer, provideSomeRuntime, effect_provide;
var init_layer = __esm(() => {
  init_Cause();
  init_Clock();
  init_Context();
  init_Duration();
  init_FiberRefsPatch();
  init_Function();
  init_HashMap();
  init_Pipeable();
  init_Predicate();
  init_ScheduleDecision();
  init_ScheduleIntervals();
  init_Scope();
  init_core_effect();
  init_core();
  init_circular();
  init_fiberRuntime();
  init_circular2();
  init_ref();
  init_runtime();
  init_runtimeFlags();
  init_synchronizedRef();
  init_tracer();
  LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
  layerVariance = {
    _RIn: (_) => _,
    _E: (_) => _,
    _ROut: (_) => _
  };
  proto3 = {
    [LayerTypeId]: layerVariance,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
  CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
    defaultValue: () => unsafeMakeMemoMap()
  });
  MemoMapImpl = class MemoMapImpl {
    ref;
    [MemoMapTypeId];
    constructor(ref) {
      this.ref = ref;
      this[MemoMapTypeId] = MemoMapTypeId;
    }
    getOrElseMemoize(layer, scope2) {
      return pipe(modifyEffect(this.ref, (map15) => {
        const inMap = map15.get(layer);
        if (inMap !== undefined) {
          const [acquire, release] = inMap;
          const cached3 = pipe(acquire, flatMap9(([patch12, b]) => pipe(patchFiberRefs(patch12), as2(b))), onExit(exitMatch({
            onFailure: () => void_2,
            onSuccess: () => scopeAddFinalizerExit(scope2, release)
          })));
          return succeed([cached3, map15]);
        }
        return pipe(make28(0), flatMap9((observers) => pipe(deferredMake(), flatMap9((deferred) => pipe(make28(() => void_2), map10((finalizerRef) => {
          const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap9((innerScope) => pipe(restore(flatMap9(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap9((exit2) => {
            switch (exit2._tag) {
              case OP_FAILURE: {
                return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit2)), zipRight2(failCause(exit2.effect_instruction_i0)));
              }
              case OP_SUCCESS: {
                return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify5(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update2(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map15.delete(layer)), zipRight2(get11(finalizerRef)), flatMap9((finalizer) => finalizer(exit3))))), zipRight2(deferredSucceed(deferred, exit2.effect_instruction_i0)), as2(exit2.effect_instruction_i0[1]));
              }
            }
          })))));
          const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
            onFailure: () => void_2,
            onSuccess: () => update2(observers, (n) => n + 1)
          }))), (exit2) => pipe(get11(finalizerRef), flatMap9((finalizer) => finalizer(exit2)))];
          return [resource, isFresh(layer) ? map15 : map15.set(layer, memoized)];
        }))))));
      }), flatten7);
    }
  };
  makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
  buildWithScope = /* @__PURE__ */ dual(2, (self, scope2) => flatMap9(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope2)));
  buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope2) => flatMap9(makeBuilder(self, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
  catchAll2 = /* @__PURE__ */ dual(2, (self, onFailure) => match12(self, {
    onFailure,
    onSuccess: succeedContext
  }));
  catchAllCause2 = /* @__PURE__ */ dual(2, (self, onFailure) => matchCause2(self, {
    onFailure,
    onSuccess: succeedContext
  }));
  flatMap11 = /* @__PURE__ */ dual(2, (self, f) => match12(self, {
    onFailure: fail8,
    onSuccess: f
  }));
  flatten9 = /* @__PURE__ */ dual(2, (self, tag) => flatMap11(self, get3(tag)));
  fromEffect4 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return fromEffectContext(map10(effect, (service) => make6(tag, service)));
  });
  fiberRefLocally2 = /* @__PURE__ */ dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocally(ref, value)));
  locallyEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const locally = Object.create(proto3);
    locally._op_layer = "Locally";
    locally.self = self;
    locally.f = f;
    return locally;
  });
  fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocallyWith(ref, value)));
  map15 = /* @__PURE__ */ dual(2, (self, f) => flatMap11(self, (context3) => succeedContext(f(context3))));
  mapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (error) => failSync3(() => f(error))));
  matchCause2 = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    const fold = Object.create(proto3);
    fold._op_layer = OP_FOLD;
    fold.layer = self;
    fold.failureK = onFailure;
    fold.successK = onSuccess;
    return fold;
  });
  match12 = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => matchCause2(self, {
    onFailure: (cause2) => {
      const failureOrCause3 = failureOrCause2(cause2);
      switch (failureOrCause3._tag) {
        case "Left": {
          return onFailure(failureOrCause3.left);
        }
        case "Right": {
          return failCause7(failureOrCause3.right);
        }
      }
    },
    onSuccess
  }));
  merge6 = /* @__PURE__ */ dual(2, (self, that) => zipWith7(self, that, (a, b) => merge3(a, b)));
  orElse5 = /* @__PURE__ */ dual(2, (self, that) => catchAll2(self, that));
  project = /* @__PURE__ */ dual(4, (self, tagA, tagB, f) => map15(self, (context3) => make6(tagB, f(unsafeGet3(context3, tagA)))));
  retry = /* @__PURE__ */ dual(2, (self, schedule) => suspend2(() => {
    const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
    return pipe(succeed7(stateTag, {
      state: schedule.initial
    }), flatMap11((env) => retryLoop(self, schedule, stateTag, pipe(env, get3(stateTag)).state)));
  }));
  scoped2 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return scopedContext(map10(effect, (service) => make6(tag, service)));
  });
  scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map10(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make6(Scope, scope3)));
  succeed7 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const resource = tagFirst ? b : a;
    return fromEffectContext(succeed(make6(tag, resource)));
  });
  empty33 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
  sync3 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const evaluate2 = tagFirst ? b : a;
    return fromEffectContext(sync(() => make6(tag, evaluate2())));
  });
  tap3 = /* @__PURE__ */ dual(2, (self, f) => flatMap11(self, (context3) => fromEffectContext(as2(f(context3), context3))));
  tapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (e) => fromEffectContext(flatMap9(f(e), () => fail2(e)))));
  tapErrorCause2 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause2(self, (cause2) => fromEffectContext(flatMap9(f(cause2), () => failCause(cause2)))));
  toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self, memoMap) => flatMap9(scopeWith((scope3) => buildWithMemoMap(self, memoMap, scope3)), (context3) => pipe(runtime2(), provideContext(context3))));
  provide = /* @__PURE__ */ dual(2, (self, that) => suspend2(() => {
    const provideTo = Object.create(proto3);
    provideTo._op_layer = OP_PROVIDE;
    provideTo.first = Object.create(proto3, {
      _op_layer: {
        value: OP_PROVIDE_MERGE,
        enumerable: true
      },
      first: {
        value: context2(),
        enumerable: true
      },
      second: {
        value: Array.isArray(that) ? mergeAll4(...that) : that
      },
      zipK: {
        value: (a, b) => pipe(a, merge3(b))
      }
    });
    provideTo.second = self;
    return provideTo;
  }));
  provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
    const zipWith7 = Object.create(proto3);
    zipWith7._op_layer = OP_PROVIDE_MERGE;
    zipWith7.first = self;
    zipWith7.second = provide(that, self);
    zipWith7.zipK = (a, b) => {
      return pipe(a, merge3(b));
    };
    return zipWith7;
  });
  zipWith7 = /* @__PURE__ */ dual(3, (self, that, f) => suspend2(() => {
    const zipWith8 = Object.create(proto3);
    zipWith8._op_layer = OP_ZIP_WITH2;
    zipWith8.first = self;
    zipWith8.second = that;
    zipWith8.zipK = f;
    return zipWith8;
  }));
  annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  withParentSpan2 = /* @__PURE__ */ dual(2, (self, span2) => provide(self, succeedContext(make6(spanTag, span2))));
  provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith((scope3) => flatMap9(buildWithScope(layer, scope3), (context3) => provideSomeContext(self, context3))));
  provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
    const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
    const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
    return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
      const oldContext = fiber.getFiberRef(currentContext);
      const oldRefs = fiber.getFiberRefs();
      const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
      const oldFlags = fiber.currentRuntimeFlags;
      const newFlags = patch7(patchFlags)(oldFlags);
      const rollbackRefs = diff9(newRefs, oldRefs);
      const rollbackFlags = diff7(newFlags, oldFlags);
      fiber.setFiberRefs(newRefs);
      fiber.currentRuntimeFlags = newFlags;
      return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
        fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
        fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
        return void_2;
      }));
    }));
  });
  effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
    if (Array.isArray(source)) {
      return provideSomeLayer(self, mergeAll4(...source));
    } else if (isLayer(source)) {
      return provideSomeLayer(self, source);
    } else if (isContext2(source)) {
      return provideSomeContext(self, source);
    } else if (TypeId17 in source) {
      return flatMap9(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
    } else {
      return provideSomeRuntime(self, source);
    }
  });
});

// ../../node_modules/effect/dist/esm/internal/console.js
var console2, consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag))), withConsole, withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));
var init_console2 = __esm(() => {
  init_Context();
  init_Function();
  init_core();
  init_defaultServices();
  init_console();
  init_fiberRuntime();
  init_layer();
  console2 = /* @__PURE__ */ map10(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
  withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
});

// ../../node_modules/effect/dist/esm/Data.js
var exports_Data = {};
__export(exports_Data, {
  unsafeStruct: () => unsafeStruct,
  unsafeArray: () => unsafeArray,
  tuple: () => tuple3,
  taggedEnum: () => taggedEnum,
  tagged: () => tagged2,
  struct: () => struct2,
  case: () => _case,
  array: () => array4,
  TaggedError: () => TaggedError,
  TaggedClass: () => TaggedClass,
  Structural: () => Structural2,
  Error: () => Error3,
  Class: () => Class2
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value2) {
      return cases2[value2._tag](value2);
    };
  }
  const value = arguments[0];
  const cases = arguments[1];
  return cases[value._tag](value);
}
var struct2, unsafeStruct = (as4) => Object.setPrototypeOf(as4, StructuralPrototype), tuple3 = (...as4) => unsafeArray(as4), array4 = (as4) => unsafeArray(as4.slice(0)), unsafeArray = (as4) => Object.setPrototypeOf(as4, ArrayProto), _case = () => (args2) => args2 === undefined ? Object.create(StructuralPrototype) : struct2(args2), tagged2 = (tag) => (args2) => {
  const value = args2 === undefined ? Object.create(StructuralPrototype) : struct2(args2);
  value._tag = tag;
  return value;
}, Class2, TaggedClass = (tag) => {

  class Base3 extends Class2 {
    _tag = tag;
  }
  return Base3;
}, Structural2, taggedEnum = () => new Proxy({}, {
  get(_target, tag, _receiver) {
    if (tag === "$is") {
      return isTagged;
    } else if (tag === "$match") {
      return taggedMatch;
    }
    return tagged2(tag);
  }
}), Error3, TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};
var init_Data = __esm(() => {
  init_core();
  init_data();
  init_effectable();
  init_Predicate();
  struct2 = struct;
  Class2 = Structural;
  Structural2 = Structural;
  Error3 = /* @__PURE__ */ function() {
    const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
    const O = {
      BaseEffectError: class extends YieldableError {
        constructor(args2) {
          super(args2?.message, args2?.cause ? {
            cause: args2.cause
          } : undefined);
          if (args2) {
            Object.assign(this, args2);
            Object.defineProperty(this, plainArgsSymbol, {
              value: args2,
              enumerable: false
            });
          }
        }
        toJSON() {
          return {
            ...this[plainArgsSymbol],
            ...this
          };
        }
      }
    };
    return O.BaseEffectError;
  }();
});

// ../../node_modules/effect/dist/esm/internal/dateTime.js
var TypeId18, TimeZoneTypeId, Proto2, ProtoUtc, ProtoZoned, ProtoTimeZone, ProtoTimeZoneNamed, ProtoTimeZoneOffset, makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self;
}, isDateTime = (u) => hasProperty(u, TypeId18), isTimeZone = (u) => hasProperty(u, TimeZoneTypeId), isTimeZoneNamed = (u) => isTimeZone(u) && u._tag === "Named", isZoned = (self) => self._tag === "Zoned", makeUtc = (epochMillis) => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self;
}, unsafeFromDate = (date) => {
  const epochMillis = date.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
}, unsafeMake10 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date = new Date(0);
    setPartsDate(date, input);
    return unsafeFromDate(date);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
}, hasZone = (input) => /Z|[+-]\d{2}$|[+-]\d{2}:\d{2}$|\]$/.test(input), minEpochMillis, maxEpochMillis, unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === undefined && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake10(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new IllegalArgumentException2(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === undefined) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1000;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone);
}, validZoneCache, formatOptions, zoneMakeIntl = (format5) => {
  const zoneId = format5.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format5;
  validZoneCache.set(zoneId, zone);
  return zone;
}, zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
}, zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
}, zoneMakeNamed, offsetZoneRegex, zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some2(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
}, toDateUtc = (self) => new Date(self.epochMillis), toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== undefined) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== "literal");
  const date = new Date(0);
  date.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date.getTime();
  return date;
}, zonedOffset = (self) => {
  const date = toDate(self);
  return date.getTime() - toEpochMillis(self);
}, offsetToString = (offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1000));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1000) / (60 * 1000));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
}, zonedOffsetIso = (self) => offsetToString(zonedOffset(self)), toEpochMillis = (self) => self.epochMillis, dateToParts = (date) => ({
  millis: date.getUTCMilliseconds(),
  seconds: date.getUTCSeconds(),
  minutes: date.getUTCMinutes(),
  hours: date.getUTCHours(),
  day: date.getUTCDate(),
  weekDay: date.getUTCDay(),
  month: date.getUTCMonth() + 1,
  year: date.getUTCFullYear()
}), toParts = (self) => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== undefined) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
}, toPartsUtc = (self) => {
  if (self.partsUtc !== undefined) {
    return self.partsUtc;
  }
  self.partsUtc = withDateUtc(self, dateToParts);
  return self.partsUtc;
}, setPartsDate = (date, parts2) => {
  if (parts2.year !== undefined) {
    date.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== undefined) {
    date.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== undefined) {
    date.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== undefined) {
    const diff11 = parts2.weekDay - date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + diff11);
  }
  if (parts2.hours !== undefined) {
    date.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== undefined) {
    date.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== undefined) {
    date.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== undefined) {
    date.setUTCMilliseconds(parts2.millis);
  }
}, makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
}, offsetRegex, parseOffset = (offset) => {
  const match13 = offsetRegex.exec(offset);
  if (match13 === null) {
    return null;
  }
  const [, sign, hours2, minutes2] = match13;
  return (sign === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1000;
}, calculateNamedOffset = (adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(adjustedMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
}, mutate4, withDate, withDateUtc, formatIsoOffset = (self) => {
  const date = toDate(self);
  return self._tag === "Utc" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
}, formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;
var init_dateTime = __esm(() => {
  init_Cause();
  init_Clock();
  init_Duration();
  init_Either();
  init_Equal();
  init_Equivalence();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Order();
  init_Pipeable();
  init_Predicate();
  init_core_effect();
  init_core();
  TypeId18 = /* @__PURE__ */ Symbol.for("effect/DateTime");
  TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
  Proto2 = {
    [TypeId18]: TypeId18,
    pipe() {
      return pipeArguments(this, arguments);
    },
    [NodeInspectSymbol]() {
      return this.toString();
    },
    toJSON() {
      return toDateUtc(this).toJSON();
    }
  };
  ProtoUtc = {
    ...Proto2,
    _tag: "Utc",
    [symbol]() {
      return cached(this, number2(this.epochMillis));
    },
    [symbol2](that) {
      return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
    },
    toString() {
      return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
    }
  };
  ProtoZoned = {
    ...Proto2,
    _tag: "Zoned",
    [symbol]() {
      return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
    },
    [symbol2](that) {
      return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
    },
    toString() {
      return `DateTime.Zoned(${formatIsoZoned(this)})`;
    }
  };
  ProtoTimeZone = {
    [TimeZoneTypeId]: TimeZoneTypeId,
    [NodeInspectSymbol]() {
      return this.toString();
    }
  };
  ProtoTimeZoneNamed = {
    ...ProtoTimeZone,
    _tag: "Named",
    [symbol]() {
      return cached(this, string(`Named:${this.id}`));
    },
    [symbol2](that) {
      return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
    },
    toString() {
      return `TimeZone.Named(${this.id})`;
    },
    toJSON() {
      return {
        _id: "TimeZone",
        _tag: "Named",
        id: this.id
      };
    }
  };
  ProtoTimeZoneOffset = {
    ...ProtoTimeZone,
    _tag: "Offset",
    [symbol]() {
      return cached(this, string(`Offset:${this.offset}`));
    },
    [symbol2](that) {
      return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
    },
    toString() {
      return `TimeZone.Offset(${offsetToString(this.offset)})`;
    },
    toJSON() {
      return {
        _id: "TimeZone",
        _tag: "Offset",
        offset: this.offset
      };
    }
  };
  minEpochMillis = -8640000000000000 + 12 * 60 * 60 * 1000;
  maxEpochMillis = 8640000000000000 - 14 * 60 * 60 * 1000;
  validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => new Map);
  formatOptions = {
    day: "numeric",
    month: "numeric",
    year: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    timeZoneName: "longOffset",
    fractionalSecondDigits: 3,
    hourCycle: "h23"
  };
  zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
  offsetZoneRegex = /^(?:GMT|[+-])/;
  offsetRegex = /([+-])(\d{2}):(\d{2})$/;
  mutate4 = /* @__PURE__ */ dual(2, (self, f) => {
    if (self._tag === "Utc") {
      const date = toDateUtc(self);
      f(date);
      return makeUtc(date.getTime());
    }
    const adjustedDate = toDate(self);
    const newAdjustedDate = new Date(adjustedDate.getTime());
    f(newAdjustedDate);
    return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
  });
  withDate = /* @__PURE__ */ dual(2, (self, f) => f(toDate(self)));
  withDateUtc = /* @__PURE__ */ dual(2, (self, f) => f(toDateUtc(self)));
});

// ../../node_modules/effect/dist/esm/String.js
var isNonEmpty6 = (self) => self.length > 0;
var init_String = __esm(() => {
  init_Equivalence();
  init_Function();
  init_Number();
  init_Option();
  init_Order();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/Cron.js
function aliasOrValue(field, aliases) {
  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}
var TypeId19, CronProto, isCron = (u) => hasProperty(u, TypeId19), make43 = (values4) => {
  const o = Object.create(CronProto);
  o.seconds = new Set(sort(values4.seconds ?? [0], Order));
  o.minutes = new Set(sort(values4.minutes, Order));
  o.hours = new Set(sort(values4.hours, Order));
  o.days = new Set(sort(values4.days, Order));
  o.months = new Set(sort(values4.months, Order));
  o.weekdays = new Set(sort(values4.weekdays, Order));
  o.tz = fromNullable(values4.tz);
  const seconds2 = Array.from(o.seconds);
  const minutes2 = Array.from(o.minutes);
  const hours2 = Array.from(o.hours);
  const days2 = Array.from(o.days);
  const months = Array.from(o.months);
  const weekdays = Array.from(o.weekdays);
  o.first = {
    second: seconds2[0] ?? 0,
    minute: minutes2[0] ?? 0,
    hour: hours2[0] ?? 0,
    day: days2[0] ?? 1,
    month: (months[0] ?? 1) - 1,
    weekday: weekdays[0] ?? 0
  };
  o.next = {
    second: nextLookupTable(seconds2, 60),
    minute: nextLookupTable(minutes2, 60),
    hour: nextLookupTable(hours2, 24),
    day: nextLookupTable(days2, 32),
    month: nextLookupTable(months, 13),
    weekday: nextLookupTable(weekdays, 7)
  };
  return o;
}, nextLookupTable = (values4, size12) => {
  const result = new Array(size12).fill(undefined);
  if (values4.length === 0) {
    return result;
  }
  let current = undefined;
  let index = values4.length - 1;
  for (let i = size12 - 1;i >= 0; i--) {
    while (index >= 0 && values4[index] >= i) {
      current = values4[index--];
    }
    result[i] = current;
  }
  return result;
}, ParseErrorTypeId, ParseError, parse = (cron, tz) => {
  const segments = cron.split(" ").filter(isNonEmpty6);
  if (segments.length !== 5 && segments.length !== 6) {
    return left2(new ParseError({
      message: `Invalid number of segments in cron expression`,
      input: cron
    }));
  }
  if (segments.length === 5) {
    segments.unshift("0");
  }
  const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
  const zone = tz === undefined || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
    message: `Invalid time zone in cron expression`,
    input: tz
  }));
  return all({
    tz: zone,
    seconds: parseSegment(seconds2, secondOptions),
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map(make43));
}, match13 = (cron, date) => {
  const parts2 = unsafeMakeZoned(date, {
    timeZone: getOrUndefined(cron.tz)
  }).pipe(toParts);
  if (cron.seconds.size !== 0 && !cron.seconds.has(parts2.seconds)) {
    return false;
  }
  if (cron.minutes.size !== 0 && !cron.minutes.has(parts2.minutes)) {
    return false;
  }
  if (cron.hours.size !== 0 && !cron.hours.has(parts2.hours)) {
    return false;
  }
  if (cron.months.size !== 0 && !cron.months.has(parts2.month)) {
    return false;
  }
  if (cron.days.size === 0 && cron.weekdays.size === 0) {
    return true;
  }
  if (cron.weekdays.size === 0) {
    return cron.days.has(parts2.day);
  }
  if (cron.days.size === 0) {
    return cron.weekdays.has(parts2.weekDay);
  }
  return cron.days.has(parts2.day) || cron.weekdays.has(parts2.weekDay);
}, daysInMonth = (date) => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)).getUTCDate(), next2 = (cron, startFrom) => {
  const tz = getOrUndefined(cron.tz);
  const zoned = unsafeMakeZoned(startFrom ?? new Date, {
    timeZone: tz
  });
  const utc = tz !== undefined && isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? constVoid : (current) => {
    const adjusted = unsafeMakeZoned(current, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(toDate);
    const drift = current.getTime() - adjusted.getTime();
    if (drift > 0) {
      current.setTime(current.getTime() + drift);
    }
  };
  const result = mutate4(zoned, (current) => {
    current.setUTCSeconds(current.getUTCSeconds() + 1, 0);
    for (let i = 0;i < 1e4; i++) {
      if (cron.seconds.size !== 0) {
        const currentSecond = current.getUTCSeconds();
        const nextSecond = cron.next.second[currentSecond];
        if (nextSecond === undefined) {
          current.setUTCMinutes(current.getUTCMinutes() + 1, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextSecond > currentSecond) {
          current.setUTCSeconds(nextSecond);
          adjustDst(current);
          continue;
        }
      }
      if (cron.minutes.size !== 0) {
        const currentMinute = current.getUTCMinutes();
        const nextMinute = cron.next.minute[currentMinute];
        if (nextMinute === undefined) {
          current.setUTCHours(current.getUTCHours() + 1, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextMinute > currentMinute) {
          current.setUTCMinutes(nextMinute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.hours.size !== 0) {
        const currentHour = current.getUTCHours();
        const nextHour = cron.next.hour[currentHour];
        if (nextHour === undefined) {
          current.setUTCDate(current.getUTCDate() + 1);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextHour > currentHour) {
          current.setUTCHours(nextHour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.weekdays.size !== 0 || cron.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron.weekdays.size !== 0) {
          const currentWeekday = current.getUTCDay();
          const nextWeekday = cron.next.weekday[currentWeekday];
          a = nextWeekday === undefined ? 7 - currentWeekday + cron.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron.days.size !== 0 && a !== 0) {
          const currentDay = current.getUTCDate();
          const nextDay = cron.next.day[currentDay];
          b = nextDay === undefined ? daysInMonth(current) - currentDay + cron.first.day : nextDay - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current.setUTCDate(current.getUTCDate() + addDays);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      if (cron.months.size !== 0) {
        const currentMonth = current.getUTCMonth() + 1;
        const nextMonth = cron.next.month[currentMonth];
        if (nextMonth === undefined) {
          current.setUTCFullYear(current.getUTCFullYear() + 1);
          current.setUTCMonth(cron.first.month, cron.first.day);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
        if (nextMonth > currentMonth) {
          current.setUTCMonth(nextMonth - 1, cron.first.day);
          current.setUTCHours(cron.first.hour, cron.first.minute, cron.first.second);
          adjustDst(current);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return toDateUtc(result);
}, Equivalence3, restrictionsArrayEquals, restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable2(self), fromIterable2(that)), equals4, secondOptions, minuteOptions, hourOptions, dayOptions, monthOptions, weekdayOptions, parseSegment = (input, options) => {
  const capacity2 = options.max - options.min + 1;
  const values4 = new Set;
  const fields = input.split(",");
  for (const field of fields) {
    const [raw, step3] = splitStep(field);
    if (raw === "*" && step3 === undefined) {
      return right2(new Set);
    }
    if (step3 !== undefined) {
      if (!Number.isInteger(step3)) {
        return left2(new ParseError({
          message: `Expected step value to be a positive integer`,
          input
        }));
      }
      if (step3 < 1) {
        return left2(new ParseError({
          message: `Expected step value to be greater than 0`,
          input
        }));
      }
      if (step3 > options.max) {
        return left2(new ParseError({
          message: `Expected step value to be less than ${options.max}`,
          input
        }));
      }
    }
    if (raw === "*") {
      for (let i = options.min;i <= options.max; i += step3 ?? 1) {
        values4.add(i);
      }
    } else {
      const [left3, right3] = splitRange(raw, options.aliases);
      if (!Number.isInteger(left3)) {
        return left2(new ParseError({
          message: `Expected a positive integer`,
          input
        }));
      }
      if (left3 < options.min || left3 > options.max) {
        return left2(new ParseError({
          message: `Expected a value between ${options.min} and ${options.max}`,
          input
        }));
      }
      if (right3 === undefined) {
        values4.add(left3);
      } else {
        if (!Number.isInteger(right3)) {
          return left2(new ParseError({
            message: `Expected a positive integer`,
            input
          }));
        }
        if (right3 < options.min || right3 > options.max) {
          return left2(new ParseError({
            message: `Expected a value between ${options.min} and ${options.max}`,
            input
          }));
        }
        if (left3 > right3) {
          return left2(new ParseError({
            message: `Invalid value range`,
            input
          }));
        }
        for (let i = left3;i <= right3; i += step3 ?? 1) {
          values4.add(i);
        }
      }
    }
    if (values4.size >= capacity2) {
      return right2(new Set);
    }
  }
  return right2(values4);
}, splitStep = (input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, undefined];
}, splitRange = (input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), undefined];
};
var init_Cron = __esm(() => {
  init_Array();
  init_Data();
  init_Either();
  init_Equal();
  init_Equivalence();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_dateTime();
  init_Number();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_String();
  TypeId19 = /* @__PURE__ */ Symbol.for("effect/Cron");
  CronProto = {
    [TypeId19]: TypeId19,
    [symbol2](that) {
      return isCron(that) && equals4(this, that);
    },
    [symbol]() {
      return pipe(hash(this.tz), combine(array2(fromIterable2(this.seconds))), combine(array2(fromIterable2(this.minutes))), combine(array2(fromIterable2(this.hours))), combine(array2(fromIterable2(this.days))), combine(array2(fromIterable2(this.months))), combine(array2(fromIterable2(this.weekdays))), cached(this));
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Cron",
        tz: this.tz,
        seconds: fromIterable2(this.seconds),
        minutes: fromIterable2(this.minutes),
        hours: fromIterable2(this.hours),
        days: fromIterable2(this.days),
        months: fromIterable2(this.months),
        weekdays: fromIterable2(this.weekdays)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Cron/errors/ParseError");
  ParseError = class ParseError extends (/* @__PURE__ */ TaggedError("CronParseError")) {
    [ParseErrorTypeId] = ParseErrorTypeId;
  };
  Equivalence3 = /* @__PURE__ */ make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
  restrictionsArrayEquals = /* @__PURE__ */ array(number);
  equals4 = /* @__PURE__ */ dual(2, (self, that) => Equivalence3(self, that));
  secondOptions = {
    min: 0,
    max: 59
  };
  minuteOptions = {
    min: 0,
    max: 59
  };
  hourOptions = {
    min: 0,
    max: 23
  };
  dayOptions = {
    min: 1,
    max: 31
  };
  monthOptions = {
    min: 1,
    max: 12,
    aliases: {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12
    }
  };
  weekdayOptions = {
    min: 0,
    max: 6,
    aliases: {
      sun: 0,
      mon: 1,
      tue: 2,
      wed: 3,
      thu: 4,
      fri: 5,
      sat: 6
    }
  };
});

// ../../node_modules/effect/dist/esm/Random.js
var next3;
var init_Random = __esm(() => {
  init_defaultServices();
  init_random();
  next3 = next;
});

// ../../node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule", ScheduleTypeId, isSchedule = (u) => hasProperty(u, ScheduleTypeId), ScheduleDriverSymbolKey = "effect/ScheduleDriver", ScheduleDriverTypeId, defaultIterationMetadata, CurrentIterationMetadata, scheduleVariance, scheduleDriverVariance, ScheduleImpl, updateInfo = (iterationMetaRef, now, input) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now
} : {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
}), ScheduleDriverImpl, makeWithState = (initial, step3) => new ScheduleImpl(initial, step3), addDelay, addDelayEffect, andThen5, andThenEither, as4, asVoid3 = (self) => map16(self, constVoid), bothInOut, check, checkEffect, collectAllInputs = () => collectAllOutputs(identity2()), collectAllOutputs = (self) => reduce13(self, empty5(), (outs, out) => pipe(outs, append2(out))), collectUntil = (f) => collectAllOutputs(recurUntil(f)), collectUntilEffect = (f) => collectAllOutputs(recurUntilEffect(f)), collectWhile = (f) => collectAllOutputs(recurWhile(f)), collectWhileEffect = (f) => collectAllOutputs(recurWhileEffect(f)), compose, mapInput3, mapInputContext2, mapInputEffect, cron = (expression, tz) => {
  const parsed = isCron(expression) ? right2(expression) : parse(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now, _, [initial, previous]) => {
    if (now < previous[0]) {
      return succeed([[false, previous], [previous[1], previous[2]], continueWith2(make38(previous[1], previous[2]))]);
    }
    if (isLeft2(parsed)) {
      return die2(parsed.left);
    }
    const cron2 = parsed.right;
    const date = new Date(now);
    let next4;
    if (initial && match13(cron2, date)) {
      next4 = now;
    }
    next4 = next2(cron2, date).getTime();
    const start3 = beginningOfSecond(next4);
    const end3 = endOfSecond(next4);
    return succeed([[false, [next4, start3, end3]], [start3, end3], continueWith2(make38(start3, end3))]);
  });
}, dayOfMonth = (day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now, day, initial);
    const start3 = beginningOfDay(day0);
    const end3 = endOfDay(day0);
    const interval = make38(start3, end3);
    return succeed([[end3, n + 1], n, continueWith2(interval)]);
  });
}, dayOfWeek = (day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now, day, initial);
    const start3 = beginningOfDay(day0);
    const end3 = endOfDay(day0);
    const interval = make38(start3, end3);
    return succeed([[end3, n + 1], n, continueWith2(interval)]);
  });
}, delayed, delayedEffect, delayedSchedule = (schedule) => addDelay(schedule, (x) => x), delays = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), flatMap9(([state2, _, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, zero2, decision]);
  }
  return succeed([state2, millis(start2(decision.intervals) - now), decision]);
}))), mapBoth3, mapBothEffect, driver = (self) => pipe(make28([none2(), self.initial]), map10((ref) => new ScheduleDriverImpl(self, ref))), duration = (durationInput) => {
  const duration2 = decode(durationInput);
  const durationMillis = toMillis(duration2);
  return makeWithState(true, (now, _, state) => succeed(state ? [false, duration2, continueWith2(after2(now + durationMillis))] : [false, zero2, done7]));
}, either3, eitherWith, ensuring2, exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map16(forever2, (i) => times(base, Math.pow(factor, i))));
}, fibonacci = (oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold2([one, one], ([a, b]) => [b, sum(a, b)]), map16((out) => out[0])));
}, fixed = (intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now, _, [option2, n]) => sync(() => {
    switch (option2._tag) {
      case "None": {
        return [[some2([now, now + intervalMillis]), n + 1], n, continueWith2(after2(now + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option2.value;
        const runningBehind = now > lastRun + intervalMillis;
        const boundary = equals(interval, zero2) ? interval : millis(intervalMillis - (now - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero2) ? interval : boundary;
        const nextRun = runningBehind ? now : now + toMillis(sleepTime);
        return [[some2([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
}, fromDelay = (delay2) => duration(delay2), fromDelays = (delay2, ...delays2) => makeWithState([[delay2, ...delays2].map((_) => decode(_)), true], (now, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero2, done7];
})), fromFunction2 = (f) => map16(identity2(), f), hourOfDay = (hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now, hour, initial);
  const start3 = beginningOfHour(hour0);
  const end3 = endOfHour(hour0);
  const interval = make38(start3, end3);
  return succeed([[end3, n + 1], n, continueWith2(interval)]);
}), identity2 = () => makeWithState(undefined, (now, input, state) => succeed([state, input, continueWith2(after2(now))])), intersect5, intersectWith, intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty5(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan6(rInterval))) {
    return flatMap9(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap9(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
}, jittered = (self) => jitteredWith(self, {
  min: 0.8,
  max: 1.2
}), jitteredWith, linear = (baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map16(forever2, (i) => times(base, i + 1)));
}, map16, mapEffect3, minuteOfHour = (minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now, minute, initial);
  const start3 = beginningOfMinute(minute0);
  const end3 = endOfMinute(minute0);
  const interval = make38(start3, end3);
  return succeed([[end3, n + 1], n, continueWith2(interval)]);
}), modifyDelay, modifyDelayEffect, onDecision, passthrough2 = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision]))), provideContext3, provideService2, recurUntil = (f) => untilInput(identity2(), f), recurUntilEffect = (f) => untilInputEffect(identity2(), f), recurUntilOption = (pf) => untilOutput(map16(identity2(), pf), isSome2), recurUpTo = (durationInput) => {
  const duration2 = decode(durationInput);
  return whileOutput(elapsed, (elapsed) => lessThan2(elapsed, duration2));
}, recurWhile = (f) => whileInput(identity2(), f), recurWhileEffect = (f) => whileInputEffect(identity2(), f), recurs = (n) => whileOutput(forever2, (out) => out < n), reduce13, reduceEffect2, repetitions = (self) => reduce13(self, 0, (n, _) => n + 1), resetAfter, resetWhen, run, runLoop = (self, now, inputs, state, acc) => {
  if (!isNonEmpty2(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap9(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend2(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend2(acc, out));
  });
}, secondOfMinute = (second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now, second, initial);
  const start3 = beginningOfSecond(second0);
  const end3 = endOfSecond(second0);
  const interval = make38(start3, end3);
  return succeed([[end3, n + 1], n, continueWith2(interval)]);
}), spaced = (duration2) => addDelay(forever2, () => duration2), succeed8 = (value) => map16(forever2, () => value), sync4 = (evaluate2) => map16(forever2, evaluate2), tapInput, tapOutput, unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))])), union10, unionWith2, untilInput, untilInputEffect, untilOutput, untilOutputEffect, upTo, whileInput, whileInputEffect, whileOutput, whileOutputEffect, windowed = (intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now, _, [option2, n]) => {
    switch (option2._tag) {
      case "None": {
        return succeed([[some2(now), n + 1], n, continueWith2(after2(now + millis2))]);
      }
      case "Some": {
        return succeed([[some2(option2.value), n + 1], n, continueWith2(after2(now + (millis2 - (now - option2.value) % millis2)))]);
      }
    }
  });
}, zipLeft4, zipRight5, zipWith8, beginningOfSecond = (now) => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();
}, endOfSecond = (now) => {
  const date = new Date(beginningOfSecond(now));
  return date.setSeconds(date.getSeconds() + 1);
}, nextSecond = (now, second, initial) => {
  const date = new Date(now);
  if (date.getSeconds() === second && initial) {
    return now;
  }
  if (date.getSeconds() < second) {
    return date.setSeconds(second);
  }
  const newDate = new Date(date.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1000 * 60);
}, beginningOfMinute = (now) => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();
}, endOfMinute = (now) => {
  const date = new Date(beginningOfMinute(now));
  return date.setMinutes(date.getMinutes() + 1);
}, nextMinute = (now, minute, initial) => {
  const date = new Date(now);
  if (date.getMinutes() === minute && initial) {
    return now;
  }
  if (date.getMinutes() < minute) {
    return date.setMinutes(minute);
  }
  const newDate = new Date(date.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);
}, beginningOfHour = (now) => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();
}, endOfHour = (now) => {
  const date = new Date(beginningOfHour(now));
  return date.setHours(date.getHours() + 1);
}, nextHour = (now, hour, initial) => {
  const date = new Date(now);
  if (date.getHours() === hour && initial) {
    return now;
  }
  if (date.getHours() < hour) {
    return date.setHours(hour);
  }
  const newDate = new Date(date.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);
}, beginningOfDay = (now) => {
  const date = new Date(now);
  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();
}, endOfDay = (now) => {
  const date = new Date(beginningOfDay(now));
  return date.setDate(date.getDate() + 1);
}, nextDay = (now, dayOfWeek2, initial) => {
  const date = new Date(now);
  if (date.getDay() === dayOfWeek2 && initial) {
    return now;
  }
  const nextDayOfWeek = (7 + dayOfWeek2 - date.getDay()) % 7;
  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
}, nextDayOfMonth = (now, day, initial) => {
  const date = new Date(now);
  if (date.getDate() === day && initial) {
    return now;
  }
  if (date.getDate() < day) {
    return date.setDate(day);
  }
  return findNextMonth(now, day, 1);
}, findNextMonth = (now, day, months) => {
  const d = new Date(now);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now, day, months + 1);
}, ScheduleDefectTypeId, ScheduleDefect, isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId), scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e))), scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error) => fail(error.error)
}), scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2))), repeat_Effect, repeat_combined, repeatOrElse_Effect, repeatOrElseEffectLoop = (self, driver2, orElse6, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error) => orElse6(error, some2(b)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self, driver2, orElse6, value2)
  })
}), retry_Effect, retry_combined, fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
}, retryOrElse_Effect, retryOrElse_EffectLoop = (self, driver2, orElse6) => {
  return catchAll(self, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap9((out) => orElse6(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver2, orElse6)
  }));
}, schedule_Effect, scheduleFrom_Effect, scheduleFrom_EffectLoop = (self, initial, driver2) => matchEffect(driver2.next(initial), {
  onFailure: () => orDie(driver2.last),
  onSuccess: () => flatMap9(self, (a) => scheduleFrom_EffectLoop(self, a, driver2))
}), count, elapsed, forever2, once2, stop, scheduleForked;
var init_schedule = __esm(() => {
  init_Chunk();
  init_Clock();
  init_Context();
  init_Cron();
  init_Duration();
  init_Either();
  init_Equal();
  init_Function();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Random();
  init_ScheduleDecision();
  init_ScheduleInterval();
  init_ScheduleIntervals();
  init_cause();
  init_core_effect();
  init_core();
  init_circular();
  init_ref();
  ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
  ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
  defaultIterationMetadata = {
    start: 0,
    now: 0,
    input: undefined,
    elapsed: zero2,
    elapsedSincePrevious: zero2,
    recurrence: 0
  };
  CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
    defaultValue: () => defaultIterationMetadata
  });
  scheduleVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };
  scheduleDriverVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };
  ScheduleImpl = class ScheduleImpl {
    initial;
    step;
    [ScheduleTypeId] = scheduleVariance;
    constructor(initial, step3) {
      this.initial = initial;
      this.step = step3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  ScheduleDriverImpl = class ScheduleDriverImpl {
    schedule;
    ref;
    [ScheduleDriverTypeId] = scheduleDriverVariance;
    constructor(schedule, ref) {
      this.schedule = schedule;
      this.ref = ref;
    }
    get state() {
      return map10(get11(this.ref), (tuple4) => tuple4[1]);
    }
    get last() {
      return flatMap9(get11(this.ref), ([element, _]) => {
        switch (element._tag) {
          case "None": {
            return failSync(() => new NoSuchElementException);
          }
          case "Some": {
            return succeed(element.value);
          }
        }
      });
    }
    iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
    get reset() {
      return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set5(this.iterationMeta, defaultIterationMetadata)));
    }
    next(input) {
      return pipe(map10(get11(this.ref), (tuple4) => tuple4[1]), flatMap9((state) => pipe(currentTimeMillis2, flatMap9((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap9(([state2, out, decision]) => {
        const setState = set5(this.ref, [some2(out), state2]);
        if (isDone5(decision)) {
          return setState.pipe(zipRight2(fail2(none2())));
        }
        const millis2 = start2(decision.intervals) - now;
        if (millis2 <= 0) {
          return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now, input)), as2(out));
        }
        const duration = millis(millis2);
        return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now, input)), zipRight2(sleep3(duration)), as2(out));
      }))))));
    }
  };
  addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
  addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => map10(f(out), (delay2) => sum(duration, decode(delay2)))));
  andThen5 = /* @__PURE__ */ dual(2, (self, that) => map16(andThenEither(self, that), merge));
  andThenEither = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? flatMap9(self.step(now, input, state[0]), ([lState, out, decision]) => {
    if (isDone5(decision)) {
      return map10(that.step(now, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
    }
    return succeed([[lState, state[1], true], left2(out), decision]);
  }) : map10(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
  as4 = /* @__PURE__ */ dual(2, (self, out) => map16(self, () => out));
  bothInOut = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => zipWith4(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
    if (isContinue2(lDecision) && isContinue2(rDecision)) {
      const interval = pipe(lDecision.intervals, union9(rDecision.intervals));
      return [[lState, rState], [out, out2], _continue2(interval)];
    }
    return [[lState, rState], [out, out2], done7];
  })));
  check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
  checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, done7]);
    }
    return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
  })));
  compose = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => flatMap9(self.step(now, input, state[0]), ([lState, out, lDecision]) => map10(that.step(now, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max4(rDecision.intervals)))]))));
  mapInput3 = /* @__PURE__ */ dual(2, (self, f) => mapInputEffect(self, (input2) => sync(() => f(input2))));
  mapInputContext2 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => mapInputContext(self.step(now, input, state), f)));
  mapInputEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input2, state) => flatMap9(f(input2), (input) => self.step(now, input, state))));
  delayed = /* @__PURE__ */ dual(2, (self, f) => delayedEffect(self, (duration) => sync(() => f(duration))));
  delayedEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (_, delay2) => f(delay2)));
  mapBoth3 = /* @__PURE__ */ dual(2, (self, {
    onInput,
    onOutput
  }) => map16(mapInput3(self, onInput), onOutput));
  mapBothEffect = /* @__PURE__ */ dual(2, (self, {
    onInput,
    onOutput
  }) => mapEffect3(mapInputEffect(self, onInput), onOutput));
  either3 = /* @__PURE__ */ dual(2, (self, that) => union10(self, that));
  eitherWith = /* @__PURE__ */ dual(3, (self, that, f) => unionWith2(self, that, f));
  ensuring2 = /* @__PURE__ */ dual(2, (self, finalizer) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => isDone5(decision) ? as2(finalizer, [state2, out, decision]) : succeed([state2, out, decision]))));
  intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
  intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith4(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap9(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
    if (isContinue2(lDecision) && isContinue2(rDecision)) {
      return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
    }
    return succeed([[lState, rState], [out, out2], done7]);
  }))));
  jitteredWith = /* @__PURE__ */ dual(2, (self, options) => {
    const {
      max: max5,
      min: min3
    } = Object.assign({
      min: 0.8,
      max: 1.2
    }, options);
    return delayedEffect(self, (duration2) => map10(next3, (random3) => {
      const d = toMillis(duration2);
      const jittered2 = d * min3 * (1 - random3) + d * max5 * random3;
      return millis(jittered2);
    }));
  });
  map16 = /* @__PURE__ */ dual(2, (self, f) => mapEffect3(self, (out) => sync(() => f(out))));
  mapEffect3 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
  modifyDelay = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration2) => sync(() => f(out, duration2))));
  modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, decision]);
    }
    const intervals = decision.intervals;
    const delay2 = size11(make38(now, start2(intervals)));
    return map10(f(out, delay2), (durationInput) => {
      const duration2 = decode(durationInput);
      const oldStart = start2(intervals);
      const newStart = now + toMillis(duration2);
      const delta = newStart - oldStart;
      const newEnd = Math.max(0, end2(intervals) + delta);
      const newInterval = make38(newStart, newEnd);
      return [state2, out, continueWith2(newInterval)];
    });
  })));
  onDecision = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => as2(f(out, decision), [state2, out, decision]))));
  provideContext3 = /* @__PURE__ */ dual(2, (self, context3) => makeWithState(self.initial, (now, input, state) => provideContext(self.step(now, input, state), context3)));
  provideService2 = /* @__PURE__ */ dual(3, (self, tag, service2) => makeWithState(self.initial, (now, input, state) => contextWithEffect((env) => provideContext(self.step(now, input, state), add2(env, tag, service2)))));
  reduce13 = /* @__PURE__ */ dual(3, (self, zero3, f) => reduceEffect2(self, zero3, (z, out) => sync(() => f(z, out))));
  reduceEffect2 = /* @__PURE__ */ dual(3, (self, zero3, f) => makeWithState([self.initial, zero3], (now, input, [s, z]) => flatMap9(self.step(now, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z], z, decision]) : map10(f(z, out), (z2) => [[s2, z2], z, decision]))));
  resetAfter = /* @__PURE__ */ dual(2, (self, durationInput) => {
    const duration2 = decode(durationInput);
    return pipe(self, intersect5(elapsed), resetWhen(([, time]) => greaterThanOrEqualTo2(time, duration2)), map16((out) => out[0]));
  });
  resetWhen = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap9(self.step(now, input, state), ([state2, out, decision]) => f(out) ? self.step(now, input, self.initial) : succeed([state2, out, decision]))));
  run = /* @__PURE__ */ dual(3, (self, now, input) => pipe(runLoop(self, now, fromIterable3(input), self.initial, empty5()), map10((list) => reverse2(list))));
  tapInput = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => zipRight2(f(input), self.step(now, input, state))));
  tapOutput = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => tap2(self.step(now, input, state), ([, out]) => f(out))));
  union10 = /* @__PURE__ */ dual(2, (self, that) => unionWith2(self, that, union9));
  unionWith2 = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => zipWith4(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
    if (isDone5(lDecision) && isDone5(rDecision)) {
      return [[lState, rState], [l, r], done7];
    }
    if (isDone5(lDecision) && isContinue2(rDecision)) {
      return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
    }
    if (isContinue2(lDecision) && isDone5(rDecision)) {
      return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
    }
    if (isContinue2(lDecision) && isContinue2(rDecision)) {
      const combined = f(lDecision.intervals, rDecision.intervals);
      return [[lState, rState], [l, r], _continue2(combined)];
    }
    throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
  })));
  untilInput = /* @__PURE__ */ dual(2, (self, f) => check(self, (input, _) => !f(input)));
  untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
  untilOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => !f(out)));
  untilOutputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (_, out) => negate(f(out))));
  upTo = /* @__PURE__ */ dual(2, (self, duration2) => zipLeft4(self, recurUpTo(duration2)));
  whileInput = /* @__PURE__ */ dual(2, (self, f) => check(self, (input, _) => f(input)));
  whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
  whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
  whileOutputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));
  zipLeft4 = /* @__PURE__ */ dual(2, (self, that) => map16(intersect5(self, that), (out) => out[0]));
  zipRight5 = /* @__PURE__ */ dual(2, (self, that) => map16(intersect5(self, that), (out) => out[1]));
  zipWith8 = /* @__PURE__ */ dual(3, (self, that, f) => map16(intersect5(self, that), ([out, out2]) => f(out, out2)));
  ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
  ScheduleDefect = class ScheduleDefect {
    error;
    [ScheduleDefectTypeId];
    constructor(error) {
      this.error = error;
      this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
    }
  };
  repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => fail2(e)));
  repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
    if (isSchedule(options)) {
      return repeat_Effect(self, options);
    }
    const base = options.schedule ?? passthrough2(forever2);
    const withWhile = options.while ? whileInputEffect(base, (a) => {
      const applied = options.while(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
      const applied = options.until(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map16((intersectionPair) => intersectionPair[0])) : withUntil;
    return scheduleDefectRefail(repeat_Effect(self, withTimes));
  });
  repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule, orElse6) => flatMap9(driver(schedule), (driver2) => matchEffect(self, {
    onFailure: (error) => orElse6(error, none2()),
    onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse6(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
  })));
  retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
  retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
    if (isSchedule(options)) {
      return retry_Effect(self, options);
    }
    return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
  });
  retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse6) => flatMap9(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse6(e, out), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
  schedule_Effect = /* @__PURE__ */ dual(2, (self, schedule) => scheduleFrom_Effect(self, undefined, schedule));
  scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self, initial, schedule) => flatMap9(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
  count = /* @__PURE__ */ unfold2(0, (n) => n + 1);
  elapsed = /* @__PURE__ */ makeWithState(/* @__PURE__ */ none2(), (now, _, state) => {
    switch (state._tag) {
      case "None": {
        return succeed([some2(now), zero2, continueWith2(after2(now))]);
      }
      case "Some": {
        return succeed([some2(state.value), millis(now - state.value), continueWith2(after2(now))]);
      }
    }
  });
  forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
  once2 = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(1));
  stop = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(0));
  scheduleForked = /* @__PURE__ */ dual(2, (self, schedule) => forkScoped(schedule_Effect(self, schedule)));
});

// ../../node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId20, withExecutionPlan, scheduleFromStep = (step3, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : undefined
  });
};
var init_executionPlan = __esm(() => {
  init_Either();
  init_Function();
  init_Predicate();
  init_core();
  init_layer();
  init_schedule();
  TypeId20 = /* @__PURE__ */ Symbol.for("effect/ExecutionPlan");
  withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
    let i = 0;
    let result;
    return flatMap9(whileLoop({
      while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
      body: () => {
        const step3 = plan.steps[i];
        let nextEffect = effect_provide(effect, step3.provide);
        if (result) {
          let attempted = false;
          const wrapped = nextEffect;
          nextEffect = suspend(() => {
            if (attempted)
              return wrapped;
            attempted = true;
            return result;
          });
          nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
        } else {
          const schedule = scheduleFromStep(step3, true);
          nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
        }
        return either2(nextEffect);
      },
      step: (either4) => {
        result = either4;
        i++;
      }
    }), () => result);
  }));
});

// ../../node_modules/effect/dist/esm/internal/query.js
var currentCache, currentCacheEnabled, fromRequest = (request, dataSource) => flatMap9(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap9(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(empty19, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
              orNew.left.listeners.decrement();
              return exit2;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners;
    listeners.increment();
    return flatMap9(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
})), cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(request), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_2;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_2;
  });
}, withRequestCaching, withRequestCache;
var init_query = __esm(() => {
  init_Duration();
  init_Function();
  init_GlobalValue();
  init_blockedRequests();
  init_cache();
  init_core();
  init_fiberRuntime();
  init_request();
  currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map10(deferredMake(), (handle) => ({
    listeners: new Listeners,
    handle
  })), () => seconds(60))));
  currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
  withRequestCaching = /* @__PURE__ */ dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
  withRequestCache = /* @__PURE__ */ dual(2, (self, cache) => fiberRefLocally(self, currentCache, cache));
});

// ../../node_modules/effect/dist/esm/Request.js
var isRequest2;
var init_Request = __esm(() => {
  init_blockedRequests();
  init_cache();
  init_core();
  init_fiberRuntime();
  init_request();
  isRequest2 = isRequest;
});

// ../../node_modules/effect/dist/esm/Effect.js
var exports_Effect = {};
__export(exports_Effect, {
  zipWith: () => zipWith9,
  zipRight: () => zipRight6,
  zipLeft: () => zipLeft5,
  zip: () => zip7,
  yieldNow: () => yieldNow4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  withTracerTiming: () => withTracerTiming2,
  withTracerScoped: () => withTracerScoped2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracer: () => withTracer2,
  withSpanScoped: () => withSpanScoped2,
  withSpan: () => withSpan3,
  withSchedulingPriority: () => withSchedulingPriority2,
  withScheduler: () => withScheduler2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRequestCaching: () => withRequestCaching2,
  withRequestCache: () => withRequestCache2,
  withRequestBatching: () => withRequestBatching2,
  withRandomScoped: () => withRandomScoped2,
  withRandom: () => withRandom2,
  withParentSpan: () => withParentSpan3,
  withMetric: () => withMetric2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withLogSpan: () => withLogSpan2,
  withFiberRuntime: () => withFiberRuntime2,
  withExecutionPlan: () => withExecutionPlan2,
  withEarlyRelease: () => withEarlyRelease2,
  withConsoleScoped: () => withConsoleScoped2,
  withConsole: () => withConsole2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConfigProvider: () => withConfigProvider2,
  withConcurrency: () => withConcurrency2,
  withClockScoped: () => withClockScoped2,
  withClock: () => withClock2,
  whileLoop: () => whileLoop2,
  whenRef: () => whenRef2,
  whenLogLevel: () => whenLogLevel2,
  whenFiberRef: () => whenFiberRef2,
  whenEffect: () => whenEffect2,
  when: () => when2,
  void: () => _void,
  validateWith: () => validateWith2,
  validateFirst: () => validateFirst2,
  validateAll: () => validateAll2,
  validate: () => validate2,
  using: () => using2,
  useSpan: () => useSpan2,
  updateService: () => updateService2,
  updateFiberRefs: () => updateFiberRefs2,
  unsandbox: () => unsandbox2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unlessEffect: () => unlessEffect2,
  unless: () => unless2,
  uninterruptibleMask: () => uninterruptibleMask3,
  uninterruptible: () => uninterruptible2,
  tryPromise: () => tryPromise2,
  tryMapPromise: () => tryMapPromise2,
  tryMap: () => tryMap2,
  try: () => try_2,
  transposeOption: () => transposeOption,
  transposeMapOption: () => transposeMapOption,
  transplant: () => transplant2,
  tracerWith: () => tracerWith4,
  tracer: () => tracer2,
  timeoutTo: () => timeoutTo2,
  timeoutOption: () => timeoutOption2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFail: () => timeoutFail2,
  timeout: () => timeout2,
  timedWith: () => timedWith2,
  timed: () => timed2,
  tapErrorTag: () => tapErrorTag2,
  tapErrorCause: () => tapErrorCause3,
  tapError: () => tapError3,
  tapDefect: () => tapDefect2,
  tapBoth: () => tapBoth2,
  tap: () => tap4,
  takeWhile: () => takeWhile3,
  takeUntil: () => takeUntil2,
  tagMetricsScoped: () => tagMetricsScoped2,
  tagMetrics: () => tagMetrics2,
  sync: () => sync5,
  suspend: () => suspend3,
  supervised: () => supervised2,
  summarized: () => summarized2,
  succeedSome: () => succeedSome2,
  succeedNone: () => succeedNone2,
  succeed: () => succeed10,
  step: () => step3,
  spanLinks: () => spanLinks2,
  spanAnnotations: () => spanAnnotations2,
  sleep: () => sleep4,
  setFiberRefs: () => setFiberRefs2,
  serviceOptional: () => serviceOptional2,
  serviceOption: () => serviceOption2,
  serviceMembers: () => serviceMembers2,
  serviceFunctions: () => serviceFunctions2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunction: () => serviceFunction2,
  serviceConstants: () => serviceConstants2,
  sequentialFinalizers: () => sequentialFinalizers2,
  scopedWith: () => scopedWith2,
  scoped: () => scoped3,
  scopeWith: () => scopeWith2,
  scope: () => scope3,
  scheduleFrom: () => scheduleFrom,
  scheduleForked: () => scheduleForked2,
  schedule: () => schedule,
  sandbox: () => sandbox2,
  runtime: () => runtime3,
  runSyncExit: () => runSyncExit,
  runSync: () => runSync,
  runRequestBlock: () => runRequestBlock2,
  runPromiseExit: () => runPromiseExit,
  runPromise: () => runPromise,
  runFork: () => runFork2,
  runCallback: () => runCallback,
  retryOrElse: () => retryOrElse,
  retry: () => retry2,
  request: () => request,
  replicateEffect: () => replicateEffect2,
  replicate: () => replicate2,
  repeatOrElse: () => repeatOrElse,
  repeatN: () => repeatN2,
  repeat: () => repeat,
  reduceWhile: () => reduceWhile2,
  reduceRight: () => reduceRight4,
  reduceEffect: () => reduceEffect3,
  reduce: () => reduce14,
  randomWith: () => randomWith2,
  random: () => random3,
  raceWith: () => raceWith2,
  raceFirst: () => raceFirst2,
  raceAll: () => raceAll2,
  race: () => race2,
  provideServiceEffect: () => provideServiceEffect2,
  provideService: () => provideService3,
  provide: () => provide2,
  promise: () => promise2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  patchFiberRefs: () => patchFiberRefs2,
  partition: () => partition5,
  parallelFinalizers: () => parallelFinalizers2,
  parallelErrors: () => parallelErrors2,
  orElseSucceed: () => orElseSucceed2,
  orElseFail: () => orElseFail2,
  orElse: () => orElse6,
  orDieWith: () => orDieWith2,
  orDie: () => orDie3,
  optionFromOptional: () => optionFromOptional2,
  option: () => option2,
  once: () => once3,
  onInterrupt: () => onInterrupt2,
  onExit: () => onExit3,
  onError: () => onError2,
  none: () => none9,
  never: () => never4,
  negate: () => negate2,
  metricLabels: () => metricLabels2,
  mergeAll: () => mergeAll5,
  merge: () => merge7,
  matchEffect: () => matchEffect2,
  matchCauseEffect: () => matchCauseEffect3,
  matchCause: () => matchCause3,
  match: () => match14,
  mapInputContext: () => mapInputContext3,
  mapErrorCause: () => mapErrorCause2,
  mapError: () => mapError3,
  mapBoth: () => mapBoth4,
  mapAccum: () => mapAccum4,
  map: () => map17,
  makeSpanScoped: () => makeSpanScoped2,
  makeSpan: () => makeSpan2,
  makeSemaphore: () => makeSemaphore2,
  makeLatch: () => makeLatch2,
  loop: () => loop2,
  logWithLevel: () => logWithLevel2,
  logWarning: () => logWarning2,
  logTrace: () => logTrace2,
  logInfo: () => logInfo2,
  logFatal: () => logFatal2,
  logError: () => logError2,
  logDebug: () => logDebug2,
  logAnnotations: () => logAnnotations2,
  log: () => log2,
  locallyWith: () => locallyWith,
  locallyScopedWith: () => locallyScopedWith,
  locallyScoped: () => locallyScoped,
  locally: () => locally,
  linkSpans: () => linkSpans2,
  linkSpanCurrent: () => linkSpanCurrent2,
  liftPredicate: () => liftPredicate3,
  let: () => let_4,
  labelMetricsScoped: () => labelMetricsScoped2,
  labelMetrics: () => labelMetrics2,
  iterate: () => iterate2,
  isSuccess: () => isSuccess3,
  isFailure: () => isFailure4,
  isEffect: () => isEffect2,
  intoDeferred: () => intoDeferred2,
  interruptibleMask: () => interruptibleMask2,
  interruptible: () => interruptible4,
  interruptWith: () => interruptWith3,
  interrupt: () => interrupt7,
  inheritFiberRefs: () => inheritFiberRefs2,
  ignoreLogged: () => ignoreLogged2,
  ignore: () => ignore2,
  if: () => if_2,
  head: () => head4,
  getRuntimeFlags: () => getRuntimeFlags,
  getFiberRefs: () => getFiberRefs,
  gen: () => gen3,
  functionWithSpan: () => functionWithSpan2,
  fromNullable: () => fromNullable3,
  fromFiberEffect: () => fromFiberEffect2,
  fromFiber: () => fromFiber2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  forkScoped: () => forkScoped2,
  forkIn: () => forkIn2,
  forkDaemon: () => forkDaemon2,
  forkAll: () => forkAll2,
  fork: () => fork3,
  forever: () => forever3,
  forEach: () => forEach9,
  fnUntraced: () => fnUntraced2,
  fn: () => fn,
  flipWith: () => flipWith2,
  flip: () => flip2,
  flatten: () => flatten10,
  flatMap: () => flatMap12,
  firstSuccessOf: () => firstSuccessOf2,
  findFirst: () => findFirst8,
  finalizersMask: () => finalizersMask2,
  filterOrFail: () => filterOrFail2,
  filterOrElse: () => filterOrElse2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrDie: () => filterOrDie2,
  filterMap: () => filterMap7,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterEffectOrElse: () => filterEffectOrElse2,
  filter: () => filter9,
  fiberIdWith: () => fiberIdWith2,
  fiberId: () => fiberId2,
  failSync: () => failSync4,
  failCauseSync: () => failCauseSync4,
  failCause: () => failCause9,
  fail: () => fail10,
  exit: () => exit2,
  exists: () => exists3,
  every: () => every8,
  eventually: () => eventually2,
  ensuringChildren: () => ensuringChildren2,
  ensuringChild: () => ensuringChild2,
  ensuring: () => ensuring3,
  either: () => either4,
  dropWhile: () => dropWhile3,
  dropUntil: () => dropUntil2,
  disconnect: () => disconnect2,
  diffFiberRefs: () => diffFiberRefs2,
  dieSync: () => dieSync4,
  dieMessage: () => dieMessage2,
  die: () => die7,
  descriptorWith: () => descriptorWith2,
  descriptor: () => descriptor2,
  delay: () => delay2,
  daemonChildren: () => daemonChildren2,
  custom: () => custom3,
  currentSpan: () => currentSpan2,
  currentParentSpan: () => currentParentSpan2,
  contextWithEffect: () => contextWithEffect2,
  contextWith: () => contextWith2,
  context: () => context3,
  consoleWith: () => consoleWith2,
  console: () => console3,
  configProviderWith: () => configProviderWith2,
  clockWith: () => clockWith4,
  clock: () => clock2,
  checkInterruptible: () => checkInterruptible2,
  cause: () => cause2,
  catchTags: () => catchTags2,
  catchTag: () => catchTag2,
  catchSomeDefect: () => catchSomeDefect2,
  catchSomeCause: () => catchSomeCause2,
  catchSome: () => catchSome2,
  catchIf: () => catchIf2,
  catchAllDefect: () => catchAllDefect2,
  catchAllCause: () => catchAllCause3,
  catchAll: () => catchAll3,
  catch: () => _catch2,
  cachedWithTTL: () => cachedWithTTL,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedFunction: () => cachedFunction2,
  cached: () => cached3,
  cacheRequestResult: () => cacheRequestResult,
  blocked: () => blocked2,
  bindTo: () => bindTo4,
  bindAll: () => bindAll2,
  bind: () => bind4,
  awaitAllChildren: () => awaitAllChildren2,
  asyncEffect: () => asyncEffect2,
  async: () => async,
  asVoid: () => asVoid4,
  asSomeError: () => asSomeError2,
  asSome: () => asSome2,
  as: () => as5,
  ap: () => ap2,
  annotateSpans: () => annotateSpans3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateLogs: () => annotateLogs3,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  andThen: () => andThen6,
  allowInterrupt: () => allowInterrupt2,
  allWith: () => allWith2,
  allSuccesses: () => allSuccesses2,
  all: () => all7,
  addFinalizer: () => addFinalizer3,
  acquireUseRelease: () => acquireUseRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireRelease: () => acquireRelease2,
  Tag: () => Tag3,
  Service: () => Service,
  EffectTypeId: () => EffectTypeId3,
  Do: () => Do3
});
function defineLength(length3, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length3,
    configurable: true
  });
}
function fnApply(options) {
  let effect;
  let fnError = undefined;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die7(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause9(sequential(die(fnError), die(error))) : die7(error);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split(`
`);
      const stackCall = options.errorCall.stack.trim().split(`
`);
      let endStackDef = stackDef.slice(2).join(`
`).trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join(`
`).trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect, options.spanName, opts);
}
var EffectTypeId3, isEffect2, cachedWithTTL, cachedInvalidateWithTTL2, cached3, cachedFunction2, once3, all7, allWith2, allSuccesses2, dropUntil2, dropWhile3, takeUntil2, takeWhile3, every8, exists3, filter9, filterMap7, findFirst8, forEach9, head4, mergeAll5, partition5, reduce14, reduceWhile2, reduceRight4, reduceEffect3, replicate2, replicateEffect2, validateAll2, validateFirst2, async, asyncEffect2, custom3, withFiberRuntime2, fail10, failSync4, failCause9, failCauseSync4, die7, dieMessage2, dieSync4, gen3, never4, none9, promise2, succeed10, succeedNone2, succeedSome2, suspend3, sync5, _void, yieldNow4, _catch2, catchAll3, catchAllCause3, catchAllDefect2, catchIf2, catchSome2, catchSomeCause2, catchSomeDefect2, catchTag2, catchTags2, cause2, eventually2, ignore2, ignoreLogged2, parallelErrors2, sandbox2, retry2, withExecutionPlan2, retryOrElse, try_2, tryMap2, tryMapPromise2, tryPromise2, unsandbox2, allowInterrupt2, checkInterruptible2, disconnect2, interrupt7, interruptWith3, interruptible4, interruptibleMask2, onInterrupt2, uninterruptible2, uninterruptibleMask3, liftPredicate3, as5, asSome2, asSomeError2, asVoid4, flip2, flipWith2, map17, mapAccum4, mapBoth4, mapError3, mapErrorCause2, merge7, negate2, acquireRelease2, acquireReleaseInterruptible2, acquireUseRelease2, addFinalizer3, ensuring3, onError2, onExit3, parallelFinalizers2, sequentialFinalizers2, finalizersMask2, scope3, scopeWith2, scopedWith2, scoped3, using2, withEarlyRelease2, awaitAllChildren2, daemonChildren2, descriptor2, descriptorWith2, diffFiberRefs2, ensuringChild2, ensuringChildren2, fiberId2, fiberIdWith2, fork3, forkDaemon2, forkAll2, forkIn2, forkScoped2, forkWithErrorHandler2, fromFiber2, fromFiberEffect2, supervised2, transplant2, withConcurrency2, withScheduler2, withSchedulingPriority2, withMaxOpsBeforeYield2, clock2, clockWith4, withClockScoped2, withClock2, console3, consoleWith2, withConsoleScoped2, withConsole2, delay2, sleep4, timed2, timedWith2, timeout2, timeoutOption2, timeoutFail2, timeoutFailCause2, timeoutTo2, configProviderWith2, withConfigProvider2, withConfigProviderScoped2, context3, contextWith2, contextWithEffect2, mapInputContext3, provide2, provideService3, provideServiceEffect2, serviceFunction2, serviceFunctionEffect2, serviceFunctions2, serviceConstants2, serviceMembers2, serviceOption2, serviceOptional2, updateService2, Do3, bind4, bindAll2, bindTo4, let_4, option2, either4, exit2, intoDeferred2, if_2, filterOrDie2, filterOrDieMessage2, filterOrElse2, filterOrFail2, filterEffectOrElse2, filterEffectOrFail2, unless2, unlessEffect2, when2, whenEffect2, whenFiberRef2, whenRef2, flatMap12, andThen6, flatten10, race2, raceAll2, raceFirst2, raceWith2, summarized2, tap4, tapBoth2, tapDefect2, tapError3, tapErrorTag2, tapErrorCause3, forever3, iterate2, loop2, repeat, repeatN2, repeatOrElse, schedule, scheduleForked2, scheduleFrom, whileLoop2, getFiberRefs, inheritFiberRefs2, locally, locallyWith, locallyScoped, locallyScopedWith, patchFiberRefs2, setFiberRefs2, updateFiberRefs2, isFailure4, isSuccess3, match14, matchCause3, matchCauseEffect3, matchEffect2, log2, logWithLevel2 = (level, ...message) => logWithLevel(level)(...message), logTrace2, logDebug2, logInfo2, logWarning2, logError2, logFatal2, withLogSpan2, annotateLogs3, annotateLogsScoped2, logAnnotations2, withUnhandledErrorLogLevel2, whenLogLevel2, orDie3, orDieWith2, orElse6, orElseFail2, orElseSucceed2, firstSuccessOf2, random3, randomWith2, withRandom2, withRandomScoped2, runtime3, getRuntimeFlags, patchRuntimeFlags, withRuntimeFlagsPatch, withRuntimeFlagsPatchScoped, tagMetrics2, labelMetrics2, tagMetricsScoped2, labelMetricsScoped2, metricLabels2, withMetric2, unsafeMakeSemaphore2, makeSemaphore2, unsafeMakeLatch2, makeLatch2, runFork2, runCallback, runPromise, runPromiseExit, runSync, runSyncExit, validate2, validateWith2, zip7, zipLeft5, zipRight6, zipWith9, ap2, blocked2, runRequestBlock2, step3, request, cacheRequestResult, withRequestBatching2, withRequestCaching2, withRequestCache2, tracer2, tracerWith4, withTracer2, withTracerScoped2, withTracerEnabled2, withTracerTiming2, annotateSpans3, annotateCurrentSpan2, currentSpan2, currentParentSpan2, spanAnnotations2, spanLinks2, linkSpans2, linkSpanCurrent2, makeSpan2, makeSpanScoped2, useSpan2, withSpan3, functionWithSpan2, withSpanScoped2, withParentSpan3, fromNullable3, optionFromOptional2, transposeOption = (self) => {
  return isNone(self) ? succeedNone2 : map17(self.value, some);
}, transposeMapOption, makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args2) => andThen3(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen3(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen3(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen3(target, (s) => s[prop]);
      Object.assign(fn, cn);
      Object.setPrototypeOf(fn, Object.getPrototypeOf(cn));
      cache.set(prop, fn);
      return fn;
    }
  });
}, Tag3 = (id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen3(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
}, Service = function() {
  return function() {
    const [id3, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service2) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service2);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service2);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
        return service2;
      }
    };
    TagClass.prototype._tag = id3;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service2) => new this(service2);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen3(this, body);
      }
    });
    TagClass.key = id3;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect4(TagClass, map17(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect4(TagClass, map17(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped2(TagClass, map17(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped2(TagClass, map17(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync3(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed7(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
}, fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error;
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
}, fnUntraced2;
var init_Effect = __esm(() => {
  init_Function();
  init_cause();
  init_console2();
  init_context();
  init_core_effect();
  init_core();
  init_defaultServices();
  init_circular();
  init_executionPlan();
  init_fiberRuntime();
  init_layer();
  init_option();
  init_query();
  init_runtime();
  init_schedule();
  init_tracer();
  init_Request();
  init_Scheduler();
  init_Utils();
  EffectTypeId3 = EffectTypeId2;
  isEffect2 = isEffect;
  cachedWithTTL = cached2;
  cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
  cached3 = memoize;
  cachedFunction2 = cachedFunction;
  once3 = once;
  all7 = all5;
  allWith2 = allWith;
  allSuccesses2 = allSuccesses;
  dropUntil2 = dropUntil;
  dropWhile3 = dropWhile2;
  takeUntil2 = takeUntil;
  takeWhile3 = takeWhile2;
  every8 = every7;
  exists3 = exists2;
  filter9 = filter7;
  filterMap7 = filterMap6;
  findFirst8 = findFirst6;
  forEach9 = forEach8;
  head4 = head3;
  mergeAll5 = mergeAll3;
  partition5 = partition4;
  reduce14 = reduce11;
  reduceWhile2 = reduceWhile;
  reduceRight4 = reduceRight3;
  reduceEffect3 = reduceEffect;
  replicate2 = replicate;
  replicateEffect2 = replicateEffect;
  validateAll2 = validateAll;
  validateFirst2 = validateFirst;
  async = async_;
  asyncEffect2 = asyncEffect;
  custom3 = custom2;
  withFiberRuntime2 = withFiberRuntime;
  fail10 = fail2;
  failSync4 = failSync;
  failCause9 = failCause;
  failCauseSync4 = failCauseSync;
  die7 = die2;
  dieMessage2 = dieMessage;
  dieSync4 = dieSync;
  gen3 = gen2;
  never4 = never;
  none9 = none6;
  promise2 = promise;
  succeed10 = succeed;
  succeedNone2 = succeedNone;
  succeedSome2 = succeedSome;
  suspend3 = suspend;
  sync5 = sync;
  _void = void_2;
  yieldNow4 = yieldNow;
  _catch2 = _catch;
  catchAll3 = catchAll;
  catchAllCause3 = catchAllCause;
  catchAllDefect2 = catchAllDefect;
  catchIf2 = catchIf;
  catchSome2 = catchSome;
  catchSomeCause2 = catchSomeCause;
  catchSomeDefect2 = catchSomeDefect;
  catchTag2 = catchTag;
  catchTags2 = catchTags;
  cause2 = cause;
  eventually2 = eventually;
  ignore2 = ignore;
  ignoreLogged2 = ignoreLogged;
  parallelErrors2 = parallelErrors;
  sandbox2 = sandbox;
  retry2 = retry_combined;
  withExecutionPlan2 = withExecutionPlan;
  retryOrElse = retryOrElse_Effect;
  try_2 = try_;
  tryMap2 = tryMap;
  tryMapPromise2 = tryMapPromise;
  tryPromise2 = tryPromise;
  unsandbox2 = unsandbox;
  allowInterrupt2 = allowInterrupt;
  checkInterruptible2 = checkInterruptible;
  disconnect2 = disconnect;
  interrupt7 = interrupt2;
  interruptWith3 = interruptWith;
  interruptible4 = interruptible2;
  interruptibleMask2 = interruptibleMask;
  onInterrupt2 = onInterrupt;
  uninterruptible2 = uninterruptible;
  uninterruptibleMask3 = uninterruptibleMask;
  liftPredicate3 = liftPredicate2;
  as5 = as2;
  asSome2 = asSome;
  asSomeError2 = asSomeError;
  asVoid4 = asVoid2;
  flip2 = flip;
  flipWith2 = flipWith;
  map17 = map10;
  mapAccum4 = mapAccum3;
  mapBoth4 = mapBoth;
  mapError3 = mapError;
  mapErrorCause2 = mapErrorCause;
  merge7 = merge5;
  negate2 = negate;
  acquireRelease2 = acquireRelease;
  acquireReleaseInterruptible2 = acquireReleaseInterruptible;
  acquireUseRelease2 = acquireUseRelease;
  addFinalizer3 = addFinalizer;
  ensuring3 = ensuring;
  onError2 = onError;
  onExit3 = onExit;
  parallelFinalizers2 = parallelFinalizers;
  sequentialFinalizers2 = sequentialFinalizers;
  finalizersMask2 = finalizersMask;
  scope3 = scope;
  scopeWith2 = scopeWith;
  scopedWith2 = scopedWith;
  scoped3 = scopedEffect;
  using2 = using;
  withEarlyRelease2 = withEarlyRelease;
  awaitAllChildren2 = awaitAllChildren;
  daemonChildren2 = daemonChildren;
  descriptor2 = descriptor;
  descriptorWith2 = descriptorWith;
  diffFiberRefs2 = diffFiberRefs;
  ensuringChild2 = ensuringChild;
  ensuringChildren2 = ensuringChildren;
  fiberId2 = fiberId;
  fiberIdWith2 = fiberIdWith;
  fork3 = fork;
  forkDaemon2 = forkDaemon;
  forkAll2 = forkAll;
  forkIn2 = forkIn;
  forkScoped2 = forkScoped;
  forkWithErrorHandler2 = forkWithErrorHandler;
  fromFiber2 = fromFiber;
  fromFiberEffect2 = fromFiberEffect;
  supervised2 = supervised;
  transplant2 = transplant;
  withConcurrency2 = withConcurrency;
  withScheduler2 = withScheduler;
  withSchedulingPriority2 = withSchedulingPriority;
  withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
  clock2 = clock;
  clockWith4 = clockWith3;
  withClockScoped2 = withClockScoped;
  withClock2 = withClock;
  console3 = console2;
  consoleWith2 = consoleWith;
  withConsoleScoped2 = withConsoleScoped;
  withConsole2 = withConsole;
  delay2 = delay;
  sleep4 = sleep3;
  timed2 = timed;
  timedWith2 = timedWith;
  timeout2 = timeout;
  timeoutOption2 = timeoutOption;
  timeoutFail2 = timeoutFail;
  timeoutFailCause2 = timeoutFailCause;
  timeoutTo2 = timeoutTo;
  configProviderWith2 = configProviderWith;
  withConfigProvider2 = withConfigProvider;
  withConfigProviderScoped2 = withConfigProviderScoped;
  context3 = context;
  contextWith2 = contextWith;
  contextWithEffect2 = contextWithEffect;
  mapInputContext3 = mapInputContext;
  provide2 = effect_provide;
  provideService3 = provideService;
  provideServiceEffect2 = provideServiceEffect;
  serviceFunction2 = serviceFunction;
  serviceFunctionEffect2 = serviceFunctionEffect;
  serviceFunctions2 = serviceFunctions;
  serviceConstants2 = serviceConstants;
  serviceMembers2 = serviceMembers;
  serviceOption2 = serviceOption;
  serviceOptional2 = serviceOptional;
  updateService2 = updateService;
  Do3 = Do2;
  bind4 = bind3;
  bindAll2 = bindAll;
  bindTo4 = bindTo3;
  let_4 = let_3;
  option2 = option;
  either4 = either2;
  exit2 = exit;
  intoDeferred2 = intoDeferred;
  if_2 = if_;
  filterOrDie2 = filterOrDie;
  filterOrDieMessage2 = filterOrDieMessage;
  filterOrElse2 = filterOrElse;
  filterOrFail2 = filterOrFail;
  filterEffectOrElse2 = filterEffectOrElse;
  filterEffectOrFail2 = filterEffectOrFail;
  unless2 = unless;
  unlessEffect2 = unlessEffect;
  when2 = when;
  whenEffect2 = whenEffect;
  whenFiberRef2 = whenFiberRef;
  whenRef2 = whenRef;
  flatMap12 = flatMap9;
  andThen6 = andThen3;
  flatten10 = flatten7;
  race2 = race;
  raceAll2 = raceAll;
  raceFirst2 = raceFirst;
  raceWith2 = raceWith;
  summarized2 = summarized;
  tap4 = tap2;
  tapBoth2 = tapBoth;
  tapDefect2 = tapDefect;
  tapError3 = tapError;
  tapErrorTag2 = tapErrorTag;
  tapErrorCause3 = tapErrorCause;
  forever3 = forever;
  iterate2 = iterate;
  loop2 = loop;
  repeat = repeat_combined;
  repeatN2 = repeatN;
  repeatOrElse = repeatOrElse_Effect;
  schedule = schedule_Effect;
  scheduleForked2 = scheduleForked;
  scheduleFrom = scheduleFrom_Effect;
  whileLoop2 = whileLoop;
  getFiberRefs = fiberRefs2;
  inheritFiberRefs2 = inheritFiberRefs;
  locally = fiberRefLocally;
  locallyWith = fiberRefLocallyWith;
  locallyScoped = fiberRefLocallyScoped;
  locallyScopedWith = fiberRefLocallyScopedWith;
  patchFiberRefs2 = patchFiberRefs;
  setFiberRefs2 = setFiberRefs;
  updateFiberRefs2 = updateFiberRefs;
  isFailure4 = isFailure2;
  isSuccess3 = isSuccess2;
  match14 = match7;
  matchCause3 = matchCause;
  matchCauseEffect3 = matchCauseEffect;
  matchEffect2 = matchEffect;
  log2 = log;
  logTrace2 = logTrace;
  logDebug2 = logDebug;
  logInfo2 = logInfo;
  logWarning2 = logWarning;
  logError2 = logError;
  logFatal2 = logFatal;
  withLogSpan2 = withLogSpan;
  annotateLogs3 = annotateLogs;
  annotateLogsScoped2 = annotateLogsScoped;
  logAnnotations2 = logAnnotations;
  withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
  whenLogLevel2 = whenLogLevel;
  orDie3 = orDie;
  orDieWith2 = orDieWith;
  orElse6 = orElse2;
  orElseFail2 = orElseFail;
  orElseSucceed2 = orElseSucceed;
  firstSuccessOf2 = firstSuccessOf;
  random3 = random2;
  randomWith2 = randomWith;
  withRandom2 = withRandom;
  withRandomScoped2 = withRandomScoped;
  runtime3 = runtime2;
  getRuntimeFlags = runtimeFlags;
  patchRuntimeFlags = updateRuntimeFlags;
  withRuntimeFlagsPatch = withRuntimeFlags;
  withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
  tagMetrics2 = tagMetrics;
  labelMetrics2 = labelMetrics;
  tagMetricsScoped2 = tagMetricsScoped;
  labelMetricsScoped2 = labelMetricsScoped;
  metricLabels2 = metricLabels;
  withMetric2 = withMetric;
  unsafeMakeSemaphore2 = unsafeMakeSemaphore;
  makeSemaphore2 = makeSemaphore;
  unsafeMakeLatch2 = unsafeMakeLatch;
  makeLatch2 = makeLatch;
  runFork2 = unsafeForkEffect;
  runCallback = unsafeRunEffect;
  runPromise = unsafeRunPromiseEffect;
  runPromiseExit = unsafeRunPromiseExitEffect;
  runSync = unsafeRunSyncEffect;
  runSyncExit = unsafeRunSyncExitEffect;
  validate2 = validate;
  validateWith2 = validateWith;
  zip7 = zipOptions;
  zipLeft5 = zipLeftOptions;
  zipRight6 = zipRightOptions;
  zipWith9 = zipWithOptions;
  ap2 = /* @__PURE__ */ dual(2, (self, that) => zipWith9(self, that, (f, a) => f(a)));
  blocked2 = blocked;
  runRequestBlock2 = runRequestBlock;
  step3 = step2;
  request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
  cacheRequestResult = cacheRequest;
  withRequestBatching2 = withRequestBatching;
  withRequestCaching2 = withRequestCaching;
  withRequestCache2 = withRequestCache;
  tracer2 = tracer;
  tracerWith4 = tracerWith;
  withTracer2 = withTracer;
  withTracerScoped2 = withTracerScoped;
  withTracerEnabled2 = withTracerEnabled;
  withTracerTiming2 = withTracerTiming;
  annotateSpans3 = annotateSpans;
  annotateCurrentSpan2 = annotateCurrentSpan;
  currentSpan2 = currentSpan;
  currentParentSpan2 = currentParentSpan;
  spanAnnotations2 = spanAnnotations;
  spanLinks2 = spanLinks;
  linkSpans2 = linkSpans;
  linkSpanCurrent2 = linkSpanCurrent;
  makeSpan2 = makeSpan;
  makeSpanScoped2 = makeSpanScoped;
  useSpan2 = useSpan;
  withSpan3 = withSpan;
  functionWithSpan2 = functionWithSpan;
  withSpanScoped2 = withSpanScoped;
  withParentSpan3 = withParentSpan;
  fromNullable3 = fromNullable2;
  optionFromOptional2 = optionFromOptional;
  transposeMapOption = /* @__PURE__ */ dual(2, (self, f) => isNone(self) ? succeedNone2 : map17(f(self.value), some));
  fnUntraced2 = fnUntraced;
});

// ../../node_modules/effect/dist/esm/FiberRef.js
var exports_FiberRef = {};
__export(exports_FiberRef, {
  updateSomeAndGet: () => updateSomeAndGet3,
  updateSome: () => updateSome3,
  updateAndGet: () => updateAndGet3,
  update: () => update5,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMake: () => unsafeMake11,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  set: () => set7,
  reset: () => reset,
  modifySome: () => modifySome3,
  modify: () => modify7,
  makeWith: () => makeWith2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeContext: () => makeContext2,
  make: () => make44,
  interruptedCause: () => interruptedCause,
  getWith: () => getWith,
  getAndUpdateSome: () => getAndUpdateSome3,
  getAndUpdate: () => getAndUpdate3,
  getAndSet: () => getAndSet3,
  get: () => get13,
  delete: () => _delete,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentSupervisor: () => currentSupervisor2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentScheduler: () => currentScheduler2,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentLoggers: () => currentLoggers2,
  currentLogSpan: () => currentLogSpan2,
  currentLogLevel: () => currentLogLevel2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentContext: () => currentContext2,
  currentConcurrency: () => currentConcurrency2,
  FiberRefTypeId: () => FiberRefTypeId2
});
var FiberRefTypeId2, make44, makeWith2, makeContext2, makeRuntimeFlags, unsafeMake11, unsafeMakeHashSet, unsafeMakeContext, unsafeMakeSupervisor, unsafeMakePatch, get13, getAndSet3, getAndUpdate3, getAndUpdateSome3, getWith, set7, _delete, reset, modify7, modifySome3, update5, updateSome3, updateAndGet3, updateSomeAndGet3, currentConcurrency2, currentRequestBatchingEnabled, currentRequestCache, currentRequestCacheEnabled, currentContext2, currentSchedulingPriority2, currentMaxOpsBeforeYield2, unhandledErrorLogLevel, currentLogAnnotations2, currentLoggers2, currentLogLevel2, currentMinimumLogLevel2, currentLogSpan2, currentRuntimeFlags2, currentScheduler2, currentSupervisor2, currentMetricLabels2, currentTracerEnabled2, currentTracerTimingEnabled2, currentTracerSpanAnnotations2, currentTracerSpanLinks2, interruptedCause;
var init_FiberRef = __esm(() => {
  init_core();
  init_fiberRuntime();
  init_query();
  init_Scheduler();
  FiberRefTypeId2 = FiberRefTypeId;
  make44 = fiberRefMake;
  makeWith2 = fiberRefMakeWith;
  makeContext2 = fiberRefMakeContext;
  makeRuntimeFlags = fiberRefMakeRuntimeFlags;
  unsafeMake11 = fiberRefUnsafeMake;
  unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
  unsafeMakeContext = fiberRefUnsafeMakeContext;
  unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
  unsafeMakePatch = fiberRefUnsafeMakePatch;
  get13 = fiberRefGet;
  getAndSet3 = fiberRefGetAndSet;
  getAndUpdate3 = fiberRefGetAndUpdate;
  getAndUpdateSome3 = fiberRefGetAndUpdateSome;
  getWith = fiberRefGetWith;
  set7 = fiberRefSet;
  _delete = fiberRefDelete;
  reset = fiberRefReset;
  modify7 = fiberRefModify;
  modifySome3 = fiberRefModifySome;
  update5 = fiberRefUpdate;
  updateSome3 = fiberRefUpdateSome;
  updateAndGet3 = fiberRefUpdateAndGet;
  updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
  currentConcurrency2 = currentConcurrency;
  currentRequestBatchingEnabled = currentRequestBatching;
  currentRequestCache = currentCache;
  currentRequestCacheEnabled = currentCacheEnabled;
  currentContext2 = currentContext;
  currentSchedulingPriority2 = currentSchedulingPriority;
  currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
  unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
  currentLogAnnotations2 = currentLogAnnotations;
  currentLoggers2 = currentLoggers;
  currentLogLevel2 = currentLogLevel;
  currentMinimumLogLevel2 = currentMinimumLogLevel;
  currentLogSpan2 = currentLogSpan;
  currentRuntimeFlags2 = currentRuntimeFlags;
  currentScheduler2 = currentScheduler;
  currentSupervisor2 = currentSupervisor;
  currentMetricLabels2 = currentMetricLabels;
  currentTracerEnabled2 = currentTracerEnabled;
  currentTracerTimingEnabled2 = currentTracerTimingEnabled;
  currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
  currentTracerSpanLinks2 = currentTracerSpanLinks;
  interruptedCause = currentInterruptedCause;
});

// ../../node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider)), parentSpan = (span2) => succeedContext(make6(spanTag, span2)), span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped2(spanTag, options?.onEnd ? tap2(makeSpanScoped(name, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name, options));
}, setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));
var init_circular3 = __esm(() => {
  init_Context();
  init_Function();
  init_HashSet();
  init_core();
  init_fiberRuntime();
  init_layer();
  init_runtimeFlags();
  init_runtimeFlagsPatch();
  init_supervisor();
  init_tracer();
});

// ../../node_modules/effect/dist/esm/Layer.js
var exports_Layer = {};
__export(exports_Layer, {
  zipWith: () => zipWith10,
  withSpan: () => withSpan4,
  withParentSpan: () => withParentSpan4,
  updateService: () => updateService3,
  unwrapScoped: () => unwrapScoped2,
  unwrapEffect: () => unwrapEffect2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  toRuntime: () => toRuntime2,
  tapErrorCause: () => tapErrorCause4,
  tapError: () => tapError4,
  tap: () => tap5,
  syncContext: () => syncContext2,
  sync: () => sync6,
  suspend: () => suspend4,
  succeedContext: () => succeedContext2,
  succeed: () => succeed11,
  span: () => span3,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setTracerTiming: () => setTracerTiming,
  setTracerEnabled: () => setTracerEnabled,
  setTracer: () => setTracer2,
  setScheduler: () => setScheduler,
  setRequestCaching: () => setRequestCaching,
  setRequestCache: () => setRequestCache,
  setRequestBatching: () => setRequestBatching,
  setRandom: () => setRandom,
  setConfigProvider: () => setConfigProvider2,
  setClock: () => setClock,
  service: () => service2,
  scopedDiscard: () => scopedDiscard2,
  scopedContext: () => scopedContext2,
  scoped: () => scoped4,
  scope: () => scope4,
  retry: () => retry3,
  provideMerge: () => provideMerge2,
  provide: () => provide3,
  project: () => project2,
  passthrough: () => passthrough3,
  parentSpan: () => parentSpan2,
  orElse: () => orElse7,
  orDie: () => orDie4,
  mergeAll: () => mergeAll6,
  merge: () => merge8,
  memoize: () => memoize3,
  matchCause: () => matchCause4,
  match: () => match15,
  mapError: () => mapError4,
  map: () => map18,
  makeMemoMap: () => makeMemoMap2,
  locallyWith: () => locallyWith2,
  locallyScoped: () => locallyScoped2,
  locallyEffect: () => locallyEffect2,
  locally: () => locally2,
  launch: () => launch2,
  isLayer: () => isLayer2,
  isFresh: () => isFresh2,
  function: () => fromFunction3,
  fresh: () => fresh2,
  flatten: () => flatten11,
  flatMap: () => flatMap13,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  failSync: () => failSync5,
  failCauseSync: () => failCauseSync5,
  failCause: () => failCause10,
  fail: () => fail11,
  extendScope: () => extendScope2,
  empty: () => empty34,
  effectDiscard: () => effectDiscard,
  effectContext: () => effectContext,
  effect: () => effect,
  discard: () => discard2,
  dieSync: () => dieSync5,
  die: () => die8,
  context: () => context4,
  catchAllCause: () => catchAllCause4,
  catchAll: () => catchAll4,
  buildWithScope: () => buildWithScope2,
  buildWithMemoMap: () => buildWithMemoMap2,
  build: () => build2,
  annotateSpans: () => annotateSpans4,
  annotateLogs: () => annotateLogs4,
  MemoMapTypeId: () => MemoMapTypeId2,
  LayerTypeId: () => LayerTypeId2,
  CurrentMemoMap: () => CurrentMemoMap2
});
var LayerTypeId2, MemoMapTypeId2, CurrentMemoMap2, isLayer2, isFresh2, annotateLogs4, annotateSpans4, build2, buildWithScope2, catchAll4, catchAllCause4, context4, die8, dieSync5, discard2, effect, effectDiscard, effectContext, empty34, extendScope2, fail11, failSync5, failCause10, failCauseSync5, flatMap13, flatten11, fresh2, fromFunction3, launch2, map18, mapError4, match15, matchCause4, memoize3, merge8, mergeAll6, orDie4, orElse7, passthrough3, project2, locallyEffect2, locally2, locallyWith2, locallyScoped2, fiberRefLocallyScopedWith3, retry3, scope4, scoped4, scopedDiscard2, scopedContext2, service2, succeed11, succeedContext2, suspend4, sync6, syncContext2, tap5, tapError4, tapErrorCause4, toRuntime2, toRuntimeWithMemoMap2, provide3, provideMerge2, zipWith10, unwrapEffect2, unwrapScoped2, setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3))), setConfigProvider2, parentSpan2, setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4))), setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching)), setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching)), setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap9(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache)), setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler)), span3, setTracer2, setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2)), setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2)), setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level)), withSpan4, withParentSpan4, makeMemoMap2, buildWithMemoMap2, updateService3;
var init_Layer = __esm(() => {
  init_Context();
  init_Function();
  init_clock();
  init_core();
  init_defaultServices();
  init_fiberRuntime();
  init_layer();
  init_circular3();
  init_query();
  init_random();
  init_Scheduler();
  LayerTypeId2 = LayerTypeId;
  MemoMapTypeId2 = MemoMapTypeId;
  CurrentMemoMap2 = CurrentMemoMap;
  isLayer2 = isLayer;
  isFresh2 = isFresh;
  annotateLogs4 = annotateLogs2;
  annotateSpans4 = annotateSpans2;
  build2 = build;
  buildWithScope2 = buildWithScope;
  catchAll4 = catchAll2;
  catchAllCause4 = catchAllCause2;
  context4 = context2;
  die8 = die6;
  dieSync5 = dieSync3;
  discard2 = discard;
  effect = fromEffect4;
  effectDiscard = fromEffectDiscard;
  effectContext = fromEffectContext;
  empty34 = empty33;
  extendScope2 = extendScope;
  fail11 = fail8;
  failSync5 = failSync3;
  failCause10 = failCause7;
  failCauseSync5 = failCauseSync3;
  flatMap13 = flatMap11;
  flatten11 = flatten9;
  fresh2 = fresh;
  fromFunction3 = fromFunction;
  launch2 = launch;
  map18 = map15;
  mapError4 = mapError2;
  match15 = match12;
  matchCause4 = matchCause2;
  memoize3 = memoize2;
  merge8 = merge6;
  mergeAll6 = mergeAll4;
  orDie4 = orDie2;
  orElse7 = orElse5;
  passthrough3 = passthrough;
  project2 = project;
  locallyEffect2 = locallyEffect;
  locally2 = fiberRefLocally2;
  locallyWith2 = fiberRefLocallyWith2;
  locallyScoped2 = fiberRefLocallyScoped2;
  fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
  retry3 = retry;
  scope4 = scope2;
  scoped4 = scoped2;
  scopedDiscard2 = scopedDiscard;
  scopedContext2 = scopedContext;
  service2 = service;
  succeed11 = succeed7;
  succeedContext2 = succeedContext;
  suspend4 = suspend2;
  sync6 = sync3;
  syncContext2 = syncContext;
  tap5 = tap3;
  tapError4 = tapError2;
  tapErrorCause4 = tapErrorCause2;
  toRuntime2 = toRuntime;
  toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
  provide3 = provide;
  provideMerge2 = provideMerge;
  zipWith10 = zipWith7;
  unwrapEffect2 = unwrapEffect;
  unwrapScoped2 = unwrapScoped;
  setConfigProvider2 = setConfigProvider;
  parentSpan2 = parentSpan;
  span3 = span2;
  setTracer2 = setTracer;
  withSpan4 = withSpan2;
  withParentSpan4 = withParentSpan2;
  makeMemoMap2 = makeMemoMap;
  buildWithMemoMap2 = buildWithMemoMap;
  updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map18(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));
});

// ../../node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue", EnqueueTypeId, DequeueSymbolKey = "effect/QueueDequeue", DequeueTypeId, QueueStrategySymbolKey = "effect/QueueStrategy", QueueStrategyTypeId, BackingQueueSymbolKey = "effect/BackingQueue", BackingQueueTypeId, queueStrategyVariance, backingQueueVariance, enqueueVariance, dequeueVariance, QueueImpl, takeRemainderLoop = (self, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max5), flatMap9((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self), flatMap9((b) => takeRemainderLoop(self, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, isQueue = (u) => isEnqueue(u) && isDequeue(u), isEnqueue = (u) => hasProperty(u, EnqueueTypeId), isDequeue = (u) => hasProperty(u, DequeueTypeId), bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make45(backingQueueFromMutableQueue(queue), backPressureStrategy()))), dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make45(backingQueueFromMutableQueue(queue), droppingStrategy()))), sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make45(backingQueueFromMutableQueue(queue), slidingStrategy()))), unbounded2 = () => pipe(sync(() => unbounded()), flatMap9((queue) => make45(backingQueueFromMutableQueue(queue), droppingStrategy()))), unsafeMake12 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
}, make45 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake12(queue, unbounded(), deferred, make13(false), strategy))), BackingQueueFromMutableQueue, backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable), capacity2 = (self) => self.capacity(), size12 = (self) => self.size, isFull = (self) => self.isFull, isEmpty10 = (self) => self.isEmpty, isShutdown = (self) => self.isShutdown, awaitShutdown = (self) => self.awaitShutdown, shutdown = (self) => self.shutdown, offer2, unsafeOffer, offerAll2, poll5 = (self) => map10(self.takeUpTo(1), head2), take2 = (self) => self.take, takeAll = (self) => self.takeAll, takeUpTo, takeBetween, takeN, backPressureStrategy = () => new BackPressureStrategy, droppingStrategy = () => new DroppingStrategy, slidingStrategy = () => new SlidingStrategy, BackPressureStrategy, DroppingStrategy, SlidingStrategy, unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
}, unsafeOfferAll = (queue, as6) => {
  return pipe(queue, offerAll(as6));
}, unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, unsafePollN = (queue, max5) => {
  return pipe(queue, pollUpTo(max5));
}, unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
}, unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};
var init_queue = __esm(() => {
  init_Array();
  init_Chunk();
  init_Effectable();
  init_Function();
  init_MutableQueue();
  init_MutableRef();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_core();
  init_fiberRuntime();
  EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
  DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
  QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
  BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
  queueStrategyVariance = {
    _A: (_) => _
  };
  backingQueueVariance = {
    _A: (_) => _
  };
  enqueueVariance = {
    _In: (_) => _
  };
  dequeueVariance = {
    _Out: (_) => _
  };
  QueueImpl = class QueueImpl extends Class {
    queue;
    takers;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
      super();
      this.queue = queue;
      this.takers = takers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
    capacity() {
      return this.queue.capacity();
    }
    get size() {
      return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
    }
    get isEmpty() {
      return map10(this.size, (size12) => size12 <= 0);
    }
    get isFull() {
      return map10(this.size, (size12) => size12 >= this.capacity());
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid2);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return true;
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded;
    }
    offer(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let noRemaining;
        if (this.queue.length() === 0) {
          const taker = pipe(this.takers, poll2(EmptyMutableQueue));
          if (taker !== EmptyMutableQueue) {
            unsafeCompleteDeferred(taker, value);
            noRemaining = true;
          } else {
            noRemaining = false;
          }
        } else {
          noRemaining = false;
        }
        if (noRemaining) {
          return succeed(true);
        }
        const succeeded = this.queue.offer(value);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
      });
    }
    offerAll(iterable) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const values4 = fromIterable2(iterable);
        const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values4.length)) : empty2;
        const [forTakers, remaining] = pipe(values4, splitAt(pTakers.length));
        for (let i = 0;i < pTakers.length; i++) {
          const taker = pTakers[i];
          const item = forTakers[i];
          unsafeCompleteDeferred(taker, item);
        }
        if (remaining.length === 0) {
          return succeed(true);
        }
        const surplus = this.queue.offerAll(remaining);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
      });
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const item = this.queue.poll(EmptyMutableQueue);
        if (item !== EmptyMutableQueue) {
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return succeed(item);
        } else {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.takers, offer(deferred));
            unsafeCompleteTakers(this.strategy, this.queue, this.takers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => {
            return sync(() => unsafeRemove(this.takers, deferred));
          }));
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
          const values4 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return fromIterable3(values4);
        });
      });
    }
    takeUpTo(max5) {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values4 = this.queue.pollUpTo(max5);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values4);
      }));
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop(this, min3, max5, empty5()));
    }
  };
  BackingQueueFromMutableQueue = class BackingQueueFromMutableQueue {
    mutable;
    [BackingQueueTypeId] = backingQueueVariance;
    constructor(mutable) {
      this.mutable = mutable;
    }
    poll(def) {
      return poll2(this.mutable, def);
    }
    pollUpTo(limit) {
      return pollUpTo(this.mutable, limit);
    }
    offerAll(elements) {
      return offerAll(this.mutable, elements);
    }
    offer(element) {
      return offer(this.mutable, element);
    }
    capacity() {
      return capacity(this.mutable);
    }
    length() {
      return length2(this.mutable);
    }
  };
  offer2 = /* @__PURE__ */ dual(2, (self, value) => self.offer(value));
  unsafeOffer = /* @__PURE__ */ dual(2, (self, value) => self.unsafeOffer(value));
  offerAll2 = /* @__PURE__ */ dual(2, (self, iterable) => self.offerAll(iterable));
  takeUpTo = /* @__PURE__ */ dual(2, (self, max5) => self.takeUpTo(max5));
  takeBetween = /* @__PURE__ */ dual(3, (self, min3, max5) => self.takeBetween(min3, max5));
  takeN = /* @__PURE__ */ dual(2, (self, n) => self.takeBetween(n, n));
  BackPressureStrategy = class BackPressureStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    putters = /* @__PURE__ */ unbounded();
    surplusSize() {
      return length2(this.putters);
    }
    onCompleteTakersWithEmptyQueue(takers) {
      while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
        const taker = poll2(takers, undefined);
        const putter = poll2(this.putters, undefined);
        if (putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        }
        unsafeCompleteDeferred(taker, putter[0]);
      }
    }
    get shutdown() {
      return pipe(fiberId, flatMap9((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap9((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)))));
    }
    handleSurplus(iterable, queue, takers, isShutdown2) {
      return withFiberRuntime((state) => {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          this.unsafeOffer(iterable, deferred);
          this.unsafeOnQueueEmptySpace(queue, takers);
          unsafeCompleteTakers(this, queue, takers);
          return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnQueueEmptySpace(queue, takers) {
      let keepPolling = true;
      while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
        const putter = pipe(this.putters, poll2(EmptyMutableQueue));
        if (putter === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const offered = queue.offer(putter[0]);
          if (offered && putter[2]) {
            unsafeCompleteDeferred(putter[1], true);
          } else if (!offered) {
            unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
          }
          unsafeCompleteTakers(this, queue, takers);
        }
      }
    }
    unsafeOffer(iterable, deferred) {
      const stuff = fromIterable2(iterable);
      for (let i = 0;i < stuff.length; i++) {
        const value = stuff[i];
        if (i === stuff.length - 1) {
          pipe(this.putters, offer([value, deferred, true]));
        } else {
          pipe(this.putters, offer([value, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
    }
  };
  DroppingStrategy = class DroppingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_2;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(_iterable, _queue, _takers, _isShutdown) {
      return succeed(false);
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
  };
  SlidingStrategy = class SlidingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_2;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(iterable, queue, takers, _isShutdown) {
      return sync(() => {
        this.unsafeOffer(queue, iterable);
        unsafeCompleteTakers(this, queue, takers);
        return true;
      });
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
    unsafeOffer(queue, iterable) {
      const iterator = iterable[Symbol.iterator]();
      let next4;
      let offering = true;
      while (!(next4 = iterator.next()).done && offering) {
        if (queue.capacity() === 0) {
          return;
        }
        queue.poll(EmptyMutableQueue);
        offering = queue.offer(next4.value);
      }
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/pubsub.js
class BoundedPubSubArb {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity4, replayBuffer) {
    this.capacity = capacity4;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity4
    });
    this.subscribers = Array.from({
      length: capacity4
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk2 = fromIterable3(elements);
    const n = chunk2.length;
    const size14 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size14;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubArbSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size14 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size14);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubPow2 {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity4, replayBuffer) {
    this.capacity = capacity4;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity4
    });
    this.mask = capacity4 - 1;
    this.subscribers = Array.from({
      length: capacity4
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk2 = fromIterable3(elements);
    const n = chunk2.length;
    const size14 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size14;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubPow2Subscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size14 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size14);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubSingle {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk2 = fromIterable3(elements);
    if (isEmpty(chunk2)) {
      return chunk2;
    }
    if (this.publish(unsafeHead2(chunk2))) {
      return drop2(chunk2, 1);
    } else {
      return chunk2;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubSingleSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty5();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
}

class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty35 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty35 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty35;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}

class BackPressureStrategy2 {
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap9(fiberId, (fiberId3) => flatMap9(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last4]) => last4 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown3) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get6(isShutdown3) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next4 = iterator.next();
    if (!next4.done) {
      while (true) {
        const value = next4.value;
        next4 = iterator.next();
        if (next4.done) {
          pipe(this.publishers, offer([value, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
  }
}

class DroppingStrategy2 {
  get shutdown() {
    return void_2;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
}

class SlidingStrategy2 {
  get shutdown() {
    return void_2;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next4 = it.next();
    if (!next4.done && pubsub.capacity > 0) {
      let a = next4.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next4 = it.next()) && !next4.done) {
          a = next4.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
}

class ReplayBuffer {
  capacity;
  constructor(capacity4) {
    this.capacity = capacity4;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as6) {
    for (const a of as6) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty5();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0;i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var AbsentValue, addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, new Set);
  }
  const set8 = subscribers.get(subscription);
  set8.add(pollers);
}, removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set8 = subscribers.get(subscription);
  set8.delete(pollers);
  if (set8.size === 0) {
    subscribers.delete(subscription);
  }
}, bounded3 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new BackPressureStrategy2);
}), dropping2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new DroppingStrategy2);
}), sliding2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new SlidingStrategy2);
}), unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2);
}), capacity3 = (self) => self.capacity(), size13 = (self) => self.size, isFull2 = (self) => self.isFull, isEmpty11 = (self) => self.isEmpty, shutdown2 = (self) => self.shutdown, isShutdown2 = (self) => self.isShutdown, awaitShutdown2 = (self) => self.awaitShutdown, publish, publishAll, subscribe = (self) => self.subscribe, makeBoundedPubSub = (capacity4) => {
  const options = typeof capacity4 === "number" ? {
    capacity: capacity4
  } : capacity4;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : undefined;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
}, makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined), makeSubscription = (pubsub, subscribers, strategy) => map10(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make13(false), strategy)), unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow()), SubscriptionImpl, takeRemainderLoop2 = (self, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max5), flatMap9((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap9((b) => takeRemainderLoop2(self, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, PubSubImpl, makePubSub = (pubsub, strategy) => flatMap9(scopeMake(), (scope5) => map10(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, new Map, scope5, deferred, make13(false), strategy))), unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy), ensureCapacity = (capacity4) => {
  if (capacity4 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity4}`);
  }
}, unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
}, unsafeOfferAll2 = (queue, as6) => {
  return pipe(queue, offerAll(as6));
}, unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
}, unsafePollN2 = (subscription, max5) => {
  return subscription.pollUpTo(max5);
}, unsafePublishAll = (pubsub, as6) => {
  return pubsub.publishAll(as6);
}, unsafeRemove2 = (queue, value) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value)));
}, unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty7(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
}, unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
}, emptyReplayWindow;
var init_pubsub = __esm(() => {
  init_Chunk();
  init_Effectable();
  init_Function();
  init_MutableQueue();
  init_MutableRef();
  init_Number();
  init_Option();
  init_Pipeable();
  init_core();
  init_executionStrategy();
  init_fiberRuntime();
  init_queue();
  AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
  publish = /* @__PURE__ */ dual(2, (self, value) => self.publish(value));
  publishAll = /* @__PURE__ */ dual(2, (self, elements) => self.publishAll(elements));
  SubscriptionImpl = class SubscriptionImpl extends Class {
    pubsub;
    subscribers;
    subscription;
    pollers;
    shutdownHook;
    shutdownFlag;
    strategy;
    replayWindow;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
      super();
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.subscription = subscription;
      this.pollers = pollers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
      this.replayWindow = replayWindow;
    }
    commit() {
      return this.take;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    capacity() {
      return this.pubsub.capacity;
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.subscription.size() + this.replayWindow.remaining);
    }
    get isFull() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
    }
    get isEmpty() {
      return map10(this.size, (size14) => size14 === 0);
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        set2(this.shutdownFlag, true);
        return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
          this.subscribers.delete(this.subscription);
          this.subscription.unsubscribe();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        })), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid2);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.replayWindow.remaining > 0) {
          const message2 = this.replayWindow.take();
          return succeed(message2);
        }
        const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
        if (message === EmptyMutableQueue) {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.pollers, offer(deferred));
            pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
            this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
        } else {
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          return succeed(message);
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const as6 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty5();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        if (this.replayWindow.remaining > 0) {
          return succeed(appendAll2(this.replayWindow.takeAll(), as6));
        }
        return succeed(as6);
      });
    }
    takeUpTo(max5) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let replay = undefined;
        if (this.replayWindow.remaining >= max5) {
          const as7 = this.replayWindow.takeN(max5);
          return succeed(as7);
        } else if (this.replayWindow.remaining > 0) {
          replay = this.replayWindow.takeAll();
          max5 = max5 - replay.length;
        }
        const as6 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max5) : empty5();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return replay ? succeed(appendAll2(replay, as6)) : succeed(as6);
      });
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop2(this, min3, max5, empty5()));
    }
  };
  PubSubImpl = class PubSubImpl {
    pubsub;
    subscribers;
    scope;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.scope = scope5;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    capacity() {
      return this.pubsub.capacity;
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.pubsub.size());
    }
    get isFull() {
      return map10(this.size, (size14) => size14 === this.capacity());
    }
    get isEmpty() {
      return map10(this.size, (size14) => size14 === 0);
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid2);
      }));
    }
    publish(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.pubsub.publish(value)) {
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
      });
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return true;
      }
      return false;
    }
    publishAll(elements) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const surplus = unsafePublishAll(this.pubsub, elements);
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        if (isEmpty(surplus)) {
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
      });
    }
    get subscribe() {
      const acquire = tap2(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
      return map10(acquireRelease(acquire, (tuple4, exit3) => tuple4[0].close(exit3)), (tuple4) => tuple4[1]);
    }
    offer(value) {
      return this.publish(value);
    }
    offerAll(elements) {
      return this.publishAll(elements);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  emptyReplayWindow = {
    remaining: 0,
    take: () => {
      return;
    },
    takeN: () => empty5(),
    takeAll: () => empty5()
  };
});

// ../../node_modules/effect/dist/esm/PubSub.js
var exports_PubSub = {};
__export(exports_PubSub, {
  unbounded: () => unbounded4,
  subscribe: () => subscribe2,
  sliding: () => sliding3,
  size: () => size14,
  shutdown: () => shutdown3,
  publishAll: () => publishAll2,
  publish: () => publish2,
  isShutdown: () => isShutdown3,
  isFull: () => isFull3,
  isEmpty: () => isEmpty12,
  dropping: () => dropping3,
  capacity: () => capacity4,
  bounded: () => bounded4,
  awaitShutdown: () => awaitShutdown3
});
var bounded4, dropping3, sliding3, unbounded4, capacity4, size14, isFull3, isEmpty12, shutdown3, isShutdown3, awaitShutdown3, publish2, publishAll2, subscribe2;
var init_PubSub = __esm(() => {
  init_pubsub();
  bounded4 = bounded3;
  dropping3 = dropping2;
  sliding3 = sliding2;
  unbounded4 = unbounded3;
  capacity4 = capacity3;
  size14 = size13;
  isFull3 = isFull2;
  isEmpty12 = isEmpty11;
  shutdown3 = shutdown2;
  isShutdown3 = isShutdown2;
  awaitShutdown3 = awaitShutdown2;
  publish2 = publish;
  publishAll2 = publishAll;
  subscribe2 = subscribe;
});

// ../../node_modules/effect/dist/esm/Queue.js
var exports_Queue = {};
__export(exports_Queue, {
  unsafeOffer: () => unsafeOffer2,
  unbounded: () => unbounded5,
  takeUpTo: () => takeUpTo2,
  takeN: () => takeN2,
  takeBetween: () => takeBetween2,
  takeAll: () => takeAll2,
  take: () => take3,
  slidingStrategy: () => slidingStrategy2,
  sliding: () => sliding4,
  size: () => size15,
  shutdown: () => shutdown4,
  poll: () => poll6,
  offerAll: () => offerAll3,
  offer: () => offer3,
  make: () => make46,
  isShutdown: () => isShutdown4,
  isQueue: () => isQueue2,
  isFull: () => isFull4,
  isEnqueue: () => isEnqueue2,
  isEmpty: () => isEmpty13,
  isDequeue: () => isDequeue2,
  droppingStrategy: () => droppingStrategy2,
  dropping: () => dropping4,
  capacity: () => capacity5,
  bounded: () => bounded5,
  backPressureStrategy: () => backPressureStrategy2,
  awaitShutdown: () => awaitShutdown4,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  BackingQueueTypeId: () => BackingQueueTypeId2
});
var EnqueueTypeId2, DequeueTypeId2, QueueStrategyTypeId2, BackingQueueTypeId2, isQueue2, isDequeue2, isEnqueue2, backPressureStrategy2, droppingStrategy2, slidingStrategy2, make46, bounded5, dropping4, sliding4, unbounded5, capacity5, size15, isEmpty13, isFull4, isShutdown4, awaitShutdown4, shutdown4, offer3, unsafeOffer2, offerAll3, poll6, take3, takeAll2, takeUpTo2, takeBetween2, takeN2;
var init_Queue = __esm(() => {
  init_queue();
  EnqueueTypeId2 = EnqueueTypeId;
  DequeueTypeId2 = DequeueTypeId;
  QueueStrategyTypeId2 = QueueStrategyTypeId;
  BackingQueueTypeId2 = BackingQueueTypeId;
  isQueue2 = isQueue;
  isDequeue2 = isDequeue;
  isEnqueue2 = isEnqueue;
  backPressureStrategy2 = backPressureStrategy;
  droppingStrategy2 = droppingStrategy;
  slidingStrategy2 = slidingStrategy;
  make46 = make45;
  bounded5 = bounded2;
  dropping4 = dropping;
  sliding4 = sliding;
  unbounded5 = unbounded2;
  capacity5 = capacity2;
  size15 = size12;
  isEmpty13 = isEmpty10;
  isFull4 = isFull;
  isShutdown4 = isShutdown;
  awaitShutdown4 = awaitShutdown;
  shutdown4 = shutdown;
  offer3 = offer2;
  unsafeOffer2 = unsafeOffer;
  offerAll3 = offerAll2;
  poll6 = poll5;
  take3 = take2;
  takeAll2 = takeAll;
  takeUpTo2 = takeUpTo;
  takeBetween2 = takeBetween;
  takeN2 = takeN;
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue", OP_CLOSE = "Close", OP_YIELD2 = "Yield";

// ../../node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision", ChildExecutorDecisionTypeId, proto4, Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};
var init_childExecutorDecision = __esm(() => {
  init_Function();
  init_Predicate();
  ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
  proto4 = {
    [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK", OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// ../../node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId, continuationVariance, ContinuationKImpl, ContinuationFinalizerImpl;
var init_continuation = __esm(() => {
  init_Exit();
  ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
  continuationVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutDone: (_) => _,
    _OutErr2: (_) => _,
    _OutElem: (_) => _,
    _OutDone2: (_) => _
  };
  ContinuationKImpl = class ContinuationKImpl {
    onSuccess;
    onHalt;
    _tag = OP_CONTINUATION_K;
    [ContinuationTypeId] = continuationVariance;
    constructor(onSuccess, onHalt) {
      this.onSuccess = onSuccess;
      this.onHalt = onHalt;
    }
    onExit(exit3) {
      return isFailure(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
    }
  };
  ContinuationFinalizerImpl = class ContinuationFinalizerImpl {
    finalizer;
    _tag = OP_CONTINUATION_FINALIZER;
    [ContinuationTypeId] = continuationVariance;
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext", OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// ../../node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy", UpstreamPullStrategyTypeId, upstreamPullStrategyVariance, proto5, PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
var init_upstreamPullStrategy = __esm(() => {
  init_Function();
  init_Predicate();
  UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
  upstreamPullStrategyVariance = {
    _A: (_) => _
  };
  proto5 = {
    [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut", OP_BRIDGE = "Bridge", OP_CONCAT_ALL = "ConcatAll", OP_EMIT = "Emit", OP_ENSURING = "Ensuring", OP_FAIL3 = "Fail", OP_FOLD2 = "Fold", OP_FROM_EFFECT2 = "FromEffect", OP_PIPE_TO = "PipeTo", OP_PROVIDE2 = "Provide", OP_READ = "Read", OP_SUCCEED = "Succeed", OP_SUCCEED_NOW = "SucceedNow", OP_SUSPEND2 = "Suspend";

// ../../node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel", ChannelTypeId2, channelVariance2, proto6, isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u), acquireReleaseOut, catchAllCause5, collectElements = (self) => {
  return suspend5(() => {
    const builder = [];
    return flatMap14(pipeTo(self, collectElementsReader(builder)), (value) => sync7(() => [fromIterable3(builder), value]));
  });
}, collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap14(sync7(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail12,
  onDone: succeedNow
}), concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
}, concatMapWith, embedInput, ensuringWith, fail12 = (error) => failCause11(fail6(error)), failCause11 = (cause3) => failCauseSync6(() => cause3), failCauseSync6 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate2;
  return op;
}, flatMap14, foldCauseChannel, fromEffect5 = (effect2) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect2;
  return op;
}, pipeTo, provideContext4, readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause11
  }),
  onDone: options.onDone
}), readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
}, succeed12 = (value) => sync7(() => value), succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
}, suspend5 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate2;
  return op;
}, sync7 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate2;
  return op;
}, void_7, write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};
var init_core_stream = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Effect();
  init_Either();
  init_Function();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_childExecutorDecision();
  init_continuation();
  init_upstreamPullStrategy();
  ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
  channelVariance2 = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  proto6 = {
    [ChannelTypeId2]: channelVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
    const op = Object.create(proto6);
    op._tag = OP_BRACKET_OUT;
    op.acquire = () => self;
    op.finalizer = release;
    return op;
  });
  catchAllCause5 = /* @__PURE__ */ dual(2, (self, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(succeed12, f);
    return op;
  });
  concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h2) => {
    const op = Object.create(proto6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = g;
    op.combineAll = h2;
    op.onPull = () => PullAfterNext(none2());
    op.onEmit = () => Continue;
    op.value = () => self;
    op.k = f;
    return op;
  });
  embedInput = /* @__PURE__ */ dual(2, (self, input) => {
    const op = Object.create(proto6);
    op._tag = OP_BRIDGE;
    op.input = input;
    op.channel = self;
    return op;
  });
  ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer) => {
    const op = Object.create(proto6);
    op._tag = OP_ENSURING;
    op.channel = self;
    op.finalizer = finalizer;
    return op;
  });
  flatMap14 = /* @__PURE__ */ dual(2, (self, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(f, failCause11);
    return op;
  });
  foldCauseChannel = /* @__PURE__ */ dual(2, (self, options) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
    return op;
  });
  pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
    const op = Object.create(proto6);
    op._tag = OP_PIPE_TO;
    op.left = () => self;
    op.right = () => that;
    return op;
  });
  provideContext4 = /* @__PURE__ */ dual(2, (self, env) => {
    const op = Object.create(proto6);
    op._tag = OP_PROVIDE2;
    op.context = () => env;
    op.inner = self;
    return op;
  });
  void_7 = /* @__PURE__ */ succeedNow(undefined);
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done", OP_EMIT2 = "Emit", OP_FROM_EFFECT3 = "FromEffect", OP_READ2 = "Read";

// ../../node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId, channelStateVariance, proto7, Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
}, Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
}, fromEffect6 = (effect2) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect2;
  return op;
}, Read = (upstream, onEffect, onEmit, onDone) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone;
  return op;
}, isFromEffect = (self) => self._tag === OP_FROM_EFFECT3, effect2 = (self) => isFromEffect(self) ? self.effect : _void, effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : undefined;
var init_channelState = __esm(() => {
  init_Effect();
  init_Predicate();
  ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
  channelStateVariance = {
    _E: (_) => _,
    _R: (_) => _
  };
  proto7 = {
    [ChannelStateTypeId]: channelStateVariance
  };
});

// ../../node_modules/effect/dist/esm/internal/channel/subexecutor.js
class PullFromChild {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.childExecutor.close(exit3);
    const fin2 = this.parentSubexecutor.close(exit3);
    if (fin1 !== undefined && fin2 !== undefined) {
      return zipWith9(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== undefined) {
      return fin1;
    } else if (fin2 !== undefined) {
      return fin2;
    } else {
      return;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

class PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith9(acc, exit2(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}

class DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== undefined && next4 !== undefined) {
        return zipWith9(acc, exit2(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next4 !== undefined) {
        return exit2(next4);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}

class Emit2 {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value, next4) {
    this.value = value;
    this.next = next4;
  }
  close(exit3) {
    const result = this.next.close(exit3);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}
var OP_PULL_FROM_CHILD = "PullFromChild", OP_PULL_FROM_UPSTREAM = "PullFromUpstream", OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors", OP_EMIT3 = "Emit";
var init_subexecutor = __esm(() => {
  init_Effect();
  init_Exit();
  init_Function();
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled", OP_NO_UPSTREAM = "NoUpstream";

// ../../node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest", UpstreamPullRequestTypeId, upstreamPullRequestVariance, proto8, Pulled = (value) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value;
  return op;
}, NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};
var init_upstreamPullRequest = __esm(() => {
  init_Function();
  init_Predicate();
  UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
  upstreamPullRequestVariance = {
    _A: (_) => _
  };
  proto8 = {
    [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
  };
});

// ../../node_modules/effect/dist/esm/internal/channel/channelExecutor.js
class ChannelExecutor {
  _activeSubexecutor = undefined;
  _cancelled = undefined;
  _closeLastSubstream = undefined;
  _currentChannel;
  _done = undefined;
  _doneStack = [];
  _emitted = undefined;
  _executeCloseLastSubstream;
  _input = undefined;
  _inProgressFinalizer = undefined;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== undefined) {
                  const inputExecutor = this._input;
                  this._input = undefined;
                  const drainer = () => flatMap12(bridgeInput.awaitRead(), () => suspend3(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match6(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value) => bridgeInput.done(value)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap12(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect6(flatMap12(forkDaemon2(interruptible4(drainer())), (fiber) => sync5(() => this.addFinalizer((exit3) => flatMap12(interrupt6(fiber), () => suspend3(() => {
                    const effect3 = this.restorePipe(exit3, inputExecutor);
                    return effect3 !== undefined ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync5(() => {
                  const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight6(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                this._closeLastSubstream = undefined;
                this._currentChannel = undefined;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_7;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect3, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value) => {
                    const state = this.doneSucceed(value);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit3) => {
                  const effect3 = this.restorePipe(exit3, previousInput);
                  return effect3 !== undefined ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync5(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read.more(emitted);
                  } catch (error) {
                    this._currentChannel = read.done.onExit(die4(error));
                  }
                  return;
                }, (exit3) => {
                  const onExit4 = (exit4) => {
                    return read.done.onExit(exit4);
                  };
                  this._currentChannel = onExit4(exit3);
                  return;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error) {
          this._currentChannel = failCause11(die5(error));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit3) {
    this._cancelled = exit3;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit3) {
    const finalizers = [];
    let next4 = this._doneStack.pop();
    while (next4) {
      if (next4._tag === "ContinuationFinalizer") {
        finalizers.push(next4.finalizer);
      }
      next4 = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit3, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== undefined) {
      const effect3 = currInput.close(exit3);
      return effect3;
    }
    return _void;
  }
  close(exit3) {
    let runInProgressFinalizers = undefined;
    const finalizer = this._inProgressFinalizer;
    if (finalizer !== undefined) {
      runInProgressFinalizers = pipe(finalizer, ensuring3(sync5(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = undefined;
    const selfFinalizers = this.popAllFinalizers(exit3);
    if (selfFinalizers !== undefined) {
      closeSelf = pipe(selfFinalizers, ensuring3(sync5(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
      return;
    }
    return pipe(exit2(ifNotNull(closeSubexecutors)), zip7(exit2(ifNotNull(runInProgressFinalizers))), zip7(exit2(ifNotNull(closeSelf))), map17(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))), uninterruptible2, flatMap12((exit4) => suspend3(() => exit4)));
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head5.onSuccess(value);
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap12(() => sync5(() => this.doneSucceed(value))));
    return fromEffect6(effect3);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head5.onHalt(cause3);
      } catch (error) {
        this._currentChannel = failCause11(die5(error));
      }
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap12(() => sync5(() => this.doneHalt(cause3))));
    return fromEffect6(effect3);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync5(() => {
        this._currentChannel = failCause11(cause3);
      }),
      onSuccess: (out) => sync5(() => {
        this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === undefined) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring4) {
    this.addFinalizer(ensuring4.finalizer);
    this._currentChannel = ensuring4.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit3) {
    const state = match6(exit3, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    });
    this._activeSubexecutor = undefined;
    return state === undefined ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach9((closeFunc) => pipe(sync5(() => closeFunc(subexecutorDone)), flatMap12((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match6({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    }));
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return;
    }, match6({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight6(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map17(() => {
          const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return;
    }, (exit3) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
        const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map17(() => this.replaceSubexecutor(drain)));
        }
        this.replaceSubexecutor(drain);
        return;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map11((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
      return state === undefined ? undefined : effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => succeed10(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
}
var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void, runFinalizers = (finalizers, exit3) => {
  return pipe(forEach9(finalizers, (fin) => exit2(fin(exit3))), map17((exits) => pipe(all4(exits), getOrElse(() => void_3))), flatMap12((exit4) => suspend3(() => exit4)));
}, readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause3((cause3) => suspend3(() => {
          const doneEffect = current.onDone(failCause3(cause3));
          return doneEffect === undefined ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend3(() => read());
      }
    }
  };
  return read();
}, runIn, runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap12(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend3(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause9);
    }
  }
};
var init_channelExecutor = __esm(() => {
  init_Cause();
  init_Deferred();
  init_Effect();
  init_ExecutionStrategy();
  init_Exit();
  init_Fiber();
  init_FiberId();
  init_Function();
  init_HashSet();
  init_Option();
  init_Scope();
  init_core_stream();
  init_channelState();
  init_continuation();
  init_subexecutor();
  init_upstreamPullRequest();
  runIn = /* @__PURE__ */ dual(2, (self, scope5) => {
    const run2 = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync5(() => new ChannelExecutor(self, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight6(_await(channelDeferred)), zipLeft5(_await(scopeDeferred)))), (exec, exit3) => {
      const finalize = exec.close(exit3);
      if (finalize === undefined) {
        return _void;
      }
      return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause9(cause3)));
    });
    return uninterruptibleMask3((restore) => all7([fork2(scope5, sequential3), make19(), make19()]).pipe(flatMap12(([child, channelDeferred, scopeDeferred]) => restore(run2(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap12((fiber) => scope5.addFinalizer((exit3) => {
      const interruptors3 = isFailure(exit3) ? interruptors2(exit3.cause) : undefined;
      return isDone(channelDeferred).pipe(flatMap12((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight6(_await3(fiber)), zipRight6(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight6(interruptors3 && size4(interruptors3) > 0 ? interruptAs(fiber, combineAll3(interruptors3)) : interrupt6(fiber)), zipRight6(inheritAll2(fiber)))));
    }).pipe(zipRight6(restore(_await(channelDeferred)))))))));
  });
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done", OP_AWAIT = "Await";

// ../../node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision", MergeDecisionTypeId, proto9, Done3 = (effect3) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect3;
  return op;
}, Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};
var init_mergeDecision = __esm(() => {
  init_Function();
  init_Predicate();
  MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
  proto9 = {
    [MergeDecisionTypeId]: {
      _R: (_) => _,
      _E0: (_) => _,
      _Z0: (_) => _,
      _E: (_) => _,
      _Z: (_) => _
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning", OP_LEFT_DONE = "LeftDone", OP_RIGHT_DONE = "RightDone";

// ../../node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState", MergeStateTypeId, proto10, BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
}, LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
}, RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};
var init_mergeState = __esm(() => {
  init_Function();
  init_Predicate();
  MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
  proto10 = {
    [MergeStateTypeId]: MergeStateTypeId
  };
});

// ../../node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure", OP_BUFFER_SLIDING = "BufferSliding";

// ../../node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy", MergeStrategyTypeId, proto11, BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
}, BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
}, match16;
var init_mergeStrategy = __esm(() => {
  init_Function();
  init_Predicate();
  MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
  proto11 = {
    [MergeStrategyTypeId]: MergeStrategyTypeId
  };
  match16 = /* @__PURE__ */ dual(2, (self, {
    onBackPressure,
    onBufferSliding
  }) => {
    switch (self._tag) {
      case OP_BACK_PRESSURE: {
        return onBackPressure();
      }
      case OP_BUFFER_SLIDING: {
        return onBufferSliding();
      }
    }
  });
});

// ../../node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
class SingleProducerAsyncInputImpl {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten10(modify6(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
  }
  done(value) {
    return flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
            discard: true
          }), stateDone(value)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap12(make19(), (deferred) => flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== undefined) {
            return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach9(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map13(cause3, left2)), (elem) => succeed3(elem), (done9) => fail4(right2(done9)));
  }
  takeWith(onError3, onElement, onDone) {
    return flatMap12(make19(), (deferred) => flatten10(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight6(succeed2(state.notifyProducer, undefined), matchCause3(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause3(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed10(onError3(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed10(onDone(state.done)), state];
        }
      }
    })));
  }
}
var OP_STATE_EMPTY = "Empty", OP_STATE_EMIT = "Emit", OP_STATE_ERROR = "Error", OP_STATE_DONE2 = "Done", stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
}), stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
}), stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
}), stateDone = (done9) => ({
  _tag: OP_STATE_DONE2,
  done: done9
}), make47 = () => pipe(make19(), flatMap12((deferred) => make29(stateEmpty(deferred))), map17((ref) => new SingleProducerAsyncInputImpl(ref)));
var init_singleProducerAsyncInput = __esm(() => {
  init_Cause();
  init_Deferred();
  init_Effect();
  init_Either();
  init_Exit();
  init_Function();
  init_Ref();
});

// ../../node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap14(fromEffect5(make29(() => _void)), (ref) => pipe(fromEffect5(uninterruptible2(tap4(acquire, (a) => set6(ref, (exit3) => release(a, exit3))))), flatMap14(use), ensuringWith((exit3) => flatMap12(get12(ref), (f) => f(exit3))))), as6, catchAll5, concatMap, drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause11,
    onDone: succeed12
  });
  return pipeTo(self, drainer);
}, ensuring4, flatten12 = (self) => flatMap14(self, identity), foldChannel, fromInput = (input) => unwrap(input.takeWith(failCause11, (elem) => flatMap14(write(elem), () => fromInput(input)), succeed12)), fromQueue = (queue) => suspend5(() => fromQueueInternal(queue)), fromQueueInternal = (queue) => pipe(fromEffect5(take3(queue)), flatMap14(match({
  onLeft: match6({
    onFailure: failCause11,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap14(write(elem), () => fromQueueInternal(queue))
}))), identityChannel = () => readWith({
  onInput: (input) => flatMap14(write(input), () => identityChannel()),
  onFailure: fail12,
  onDone: succeedNow
}), interruptWhen, interruptWhenDeferred, map19, mapError5, mapErrorCause3, mapOut, mapOutEffect, mapOutEffectPar, mergeAll7 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
}, mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope5) => gen3(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make47();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope5, shutdown4(cancelers));
  const lastDone = yield* make29(none2());
  const errorSignal = yield* make19();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap12(match({
      onLeft: (done9) => succeed10(some2(done9)),
      onRight: (outElem) => as5(offer3(queue, succeed10(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap12((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause9(cause3) : offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed2(errorSignal, undefined)), asVoid4)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed10(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as5(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight6(interrupt6(failureAwait), get12(lastDone).pipe(flatMap12(match2({
          onNone: () => offer3(queue, succeed10(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed10(left2(f(lastDone2, outDone))))
        })), as5(false)))
      }),
      onRight: (channel) => match16(mergeStrategy, {
        onBackPressure: () => gen3(function* () {
          const latch = yield* make19();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap12((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap12(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen3(function* () {
          const canceler = yield* make19();
          const latch = yield* make19();
          const size16 = yield* size15(cancelers);
          yield* take3(cancelers).pipe(flatMap12((canceler2) => succeed2(canceler2, undefined)), when2(() => size16 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap12((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap12(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope5));
  const consumer = pipe(take3(queue), flatten10, matchCause3({
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap14(write(outElem), () => consumer)
    })
  }), unwrap);
  return embedInput(consumer, input);
})), mergeMap, mergeWith2, orDieWith3, orElse8, pipeToOrFail, repeated = (self) => flatMap14(self, () => repeated(self)), run2 = (self) => scopedWith2((scope5) => runIn(self, scope5)), runDrain = (self) => run2(drain(self)), runScoped = (self) => scopeWith2((scope5) => runIn(self, scope5)), scoped5 = (effect3) => unwrap(uninterruptibleMask3((restore) => map17(make41(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect3, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit3) => close(scope5, exit3))))), scopedWith3 = (f) => unwrapScoped3(map17(scope3, (scope5) => flatMap14(fromEffect5(f(scope5)), write))), splitLines = () => suspend5(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk2) => {
    const chunkBuilder = [];
    map4(chunk2, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf(`
`);
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf(`
`, from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop3 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop3 : flatMap14(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause11(cause3) : flatMap14(write(of2(stringBuilder)), () => failCause11(cause3)),
    onDone: (done9) => stringBuilder.length === 0 ? succeed12(done9) : flatMap14(write(of2(stringBuilder)), () => succeed12(done9))
  });
  return loop3;
}), toPubSub = (pubsub) => toQueue(pubsub), toPull = (self) => flatMap12(scope3, (scope5) => toPullIn(self, scope5)), toPullIn, interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match6(exec.getDone(), {
        onFailure: failCause9,
        onSuccess: (done9) => succeed10(left2(done9))
      });
    }
    case OP_EMIT2: {
      return succeed10(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap12(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause9(cause3));
    }
  }
}, toQueue = (queue) => suspend5(() => toQueueInternal(queue)), toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap14(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(pipe(offer3(queue, left2(failCause3(cause3))))),
    onDone: (done9) => fromEffect5(pipe(offer3(queue, left2(succeed3(done9)))))
  });
}, unwrap = (channel) => flatten12(fromEffect5(channel)), unwrapScoped3 = (self) => concatAllWith(scoped5(self), (d, _) => d, (d, _) => d), unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d), withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all7([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context5]) => provideContext4(self, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
  }
  return (self) => acquireUseRelease3(acquire, ([span4, context5]) => provideContext4(self, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
}, writeAll = (...outs) => writeChunk(fromIterable3(outs)), writeChunk = (outs) => writeChunkWriter(0, outs.length, outs), writeChunkWriter = (idx, len, chunk2) => {
  return idx === len ? void_7 : pipe(write(pipe(chunk2, unsafeGet4(idx))), flatMap14(() => writeChunkWriter(idx + 1, len, chunk2)));
}, zip8, zipLeft6, zipRight7, ChannelExceptionTypeId, ChannelException = (error) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error
}), isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);
var init_channel = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Context();
  init_Deferred();
  init_Effect();
  init_Either();
  init_Equal();
  init_Exit();
  init_Fiber();
  init_FiberRef();
  init_Function();
  init_Layer();
  init_Option();
  init_Predicate();
  init_PubSub();
  init_Queue();
  init_Ref();
  init_Scope();
  init_channelExecutor();
  init_mergeDecision();
  init_mergeState();
  init_mergeStrategy();
  init_singleProducerAsyncInput();
  init_core_effect();
  init_core_stream();
  init_tracer();
  as6 = /* @__PURE__ */ dual(2, (self, value) => map19(self, () => value));
  catchAll5 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause11
  })));
  concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => {
    return;
  }, () => {
    return;
  }));
  ensuring4 = /* @__PURE__ */ dual(2, (self, finalizer) => ensuringWith(self, () => finalizer));
  foldChannel = /* @__PURE__ */ dual(2, (self, options) => foldCauseChannel(self, {
    onFailure: (cause3) => {
      const either5 = failureOrCause2(cause3);
      switch (either5._tag) {
        case "Left": {
          return options.onFailure(either5.left);
        }
        case "Right": {
          return failCause11(either5.right);
        }
      }
    },
    onSuccess: options.onSuccess
  }));
  interruptWhen = /* @__PURE__ */ dual(2, (self, effect3) => mergeWith2(self, {
    other: fromEffect5(effect3),
    onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
    onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
  }));
  interruptWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
  map19 = /* @__PURE__ */ dual(2, (self, f) => flatMap14(self, (a) => sync7(() => f(a))));
  mapError5 = /* @__PURE__ */ dual(2, (self, f) => mapErrorCause3(self, map13(f)));
  mapErrorCause3 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => failCause11(f(cause3))));
  mapOut = /* @__PURE__ */ dual(2, (self, f) => {
    const reader = readWith({
      onInput: (outElem) => flatMap14(write(f(outElem)), () => reader),
      onFailure: fail12,
      onDone: succeedNow
    });
    return pipeTo(self, reader);
  });
  mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const reader = readWithCause({
      onInput: (outElem) => pipe(fromEffect5(f(outElem)), flatMap14(write), flatMap14(() => reader)),
      onFailure: failCause11,
      onDone: succeedNow
    });
    return pipeTo(self, reader);
  });
  mapOutEffectPar = /* @__PURE__ */ dual(3, (self, f, n) => unwrapScopedWith((scope5) => gen3(function* () {
    const input = yield* make47();
    const queueReader = fromInput(input);
    const queue = yield* bounded5(n);
    yield* addFinalizer2(scope5, shutdown4(queue));
    const errorSignal = yield* make19();
    const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
    const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope5));
    yield* pull.pipe(matchCauseEffect3({
      onFailure: (cause3) => offer3(queue, failCause9(cause3)),
      onSuccess: match({
        onLeft: (outDone) => zipRight6(interruptible4(withPermits(n)(_void)), asVoid4(offer3(queue, succeed10(left2(outDone))))),
        onRight: (outElem) => gen3(function* () {
          const deferred = yield* make19();
          const latch = yield* make19();
          yield* offer3(queue, map17(_await(deferred), right2));
          yield* succeed2(latch, undefined).pipe(zipRight6(uninterruptibleMask3((restore) => exit2(restore(_await(errorSignal))).pipe(raceFirst2(exit2(restore(f(outElem)))), flatMap12(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
        })
      })
    }), forever3, interruptible4, forkIn2(scope5));
    const consumer = unwrap(matchCause3(flatten10(take3(queue)), {
      onFailure: failCause11,
      onSuccess: match({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap14(write(outElem), () => consumer)
      })
    }));
    return embedInput(consumer, input);
  })));
  mergeMap = /* @__PURE__ */ dual(3, (self, f, options) => mergeAll7(options)(mapOut(self, f)));
  mergeWith2 = /* @__PURE__ */ dual(2, (self, options) => {
    function merge9(scope5) {
      return gen3(function* () {
        const input = yield* make47();
        const queueReader = fromInput(input);
        const pullL = yield* toPullIn(pipeTo(queueReader, self), scope5);
        const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
        function handleSide(exit3, fiber, pull) {
          return (done9, both2, single2) => {
            function onDecision2(decision) {
              const op = decision;
              if (op._tag === OP_DONE4) {
                return succeed10(fromEffect5(zipRight6(interrupt6(fiber), op.effect)));
              }
              return map17(_await3(fiber), match6({
                onFailure: (cause3) => fromEffect5(op.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done10) => fromEffect5(op.f(succeed3(done10))),
                  onRight: (elem) => zipRight7(write(elem), go(single2(op.f)))
                })
              }));
            }
            return match6(exit3, {
              onFailure: (cause3) => onDecision2(done9(failCause3(cause3))),
              onSuccess: match({
                onLeft: (z) => onDecision2(done9(succeed3(z))),
                onRight: (elem) => succeed10(flatMap14(write(elem), () => flatMap14(fromEffect5(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go(both2(leftFiber, fiber)))))
              })
            });
          };
        }
        function go(state) {
          switch (state._tag) {
            case OP_BOTH_RUNNING: {
              const leftJoin = interruptible4(join4(state.left));
              const rightJoin = interruptible4(join4(state.right));
              return unwrap(raceWith2(leftJoin, rightJoin, {
                onSelfDone: (leftExit, rf) => zipRight6(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
                onOtherDone: (rightExit, lf) => zipRight6(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
              }));
            }
            case OP_LEFT_DONE: {
              return unwrap(map17(exit2(pullR), match6({
                onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done9) => fromEffect5(state.f(succeed3(done9))),
                  onRight: (elem) => flatMap14(write(elem), () => go(LeftDone(state.f)))
                })
              })));
            }
            case OP_RIGHT_DONE: {
              return unwrap(map17(exit2(pullL), match6({
                onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done9) => fromEffect5(state.f(succeed3(done9))),
                  onRight: (elem) => flatMap14(write(elem), () => go(RightDone(state.f)))
                })
              })));
            }
          }
        }
        return fromEffect5(withFiberRuntime2((parent) => {
          const inherit = withFiberRuntime2((state) => {
            state.transferChildren(parent.scope());
            return _void;
          });
          const leftFiber = interruptible4(pullL).pipe(ensuring3(inherit), forkIn2(scope5));
          const rightFiber = interruptible4(pullR).pipe(ensuring3(inherit), forkIn2(scope5));
          return zipWith9(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
        })).pipe(flatMap14(go), embedInput(input));
      });
    }
    return unwrapScopedWith(merge9);
  });
  orDieWith3 = /* @__PURE__ */ dual(2, (self, f) => catchAll5(self, (e) => failCauseSync6(() => die5(f(e)))));
  orElse8 = /* @__PURE__ */ dual(2, (self, that) => catchAll5(self, that));
  pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend5(() => {
    let channelException = undefined;
    const reader = readWith({
      onInput: (outElem) => flatMap14(write(outElem), () => reader),
      onFailure: (outErr) => {
        channelException = ChannelException(outErr);
        return failCause11(die5(channelException));
      },
      onDone: succeedNow
    });
    const writer = readWithCause({
      onInput: (outElem) => pipe(write(outElem), flatMap14(() => writer)),
      onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail12(cause3.defect.error) : failCause11(cause3),
      onDone: succeedNow
    });
    return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
  }));
  toPullIn = /* @__PURE__ */ dual(2, (self, scope5) => zip7(sync5(() => new ChannelExecutor(self, undefined, identity)), runtime3()).pipe(tap4(([executor, runtime4]) => addFinalizerExit(scope5, (exit3) => {
    const finalizer = executor.close(exit3);
    return finalizer !== undefined ? provide2(finalizer, runtime4) : _void;
  })), uninterruptible2, map17(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
  zip8 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? mergeWith2(self, {
    other: that,
    onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip4(exit1, exit22))),
    onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip4(exit1, exit22)))
  }) : flatMap14(self, (a) => map19(that, (b) => [a, b])));
  zipLeft6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map19(zip8(self, that, {
    concurrent: true
  }), (tuple4) => tuple4[0]) : flatMap14(self, (z) => as6(that, z)));
  zipRight7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map19(zip8(self, that, {
    concurrent: true
  }), (tuple4) => tuple4[1]) : flatMap14(self, () => that));
  ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
});

// ../../node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2, sinkVariance2, SinkImpl, isSink = (u) => hasProperty(u, SinkTypeId2), suspend6 = (evaluate2) => new SinkImpl(suspend5(() => toChannel(evaluate2()))), collectAll = () => new SinkImpl(collectAllLoop(empty5())), collectAllLoop = (acc) => readWithCause({
  onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll2(chunk2))),
  onFailure: failCause11,
  onDone: () => succeed12(acc)
}), collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty5()))), collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk2) => {
    const [collected, leftovers] = splitAt2(chunk2, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed12(appendAll2(acc, collected));
    }
    return flatMap14(write(leftovers), () => succeed12(appendAll2(acc, collected)));
  },
  onFailure: failCause11,
  onDone: () => succeed12(acc)
}), collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map19(([chunks, z]) => [z, flatten4(chunks)]))), drain2, fail13 = (e) => new SinkImpl(fail12(e)), fold = (s, contFn, f) => suspend6(() => new SinkImpl(foldReader(s, contFn, f))), foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as6(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
}, foldChunkSplit = (s, chunk2, contFn, f, index, length3) => {
  if (index === length3) {
    return [s, empty5()];
  }
  const s1 = f(s, pipe(chunk2, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk2, contFn, f, index + 1, length3);
  }
  return [s1, pipe(chunk2, drop2(index + 1))];
}, foldSink, foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f))), foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
}, foldEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f))), foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap14(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover) => pipe(write(leftover), as6(nextS))
    })))),
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
}, foldChunkSplitEffect = (s, chunk2, contFn, f) => foldChunkSplitEffectInternal(s, chunk2, 0, chunk2.length, contFn, f), foldChunkSplitEffectInternal = (s, chunk2, index, length3, contFn, f) => {
  if (index === length3) {
    return succeed10([s, none2()]);
  }
  return pipe(f(s, pipe(chunk2, unsafeGet4(index))), flatMap12((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk2, index + 1, length3, contFn, f) : succeed10([s1, some2(pipe(chunk2, drop2(index + 1)))])));
}, foldLeftChunks = (s, f) => foldChunks(s, constTrue, f), flatMap15, forEach10 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach9(input, (v) => f(v), {
      discard: true
    })), flatMap14(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap14(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
}, forEachWhileReader = (f, input, index, length3, cont) => {
  if (index === length3) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet4(index)))), flatMap14((bool) => bool ? forEachWhileReader(f, input, index + 1, length3, cont) : write(pipe(input, drop2(index)))), catchAll5((error) => pipe(write(pipe(input, drop2(index))), zipRight7(fail12(error)))));
}, fromChannel = (channel) => new SinkImpl(channel), fromEffect7 = (effect3) => new SinkImpl(fromEffect5(effect3)), head5 = () => fold(none2(), isNone2, (option3, input) => match2(option3, {
  onNone: () => some2(input),
  onSome: () => option3
})), last4 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s)), map20, raceWith3, sum2, toChannel = (self) => isEffect2(self) ? toChannel(fromEffect7(self)) : self.channel, unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map17((sink) => toChannel(sink))))), zipRight8, zipWith11, count2, mkString;
var init_sink = __esm(() => {
  init_Array();
  init_Cause();
  init_Chunk();
  init_Clock();
  init_Duration();
  init_Effect();
  init_Either();
  init_Exit();
  init_Function();
  init_HashMap();
  init_HashSet();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_PubSub();
  init_Queue();
  init_Ref();
  init_Scope();
  init_channel();
  init_mergeDecision();
  init_core_stream();
  SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
  sinkVariance2 = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };
  SinkImpl = class SinkImpl {
    channel;
    [SinkTypeId2] = sinkVariance2;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
  foldSink = /* @__PURE__ */ dual(2, (self, options) => {
    const newChannel = pipe(toChannel(self), collectElements, foldChannel({
      onFailure: (error) => toChannel(options.onFailure(error)),
      onSuccess: ([leftovers, z]) => suspend5(() => {
        const leftoversRef = {
          ref: pipe(leftovers, filter3(isNonEmpty2))
        };
        const refReader = pipe(sync7(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty5();
          return ref;
        }), flatMap14((chunk2) => writeChunk(chunk2)));
        const passthrough4 = identityChannel();
        const continuationSink = pipe(refReader, zipRight7(passthrough4), pipeTo(toChannel(options.onSuccess(z))));
        return flatMap14(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed12(leftoversRef.ref), flatMap14(writeChunk), zipRight7(writeChunk(newLeftovers)), as6(z1)));
      })
    }));
    return new SinkImpl(newChannel);
  });
  flatMap15 = /* @__PURE__ */ dual(2, (self, f) => foldSink(self, {
    onFailure: fail13,
    onSuccess: f
  }));
  map20 = /* @__PURE__ */ dual(2, (self, f) => {
    return new SinkImpl(pipe(toChannel(self), map19(f)));
  });
  raceWith3 = /* @__PURE__ */ dual(2, (self, options) => {
    function race3(scope5) {
      return gen3(function* () {
        const pubsub = yield* bounded4(options?.capacity ?? 16);
        const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
        const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
        const reader = toPubSub(pubsub);
        const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft6(fromEffect5(shutdown4(subscription1))), mergeWith2({
          other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft6(fromEffect5(shutdown4(subscription2)))),
          onSelfDone: options.onSelfDone,
          onOtherDone: options.onOtherDone
        }));
        const racedChannel = mergeWith2(reader, {
          other: writer,
          onSelfDone: () => Await(identity),
          onOtherDone: (exit3) => Done3(exit3)
        });
        return new SinkImpl(racedChannel);
      });
    }
    return unwrapScopedWith2(race3);
  });
  sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + reduce3(chunk2, 0, (s, a) => s + a));
  zipRight8 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, options) => zipWith11(self, that, (_, z2) => z2, options));
  zipWith11 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, f, options) => options?.concurrent ? raceWith3(self, {
    other: that,
    onSelfDone: match6({
      onFailure: (cause3) => Done3(failCause9(cause3)),
      onSuccess: (leftZ) => Await(match6({
        onFailure: failCause9,
        onSuccess: (rightZ) => succeed10(f(leftZ, rightZ))
      }))
    }),
    onOtherDone: match6({
      onFailure: (cause3) => Done3(failCause9(cause3)),
      onSuccess: (rightZ) => Await(match6({
        onFailure: failCause9,
        onSuccess: (leftZ) => succeed10(f(leftZ, rightZ))
      }))
    })
  }) : flatMap15(self, (z) => map20(that, (z2) => f(z, z2))));
  count2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + chunk2.length);
  mkString = /* @__PURE__ */ suspend6(() => {
    const strings = [];
    return pipe(foldLeftChunks(undefined, (_, elems) => map4(elems, (elem) => {
      strings.push(String(elem));
    })), map20(() => strings.join("")));
  });
});

// ../../node_modules/effect/dist/esm/MergeDecision.js
var Done4, Await2;
var init_MergeDecision = __esm(() => {
  init_mergeDecision();
  Done4 = Done3;
  Await2 = Await;
});

// ../../node_modules/effect/dist/esm/internal/rcRef.js
var TypeId21, stateEmpty2, stateClosed, variance8, RcRefImpl, make48 = (options) => withFiberRuntime((fiber) => {
  const context5 = fiber.getFiberRef(currentContext);
  const scope5 = get3(context5, scopeTag);
  const ref = new RcRefImpl(options.acquire, context5, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : undefined);
  return as2(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_2;
    ref.state = stateClosed;
    return close2;
  }))), ref);
}), get14 = (self_) => {
  const self = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as2(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo3("scope"), bind3("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope5)))), map10(({
          scope: scope5,
          value
        }) => {
          const state = {
            _tag: "Acquired",
            value,
            scope: scope5,
            fiber: undefined,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo3("state"), bind3("scope", () => scopeTag), tap2(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_2;
    }
    if (self.idleTimeToLive === undefined) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_2;
    })), ensuring(sync(() => {
      state.fiber = undefined;
    })), forkIn(self.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map10(({
    state
  }) => state.value));
};
var init_rcRef = __esm(() => {
  init_Context();
  init_Duration();
  init_Effectable();
  init_Function();
  init_Readable();
  init_core_effect();
  init_core();
  init_circular();
  init_fiberRuntime();
  TypeId21 = /* @__PURE__ */ Symbol.for("effect/RcRef");
  stateEmpty2 = {
    _tag: "Empty"
  };
  stateClosed = {
    _tag: "Closed"
  };
  variance8 = {
    _A: identity,
    _E: identity
  };
  RcRefImpl = class RcRefImpl extends Class {
    acquire;
    context;
    scope;
    idleTimeToLive;
    [TypeId21] = variance8;
    [TypeId14] = TypeId14;
    state = stateEmpty2;
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
    constructor(acquire, context5, scope5, idleTimeToLive) {
      super();
      this.acquire = acquire;
      this.context = context5;
      this.scope = scope5;
      this.idleTimeToLive = idleTimeToLive;
      this.get = get14(this);
    }
    get;
    commit() {
      return this.get;
    }
  };
});

// ../../node_modules/effect/dist/esm/RcRef.js
var make49, get15;
var init_RcRef = __esm(() => {
  init_rcRef();
  make49 = make48;
  get15 = get14;
});

// ../../node_modules/effect/dist/esm/Runtime.js
var runFork3, runPromiseExit2, defaultRuntime2;
var init_Runtime = __esm(() => {
  init_runtime();
  runFork3 = unsafeFork2;
  runPromiseExit2 = unsafeRunPromiseExit;
  defaultRuntime2 = defaultRuntime;
});

// ../../node_modules/effect/dist/esm/Schedule.js
var exports_Schedule = {};
__export(exports_Schedule, {
  zipWith: () => zipWith12,
  zipRight: () => zipRight9,
  zipLeft: () => zipLeft7,
  windowed: () => windowed2,
  whileOutputEffect: () => whileOutputEffect2,
  whileOutput: () => whileOutput2,
  whileInputEffect: () => whileInputEffect2,
  whileInput: () => whileInput2,
  upTo: () => upTo2,
  untilOutputEffect: () => untilOutputEffect2,
  untilOutput: () => untilOutput2,
  untilInputEffect: () => untilInputEffect2,
  untilInput: () => untilInput2,
  unionWith: () => unionWith3,
  union: () => union11,
  unfold: () => unfold3,
  tapOutput: () => tapOutput2,
  tapInput: () => tapInput2,
  sync: () => sync8,
  succeed: () => succeed13,
  stop: () => stop2,
  spaced: () => spaced2,
  secondOfMinute: () => secondOfMinute2,
  run: () => run3,
  resetWhen: () => resetWhen2,
  resetAfter: () => resetAfter2,
  repetitions: () => repetitions2,
  repeatForever: () => repeatForever,
  reduceEffect: () => reduceEffect4,
  reduce: () => reduce15,
  recurs: () => recurs2,
  recurWhileEffect: () => recurWhileEffect2,
  recurWhile: () => recurWhile2,
  recurUpTo: () => recurUpTo2,
  recurUntilOption: () => recurUntilOption2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntil: () => recurUntil2,
  provideService: () => provideService5,
  provideContext: () => provideContext5,
  passthrough: () => passthrough4,
  once: () => once4,
  onDecision: () => onDecision2,
  modifyDelayEffect: () => modifyDelayEffect2,
  modifyDelay: () => modifyDelay2,
  minuteOfHour: () => minuteOfHour2,
  mapInputEffect: () => mapInputEffect2,
  mapInputContext: () => mapInputContext4,
  mapInput: () => mapInput4,
  mapEffect: () => mapEffect5,
  mapBothEffect: () => mapBothEffect2,
  mapBoth: () => mapBoth5,
  map: () => map21,
  makeWithState: () => makeWithState2,
  linear: () => linear2,
  jitteredWith: () => jitteredWith2,
  jittered: () => jittered2,
  isSchedule: () => isSchedule2,
  intersectWith: () => intersectWith2,
  intersect: () => intersect6,
  identity: () => identity3,
  hourOfDay: () => hourOfDay2,
  fromFunction: () => fromFunction4,
  fromDelays: () => fromDelays2,
  fromDelay: () => fromDelay2,
  forever: () => forever4,
  fixed: () => fixed2,
  fibonacci: () => fibonacci2,
  exponential: () => exponential3,
  ensuring: () => ensuring5,
  elapsed: () => elapsed2,
  eitherWith: () => eitherWith2,
  either: () => either5,
  duration: () => duration2,
  driver: () => driver2,
  delays: () => delays2,
  delayedSchedule: () => delayedSchedule2,
  delayedEffect: () => delayedEffect2,
  delayed: () => delayed2,
  dayOfWeek: () => dayOfWeek2,
  dayOfMonth: () => dayOfMonth2,
  cron: () => cron2,
  count: () => count3,
  compose: () => compose2,
  collectWhileEffect: () => collectWhileEffect2,
  collectWhile: () => collectWhile2,
  collectUntilEffect: () => collectUntilEffect2,
  collectUntil: () => collectUntil2,
  collectAllOutputs: () => collectAllOutputs2,
  collectAllInputs: () => collectAllInputs2,
  checkEffect: () => checkEffect2,
  check: () => check2,
  bothInOut: () => bothInOut2,
  asVoid: () => asVoid5,
  as: () => as7,
  andThenEither: () => andThenEither2,
  andThen: () => andThen7,
  addDelayEffect: () => addDelayEffect2,
  addDelay: () => addDelay2,
  ScheduleTypeId: () => ScheduleTypeId2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  CurrentIterationMetadata: () => CurrentIterationMetadata2
});
var ScheduleTypeId2, ScheduleDriverTypeId2, makeWithState2, isSchedule2, addDelay2, addDelayEffect2, andThen7, andThenEither2, as7, asVoid5, bothInOut2, check2, checkEffect2, collectAllInputs2, collectAllOutputs2, collectUntil2, collectUntilEffect2, collectWhile2, collectWhileEffect2, compose2, mapInput4, mapInputEffect2, mapInputContext4, count3, cron2, secondOfMinute2, minuteOfHour2, hourOfDay2, dayOfMonth2, dayOfWeek2, delayed2, delayedEffect2, delayedSchedule2, delays2, mapBoth5, mapBothEffect2, driver2, duration2, either5, eitherWith2, elapsed2, ensuring5, exponential3, fibonacci2, fixed2, forever4, fromDelay2, fromDelays2, fromFunction4, identity3, passthrough4, intersect6, intersectWith2, jittered2, jitteredWith2, linear2, map21, mapEffect5, modifyDelay2, modifyDelayEffect2, onDecision2, once4, provideContext5, provideService5, recurUntil2, recurUntilEffect2, recurUntilOption2, recurUpTo2, recurWhile2, recurWhileEffect2, recurs2, reduce15, reduceEffect4, repeatForever, repetitions2, resetAfter2, resetWhen2, run3, spaced2, stop2, succeed13, sync8, tapInput2, tapOutput2, unfold3, union11, unionWith3, untilInput2, untilInputEffect2, untilOutput2, untilOutputEffect2, upTo2, whileInput2, whileInputEffect2, whileOutput2, whileOutputEffect2, windowed2, zipLeft7, zipRight9, zipWith12, CurrentIterationMetadata2;
var init_Schedule = __esm(() => {
  init_schedule();
  ScheduleTypeId2 = ScheduleTypeId;
  ScheduleDriverTypeId2 = ScheduleDriverTypeId;
  makeWithState2 = makeWithState;
  isSchedule2 = isSchedule;
  addDelay2 = addDelay;
  addDelayEffect2 = addDelayEffect;
  andThen7 = andThen5;
  andThenEither2 = andThenEither;
  as7 = as4;
  asVoid5 = asVoid3;
  bothInOut2 = bothInOut;
  check2 = check;
  checkEffect2 = checkEffect;
  collectAllInputs2 = collectAllInputs;
  collectAllOutputs2 = collectAllOutputs;
  collectUntil2 = collectUntil;
  collectUntilEffect2 = collectUntilEffect;
  collectWhile2 = collectWhile;
  collectWhileEffect2 = collectWhileEffect;
  compose2 = compose;
  mapInput4 = mapInput3;
  mapInputEffect2 = mapInputEffect;
  mapInputContext4 = mapInputContext2;
  count3 = count;
  cron2 = cron;
  secondOfMinute2 = secondOfMinute;
  minuteOfHour2 = minuteOfHour;
  hourOfDay2 = hourOfDay;
  dayOfMonth2 = dayOfMonth;
  dayOfWeek2 = dayOfWeek;
  delayed2 = delayed;
  delayedEffect2 = delayedEffect;
  delayedSchedule2 = delayedSchedule;
  delays2 = delays;
  mapBoth5 = mapBoth3;
  mapBothEffect2 = mapBothEffect;
  driver2 = driver;
  duration2 = duration;
  either5 = either3;
  eitherWith2 = eitherWith;
  elapsed2 = elapsed;
  ensuring5 = ensuring2;
  exponential3 = exponential2;
  fibonacci2 = fibonacci;
  fixed2 = fixed;
  forever4 = forever2;
  fromDelay2 = fromDelay;
  fromDelays2 = fromDelays;
  fromFunction4 = fromFunction2;
  identity3 = identity2;
  passthrough4 = passthrough2;
  intersect6 = intersect5;
  intersectWith2 = intersectWith;
  jittered2 = jittered;
  jitteredWith2 = jitteredWith;
  linear2 = linear;
  map21 = map16;
  mapEffect5 = mapEffect3;
  modifyDelay2 = modifyDelay;
  modifyDelayEffect2 = modifyDelayEffect;
  onDecision2 = onDecision;
  once4 = once2;
  provideContext5 = provideContext3;
  provideService5 = provideService2;
  recurUntil2 = recurUntil;
  recurUntilEffect2 = recurUntilEffect;
  recurUntilOption2 = recurUntilOption;
  recurUpTo2 = recurUpTo;
  recurWhile2 = recurWhile;
  recurWhileEffect2 = recurWhileEffect;
  recurs2 = recurs;
  reduce15 = reduce13;
  reduceEffect4 = reduceEffect2;
  repeatForever = forever2;
  repetitions2 = repetitions;
  resetAfter2 = resetAfter;
  resetWhen2 = resetWhen;
  run3 = run;
  spaced2 = spaced;
  stop2 = stop;
  succeed13 = succeed8;
  sync8 = sync4;
  tapInput2 = tapInput;
  tapOutput2 = tapOutput;
  unfold3 = unfold2;
  union11 = union10;
  unionWith3 = unionWith2;
  untilInput2 = untilInput;
  untilInputEffect2 = untilInputEffect;
  untilOutput2 = untilOutput;
  untilOutputEffect2 = untilOutputEffect;
  upTo2 = upTo;
  whileInput2 = whileInput;
  whileInputEffect2 = whileInputEffect;
  whileOutput2 = whileOutput;
  whileOutputEffect2 = whileOutputEffect;
  windowed2 = windowed;
  zipLeft7 = zipLeft4;
  zipRight9 = zipRight5;
  zipWith12 = zipWith8;
  CurrentIterationMetadata2 = CurrentIterationMetadata;
});

// ../../node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left", OP_RIGHT = "Right", OP_BOTH = "Both", OP_EITHER = "Either";

// ../../node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left, Right, Both, Either, fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
var init_haltStrategy = __esm(() => {
  init_Function();
  Left = {
    _tag: OP_LEFT
  };
  Right = {
    _tag: OP_RIGHT
  };
  Both = {
    _tag: OP_BOTH
  };
  Either = {
    _tag: OP_EITHER
  };
});

// ../../node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2;
var init_StreamHaltStrategy = __esm(() => {
  init_haltStrategy();
  Both2 = Both;
});

// ../../node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// ../../node_modules/effect/dist/esm/internal/stm/entry.js
var make50 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
}), unsafeGet7 = (self) => {
  return self.newValue;
}, unsafeSet = (self, value) => {
  self.isChanged = true;
  self.newValue = value;
}, commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
}, isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
}, isChanged = (self) => {
  return self.isChanged;
};
var init_entry = () => {};

// ../../node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid", JournalAnalysisReadWrite = "ReadWrite", JournalAnalysisReadOnly = "ReadOnly", commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
}, analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
}, collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
}, execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
}, addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};
var init_journal = __esm(() => {
  init_entry();
});

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime", OP_ON_FAILURE2 = "OnFailure", OP_ON_RETRY = "OnRetry", OP_ON_SUCCESS2 = "OnSuccess", OP_PROVIDE3 = "Provide", OP_SYNC2 = "Sync", OP_SUCCEED2 = "Succeed", OP_RETRY = "Retry", OP_FAIL4 = "Fail", OP_DIE2 = "Die", OP_INTERRUPT2 = "Interrupt";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail", OP_DIE3 = "Die", OP_INTERRUPT3 = "Interrupt", OP_SUCCEED3 = "Succeed", OP_RETRY2 = "Retry";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done", OP_SUSPEND3 = "Suspend";

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done", OP_INTERRUPTED = "Interrupted", OP_RUNNING2 = "Running";

// ../../node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State", STMStateTypeId, isSTMState = (u) => hasProperty(u, STMStateTypeId), isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
}, isDone6 = (self) => {
  return self._tag === OP_DONE6;
}, done9 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
}, interruptedHash, interrupted3, runningHash, running3, fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done9(die4(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};
var init_stmState = __esm(() => {
  init_Equal();
  init_Exit();
  init_Function();
  init_Hash();
  init_Predicate();
  STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
  interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
  interrupted3 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_INTERRUPTED,
    [symbol]() {
      return interruptedHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_INTERRUPTED;
    }
  };
  runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
  running3 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_RUNNING2,
    [symbol]() {
      return runningHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_RUNNING2;
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit", TExitTypeId, variance9, isExit2 = (u) => hasProperty(u, TExitTypeId), isSuccess4 = (self) => {
  return self._tag === OP_SUCCEED3;
}, isRetry = (self) => {
  return self._tag === OP_RETRY2;
}, fail14 = (error) => ({
  [TExitTypeId]: variance9,
  _tag: OP_FAIL5,
  error,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
  }
}), die9 = (defect) => ({
  [TExitTypeId]: variance9,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
}), interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance9,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
}), succeed14 = (value) => ({
  [TExitTypeId]: variance9,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
}), retryHash, retry4;
var init_tExit = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Predicate();
  TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
  variance9 = {
    _A: (_) => _,
    _E: (_) => _
  };
  retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
  retry4 = {
    [TExitTypeId]: variance9,
    _tag: OP_RETRY2,
    [symbol]() {
      return retryHash;
    },
    [symbol2](that) {
      return isExit2(that) && isRetry(that);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done10 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
}, suspend7 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};
var init_tryCommit = () => {};

// ../../node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter, make51 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};
var init_txnId = __esm(() => {
  txnCounter = {
    ref: 0
  };
});

// ../../node_modules/effect/dist/esm/internal/stm/core.js
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self, journal, fiberId3, r0) {
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail15(current.left);
              break;
            }
            case "None": {
              curr = fail15(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed15(current.right);
              break;
            }
            case "Some": {
              curr = succeed15(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die9(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail14(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring6(sync9(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed14(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die10(e);
      }
    }
    return exit3;
  }
}
var STMSymbolKey2 = "effect/STM", STMTypeId2, stmVariance, STMPrimitive, unsafeAtomically = (self, onDone, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make51();
      const state2 = {
        value: running3
      };
      const effect3 = async((k) => tryCommitAsync(fiberId3, self, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause9(cause3);
      })));
    }
  }
}), tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail6(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die5(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
}, tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail6(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die5(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
}, tryCommitAsync = (fiberId3, self, txnId, state, context5, scheduler, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self, txnId, state, context5, scheduler, priority, k));
        break;
      }
    }
  }
}, completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit3);
}, completeTryCommit = (exit3, k) => {
  k(exit3);
}, catchAll6, die10 = (defect) => dieSync6(() => defect), dieSync6 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
}, effect3 = (f) => withSTMRuntime((_) => succeed15(f(_.journal, _.fiberId, _.getEnv()))), ensuring6, fail15 = (error) => failSync7(() => error), failSync7 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
}, flatMap16, matchSTM, withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
}, interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
}, map22, retry5, succeed15 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
}, sync9 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
}, zipRight10, zipWith13;
var init_core2 = __esm(() => {
  init_Cause();
  init_Context();
  init_Effect();
  init_Either();
  init_Equal();
  init_Exit();
  init_FiberRef();
  init_Function();
  init_Hash();
  init_Pipeable();
  init_Predicate();
  init_Utils();
  init_core_stream();
  init_core();
  init_effectable();
  init_singleShotGen();
  init_sink();
  init_journal();
  init_stmState();
  init_tExit();
  init_tryCommit();
  init_txnId();
  STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
  stmVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };
  STMPrimitive = class STMPrimitive {
    effect_instruction_i0;
    _op = OP_COMMIT;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    [EffectTypeId3];
    [StreamTypeId];
    [SinkTypeId2];
    [ChannelTypeId2];
    get [STMTypeId2]() {
      return stmVariance;
    }
    constructor(effect_instruction_i0) {
      this.effect_instruction_i0 = effect_instruction_i0;
      this[EffectTypeId3] = effectVariance;
      this[StreamTypeId] = stmVariance;
      this[SinkTypeId2] = stmVariance;
      this[ChannelTypeId2] = stmVariance;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
    commit() {
      return unsafeAtomically(this, constVoid, constVoid);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  catchAll6 = /* @__PURE__ */ dual(2, (self, f) => {
    const stm = new STMPrimitive(OP_ON_FAILURE2);
    stm.effect_instruction_i1 = self;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  ensuring6 = /* @__PURE__ */ dual(2, (self, finalizer) => matchSTM(self, {
    onFailure: (e) => zipRight10(finalizer, fail15(e)),
    onSuccess: (a) => zipRight10(finalizer, succeed15(a))
  }));
  flatMap16 = /* @__PURE__ */ dual(2, (self, f) => {
    const stm = new STMPrimitive(OP_ON_SUCCESS2);
    stm.effect_instruction_i1 = self;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  matchSTM = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => pipe(self, map22(right2), catchAll6((e) => pipe(onFailure(e), map22(left2))), flatMap16((either6) => {
    switch (either6._tag) {
      case "Left": {
        return succeed15(either6.left);
      }
      case "Right": {
        return onSuccess(either6.right);
      }
    }
  })));
  map22 = /* @__PURE__ */ dual(2, (self, f) => pipe(self, flatMap16((a) => sync9(() => f(a)))));
  retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
  zipRight10 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, flatMap16(() => that)));
  zipWith13 = /* @__PURE__ */ dual(3, (self, that, f) => pipe(self, flatMap16((a) => pipe(that, map22((b) => f(a, b))))));
});

// ../../node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure", OP_DROPPING_STRATEGY = "Dropping", OP_SLIDING_STRATEGY = "Sliding";

// ../../node_modules/effect/dist/esm/internal/stm/stm.js
var as8, flatten13 = (self) => flatMap16(self, identity), forEach11, all8 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach11(input, identity, options);
  } else if (options?.discard) {
    return forEach11(Object.values(input), identity, options);
  }
  return map22(forEach11(Object.entries(input), ([_, e]) => map22(e, (a) => [_, a])), (values4) => {
    const res = {};
    for (const [k, v] of values4) {
      res[k] = v;
    }
    return res;
  });
}, suspend8 = (evaluate2) => flatten13(sync9(evaluate2)), tap6, void_8;
var init_stm = __esm(() => {
  init_Array();
  init_Cause();
  init_Chunk();
  init_Context();
  init_Effect();
  init_Either();
  init_Exit();
  init_Function();
  init_Option();
  init_Predicate();
  init_Utils();
  init_core();
  init_core2();
  init_journal();
  init_stmState();
  as8 = /* @__PURE__ */ dual(2, (self, value) => pipe(self, map22(() => value)));
  forEach11 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
    if (options?.discard) {
      return pipe(sync9(() => iterable[Symbol.iterator]()), flatMap16((iterator) => {
        const loop3 = suspend8(() => {
          const next4 = iterator.next();
          if (next4.done) {
            return void_8;
          }
          return pipe(f(next4.value), flatMap16(() => loop3));
        });
        return loop3;
      }));
    }
    return suspend8(() => fromIterable2(iterable).reduce((acc, curr) => zipWith13(acc, f(curr), (array5, elem) => {
      array5.push(elem);
      return array5;
    }), succeed15([])));
  });
  tap6 = /* @__PURE__ */ dual(2, (self, f) => flatMap16(self, (a) => as8(f(a), a)));
  void_8 = /* @__PURE__ */ succeed15(undefined);
});

// ../../node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef", TRefTypeId, tRefVariance, TRefImpl, make52 = (value) => effect3((journal) => {
  const ref = new TRefImpl(value);
  journal.set(ref, make50(ref, true));
  return ref;
}), get16 = (self) => self.modify((a) => [a, a]), set8, getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make50(self, false);
  journal.set(self, entry);
  return entry;
}, unsafeGet8, unsafeSet2;
var init_tRef = __esm(() => {
  init_Function();
  init_Option();
  init_Pipeable();
  init_core2();
  init_entry();
  TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
  tRefVariance = {
    _A: (_) => _
  };
  TRefImpl = class TRefImpl {
    [TRefTypeId] = tRefVariance;
    todos;
    versioned;
    constructor(value) {
      this.versioned = new Versioned(value);
      this.todos = new Map;
    }
    modify(f) {
      return effect3((journal) => {
        const entry = getOrMakeEntry(this, journal);
        const [retValue, newValue] = f(unsafeGet7(entry));
        unsafeSet(entry, newValue);
        return retValue;
      });
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  set8 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [undefined, value]));
  unsafeGet8 = /* @__PURE__ */ dual(2, (self, journal) => unsafeGet7(getOrMakeEntry(self, journal)));
  unsafeSet2 = /* @__PURE__ */ dual(3, (self, value, journal) => {
    const entry = getOrMakeEntry(self, journal);
    unsafeSet(entry, value);
    return;
  });
});

// ../../node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue", TEnqueueTypeId, TDequeueSymbolKey = "effect/TQueue/TDequeue", TDequeueTypeId, tDequeueVariance, tEnqueueVariance, TQueueImpl, isShutdown5 = (self) => self.isShutdown, shutdown5 = (self) => self.shutdown, take4 = (self) => self.take;
var init_tQueue = __esm(() => {
  init_Array();
  init_Chunk();
  init_Function();
  init_Option();
  init_Predicate();
  init_core2();
  init_stm();
  init_tRef();
  TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
  TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
  tDequeueVariance = {
    _Out: (_) => _
  };
  tEnqueueVariance = {
    _In: (_) => _
  };
  TQueueImpl = class TQueueImpl {
    ref;
    requestedCapacity;
    strategy;
    [TDequeueTypeId] = tDequeueVariance;
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(ref, requestedCapacity, strategy) {
      this.ref = ref;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
    }
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet8(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed15(queue.length);
    });
    isFull = /* @__PURE__ */ map22(this.size, (size16) => size16 === this.requestedCapacity);
    isEmpty = /* @__PURE__ */ map22(this.size, (size16) => size16 === 0);
    shutdown = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      unsafeSet2(this.ref, undefined, runtime4.journal);
      return void_8;
    });
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const queue = unsafeGet8(this.ref, journal);
      return queue === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown5) => isShutdown5 ? void_8 : retry5);
    offer(value) {
      return withSTMRuntime((runtime4) => {
        const queue = pipe(this.ref, unsafeGet8(runtime4.journal));
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        if (queue.length < this.requestedCapacity) {
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime4.journal);
          return succeed15(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed15(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (queue.length === 0) {
              return succeed15(true);
            }
            queue.shift();
            queue.push(value);
            unsafeSet2(this.ref, queue, runtime4.journal);
            return succeed15(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return withSTMRuntime((runtime4) => {
        const as9 = Array.from(iterable);
        const queue = unsafeGet8(this.ref, runtime4.journal);
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        if (queue.length + as9.length <= this.requestedCapacity) {
          unsafeSet2(this.ref, [...queue, ...as9], runtime4.journal);
          return succeed15(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            const forQueue = as9.slice(0, this.requestedCapacity - queue.length);
            unsafeSet2(this.ref, [...queue, ...forQueue], runtime4.journal);
            return succeed15(false);
          }
          case OP_SLIDING_STRATEGY: {
            const forQueue = as9.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime4.journal);
            return succeed15(true);
          }
        }
      });
    }
    peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet8(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      return succeed15(queue[0]);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet8(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed15(fromNullable(queue[0]));
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet8(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      const dequeued = queue.shift();
      unsafeSet2(this.ref, queue, runtime4.journal);
      return succeed15(dequeued);
    });
    takeAll = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet8(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      unsafeSet2(this.ref, [], runtime4.journal);
      return succeed15(queue);
    });
    takeUpTo(max5) {
      return withSTMRuntime((runtime4) => {
        const queue = unsafeGet8(this.ref, runtime4.journal);
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
        unsafeSet2(this.ref, Array.from(remaining), runtime4.journal);
        return succeed15(Array.from(toTake));
      });
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub", TPubSubTypeId, AbsentValue2, makeNode2 = (head6, subscribers, tail2) => ({
  head: head6,
  subscribers,
  tail: tail2
}), TPubSubImpl, TPubSubSubscriptionImpl, makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap16((currentPublisherTail) => pipe(all8([make52(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap6(([_, currentSubscriberCount]) => pipe(subscriberCount, set8(currentSubscriberCount + 1))), tap6(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set8(pipe(currentSubscribers, add4(subscriberHead))))), map22(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers))))), subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers), subscribeScoped = (self) => acquireRelease2(subscribe3(self), (dequeue) => shutdown5(dequeue));
var init_tPubSub = __esm(() => {
  init_Array();
  init_Effect();
  init_Function();
  init_HashSet();
  init_Option();
  init_core2();
  init_stm();
  init_tQueue();
  init_tRef();
  TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
  AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
  TPubSubImpl = class TPubSubImpl {
    pubsubSize;
    publisherHead;
    publisherTail;
    requestedCapacity;
    strategy;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = {
      _A: (_) => _
    };
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.publisherTail = publisherTail;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
      return currentPublisherTail === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown6) => isShutdown6 ? void_8 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime4.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed15(unsafeGet8(this.pubsubSize, runtime4.journal));
    });
    isEmpty = /* @__PURE__ */ map22(this.size, (size16) => size16 === 0);
    isFull = /* @__PURE__ */ map22(this.size, (size16) => size16 === this.capacity());
    offer(value) {
      return withSTMRuntime((runtime4) => {
        const currentPublisherTail = unsafeGet8(this.publisherTail, runtime4.journal);
        if (currentPublisherTail === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime4.journal);
        if (currentSubscriberCount === 0) {
          return succeed15(true);
        }
        const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime4.journal);
        if (currentPubSubSize < this.requestedCapacity) {
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
          unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime4.journal);
          return succeed15(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed15(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (this.requestedCapacity > 0) {
              let currentPublisherHead = unsafeGet8(this.publisherHead, runtime4.journal);
              let loop3 = true;
              while (loop3) {
                const node = unsafeGet8(currentPublisherHead, runtime4.journal);
                if (node === undefined) {
                  return retry5;
                }
                const head6 = node.head;
                const tail2 = node.tail;
                if (head6 !== AbsentValue2) {
                  const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                  unsafeSet2(currentPublisherHead, updatedNode2, runtime4.journal);
                  unsafeSet2(this.publisherHead, tail2, runtime4.journal);
                  loop3 = false;
                } else {
                  currentPublisherHead = tail2;
                }
              }
            }
            const updatedPublisherTail = new TRefImpl(undefined);
            const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
            unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
            unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
            return succeed15(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return map22(forEach11(iterable, (a) => this.offer(a)), every(identity));
    }
    shutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
      if (currentPublisherTail !== undefined) {
        unsafeSet2(this.publisherTail, undefined, journal);
        const currentSubscribers = unsafeGet8(this.subscribers, journal);
        forEach4(currentSubscribers, (subscriber) => {
          unsafeSet2(subscriber, undefined, journal);
        });
        unsafeSet2(this.subscribers, empty8(), journal);
      }
    });
  };
  TPubSubSubscriptionImpl = class TPubSubSubscriptionImpl {
    pubsubSize;
    publisherHead;
    requestedCapacity;
    subscriberHead;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = TPubSubTypeId;
    [TDequeueTypeId] = tDequeueVariance;
    constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.requestedCapacity = requestedCapacity;
      this.subscriberHead = subscriberHead;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
      return currentSubscriberHead === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown6) => isShutdown6 ? void_8 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let loop3 = true;
      let size16 = 0;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail2 = node.tail;
          if (head6 !== AbsentValue2) {
            size16 = size16 + 1;
            if (size16 >= Number.MAX_SAFE_INTEGER) {
              loop3 = false;
            }
          }
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(size16);
    });
    isEmpty = /* @__PURE__ */ map22(this.size, (size16) => size16 === 0);
    isFull = /* @__PURE__ */ map22(this.size, (size16) => size16 === this.capacity());
    peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail2 = node.tail;
        if (head6 !== AbsentValue2) {
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(value);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = none2();
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          value = none2();
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail2 = node.tail;
          if (head6 !== AbsentValue2) {
            value = some2(head6);
            loop3 = false;
          } else {
            currentSubscriberHead = tail2;
          }
        }
      }
      return succeed15(value);
    });
    shutdown = /* @__PURE__ */ effect3((journal) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
      if (currentSubscriberHead !== undefined) {
        unsafeSet2(this.subscriberHead, undefined, journal);
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet8(currentSubscriberHead, journal);
          if (node === undefined) {
            loop3 = false;
          } else {
            const head6 = node.head;
            const tail2 = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size16 = unsafeGet8(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
                unsafeSet2(this.publisherHead, tail2, journal);
                unsafeSet2(this.pubsubSize, size16 - 1, journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail2;
          }
        }
        const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
        unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet2(this.subscribers, remove5(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
      }
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail2 = node.tail;
        if (head6 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size16 = unsafeGet8(this.pubsubSize, runtime4.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail2);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
            unsafeSet2(this.publisherHead, tail2, runtime4.journal);
            unsafeSet2(this.pubsubSize, size16 - 1, runtime4.journal);
          } else {
            const updatedNode = makeNode2(head6, subscribers - 1, tail2);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
          }
          unsafeSet2(this.subscriberHead, tail2, runtime4.journal);
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(value);
    });
    takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
    takeUpTo(max5) {
      return withSTMRuntime((runtime4) => {
        let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime4.journal);
        if (currentSubscriberHead === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const builder = [];
        let n = 0;
        while (n !== max5) {
          const node = unsafeGet8(currentSubscriberHead, runtime4.journal);
          if (node === undefined) {
            n = max5;
          } else {
            const head6 = node.head;
            const tail2 = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size16 = unsafeGet8(this.pubsubSize, runtime4.journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
                unsafeSet2(this.publisherHead, tail2, runtime4.journal);
                unsafeSet2(this.pubsubSize, size16 - 1, runtime4.journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
              }
              builder.push(head6);
              n = n + 1;
            }
            currentSubscriberHead = tail2;
          }
        }
        unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime4.journal);
        return succeed15(builder);
      });
    }
  };
});

// ../../node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2;
var init_TPubSub = __esm(() => {
  init_tPubSub();
  subscribeScoped2 = subscribeScoped;
});

// ../../node_modules/effect/dist/esm/TQueue.js
var isShutdown7, take5;
var init_TQueue = __esm(() => {
  init_tQueue();
  isShutdown7 = isShutdown5;
  take5 = take4;
});

// ../../node_modules/effect/dist/esm/internal/ringBuffer.js
class RingBuffer {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity8) {
    this.capacity = capacity8;
    this.array = Array.from({
      length: capacity8
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? undefined;
  }
  put(value) {
    this.array[this.current] = value;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = undefined;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
}
var init_ringBuffer = __esm(() => {
  init_Chunk();
  init_Function();
  init_Option();
});

// ../../node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted", OP_PREVIOUS = "Previous", OP_CURRENT = "Current", notStarted, previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
}), current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});
var init_debounceState = __esm(() => {
  notStarted = {
    _tag: OP_NOT_STARTED
  };
});

// ../../node_modules/effect/dist/esm/internal/stream/emit.js
var make53 = (emit) => {
  const ops = {
    chunk(as9) {
      return this(succeed10(as9));
    },
    die(defect) {
      return this(die7(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit3) {
      return this(suspend3(() => mapBoth2(exit3, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail10(none2()));
    },
    fail(e) {
      return this(fail10(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth4(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError3(some2)));
    },
    halt(cause3) {
      return this(failCause9(pipe(cause3, map13(some2))));
    },
    single(value) {
      return this(succeed10(of2(value)));
    }
  };
  return Object.assign(emit, ops);
}, makePush = (queue, scheduler) => {
  let finished = false;
  let buffer = [];
  let running4 = false;
  function array5(items) {
    if (finished)
      return false;
    if (items.length <= 50000) {
      buffer.push.apply(buffer, items);
    } else {
      for (let i = 0;i < items.length; i++) {
        buffer.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer.length > 0) {
      queue.unsafeOffer(buffer);
      buffer = [];
    }
  }
  function done11(exit3) {
    if (finished)
      return;
    finished = true;
    if (exit3._tag === "Success") {
      buffer.push(exit3.value);
    }
    flush();
    queue.unsafeOffer(exit3._tag === "Success" ? void_3 : exit3);
  }
  return {
    single(value) {
      if (finished)
        return false;
      buffer.push(value);
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array5,
    chunk(chunk2) {
      return array5(toReadonlyArray(chunk2));
    },
    done: done11,
    end() {
      if (finished)
        return;
      finished = true;
      flush();
      queue.unsafeOffer(void_3);
    },
    halt(cause3) {
      return done11(failCause3(cause3));
    },
    fail(error) {
      return done11(fail4(error));
    },
    die(defect) {
      return done11(die4(defect));
    },
    dieMessage(message) {
      return done11(die4(new Error(message)));
    }
  };
};
var init_emit = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Effect();
  init_Exit();
  init_Function();
  init_Option();
});

// ../../node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId, OP_HANDOFF_STATE_EMPTY = "Empty", OP_HANDOFF_STATE_FULL = "Full", handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
}), handoffStateFull = (value, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value,
  notifyProducer
}), handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
}, handoffVariance, make54 = () => pipe(make19(), flatMap12((deferred) => make29(handoffStateEmpty(deferred))), map17((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
}))), offer5, take6 = (self) => flatMap12(make19(), (deferred) => flatten10(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap12(_await(notifyConsumer), () => take6(self)), state], (value, notifyProducer) => [as5(succeed2(notifyProducer, undefined), value), handoffStateEmpty(deferred)])))));
var init_handoff = __esm(() => {
  init_Deferred();
  init_Effect();
  init_Function();
  init_Option();
  init_Ref();
  HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
  handoffVariance = {
    _A: (_) => _
  };
  offer5 = /* @__PURE__ */ dual(2, (self, value) => {
    return flatMap12(make19(), (deferred) => flatten10(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight6(succeed2(notifyConsumer, undefined), _await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [flatMap12(_await(notifyProducer), () => pipe(self, offer5(value))), state])))));
  });
});

// ../../node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit", OP_HALT = "Halt", OP_END = "End", emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
}), halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
}), end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// ../../node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take", TakeTypeId, takeVariance, TakeImpl, chunk2 = (chunk3) => new TakeImpl(succeed3(chunk3)), done11 = (self) => suspend3(() => self.exit), end4, failCause12 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map13(some2)))), fromPull = (pull) => matchCause3(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause12
  }),
  onSuccess: chunk2
}), match19, of5 = (value) => new TakeImpl(succeed3(of2(value)));
var init_take = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Effect();
  init_Exit();
  init_Function();
  init_Option();
  init_Pipeable();
  TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
  takeVariance = {
    _A: (_) => _,
    _E: (_) => _
  };
  TakeImpl = class TakeImpl {
    exit;
    [TakeTypeId] = takeVariance;
    constructor(exit3) {
      this.exit = exit3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
  match19 = /* @__PURE__ */ dual(2, (self, {
    onEnd,
    onFailure,
    onSuccess
  }) => match6(self.exit, {
    onFailure: (cause3) => match2(flipCauseOption2(cause3), {
      onNone: onEnd,
      onSome: onFailure
    }),
    onSuccess
  }));
});

// ../../node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail10(none2()), failCause13 = (cause3) => mapError3(failCause9(cause3), some2);
var init_pull = __esm(() => {
  init_Chunk();
  init_Effect();
  init_Option();
  init_Queue();
  init_take();
});

// ../../node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd", OP_UPSTREAM_END = "UpstreamEnd", ScheduleEnd, UpstreamEnd;
var init_sinkEndReason = __esm(() => {
  ScheduleEnd = {
    _tag: OP_SCHEDULE_END
  };
  UpstreamEnd = {
    _tag: OP_UPSTREAM_END
  };
});

// ../../node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft", OP_DRAIN_RIGHT = "DrainRight", OP_PULL_BOTH = "PullBoth", OP_PULL_LEFT = "PullLeft", OP_PULL_RIGHT = "PullRight", DrainLeft, DrainRight, PullBoth, PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
}), PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});
var init_zipAllState = __esm(() => {
  DrainLeft = {
    _tag: OP_DRAIN_LEFT
  };
  DrainRight = {
    _tag: OP_DRAIN_RIGHT
  };
  PullBoth = {
    _tag: OP_PULL_BOTH
  };
});

// ../../node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth", OP_PULL_LEFT2 = "PullLet", OP_PULL_RIGHT2 = "PullRight", PullBoth2, PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
}), PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});
var init_zipChunksState = __esm(() => {
  PullBoth2 = {
    _tag: OP_PULL_BOTH2
  };
});

// ../../node_modules/effect/dist/esm/internal/stream.js
class StreamRechunker {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_7;
  }
}
var StreamSymbolKey = "effect/Stream", StreamTypeId2, streamVariance, StreamImpl, isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u), DefaultChunkSize = 4096, accumulate = (self) => chunks(accumulateChunks(self)), accumulateChunks = (self) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next4 = appendAll2(s, input);
      return flatMap14(write(next4), () => accumulator(next4));
    },
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty5())));
}, acquireRelease3 = (acquire, release) => scoped6(acquireRelease2(acquire, release)), aggregate, aggregateWithin, aggregateWithinEither, as9, queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === undefined) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
}, _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap12((output) => runtime3().pipe(flatMap12((runtime4) => sync5(() => {
  const runPromiseExit3 = runPromiseExit2(runtime4);
  const canceler = register(make53((resume2) => fromPull(resume2).pipe(flatMap12((take7) => offer3(output, take7)), asVoid4, runPromiseExit3).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  })));
  return canceler;
})), map17((value) => {
  const loop3 = take3(output).pipe(flatMap12((take7) => done11(take7)), match14({
    onFailure: (maybeError) => fromEffect5(shutdown4(output)).pipe(zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: (error) => fail12(error)
    }))),
    onSuccess: (chunk3) => write(chunk3).pipe(flatMap14(() => loop3))
  }), unwrap);
  return fromChannel2(loop3).pipe(ensuring7(value ?? _void));
}))), unwrapScoped4), asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap12((output) => pipe(runtime3(), flatMap12((runtime4) => pipe(register(make53((k) => pipe(fromPull(k), flatMap12((take7) => offer3(output, take7)), asVoid4, runPromiseExit2(runtime4)).then((exit3) => {
  if (isFailure(exit3)) {
    if (!isInterrupted2(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), map17(() => {
  const loop3 = pipe(take3(output), flatMap12(done11), match14({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown4(output)), zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: fail12
    }))),
    onSuccess: (chunk3) => pipe(write(chunk3), flatMap14(() => loop3))
  }), unwrap);
  return loop3;
}))))), unwrapScoped3, fromChannel2), queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === undefined && options?.strategy === undefined) {
    return unbounded5();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding4(options.bufferSize ?? 16);
    default:
      return dropping4(options?.bufferSize ?? 16);
  }
}, asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap4((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map17((queue) => {
  const loop3 = flatMap14(take3(queue), (item) => isExit(item) ? isSuccess(item) ? void_7 : failCause11(item.cause) : zipRight7(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped3, fromChannel2), asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap12((output) => pipe(runtime3(), flatMap12((runtime4) => pipe(register(make53((k) => pipe(fromPull(k), flatMap12((take7) => offer3(output, take7)), asVoid4, runPromiseExit2(runtime4)).then((exit3) => {
  if (isFailure(exit3)) {
    if (!isInterrupted2(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), zipRight6(make29(false)), flatMap12((ref) => pipe(get12(ref), map17((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap12(done11), onError2(() => pipe(set6(ref, true), zipRight6(shutdown4(output)))))))))))), scoped6, flatMap17(repeatEffectChunkOption)), branchAfter, broadcast, broadcastDynamic, share, broadcastedQueues, broadcastedQueuesDynamic, buffer, bufferChunks, bufferChunksDropping, bufferChunksSliding, bufferDropping, bufferSliding, bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map17(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match19({
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value) => flatMap14(write(value), () => process2)
    })));
    return process2;
  })));
}, bufferSignal = (scoped6, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take7) => pipe(get12(ref), tap4(_await), zipRight6(make19()), flatMap12((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight6(set6(ref, deferred)), zipRight6(_await(deferred)))), asVoid4, fromEffect5);
    return readWithCause({
      onInput: (input) => pipe(make19(), flatMap12((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap12((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid4, fromEffect5, flatMap14(() => producer(queue, ref))),
      onFailure: (error) => terminate(failCause12(error)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect5(take3(queue)), flatMap14(([take7, deferred]) => zipRight7(fromEffect5(succeed2(deferred, undefined)), match19(take7, {
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value) => pipe(write(value), flatMap14(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped6, flatMap12((queue) => pipe(make19(), tap4((start3) => succeed2(start3, undefined)), flatMap12((start3) => pipe(make29(start3), flatMap12((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as5(consumer(queue))))))));
}, catchAll7, catchAllCause6, catchSome3, catchSomeCause3, catchTag3, catchTags3, changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x))), changesWith, changesWithEffect, chunks = (self) => pipe(self, mapChunks(of2)), chunksWith, unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail10(o.value)), combine12, combineChunks, concat2, concatAll2 = (streams) => suspend9(() => pipe(streams, reduce3(empty35, (x, y) => concat2(y)(x)))), cross, crossLeft, crossRight, crossWith, debounce, die11 = (defect) => fromEffect8(die7(defect)), dieSync7 = (evaluate2) => fromEffect8(dieSync4(evaluate2)), dieMessage4 = (message) => fromEffect8(dieMessage2(message)), distributedWith, distributedWithDynamicId, newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
}, distributedWithDynamic, distributedWithDynamicCallback, drain3 = (self) => new StreamImpl(drain(toChannel2(self))), drainFork, drop3, dropRight2, dropUntil3, dropUntilEffect, dropWhile4, dropWhileEffect, either6 = (self) => pipe(self, map23(right2), catchAll7((error) => make55(left2(error)))), empty35, ensuring7, ensuringWith2, context5 = () => fromEffect8(context3()), contextWith3 = (f) => pipe(context5(), map23(f)), contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f)), contextWithStream = (f) => pipe(context5(), flatMap17(f)), execute = (effect4) => drain3(fromEffect8(effect4)), fail16 = (error) => fromEffectOption(fail10(some2(error))), failSync8 = (evaluate2) => fromEffectOption(failSync4(() => some2(evaluate2()))), failCause14 = (cause3) => fromEffect8(failCause9(cause3)), failCauseSync7 = (evaluate2) => fromEffect8(failCauseSync4(evaluate2)), filter10, filterEffect, filterMap8, filterMapEffect, filterMapWhile3, filterMapWhileEffect, finalizer = (finalizer2) => acquireRelease3(_void, () => finalizer2), find2, findEffect, flatMap17, matchConcurrency = (concurrency, sequential4, bounded8) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential4();
  }
}, flatMapParSwitchBuffer, flatten14, flattenChunks = (self) => {
  const flatten15 = readWithCause({
    onInput: (chunks2) => flatMap14(writeChunk(chunks2), () => flatten15),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten15)));
}, flattenEffect, flattenExitOption = (self) => {
  const processChunk = (chunk3, cont) => {
    const [toEmit, rest] = pipe(chunk3, splitWhere((exit3) => !isSuccess(exit3)));
    const next4 = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match6({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_7,
          onSome: failCause11
        }),
        onSuccess: () => void_7
      })
    }));
    return pipe(write(pipe(toEmit, filterMap3((exit3) => isSuccess(exit3) ? some2(exit3.value) : none2()))), flatMap14(() => next4));
  };
  const process2 = readWithCause({
    onInput: (chunk3) => processChunk(chunk3, process2),
    onFailure: (cause3) => failCause11(cause3),
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}, flattenIterables = (self) => pipe(self, map23(fromIterable3), flattenChunks), flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map23((take7) => take7.exit)))), forever5 = (self) => new StreamImpl(repeated(toChannel2(self))), fromAsyncIterable = (iterable, onError3) => pipe(acquireRelease2(sync5(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map17((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError3(reason))
}), flatMap12((result) => result.done ? fail10(none2()) : succeed10(result.value))))), unwrapScoped4), fromChannel2 = (channel) => new StreamImpl(channel), toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect8(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
}, fromChunk = (chunk3) => new StreamImpl(isEmpty(chunk3) ? void_7 : write(chunk3)), fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map17(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map17(effect4, ensuring7(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap17(scoped6(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring7(stream, shutdown3(pubsub)) : stream;
}, fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown4(queue), flatMap12((isShutdown8) => isShutdown8 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown4(queue)) : identity), fromChunks = (...chunks2) => pipe(fromIterable12(chunks2), flatMap17(fromChunk)), fromEffect8 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption), fromEffectOption = (effect4) => new StreamImpl(unwrap(match14(effect4, {
  onFailure: match2({
    onNone: () => void_7,
    onSome: fail12
  }),
  onSuccess: (a) => write(of2(a))
}))), fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map17(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map17(effect4, ensuring7(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap17(scoped6(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring7(stream, shutdown3(pubsub)) : stream;
}, fromTPubSub = (pubsub) => {
  return unwrapScoped4(map17(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
}, fromIterable12 = (iterable) => suspend9(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]())), fromIterableEffect = (effect4) => pipe(effect4, map17(fromIterable12), unwrap2), fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync5(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync5(() => {
      let next4 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next4.done) {
          return void_7;
        }
        return pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator2)));
      }
      builder = [];
      let count4 = 0;
      while (next4.done === false) {
        builder.push(next4.value);
        count4 = count4 + 1;
        if (count4 >= maxChunkSize) {
          break;
        }
        next4 = iterator2.next();
      }
      if (count4 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap14(() => loop3(iterator2)));
      }
      return void_7;
    }), unwrap);
    return new StreamImpl(loop3(iterator));
  }), unwrap2);
}, fromPull2 = (effect4) => pipe(effect4, map17(repeatEffectChunkOption), unwrapScoped4), fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown4(queue), flatMap12((isShutdown8) => isShutdown8 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown4(queue)) : identity), fromTQueue = (queue) => pipe(take5(queue), map17(of2), catchAllCause3((cause3) => pipe(isShutdown7(queue), flatMap12((isShutdown8) => isShutdown8 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption), fromSchedule = (schedule2) => pipe(driver2(schedule2), map17((driver3) => repeatEffectOption(driver3.next(undefined))), unwrap2), fromReadableStream = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map17(acquireRelease2(sync5(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap12(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some2(onError3(reason))
  }), ({
    done: done12,
    value
  }) => done12 ? fail10(none2()) : succeed10(value)))));
}, fromReadableStreamByob = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map17(acquireRelease2(sync5(() => evaluate2().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError3, allocSize)), (error) => error === EOF ? empty35 : fail16(error))));
}, EOF, readChunkStreamByobReader = (reader, onError3, size18) => {
  const buffer2 = new ArrayBuffer(size18);
  return paginateEffect(0, (offset) => flatMap12(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer2, offset, buffer2.byteLength - offset)),
    catch: (reason) => onError3(reason)
  }), ({
    done: done12,
    value
  }) => {
    if (done12) {
      return fail10(EOF);
    }
    const newOffset = offset + value.byteLength;
    return succeed10([value, newOffset >= buffer2.byteLength ? none2() : some2(newOffset)]);
  }));
}, groupAdjacentBy, grouped, groupedWithin, haltWhen, haltAfter, haltWhenDeferred, identityStream = () => new StreamImpl(identityChannel()), interleave, interleaveWith, intersperse, intersperseAffixes, interruptAfter, interruptWhen2, interruptWhenDeferred2, iterate3 = (value, next4) => unfold4(value, (a) => some2([a, next4(a)])), make55 = (...as10) => fromIterable12(as10), map23, mapAccum5, mapAccumEffect, mapBoth6, mapChunks, mapChunksEffect, mapConcat, mapConcatChunk, mapConcatChunkEffect, mapConcatEffect, mapEffectSequential, mapEffectPar, mapError6, mapErrorCause4, merge9, mergeAll8, mergeWithTag, mergeEither, mergeLeft, mergeRight, mergeWith3, mkString2 = (self) => run4(self, mkString), never5, onEnd, onError3, onDone, onStart, orDie5 = (self) => pipe(self, orDieWith4(identity)), orDieWith4, orElse9, orElseEither5, orElseFail3, orElseIfEmpty, orElseIfEmptyChunk, orElseIfEmptyStream, orElseSucceed3, paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
}), paginateChunk = (s, f) => {
  const loop3 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight7(write(page[0]), void_7),
      onSome: (s3) => flatMap14(write(page[0]), () => loop3(s3))
    });
  };
  return new StreamImpl(suspend5(() => loop3(s)));
}, paginateChunkEffect = (s, f) => {
  const loop3 = (s2) => unwrap(map17(f(s2), ([chunk3, option3]) => match2(option3, {
    onNone: () => zipRight7(write(chunk3), void_7),
    onSome: (s3) => flatMap14(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(suspend5(() => loop3(s)));
}, paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map17(([a, s3]) => [of2(a), s3]))), peel, partition6, partitionEither, pipeThrough, pipeThroughChannel, pipeThroughChannelOrFail, prepend4, provideContext6, provideSomeContext2, provideLayer, provideService6, provideServiceEffect3, provideServiceStream, mapInputContext6, provideSomeLayer2, range2 = (min3, max5, chunkSize = DefaultChunkSize) => suspend9(() => {
  if (min3 > max5) {
    return empty35;
  }
  const go = (min4, max6, chunkSize2) => {
    const remaining = max6 - min4 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min4, min4 + chunkSize2 - 1)), flatMap14(() => go(min4 + chunkSize2, max6, chunkSize2)));
    }
    return write(range(min4, min4 + remaining - 1));
  };
  return new StreamImpl(go(min3, max5, chunkSize));
}), race3, raceAll3 = (...streams) => make19().pipe(map17((halt2) => {
  let winner = null;
  return mergeAll8(streams.map((stream, index) => stream.pipe(takeWhile4(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_3);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap12(() => winner === index ? never4 : _void))))), {
    concurrency: streams.length
  });
}), unwrap2), rechunk, rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk3) => {
    if (chunk3.length === target && rechunker.isEmpty()) {
      return flatMap14(write(chunk3), () => rechunkProcess(rechunker, target));
    }
    if (chunk3.length > 0) {
      const chunks2 = [];
      let result = undefined;
      let index = 0;
      while (index < chunk3.length) {
        while (index < chunk3.length && result === undefined) {
          result = rechunker.write(pipe(chunk3, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== undefined) {
          chunks2.push(result);
          result = undefined;
        }
      }
      return flatMap14(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
    }
    return suspend5(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight7(rechunker.emitIfNotEmpty(), failCause11(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
}), refineOrDie, refineOrDieWith, repeat2, repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2))), repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2))), repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map17(effect5, (chunk3) => some2([chunk3, effect5])), catchAll3(match2({
  onNone: () => succeed10(none2()),
  onSome: fail10
})))), repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map17(of2))), repeatEither, repeatElements, repeatElementsWith, repeatValue = (value) => new StreamImpl(repeated(write(of2(value)))), repeatWith, repeatWithSchedule = (value, schedule2) => repeatEffectWithSchedule(succeed10(value), schedule2), repeatEffectWithSchedule = (effect4, schedule2) => flatMap17(fromEffect8(zip7(effect4, driver2(schedule2))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  return concat2(succeed16(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
    onFailure: succeed10,
    onSuccess: () => map17(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
  })));
}), retry6, withExecutionPlan3, scheduleDefectRefail2 = (self) => catchAllCause6(self, (cause3) => failCause14(scheduleDefectRefailCause(cause3))), run4, runCollect = (self) => run4(self, collectAll()), runCount = (self) => run4(self, count2), runDrain2 = (self) => run4(self, drain2), runFold, runFoldEffect, runFoldScoped, runFoldScopedEffect, runFoldWhile, runFoldWhileEffect, runFoldWhileScoped, runFoldWhileScopedEffect, runForEach, runForEachChunk, runForEachChunkScoped, runForEachScoped, runForEachWhile, runForEachWhileScoped, runHead = (self) => run4(self, head5()), runIntoPubSub, runIntoPubSubScoped, runIntoQueue, runIntoQueueElementsScoped, runIntoQueueScoped, runLast = (self) => run4(self, last4()), runScoped2, runSum = (self) => run4(self, sum2), scan, scanReduce, scanReduceEffect, schedule2, scheduleWith, scanEffect, scoped6 = (effect4) => new StreamImpl(ensuring4(scoped5(pipe(effect4, map17(of2))), _void)), scopedWith4 = (f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map17(of2)))), some7 = (self) => pipe(self, mapError6(some2), someOrFail(() => none2())), someOrElse, someOrFail, sliding7, slidingSize, split2, splitOnChunk, splitLines2 = (self) => pipeThroughChannel(self, splitLines()), succeed16 = (value) => fromChunk(of2(value)), sync10 = (evaluate2) => suspend9(() => fromChunk(of2(evaluate2()))), suspend9 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream()))), take7, takeRight2, takeUntil3, takeUntilEffect, takeWhile4, tap7, tapBoth3, tapError5, tapErrorCause5, tapSink, throttle, throttleEffect, throttleEnforceEffect = (self, cost, units, duration3, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip7(currentTimeMillis2), map17(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration3);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      if (weight <= available) {
        return pipe(write(input), flatMap14(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap),
    onFailure: failCause11,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map17((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
}, throttleShapeEffect = (self, costFn, units, duration3, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip7(currentTimeMillis2), map17(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration3);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration3)));
      if (greaterThan2(delay3, zero2)) {
        return pipe(fromEffect5(sleep2(delay3)), zipRight7(write(input)), flatMap14(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap14(write(input), () => loop3(remaining, currentTimeMillis3));
    }), unwrap),
    onFailure: failCause11,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map17((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
}, tick = (interval) => repeatWithSchedule(undefined, spaced2(interval)), timeout3, timeoutFail3, timeoutFailCause3, timeoutTo3, pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
}, toPubSub2, toPull2 = (self) => map17(toPull(toChannel2(self)), (pull) => pipe(pull, mapError3(some2), flatMap12(match({
  onLeft: () => fail10(none2()),
  onRight: succeed10
})))), toQueue2, toQueueOfElements, toReadableStream, toReadableStreamEffect, toReadableStreamRuntime, transduce, toAsyncIterableRuntime, toAsyncIterable = (self) => toAsyncIterableRuntime(self, defaultRuntime2), toAsyncIterableEffect = (self) => map17(runtime3(), (runtime4) => toAsyncIterableRuntime(self, runtime4)), unfold4 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3]))), unfoldChunk = (s, f) => {
  const loop3 = (s2) => match2(f(s2), {
    onNone: () => void_7,
    onSome: ([chunk3, s3]) => flatMap14(write(chunk3), () => loop3(s3))
  });
  return new StreamImpl(suspend5(() => loop3(s)));
}, unfoldChunkEffect = (s, f) => suspend9(() => {
  const loop3 = (s2) => unwrap(map17(f(s2), match2({
    onNone: () => void_7,
    onSome: ([chunk3, s3]) => flatMap14(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(loop3(s));
}), unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map17(map2(([a, s3]) => [of2(a), s3])))), void_9, unwrap2 = (effect4) => flatten14(fromEffect8(effect4)), unwrapScoped4 = (effect4) => flatten14(scoped6(effect4)), unwrapScopedWith3 = (f) => flatten14(scopedWith4((scope5) => f(scope5))), updateService4, when3, whenCase = (evaluate2, pf) => whenCaseEffect(pf)(sync5(evaluate2)), whenCaseEffect, whenEffect3, withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self), name, options));
  }
  return (self) => new StreamImpl(withSpan5(toChannel2(self), name, options));
}, zip9, zipFlatten, zipAll, zipAllLeft, zipAllRight, zipAllSortedByKey, zipAllSortedByKeyLeft, zipAllSortedByKeyRight, zipAllSortedByKeyWith, zipAllWith, zipLatest, zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty35;
  } else if (streams.length === 1) {
    return map23(streams[0], (x) => [x]);
  }
  const [head6, ...tail2] = streams;
  return zipLatestWith(head6, zipLatestAll(...tail2), (first2, second) => [first2, ...second]);
}, zipLatestWith, zipLeft8, zipRight11, zipWith14, zipWithChunks, zipWithIndex = (self) => pipe(self, mapAccum5(0, (index, a) => [index + 1, [a, index]])), zipWithNext = (self) => {
  const process2 = (last5) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk3] = mapAccum2(input, last5, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap3(chunk3, (option3) => isSome2(option3) ? some2([option3.value[0], some2(option3.value[1])]) : none2());
      return flatMap14(write(output), () => process2(newLast));
    },
    onFailure: failCause11,
    onDone: () => match2(last5, {
      onNone: () => void_7,
      onSome: (value) => zipRight7(write(of2([value, none2()])), void_7)
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
}, zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]])), zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map23(([[prev, curr], next4]) => [prev, curr, pipe(next4, map2((tuple4) => tuple4[1]))])), zipChunks = (left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take(right3.length), zipWith3(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith3(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
}, Do4, bind5, bindTo5, let_5, decodeText, encodeText = (self) => suspend9(() => {
  const encoder = new TextEncoder;
  return map23(self, (s) => encoder.encode(s));
}), fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync5(() => target.addEventListener(type, emit2.single, options)), () => sync5(() => target.removeEventListener(type, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : undefined
});
var init_stream = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Clock();
  init_Context();
  init_Deferred();
  init_Duration();
  init_Effect();
  init_Either();
  init_Equal();
  init_Exit();
  init_Fiber();
  init_FiberRef();
  init_Function();
  init_executionPlan();
  init_Layer();
  init_MergeDecision();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_PubSub();
  init_Queue();
  init_RcRef();
  init_Ref();
  init_Runtime();
  init_Schedule();
  init_StreamHaltStrategy();
  init_TPubSub();
  init_TQueue();
  init_Tuple();
  init_channel();
  init_channelExecutor();
  init_mergeStrategy();
  init_core_stream();
  init_doNotation();
  init_ringBuffer();
  init_schedule();
  init_sink();
  init_debounceState();
  init_emit();
  init_haltStrategy();
  init_handoff();
  init_pull();
  init_sinkEndReason();
  init_zipAllState();
  init_zipChunksState();
  init_take();
  init_tracer();
  StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
  streamVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };
  StreamImpl = class StreamImpl {
    channel;
    [StreamTypeId2] = streamVariance;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  aggregate = /* @__PURE__ */ dual(2, (self, sink) => aggregateWithin(self, sink, forever4));
  aggregateWithin = /* @__PURE__ */ dual(3, (self, sink, schedule2) => filterMap8(aggregateWithinEither(self, sink, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  aggregateWithinEither = /* @__PURE__ */ dual(3, (self, sink, schedule2) => {
    const layer = all7([make54(), make29(ScheduleEnd), make29(empty5()), driver2(schedule2), make29(false), make29(false)]);
    return fromEffect8(layer).pipe(flatMap17(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
      const handoffProducer = readWithCause({
        onInput: (input) => flatMap14(fromEffect5(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer),
        onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
        onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
      });
      const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty5()), flatMap12((leftovers) => {
        if (isNonEmpty2(leftovers)) {
          return pipe(set6(consumed, true), zipRight6(succeed10(pipe(write(leftovers), flatMap14(() => handoffConsumer)))));
        }
        return pipe(take6(handoff), map17((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return pipe(fromEffect5(set6(consumed, true)), zipRight7(write(signal.elements)), zipRight7(fromEffect5(get12(endAfterEmit))), flatMap14((bool) => bool ? void_7 : handoffConsumer));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              if (signal.reason._tag === OP_SCHEDULE_END) {
                return pipe(get12(consumed), map17((bool) => bool ? fromEffect5(pipe(set6(sinkEndReason, ScheduleEnd), zipRight6(set6(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set6(sinkEndReason, ScheduleEnd), zipRight6(set6(endAfterEmit, true)))), flatMap14(() => handoffConsumer))), unwrap);
              }
              return pipe(set6(sinkEndReason, signal.reason), zipRight6(set6(endAfterEmit, true)), fromEffect5);
            }
          }
        }));
      }), unwrap);
      const timeout3 = (lastB) => scheduleDriver.next(lastB);
      const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
        const forkSink = pipe(set6(consumed, false), zipRight6(set6(endAfterEmit, false)), zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
        const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten4(leftovers)), zipRight6(map17(get12(sinkEndReason), (reason) => {
          switch (reason._tag) {
            case OP_SCHEDULE_END: {
              return pipe(all7([get12(consumed), forkSink, pipe(timeout3(some2(b)), forkIn2(scope5))]), map17(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
                const toWrite = pipe(c, match2({
                  onNone: () => of2(right2(b)),
                  onSome: (c2) => make7(right2(b), left2(c2))
                }));
                if (wasConsumed) {
                  return pipe(write(toWrite), flatMap14(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
                }
                return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
              }), unwrap);
            }
            case OP_UPSTREAM_END: {
              return pipe(get12(consumed), map17((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_7), unwrap);
            }
          }
        })), unwrap);
        return unwrap(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
          onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight6(pipe(suspend3(() => sinkExit), map17(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
          onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend3(() => scheduleExit), {
            onFailure: (cause3) => match(failureOrCause2(cause3), {
              onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
              onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, none2())))))
            }),
            onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map17(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
          })
        }));
      };
      return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self), handoffProducer).pipe(run2, forkIn2(scope5), zipRight6(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn2(scope5), flatMap12((sinkFiber) => timeout3(none2()).pipe(forkIn2(scope5), map17((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
    }));
  });
  as9 = /* @__PURE__ */ dual(2, (self, value) => map23(self, () => value));
  branchAfter = /* @__PURE__ */ dual(3, (self, n, f) => suspend9(() => {
    const buffering = (acc) => readWith({
      onInput: (input) => {
        const nextSize = acc.length + input.length;
        if (nextSize >= n) {
          const [b1, b2] = pipe(input, splitAt2(n - acc.length));
          return running4(pipe(acc, appendAll2(b1)), b2);
        }
        return buffering(pipe(acc, appendAll2(input)));
      },
      onFailure: fail12,
      onDone: () => running4(acc, empty5())
    });
    const running4 = (prefix, leftover) => pipeTo(zipRight7(write(leftover), identityChannel()), toChannel2(f(prefix)));
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty5()))));
  }));
  broadcast = /* @__PURE__ */ dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map17((tuple4) => tuple4.map((queue) => flattenTake(fromQueue2(queue, {
    shutdown: true
  }))))));
  broadcastDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map17(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
  share = /* @__PURE__ */ dual(2, (self, options) => map17(make49({
    acquire: broadcastDynamic(self, options),
    idleTimeToLive: options.idleTimeToLive
  }), (rcRef) => unwrapScoped4(get15(rcRef))));
  broadcastedQueues = /* @__PURE__ */ dual(3, (self, n, maximumLag) => flatMap12(pubsubFromOptions(maximumLag), (pubsub) => pipe(all7(Array.from({
    length: n
  }, () => subscribe2(pubsub))), tap4(() => forkScoped2(runIntoPubSubScoped(self, pubsub))))));
  broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map17(toPubSub2(self, maximumLag), subscribe2));
  buffer = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.capacity === "unbounded") {
      return bufferUnbounded(self);
    } else if (options.strategy === "dropping") {
      return bufferDropping(self, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferSliding(self, options.capacity);
    }
    const queue = toQueueOfElements(self, options);
    return new StreamImpl(unwrapScoped3(map17(queue, (queue2) => {
      const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match6({
        onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
          onNone: () => void_7,
          onSome: failCause11
        })),
        onSuccess: (value) => flatMap14(write(of2(value)), () => process2)
      })));
      return process2;
    })));
  });
  bufferChunks = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.strategy === "dropping") {
      return bufferChunksDropping(self, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferChunksSliding(self, options.capacity);
    }
    const queue = toQueue2(self, options);
    return new StreamImpl(unwrapScoped3(map17(queue, (queue2) => {
      const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match19({
        onEnd: () => void_7,
        onFailure: failCause11,
        onSuccess: (value) => pipe(write(value), flatMap14(() => process2))
      })));
      return process2;
    })));
  });
  bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity8) => {
    const queue = acquireRelease2(dropping4(capacity8), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self)));
  });
  bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity8) => {
    const queue = acquireRelease2(sliding4(capacity8), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self)));
  });
  bufferDropping = /* @__PURE__ */ dual(2, (self, capacity8) => {
    const queue = acquireRelease2(dropping4(capacity8), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
  });
  bufferSliding = /* @__PURE__ */ dual(2, (self, capacity8) => {
    const queue = acquireRelease2(sliding4(capacity8), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
  });
  catchAll7 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause14
  })));
  catchAllCause6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), catchAllCause5((cause3) => toChannel2(f(cause3))))));
  catchSome3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAll7((error) => pipe(pf(error), getOrElse(() => fail16(error))))));
  catchSomeCause3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause14(cause3))))));
  catchTag3 = /* @__PURE__ */ dual(3, (self, k, f) => catchAll7(self, (e) => {
    if ("_tag" in e && e["_tag"] === k) {
      return f(e);
    }
    return fail16(e);
  }));
  catchTags3 = /* @__PURE__ */ dual(2, (self, cases) => catchAll7(self, (e) => {
    const keys5 = Object.keys(cases);
    if ("_tag" in e && keys5.includes(e["_tag"])) {
      return cases[e["_tag"]](e);
    }
    return fail16(e);
  }));
  changesWith = /* @__PURE__ */ dual(2, (self, f) => {
    const writer = (last5) => readWithCause({
      onInput: (input) => {
        const [newLast, newChunk] = reduce3(input, [last5, empty5()], ([option3, outputs], output) => {
          if (isSome2(option3) && f(option3.value, output)) {
            return [some2(output), outputs];
          }
          return [some2(output), pipe(outputs, append2(output))];
        });
        return flatMap14(write(newChunk), () => writer(newLast));
      },
      onFailure: failCause11,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
  });
  changesWithEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const writer = (last5) => readWithCause({
      onInput: (input) => pipe(input, reduce14([last5, empty5()], ([option3, outputs], output) => {
        if (isSome2(option3)) {
          return pipe(f(option3.value, output), map17((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
        }
        return succeed10([some2(output), pipe(outputs, append2(output))]);
      }), fromEffect5, flatMap14(([newLast, newChunk]) => pipe(write(newChunk), flatMap14(() => writer(newLast))))),
      onFailure: failCause11,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
  });
  chunksWith = /* @__PURE__ */ dual(2, (self, f) => flattenChunks(f(chunks(self))));
  combine12 = /* @__PURE__ */ dual(4, (self, that, s, f) => {
    function producer(handoff, latch) {
      return fromEffect5(take6(latch)).pipe(zipRight7(readWithCause({
        onInput: (input) => flatMap14(fromEffect5(offer5(handoff, succeed3(input))), () => producer(handoff, latch)),
        onFailure: (cause3) => fromEffect5(offer5(handoff, failCause3(pipe(cause3, map13(some2))))),
        onDone: () => flatMap14(fromEffect5(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
      })));
    }
    return new StreamImpl(unwrapScopedWith((scope5) => all7([make54(), make54(), make54(), make54()]).pipe(tap4(([left3, _, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap4(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map17(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight6(take6(left3).pipe(flatMap12(identity))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight6(take6(right3).pipe(flatMap12(identity))));
      return toChannel2(unfoldEffect(s, (s2) => flatMap12(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  combineChunks = /* @__PURE__ */ dual(4, (self, that, s, f) => {
    const producer = (handoff, latch) => zipRight7(fromEffect5(take6(latch)), readWithCause({
      onInput: (input) => flatMap14(fromEffect5(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
      onDone: () => fromEffect5(offer5(handoff, end4))
    }));
    return new StreamImpl(unwrapScopedWith((scope5) => all7([make54(), make54(), make54(), make54()]).pipe(tap4(([left3, _, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap4(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map17(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight6(take6(left3).pipe(flatMap12(done11))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight6(take6(right3).pipe(flatMap12(done11))));
      return toChannel2(unfoldChunkEffect(s, (s2) => flatMap12(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  concat2 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight7(toChannel2(that)))));
  cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
  crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
  crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap17(left3, () => right3));
  crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap17((a) => pipe(right3, map23((b) => f(a, b))))));
  debounce = /* @__PURE__ */ dual(2, (self, duration3) => unwrapScopedWith3((scope5) => gen3(function* () {
    const handoff = yield* make54();
    function enqueue(last5) {
      return sleep2(duration3).pipe(as5(last5), forkIn2(scope5), map17((fiber) => consumer(previous(fiber))));
    }
    const producer = readWithCause({
      onInput: (input) => match2(last2(input), {
        onNone: () => producer,
        onSome: (elem) => fromEffect5(offer5(handoff, emit(of2(elem)))).pipe(flatMap14(() => producer))
      }),
      onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
    });
    function consumer(state) {
      switch (state._tag) {
        case OP_NOT_STARTED: {
          return unwrap(take6(handoff).pipe(map17((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause11(signal.cause);
              }
              case OP_END: {
                return void_7;
              }
            }
          })));
        }
        case OP_PREVIOUS: {
          return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap12((handoffFiber) => raceWith2(join4(state.fiber), join4(handoffFiber), {
            onSelfDone: (leftExit, current2) => match6(leftExit, {
              onFailure: (cause3) => interrupt6(current2).pipe(as5(failCause11(cause3))),
              onSuccess: (chunk3) => interrupt6(current2).pipe(zipRight6(succeed10(write(chunk3).pipe(flatMap14(() => consumer(current(handoffFiber)))))))
            }),
            onOtherDone: (rightExit, previous2) => match6(rightExit, {
              onFailure: (cause3) => interrupt6(previous2).pipe(as5(failCause11(cause3))),
              onSuccess: (signal) => {
                switch (signal._tag) {
                  case OP_EMIT4: {
                    return interrupt6(previous2).pipe(zipRight6(enqueue(signal.elements)));
                  }
                  case OP_HALT: {
                    return interrupt6(previous2).pipe(as5(failCause11(signal.cause)));
                  }
                  case OP_END: {
                    return join4(previous2).pipe(map17((chunk3) => write(chunk3).pipe(zipRight7(void_7))));
                  }
                }
              }
            })
          }))));
        }
        case OP_CURRENT: {
          return unwrap(join4(state.fiber).pipe(map17((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause11(signal.cause);
              }
              case OP_END: {
                return void_7;
              }
            }
          })));
        }
      }
    }
    return scopedWith4((scope6) => pipeTo(toChannel2(self), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
  })));
  distributedWith = /* @__PURE__ */ dual(2, (self, options) => pipe(make19(), flatMap12((deferred) => pipe(self, distributedWithDynamic({
    maximumLag: options.maximumLag,
    decide: (a) => flatMap12(_await(deferred), (f) => f(a))
  }), flatMap12((next4) => pipe(all7(map4(range(0, options.size - 1), (id3) => map17(next4, ([key, queue]) => [[key, id3], queue]))), map17(unsafeFromArray), flatMap12((entries3) => {
    const [mappings, queues] = reduceRight2(entries3, [new Map, empty5()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
    return pipe(succeed2(deferred, (a) => map17(options.decide(a), (f) => (key) => pipe(f(mappings.get(key))))), as5(Array.from(queues)));
  })))))));
  distributedWithDynamicId = {
    ref: 0
  };
  distributedWithDynamic = /* @__PURE__ */ dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
  distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self, maximumLag, decide, done12) => pipe(acquireRelease2(make29(new Map), (ref, _) => pipe(get12(ref), flatMap12((queues) => pipe(queues.values(), forEach9(shutdown4))))), flatMap12((queuesRef) => gen3(function* () {
    const offer6 = (a) => pipe(decide(a), flatMap12((shouldProcess) => pipe(get12(queuesRef), flatMap12((queues) => pipe(queues.entries(), reduce14(empty5(), (acc, [id3, queue]) => {
      if (shouldProcess(id3)) {
        return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
          onFailure: (cause3) => isInterrupted2(cause3) ? succeed10(pipe(acc, prepend2(id3))) : failCause9(cause3),
          onSuccess: () => succeed10(acc)
        }));
      }
      return succeed10(acc);
    }), flatMap12((ids3) => {
      if (isNonEmpty2(ids3)) {
        return pipe(update3(queuesRef, (map23) => {
          for (const id3 of ids3) {
            map23.delete(id3);
          }
          return map23;
        }));
      }
      return _void;
    }))))), asVoid4);
    const queuesLock = yield* makeSemaphore2(1);
    const newQueue = yield* make29(pipe(bounded5(maximumLag), flatMap12((queue) => {
      const id3 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map23) => map23.set(id3, queue)), as5([id3, queue]));
    })));
    const finalize = (endTake) => queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(bounded5(1), tap4((queue) => offer3(queue, endTake)), flatMap12((queue) => {
      const id3 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map23) => map23.set(id3, queue)), as5(make3(id3, queue)));
    }))), zipRight6(pipe(get12(queuesRef), flatMap12((map23) => pipe(fromIterable3(map23.values()), forEach9((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight6(done12(endTake)), asVoid4));
    yield* pipe(self, runForEachScoped(offer6), matchCauseEffect3({
      onFailure: (cause3) => finalize(failCause3(pipe(cause3, map13(some2)))),
      onSuccess: () => finalize(fail4(none2()))
    }), forkScoped2);
    return queuesLock.withPermits(1)(flatten10(get12(newQueue)));
  }))));
  drainFork = /* @__PURE__ */ dual(2, (self, that) => fromEffect8(make19()).pipe(flatMap17((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
  drop3 = /* @__PURE__ */ dual(2, (self, n) => {
    const loop3 = (r) => readWith({
      onInput: (input) => {
        const dropped = pipe(input, drop2(r));
        const leftover = Math.max(0, r - input.length);
        const more = isEmpty(input) || leftover > 0;
        if (more) {
          return loop3(leftover);
        }
        return pipe(write(dropped), zipRight7(identityChannel()));
      },
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(n))));
  });
  dropRight2 = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return identityStream();
    }
    return suspend9(() => {
      const queue = new RingBuffer(n);
      const reader = readWith({
        onInput: (input) => {
          const outputs = pipe(input, filterMap3((elem) => {
            const head6 = queue.head();
            queue.put(elem);
            return head6;
          }));
          return pipe(write(outputs), flatMap14(() => reader));
        },
        onFailure: fail12,
        onDone: () => void_7
      });
      return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
    });
  });
  dropUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => drop3(dropWhile4(self, (a) => !predicate(a)), 1));
  dropUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropUntil2(input, predicate), map17(unsafeFromArray), map17((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return pipe(write(leftover), zipRight7(identityChannel()));
      }), unwrap),
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  dropWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const output = dropWhile(input, predicate);
        if (isEmpty(output)) {
          return suspend5(() => loop3);
        }
        return zipRight7(write(output), identityChannel());
      },
      onFailure: fail12,
      onDone: succeedNow
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
  });
  dropWhileEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropWhile3(input, predicate), map17(unsafeFromArray), map17((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return zipRight7(write(leftover), identityChannel());
      }), unwrap),
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
  });
  empty35 = /* @__PURE__ */ new StreamImpl(void_7);
  ensuring7 = /* @__PURE__ */ dual(2, (self, finalizer) => new StreamImpl(pipe(toChannel2(self), ensuring4(finalizer))));
  ensuringWith2 = /* @__PURE__ */ dual(2, (self, finalizer) => new StreamImpl(ensuringWith(toChannel2(self), finalizer)));
  filter10 = /* @__PURE__ */ dual(2, (self, predicate) => mapChunks(self, filter3(predicate)));
  filterEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = (iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeed12
        });
      } else {
        return pipe(f(next4.value), map17((bool) => bool ? pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator))) : loop3(iterator)), unwrap);
      }
    };
    return new StreamImpl(suspend5(() => pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]())))));
  });
  filterMap8 = /* @__PURE__ */ dual(2, (self, pf) => mapChunks(self, filterMap3(pf)));
  filterMapEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeed12
        });
      } else {
        return pipe(pf(next4.value), match2({
          onNone: () => sync5(() => loop3(iterator)),
          onSome: map17((a2) => flatMap14(write(of2(a2)), () => loop3(iterator)))
        }), unwrap);
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]()))));
  }));
  filterMapWhile3 = /* @__PURE__ */ dual(2, (self, pf) => {
    const loop3 = readWith({
      onInput: (input) => {
        const mapped = filterMapWhile2(input, pf);
        if (mapped.length === input.length) {
          return pipe(write(mapped), flatMap14(() => loop3));
        }
        return write(mapped);
      },
      onFailure: fail12,
      onDone: succeed12
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  filterMapWhileEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeed12
        });
      } else {
        return unwrap(match2(pf(next4.value), {
          onNone: () => succeed10(void_7),
          onSome: map17((a2) => flatMap14(write(of2(a2)), () => loop3(iterator)))
        }));
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(empty5()[Symbol.iterator]()))));
  }));
  find2 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => match2(findFirst3(input, predicate), {
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      }),
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  findEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(findFirst8(input, predicate), map17(match2({
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      })), unwrap),
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  flatMap17 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => {
    const bufferSize = options?.bufferSize ?? 16;
    if (options?.switch) {
      return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
    }
    return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as10) => pipe(as10, map4((a) => toChannel2(f(a))), reduce3(void_7, (left3, right3) => pipe(left3, zipRight7(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
  });
  flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
    concurrency: n,
    mergeStrategy: BufferSliding(),
    bufferSize
  }))));
  flatten14 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => flatMap17(self, identity, options));
  flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => options?.unordered ? flatMap17(self, (a) => fromEffect8(a), {
    concurrency: options.concurrency
  }) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
  EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
  groupAdjacentBy = /* @__PURE__ */ dual(2, (self, f) => {
    const groupAdjacentByChunk = (state, chunk3) => {
      if (isEmpty(chunk3)) {
        return [state, empty5()];
      }
      const builder = [];
      let from = 0;
      let until = 0;
      let key = undefined;
      let previousChunk = empty5();
      switch (state._tag) {
        case "Some": {
          const tuple4 = state.value;
          key = tuple4[0];
          let loop3 = true;
          while (loop3 && until < chunk3.length) {
            const input = unsafeGet4(chunk3, until);
            const updatedKey = f(input);
            if (!equals(key, updatedKey)) {
              const previousChunk2 = tuple4[1];
              const additionalChunk = unsafeFromArray(Array.from(chunk3).slice(from, until));
              const group = appendAll2(previousChunk2, additionalChunk);
              builder.push([key, group]);
              key = updatedKey;
              from = until;
              loop3 = false;
            }
            until = until + 1;
          }
          if (loop3) {
            previousChunk = tuple4[1];
          }
          break;
        }
        case "None": {
          key = f(unsafeGet4(chunk3, until));
          until = until + 1;
          break;
        }
      }
      while (until < chunk3.length) {
        const input = unsafeGet4(chunk3, until);
        const updatedKey = f(input);
        if (!equals(key, updatedKey)) {
          builder.push([key, unsafeFromArray(Array.from(chunk3).slice(from, until))]);
          key = updatedKey;
          from = until;
        }
        until = until + 1;
      }
      const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk3).slice(from, until)));
      const output = unsafeFromArray(builder);
      return [some2([key, nonEmptyChunk]), output];
    };
    const groupAdjacent = (state) => readWithCause({
      onInput: (input) => {
        const [updatedState, output] = groupAdjacentByChunk(state, input);
        return isEmpty(output) ? groupAdjacent(updatedState) : flatMap14(write(output), () => groupAdjacent(updatedState));
      },
      onFailure: (cause3) => match2(state, {
        onNone: () => failCause11(cause3),
        onSome: (output) => flatMap14(write(of2(output)), () => failCause11(cause3))
      }),
      onDone: (done12) => match2(state, {
        onNone: () => succeedNow(done12),
        onSome: (output) => flatMap14(write(of2(output)), () => succeedNow(done12))
      })
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
  });
  grouped = /* @__PURE__ */ dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
  groupedWithin = /* @__PURE__ */ dual(3, (self, chunkSize, duration3) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration3)));
  haltWhen = /* @__PURE__ */ dual(2, (self, effect4) => {
    const writer = (fiber) => pipe(poll4(fiber), map17(match2({
      onNone: () => readWith({
        onInput: (input) => flatMap14(write(input), () => writer(fiber)),
        onFailure: fail12,
        onDone: () => void_7
      }),
      onSome: match6({
        onFailure: failCause11,
        onSuccess: () => void_7
      })
    })), unwrap);
    return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map17((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
  });
  haltAfter = /* @__PURE__ */ dual(2, (self, duration3) => pipe(self, haltWhen(sleep2(duration3))));
  haltWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => {
    const writer = pipe(poll(deferred), map17(match2({
      onNone: () => readWith({
        onInput: (input) => pipe(write(input), flatMap14(() => writer)),
        onFailure: fail12,
        onDone: () => void_7
      }),
      onSome: (effect4) => unwrap(match14(effect4, {
        onFailure: fail12,
        onSuccess: () => void_7
      }))
    })), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
  });
  interleave = /* @__PURE__ */ dual(2, (self, that) => pipe(self, interleaveWith(that, forever5(make55(true, false)))));
  interleaveWith = /* @__PURE__ */ dual(3, (self, that, decider) => {
    const producer = (handoff) => readWithCause({
      onInput: (value) => flatMap14(fromEffect5(offer5(handoff, of5(value))), () => producer(handoff)),
      onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
      onDone: () => fromEffect5(offer5(handoff, end4))
    });
    return new StreamImpl(unwrapScopedWith((scope5) => pipe(make54(), zip7(make54()), tap4(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap4(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map17(([left3, right3]) => {
      const process2 = (leftDone, rightDone) => readWithCause({
        onInput: (bool) => {
          if (bool && !leftDone) {
            return pipe(fromEffect5(take6(left3)), flatMap14(match19({
              onEnd: () => rightDone ? void_7 : process2(true, rightDone),
              onFailure: failCause11,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap14(() => process2(leftDone, rightDone)))
            })));
          }
          if (!bool && !rightDone) {
            return pipe(fromEffect5(take6(right3)), flatMap14(match19({
              onEnd: () => leftDone ? void_7 : process2(leftDone, true),
              onFailure: failCause11,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap14(() => process2(leftDone, rightDone)))
            })));
          }
          return process2(leftDone, rightDone);
        },
        onFailure: failCause11,
        onDone: () => void_7
      });
      return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
    }))));
  });
  intersperse = /* @__PURE__ */ dual(2, (self, element) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend5(() => {
    const writer = (isFirst) => readWithCause({
      onInput: (chunk3) => {
        const builder = [];
        let flagResult = isFirst;
        for (const output of chunk3) {
          if (flagResult) {
            flagResult = false;
            builder.push(output);
          } else {
            builder.push(element);
            builder.push(output);
          }
        }
        return pipe(write(unsafeFromArray(builder)), flatMap14(() => writer(flagResult)));
      },
      onFailure: failCause11,
      onDone: () => void_7
    });
    return writer(true);
  })))));
  intersperseAffixes = /* @__PURE__ */ dual(2, (self, {
    end: end6,
    middle,
    start: start3
  }) => pipe(make55(start3), concat2(pipe(self, intersperse(middle))), concat2(make55(end6))));
  interruptAfter = /* @__PURE__ */ dual(2, (self, duration3) => pipe(self, interruptWhen2(sleep2(duration3))));
  interruptWhen2 = /* @__PURE__ */ dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
  interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
  map23 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(map4(f)))));
  mapAccum5 = /* @__PURE__ */ dual(3, (self, s, f) => {
    const accumulator = (s2) => readWith({
      onInput: (input) => {
        const [nextS, chunk3] = mapAccum2(input, s2, f);
        return flatMap14(write(chunk3), () => accumulator(nextS));
      },
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
  });
  mapAccumEffect = /* @__PURE__ */ dual(3, (self, s, f) => suspend9(() => {
    const accumulator = (s2) => readWith({
      onInput: (input) => pipe(suspend3(() => {
        const outputs = [];
        const emit2 = (output) => sync5(() => {
          outputs.push(output);
        });
        return pipe(input, reduce14(s2, (s3, a) => pipe(f(s3, a), flatMap12(([s4, a2]) => pipe(emit2(a2), as5(s4))))), match14({
          onFailure: (error) => {
            if (outputs.length !== 0) {
              return zipRight7(write(unsafeFromArray(outputs)), fail12(error));
            }
            return fail12(error);
          },
          onSuccess: (s3) => flatMap14(write(unsafeFromArray(outputs)), () => accumulator(s3))
        }));
      }), unwrap),
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
  }));
  mapBoth6 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, mapError6(options.onFailure), map23(options.onSuccess)));
  mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
  mapChunksEffect = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f))));
  mapConcat = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapConcatChunk((a) => fromIterable3(f(a)))));
  mapConcatChunk = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapChunks(flatMap3(f))));
  mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));
  mapConcatEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential((a) => pipe(f(a), map17(fromIterable3))), mapConcatChunk(identity)));
  mapEffectSequential = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = (iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeed12
        });
      } else {
        const value = next4.value;
        return unwrap(map17(f(value), (a2) => flatMap14(write(of2(a2)), () => loop3(iterator))));
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend5(() => loop3(empty5()[Symbol.iterator]())))));
  });
  mapEffectPar = /* @__PURE__ */ dual(3, (self, n, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
  mapError6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapError5(f))));
  mapErrorCause4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapErrorCause3(f))));
  merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
    onSelf: identity,
    onOther: identity,
    haltStrategy: options?.haltStrategy
  }));
  mergeAll8 = /* @__PURE__ */ dual((args2) => (Symbol.iterator in args2[0]), (streams, options) => flatten14(fromIterable12(streams), options));
  mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
    const keys5 = Object.keys(streams);
    const values4 = keys5.map((key) => streams[key].pipe(map23((value) => ({
      _tag: key,
      value
    }))));
    return mergeAll8(values4, options);
  });
  mergeEither = /* @__PURE__ */ dual(2, (self, that) => mergeWith3(self, that, {
    onSelf: left2,
    onOther: right2
  }));
  mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
  mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
  mergeWith3 = /* @__PURE__ */ dual(3, (self, other, options) => {
    const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
    const handler = (terminate) => (exit3) => terminate || !isSuccess(exit3) ? Done4(suspend3(() => exit3)) : Await2((exit4) => suspend3(() => exit4));
    return new StreamImpl(mergeWith2(toChannel2(map23(self, options.onSelf)), {
      other: toChannel2(map23(other, options.onOther)),
      onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
      onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
    }));
  });
  never5 = /* @__PURE__ */ fromEffect8(never4);
  onEnd = /* @__PURE__ */ dual(2, (self, effect4) => concat2(self, drain3(fromEffect8(effect4))));
  onError3 = /* @__PURE__ */ dual(2, (self, cleanup) => pipe(self, catchAllCause6((cause3) => fromEffect8(pipe(cleanup(cause3), zipRight6(failCause9(cause3)))))));
  onDone = /* @__PURE__ */ dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit3) => isSuccess(exit3) ? cleanup() : _void))));
  onStart = /* @__PURE__ */ dual(2, (self, effect4) => unwrap2(as5(effect4, self)));
  orDieWith4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f))));
  orElse9 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse8(() => toChannel2(that())))));
  orElseEither5 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, map23(left2), orElse9(() => pipe(that(), map23(right2)))));
  orElseFail3 = /* @__PURE__ */ dual(2, (self, error) => pipe(self, orElse9(() => failSync8(error))));
  orElseIfEmpty = /* @__PURE__ */ dual(2, (self, element) => pipe(self, orElseIfEmptyChunk(() => of2(element()))));
  orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self, chunk3) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk3())))));
  orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self, stream) => {
    const writer = readWith({
      onInput: (input) => {
        if (isEmpty(input)) {
          return suspend5(() => writer);
        }
        return pipe(write(input), zipRight7(identityChannel()));
      },
      onFailure: fail12,
      onDone: () => suspend5(() => toChannel2(stream()))
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
  });
  orElseSucceed3 = /* @__PURE__ */ dual(2, (self, value) => pipe(self, orElse9(() => sync10(value))));
  peel = /* @__PURE__ */ dual(2, (self, sink) => {
    const OP_EMIT5 = "Emit";
    const OP_HALT2 = "Halt";
    const OP_END2 = "End";
    return pipe(make19(), flatMap12((deferred) => pipe(make54(), map17((handoff) => {
      const consumer = foldSink(collectLeftover(sink), {
        onFailure: (error) => zipRight8(fromEffect7(fail3(deferred, error)), fail13(error)),
        onSuccess: ([z, leftovers]) => {
          const loop3 = readWithCause({
            onInput: (elements) => flatMap14(fromEffect5(offer5(handoff, {
              _tag: OP_EMIT5,
              elements
            })), () => loop3),
            onFailure: (cause3) => zipRight7(fromEffect5(offer5(handoff, {
              _tag: OP_HALT2,
              cause: cause3
            })), failCause11(cause3)),
            onDone: (_) => zipRight7(fromEffect5(offer5(handoff, {
              _tag: OP_END2
            })), void_7)
          });
          return fromChannel(pipe(fromEffect5(succeed2(deferred, z)), zipRight7(fromEffect5(pipe(handoff, offer5({
            _tag: OP_EMIT5,
            elements: leftovers
          })))), zipRight7(loop3)));
        }
      });
      const producer = pipe(take6(handoff), map17((signal) => {
        switch (signal._tag) {
          case OP_EMIT5: {
            return pipe(write(signal.elements), flatMap14(() => producer));
          }
          case OP_HALT2: {
            return failCause11(signal.cause);
          }
          case OP_END2: {
            return void_7;
          }
        }
      }), unwrap);
      return pipe(self, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run4(consumer), forkScoped2, zipRight6(_await(deferred)), map17((z) => [z, new StreamImpl(producer)]));
    }))), flatten10);
  });
  partition6 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed10(predicate(a) ? right2(a) : left2(a)), options));
  partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
    size: 2,
    maximumLag: options?.bufferSize ?? 16,
    decide: match({
      onLeft: () => succeed10((n) => n === 0),
      onRight: () => succeed10((n) => n === 1)
    })
  }), flatMap12(([queue1, queue2]) => succeed10([filterMap8(flattenExitOption(fromQueue2(queue1, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: some2,
    onRight: none2
  })), filterMap8(flattenExitOption(fromQueue2(queue2, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  }))]))));
  pipeThrough = /* @__PURE__ */ dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
  pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
  pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
  prepend4 = /* @__PURE__ */ dual(2, (self, values4) => new StreamImpl(zipRight7(write(values4), toChannel2(self))));
  provideContext6 = /* @__PURE__ */ dual(2, (self, context6) => new StreamImpl(pipe(toChannel2(self), provideContext4(context6))));
  provideSomeContext2 = /* @__PURE__ */ dual(2, (self, context6) => mapInputContext6(self, merge3(context6)));
  provideLayer = /* @__PURE__ */ dual(2, (self, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map17((env) => pipe(toChannel2(self), provideContext4(env)))))));
  provideService6 = /* @__PURE__ */ dual(3, (self, tag, resource) => provideServiceEffect3(self, tag, succeed10(resource)));
  provideServiceEffect3 = /* @__PURE__ */ dual(3, (self, tag, effect4) => provideServiceStream(self, tag, fromEffect8(effect4)));
  provideServiceStream = /* @__PURE__ */ dual(3, (self, tag, stream) => contextWithStream((env) => flatMap17(stream, (service3) => pipe(self, provideContext6(add2(env, tag, service3))))));
  mapInputContext6 = /* @__PURE__ */ dual(2, (self, f) => contextWithStream((env) => pipe(self, provideContext6(f(env)))));
  provideSomeLayer2 = /* @__PURE__ */ dual(2, (self, layer) => pipe(self, provideLayer(pipe(context4(), merge8(layer)))));
  race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
  rechunk = /* @__PURE__ */ dual(2, (self, n) => suspend9(() => {
    const target = Math.max(n, 1);
    const process2 = rechunkProcess(new StreamRechunker(target), target);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
  }));
  refineOrDie = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
  refineOrDieWith = /* @__PURE__ */ dual(3, (self, pf, f) => new StreamImpl(catchAll5(toChannel2(self), (error) => match2(pf(error), {
    onNone: () => failCause11(die5(f(error))),
    onSome: fail12
  }))));
  repeat2 = /* @__PURE__ */ dual(2, (self, schedule2) => filterMap8(repeatEither(self, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  repeatEither = /* @__PURE__ */ dual(2, (self, schedule2) => repeatWith(self, schedule2, {
    onElement: (a) => right2(a),
    onSchedule: left2
  }));
  repeatElements = /* @__PURE__ */ dual(2, (self, schedule2) => filterMap8(repeatElementsWith(self, schedule2, {
    onElement: (a) => some2(a),
    onSchedule: none2
  }), identity));
  repeatElementsWith = /* @__PURE__ */ dual(3, (self, schedule2, options) => {
    const driver3 = pipe(driver2(schedule2), map17((driver4) => {
      const feed = (input) => match2(head2(input), {
        onNone: () => loop3,
        onSome: (a) => zipRight7(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
      });
      const step4 = (input, a) => {
        const advance = pipe(driver4.next(a), as5(pipe(write(of2(options.onElement(a))), flatMap14(() => step4(input, a)))));
        const reset2 = pipe(driver4.last, orDie3, flatMap12((b) => pipe(driver4.reset, map17(() => pipe(write(of2(options.onSchedule(b))), zipRight7(feed(input)))))));
        return pipe(advance, orElse6(() => reset2), unwrap);
      };
      const loop3 = readWith({
        onInput: feed,
        onFailure: fail12,
        onDone: () => void_7
      });
      return loop3;
    }), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
  });
  repeatWith = /* @__PURE__ */ dual(3, (self, schedule2, options) => {
    return pipe(driver2(schedule2), map17((driver3) => {
      const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
      const process2 = pipe(self, provideLastIterationInfo, map23(options.onElement), toChannel2);
      const loop3 = unwrap(match14(driver3.next(undefined), {
        onFailure: () => void_7,
        onSuccess: (output) => flatMap14(process2, () => zipRight7(write(of2(options.onSchedule(output))), loop3))
      }));
      return new StreamImpl(zipRight7(process2, loop3));
    }), unwrap2);
  });
  retry6 = /* @__PURE__ */ dual(2, (self, policy) => driver2(policy).pipe(map17((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const loop3 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as5(driver3.reset, out)), catchAll5((error) => driver3.next(error).pipe(match14({
      onFailure: () => fail12(error),
      onSuccess: () => loop3
    }), unwrap)));
    return loop3;
  }), unwrap, fromChannel2));
  withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, policy, options) => suspend9(() => {
    const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
    let i = 0;
    let lastError = none2();
    const loop3 = suspend9(() => {
      const step4 = policy.steps[i++];
      if (!step4) {
        return fail16(getOrThrow2(lastError));
      }
      let nextStream = isContext2(step4.provide) ? provideSomeContext2(self, step4.provide) : provideSomeLayer2(self, step4.provide);
      let receivedElements = false;
      if (isSome2(lastError)) {
        const error = lastError.value;
        let attempted = false;
        const wrapped = nextStream;
        nextStream = suspend9(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return fail16(error);
        });
        nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
      } else {
        const schedule2 = scheduleFromStep(step4, true);
        nextStream = schedule2 ? scheduleDefectRefail2(retry6(nextStream, schedule2)) : nextStream;
      }
      return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk3) => {
        receivedElements = true;
        return chunk3;
      }) : nextStream, (error) => {
        if (preventFallbackOnPartialStream && receivedElements) {
          return fail16(error);
        }
        lastError = some2(error);
        return loop3;
      });
    });
    return loop3;
  }));
  run4 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
  runFold = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhile(self, s, constTrue, f));
  runFoldEffect = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhileEffect(self, s, constTrue, f));
  runFoldScoped = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));
  runFoldScopedEffect = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));
  runFoldWhile = /* @__PURE__ */ dual(4, (self, s, cont, f) => run4(self, fold(s, cont, f)));
  runFoldWhileEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => run4(self, foldEffect(s, cont, f)));
  runFoldWhileScoped = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(fold(s, cont, f))));
  runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(foldEffect(s, cont, f))));
  runForEach = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEach10(f)));
  runForEachChunk = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEachChunk(f)));
  runForEachChunkScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachChunk(f))));
  runForEachScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEach10(f))));
  runForEachWhile = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEachWhile(f)));
  runForEachWhileScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachWhile(f))));
  runIntoPubSub = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
  runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
  runIntoQueue = /* @__PURE__ */ dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped3));
  runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap14(fromEffect5(offerAll3(queue, map4(input, succeed3))), () => writer),
      onFailure: (cause3) => fromEffect5(offer3(queue, failCause3(map13(cause3, some2)))),
      onDone: () => fromEffect5(offer3(queue, fail4(none2())))
    });
    return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid4);
  });
  runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap14(write(chunk2(input)), () => writer),
      onFailure: (cause3) => write(failCause12(cause3)),
      onDone: () => write(end4)
    });
    return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid4);
  });
  runScoped2 = /* @__PURE__ */ dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
  scan = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, scanEffect(s, (s2, a) => succeed10(f(s2, a)))));
  scanReduce = /* @__PURE__ */ dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed10(f(a2, a)))));
  scanReduceEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapAccumEffect(none2(), (option3, a) => {
    switch (option3._tag) {
      case "None": {
        return succeed10([some2(a), a]);
      }
      case "Some": {
        return pipe(f(option3.value, a), map17((b) => [some2(b), b]));
      }
    }
  })));
  schedule2 = /* @__PURE__ */ dual(2, (self, schedule3) => filterMap8(scheduleWith(self, schedule3, {
    onElement: some2,
    onSchedule: none2
  }), identity));
  scheduleWith = /* @__PURE__ */ dual(3, (self, schedule3, options) => {
    const loop3 = (driver3, iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (chunk3) => loop3(driver3, chunk3[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeedNow
        });
      }
      return unwrap(matchEffect2(driver3.next(next4.value), {
        onFailure: () => pipe(driver3.last, orDie3, map17((b) => pipe(write(make7(options.onElement(next4.value), options.onSchedule(b))), flatMap14(() => loop3(driver3, iterator)))), zipLeft5(driver3.reset)),
        onSuccess: () => succeed10(pipe(write(of2(options.onElement(next4.value))), flatMap14(() => loop3(driver3, iterator))))
      }));
    };
    return new StreamImpl(pipe(fromEffect5(driver2(schedule3)), flatMap14((driver3) => pipe(toChannel2(self), pipeTo(loop3(driver3, empty5()[Symbol.iterator]()))))));
  });
  scanEffect = /* @__PURE__ */ dual(3, (self, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap14(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map17((s3) => [s3, s3])))))))));
  someOrElse = /* @__PURE__ */ dual(2, (self, fallback) => pipe(self, map23(getOrElse(fallback))));
  someOrFail = /* @__PURE__ */ dual(2, (self, error) => mapEffectSequential(self, match2({
    onNone: () => failSync4(error),
    onSome: succeed10
  })));
  sliding7 = /* @__PURE__ */ dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
  slidingSize = /* @__PURE__ */ dual(3, (self, chunkSize, stepSize) => {
    if (chunkSize <= 0 || stepSize <= 0) {
      return die11(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
    }
    return new StreamImpl(suspend5(() => {
      const queue = new RingBuffer(chunkSize);
      const emitOnStreamEnd = (queueSize, channelEnd) => {
        if (queueSize < chunkSize) {
          const items = queue.toChunk();
          const result2 = isEmpty(items) ? empty5() : of2(items);
          return pipe(write(result2), flatMap14(() => channelEnd));
        }
        const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
        if (lastEmitIndex === queueSize) {
          return channelEnd;
        }
        const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
        const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
        const result = isEmpty(lastItems) ? empty5() : of2(lastItems);
        return pipe(write(result), flatMap14(() => channelEnd));
      };
      const reader = (queueSize) => readWithCause({
        onInput: (input) => flatMap14(write(filterMap3(input, (element, index) => {
          queue.put(element);
          const currentIndex = queueSize + index + 1;
          if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
            return none2();
          }
          return some2(queue.toChunk());
        })), () => reader(queueSize + input.length)),
        onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause11(cause3)),
        onDone: () => emitOnStreamEnd(queueSize, void_7)
      });
      return pipe(toChannel2(self), pipeTo(reader(0)));
    }));
  });
  split2 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const split3 = (leftovers, input) => {
      const [chunk3, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
      if (isEmpty(chunk3) || isEmpty(remaining)) {
        return loop3(pipe(chunk3, appendAll2(pipe(remaining, drop2(1)))));
      }
      return pipe(write(of2(chunk3)), flatMap14(() => split3(empty5(), pipe(remaining, drop2(1)))));
    };
    const loop3 = (leftovers) => readWith({
      onInput: (input) => split3(leftovers, input),
      onFailure: fail12,
      onDone: () => {
        if (isEmpty(leftovers)) {
          return void_7;
        }
        if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
          return zipRight7(write(of2(leftovers)), void_7);
        }
        return zipRight7(split3(empty5(), leftovers), void_7);
      }
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()))));
  });
  splitOnChunk = /* @__PURE__ */ dual(2, (self, delimiter) => {
    const next4 = (leftover, delimiterIndex) => readWithCause({
      onInput: (inputChunk) => {
        let buffer2;
        const [carry, delimiterCursor] = pipe(inputChunk, reduce3([pipe(leftover, getOrElse(() => empty5())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
          const concatenated = pipe(carry2, append2(a));
          if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
            if (delimiterCursor2 + 1 === delimiter.length) {
              if (buffer2 === undefined) {
                buffer2 = [];
              }
              buffer2.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
              return [empty5(), 0];
            }
            return [concatenated, delimiterCursor2 + 1];
          }
          return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
        }));
        const output = buffer2 === undefined ? empty5() : unsafeFromArray(buffer2);
        return flatMap14(write(output), () => next4(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
      },
      onFailure: (cause3) => match2(leftover, {
        onNone: () => failCause11(cause3),
        onSome: (chunk3) => zipRight7(write(of2(chunk3)), failCause11(cause3))
      }),
      onDone: (done12) => match2(leftover, {
        onNone: () => succeed12(done12),
        onSome: (chunk3) => zipRight7(write(of2(chunk3)), succeed12(done12))
      })
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(next4(none2(), 0))));
  });
  take7 = /* @__PURE__ */ dual(2, (self, n) => {
    if (!Number.isInteger(n)) {
      return die11(new IllegalArgumentException2(`${n} must be an integer`));
    }
    const loop3 = (n2) => readWith({
      onInput: (input) => {
        const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
        const leftover = Math.max(0, n2 - taken.length);
        const more = leftover > 0;
        if (more) {
          return pipe(write(taken), flatMap14(() => loop3(leftover)));
        }
        return write(taken);
      },
      onFailure: fail12,
      onDone: succeed12
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop3(n) : void_7)));
  });
  takeRight2 = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return empty35;
    }
    return new StreamImpl(pipe(succeed10(new RingBuffer(n)), map17((queue) => {
      const reader = readWith({
        onInput: (input) => {
          for (const element of input) {
            queue.put(element);
          }
          return reader;
        },
        onFailure: fail12,
        onDone: () => pipe(write(queue.toChunk()), zipRight7(void_7))
      });
      return pipe(toChannel2(self), pipeTo(reader));
    }), unwrap));
  });
  takeUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile((a) => !predicate(a)));
        const last5 = pipe(input, drop2(taken.length), take(1));
        if (isEmpty(last5)) {
          return pipe(write(taken), flatMap14(() => loop3));
        }
        return write(pipe(taken, appendAll2(last5)));
      },
      onFailure: fail12,
      onDone: succeed12
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  takeUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = (iterator) => {
      const next4 = iterator.next();
      if (next4.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause11,
          onDone: succeed12
        });
      }
      return pipe(predicate(next4.value), map17((bool) => bool ? write(of2(next4.value)) : pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator)))), unwrap);
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]()))));
  });
  takeWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile(predicate));
        const more = taken.length === input.length;
        if (more) {
          return pipe(write(taken), flatMap14(() => loop3));
        }
        return write(taken);
      },
      onFailure: fail12,
      onDone: succeed12
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  tap7 = /* @__PURE__ */ dual(2, (self, f) => mapEffectSequential(self, (a) => as5(f(a), a)));
  tapBoth3 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, tapError5(options.onFailure), tap7(options.onSuccess)));
  tapError5 = /* @__PURE__ */ dual(2, (self, f) => catchAll7(self, (error) => fromEffect8(zipRight6(f(error), fail10(error)))));
  tapErrorCause5 = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = readWithCause({
      onInput: (chunk3) => flatMap14(write(chunk3), () => loop3),
      onFailure: (cause3) => fromEffect5(zipRight6(f(cause3), failCause9(cause3))),
      onDone: succeedNow
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  tapSink = /* @__PURE__ */ dual(2, (self, sink) => pipe(fromEffect8(all7([bounded5(1), make19()])), flatMap17(([queue, deferred]) => {
    const right3 = flattenTake(fromQueue2(queue, {
      maxChunkSize: 1
    }));
    const loop3 = readWithCause({
      onInput: (chunk3) => pipe(fromEffect5(offer3(queue, chunk2(chunk3))), foldCauseChannel({
        onFailure: () => flatMap14(write(chunk3), () => identityChannel()),
        onSuccess: () => flatMap14(write(chunk3), () => loop3)
      })),
      onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause12(cause3))), foldCauseChannel({
        onFailure: () => failCause11(cause3),
        onSuccess: () => failCause11(cause3)
      })),
      onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
        onFailure: () => void_7,
        onSuccess: () => void_7
      }))
    });
    return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop3), ensuring4(zipRight6(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run4(right3, sink), ensuring3(zipRight6(shutdown4(queue), succeed2(deferred, undefined)))))));
  })));
  throttle = /* @__PURE__ */ dual(2, (self, options) => throttleEffect(self, {
    ...options,
    cost: (chunk3) => succeed10(options.cost(chunk3))
  }));
  throttleEffect = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.strategy === "enforce") {
      return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
    }
    return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  });
  timeout3 = /* @__PURE__ */ dual(2, (self, duration3) => pipe(toPull2(self), map17(timeoutFail2({
    onTimeout: () => none2(),
    duration: duration3
  })), fromPull2));
  timeoutFail3 = /* @__PURE__ */ dual(3, (self, error, duration3) => pipe(self, timeoutTo3(duration3, failSync8(error))));
  timeoutFailCause3 = /* @__PURE__ */ dual(3, (self, cause3, duration3) => pipe(toPull2(self), map17(timeoutFailCause2({
    onTimeout: () => map13(cause3(), some2),
    duration: duration3
  })), fromPull2));
  timeoutTo3 = /* @__PURE__ */ dual(3, (self, duration3, that) => {
    const StreamTimeout = new RuntimeException2("Stream Timeout");
    return pipe(self, timeoutFailCause3(() => die5(StreamTimeout), duration3), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== undefined && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
  });
  toPubSub2 = /* @__PURE__ */ dual(2, (self, capacity8) => pipe(acquireRelease2(pubsubFromOptions(capacity8), (pubsub) => shutdown3(pubsub)), tap4((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped2))));
  toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap4(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
  toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap4(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self, queue))));
  toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
  toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => map17(runtime3(), (runtime4) => toReadableStreamRuntime(self, runtime4, options)));
  toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime4, options) => {
    const runFork4 = runFork3(runtime4);
    let currentResolve = undefined;
    let fiber = undefined;
    const latch = unsafeMakeLatch2(false);
    return new ReadableStream({
      start(controller) {
        fiber = runFork4(runForEachChunk(self, (chunk3) => {
          if (chunk3.length === 0)
            return _void;
          return latch.whenOpen(sync5(() => {
            latch.unsafeClose();
            for (const item of chunk3) {
              controller.enqueue(item);
            }
            currentResolve();
            currentResolve = undefined;
          }));
        }));
        fiber.addObserver((exit3) => {
          try {
            if (exit3._tag === "Failure") {
              controller.error(squash(exit3.cause));
            } else {
              controller.close();
            }
          } catch {}
        });
      },
      pull() {
        return new Promise((resolve) => {
          currentResolve = resolve;
          runSync(latch.open);
        });
      },
      cancel() {
        if (!fiber)
          return;
        return runPromise(asVoid4(interrupt6(fiber)));
      }
    }, options?.strategy);
  });
  transduce = /* @__PURE__ */ dual(2, (self, sink) => {
    const newChannel = suspend5(() => {
      const leftovers = {
        ref: empty5()
      };
      const upstreamDone = {
        ref: false
      };
      const buffer2 = suspend5(() => {
        const leftover = leftovers.ref;
        if (isEmpty(leftover)) {
          return readWith({
            onInput: (input) => pipe(write(input), flatMap14(() => buffer2)),
            onFailure: fail12,
            onDone: succeedNow
          });
        }
        leftovers.ref = empty5();
        return pipe(writeChunk(leftover), flatMap14(() => buffer2));
      });
      const concatAndGet = (chunk3) => {
        const leftover = leftovers.ref;
        const concatenated = appendAll2(leftover, filter3(chunk3, (chunk4) => chunk4.length !== 0));
        leftovers.ref = concatenated;
        return concatenated;
      };
      const upstreamMarker = readWith({
        onInput: (input) => flatMap14(write(input), () => upstreamMarker),
        onFailure: fail12,
        onDone: (done12) => zipRight7(sync7(() => {
          upstreamDone.ref = true;
        }), succeedNow(done12))
      });
      const transducer = pipe(sink, toChannel, collectElements, flatMap14(([leftover, z]) => pipe(succeed12([upstreamDone.ref, concatAndGet(leftover)]), flatMap14(([done12, newLeftovers]) => {
        const nextChannel = done12 && isEmpty(newLeftovers) ? void_7 : transducer;
        return pipe(write(of2(z)), flatMap14(() => nextChannel));
      }))));
      return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer2), pipeToOrFail(transducer));
    });
    return new StreamImpl(newChannel);
  });
  toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime4) => {
    const runFork4 = runFork3(runtime4);
    return {
      [Symbol.asyncIterator]() {
        let currentResolve = undefined;
        let currentReject = undefined;
        let fiber = undefined;
        const latch = unsafeMakeLatch2(false);
        return {
          next() {
            if (!fiber) {
              fiber = runFork4(runForEach(self, (value) => latch.whenOpen(sync5(() => {
                latch.unsafeClose();
                currentResolve({
                  done: false,
                  value
                });
                currentResolve = currentReject = undefined;
              }))));
              fiber.addObserver((exit3) => {
                fiber = runFork2(latch.whenOpen(sync5(() => {
                  if (exit3._tag === "Failure") {
                    currentReject(squash(exit3.cause));
                  } else {
                    currentResolve({
                      done: true,
                      value: undefined
                    });
                  }
                  currentResolve = currentReject = undefined;
                })));
              });
            }
            return new Promise((resolve, reject) => {
              currentResolve = resolve;
              currentReject = reject;
              latch.unsafeOpen();
            });
          },
          return() {
            if (!fiber)
              return Promise.resolve({
                done: true,
                value: undefined
              });
            return runPromise(as5(interrupt6(fiber), {
              done: true,
              value: undefined
            }));
          }
        };
      }
    };
  });
  void_9 = /* @__PURE__ */ succeed16(undefined);
  updateService4 = /* @__PURE__ */ dual(3, (self, tag, f) => pipe(self, mapInputContext6((context6) => pipe(context6, add2(tag, f(pipe(context6, unsafeGet3(tag))))))));
  when3 = /* @__PURE__ */ dual(2, (self, test) => pipe(self, whenEffect3(sync5(test))));
  whenCaseEffect = /* @__PURE__ */ dual(2, (self, pf) => pipe(fromEffect8(self), flatMap17((a) => pipe(pf(a), getOrElse(() => empty35)))));
  whenEffect3 = /* @__PURE__ */ dual(2, (self, effect4) => pipe(fromEffect8(effect4), flatMap17((bool) => bool ? self : empty35)));
  zip9 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [a, a2])));
  zipFlatten = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [...a, a2])));
  zipAll = /* @__PURE__ */ dual(2, (self, options) => zipAllWith(self, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2]
  }));
  zipAllLeft = /* @__PURE__ */ dual(3, (self, other, defaultSelf) => zipAllWith(self, {
    other,
    onSelf: identity,
    onOther: () => defaultSelf,
    onBoth: (a) => a
  }));
  zipAllRight = /* @__PURE__ */ dual(3, (self, other, defaultRight) => zipAllWith(self, {
    other,
    onSelf: () => defaultRight,
    onOther: identity,
    onBoth: (_, a2) => a2
  }));
  zipAllSortedByKey = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2],
    order: options.order
  }));
  zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: identity,
    onOther: () => options.defaultSelf,
    onBoth: (a) => a,
    order: options.order
  }));
  zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: () => options.defaultOther,
    onOther: identity,
    onBoth: (_, a2) => a2,
    order: options.order
  }));
  zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return pipe(pullLeft, match14({
            onFailure: fail4,
            onSuccess: (leftChunk) => succeed3([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
          }));
        }
        case OP_DRAIN_RIGHT: {
          return pipe(pullRight, match14({
            onFailure: fail4,
            onSuccess: (rightChunk) => succeed3([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
          }));
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed10(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed10(succeed3(merge10(leftOption.value, rightOption.value)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                if (isEmpty(leftOption.value)) {
                  return pull(DrainLeft, pullLeft, pullRight);
                }
                return succeed10(succeed3([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(rightOption.value)) {
                  return pull(DrainRight, pullLeft, pullRight);
                }
                return succeed10(succeed3([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
              }
              return succeed10(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed10(succeed3([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
              onSome: (error) => succeed10(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed10(succeed3(merge10(leftChunk, state.rightChunk)))
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed10(succeed3([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
              onSome: (error) => succeed10(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed10(succeed3(merge10(state.leftChunk, rightChunk)))
          });
        }
      }
    };
    const merge10 = (leftChunk, rightChunk) => {
      const hasNext = (chunk3, index) => index < chunk3.length - 1;
      const builder = [];
      let state = undefined;
      let leftIndex = 0;
      let rightIndex = 0;
      let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
      let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
      let k1 = leftTuple[0];
      let a = leftTuple[1];
      let k2 = rightTuple[0];
      let a2 = rightTuple[1];
      let loop3 = true;
      while (loop3) {
        const compare = options.order(k1, k2);
        if (compare === 0) {
          builder.push([k1, options.onBoth(a, a2)]);
          if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
            leftIndex = leftIndex + 1;
            rightIndex = rightIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else if (hasNext(leftChunk, leftIndex)) {
            state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
            loop3 = false;
          } else if (hasNext(rightChunk, rightIndex)) {
            state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
            loop3 = false;
          } else {
            state = PullBoth;
            loop3 = false;
          }
        } else if (compare < 0) {
          builder.push([k1, options.onSelf(a)]);
          if (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
          } else {
            const rightBuilder = [];
            rightBuilder.push(rightTuple);
            while (hasNext(rightChunk, rightIndex)) {
              rightIndex = rightIndex + 1;
              rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
              rightBuilder.push(rightTuple);
            }
            state = PullLeft(unsafeFromArray(rightBuilder));
            loop3 = false;
          }
        } else {
          builder.push([k2, options.onOther(a2)]);
          if (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else {
            const leftBuilder = [];
            leftBuilder.push(leftTuple);
            while (hasNext(leftChunk, leftIndex)) {
              leftIndex = leftIndex + 1;
              leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
              leftBuilder.push(leftTuple);
            }
            state = PullRight(unsafeFromArray(leftBuilder));
            loop3 = false;
          }
        }
      }
      return [unsafeFromArray(builder), state];
    };
    return combineChunks(self, options.other, PullBoth, pull);
  });
  zipAllWith = /* @__PURE__ */ dual(2, (self, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed10(fail4(error)),
            onSuccess: (leftChunk) => succeed10(succeed3([map4(leftChunk, options.onSelf), DrainLeft]))
          });
        }
        case OP_DRAIN_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed10(fail4(error)),
            onSuccess: (rightChunk) => succeed10(succeed3([map4(rightChunk, options.onOther), DrainRight]))
          });
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed10(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed10(succeed3(zip10(leftOption.value, rightOption.value, options.onBoth)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                return succeed10(succeed3([map4(leftOption.value, options.onSelf), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                return succeed10(succeed3([map4(rightOption.value, options.onOther), DrainRight]));
              }
              return succeed10(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed10(succeed3([map4(state.rightChunk, options.onOther), DrainRight])),
              onSome: (error) => succeed10(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight(leftChunk), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip10(leftChunk, state.rightChunk, options.onBoth)));
            }
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed10(succeed3([map4(state.leftChunk, options.onSelf), DrainLeft])),
              onSome: (error) => succeed10(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft(rightChunk), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip10(state.leftChunk, rightChunk, options.onBoth)));
            }
          });
        }
      }
    };
    const zip10 = (leftChunk, rightChunk, f) => {
      const [output, either7] = zipChunks(leftChunk, rightChunk, f);
      switch (either7._tag) {
        case "Left": {
          if (isEmpty(either7.left)) {
            return [output, PullBoth];
          }
          return [output, PullRight(either7.left)];
        }
        case "Right": {
          if (isEmpty(either7.right)) {
            return [output, PullBoth];
          }
          return [output, PullLeft(either7.right)];
        }
      }
    };
    return combineChunks(self, options.other, PullBoth, pull);
  });
  zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
  zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
    const pullNonEmpty = (pull) => pipe(pull, flatMap12((chunk3) => isEmpty(chunk3) ? pullNonEmpty(pull) : succeed10(chunk3)));
    return pipe(toPull2(left3), map17(pullNonEmpty), zip7(pipe(toPull2(right3), map17(pullNonEmpty))), flatMap12(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
      onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith9(join4(rightFiber), (l, r) => [l, r, true])),
      onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith9(join4(leftFiber), (l, r) => [r, l, false]))
    })), flatMap17(([l, r, leftFirst]) => pipe(fromEffect8(make29([unsafeLast(l), unsafeLast(r)])), flatMap17((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
      onLeft: (leftChunk) => pipe(modify6(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
      onRight: (rightChunk) => pipe(modify6(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
    })), flatMap17(fromChunk))))))), toPull2)), fromPull2);
  });
  zipLeft8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
    }
    return [left4, right2(pipe(right4, drop2(left4.length)))];
  })));
  zipRight11 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [right4, left2(pipe(left4, take(right4.length)))];
    }
    return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
  })));
  zipWith14 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
  zipWithChunks = /* @__PURE__ */ dual(3, (self, that, f) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_PULL_BOTH2: {
          return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed10(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth2, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight2(leftOption.value), pullLeft, pullRight);
                }
                return succeed10(succeed3(zip10(leftOption.value, rightOption.value)));
              }
              return succeed10(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT2: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed10(fail4(error)),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight2(leftChunk), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip10(leftChunk, state.rightChunk)));
            }
          });
        }
        case OP_PULL_RIGHT2: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed10(fail4(error)),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft2(rightChunk), pullLeft, pullRight);
              }
              return succeed10(succeed3(zip10(state.leftChunk, rightChunk)));
            }
          });
        }
      }
    };
    const zip10 = (leftChunk, rightChunk) => {
      const [output, either7] = f(leftChunk, rightChunk);
      switch (either7._tag) {
        case "Left": {
          if (isEmpty(either7.left)) {
            return [output, PullBoth2];
          }
          return [output, PullRight2(either7.left)];
        }
        case "Right": {
          if (isEmpty(either7.right)) {
            return [output, PullBoth2];
          }
          return [output, PullLeft2(either7.right)];
        }
      }
    };
    return pipe(self, combineChunks(that, PullBoth2, pull));
  });
  Do4 = /* @__PURE__ */ succeed16({});
  bind5 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag, f, options) => flatMap17(self, (k) => map23(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  bindTo5 = /* @__PURE__ */ bindTo(map23);
  let_5 = /* @__PURE__ */ let_(map23);
  decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend9(() => {
    const decoder = new TextDecoder(encoding);
    return map23(self, (s) => decoder.decode(s));
  }));
});

// ../../node_modules/effect/dist/esm/Channel.js
var init_Channel = __esm(() => {
  init_channel();
  init_core_stream();
  init_sink();
  init_stream();
});

// ../../node_modules/effect/dist/esm/ChildExecutorDecision.js
var init_ChildExecutorDecision = __esm(() => {
  init_childExecutorDecision();
});

// ../../node_modules/effect/dist/esm/ConfigError.js
var init_ConfigError = __esm(() => {
  init_configError();
});

// ../../node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted", redactedRegistry, RedactedTypeId, proto12, isRedacted = (u) => hasProperty(u, RedactedTypeId);
var init_redacted = __esm(() => {
  init_Equal();
  init_Function();
  init_GlobalValue();
  init_Hash();
  init_Inspectable();
  init_Pipeable();
  init_Predicate();
  redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => new WeakMap);
  RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
  proto12 = {
    [RedactedTypeId]: {
      _A: (_) => _
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return "<redacted>";
    },
    toJSON() {
      return "<redacted>";
    },
    [NodeInspectSymbol]() {
      return "<redacted>";
    },
    [symbol]() {
      return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
    },
    [symbol2](that) {
      return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret", SecretTypeId, SecretProto;
var init_secret = __esm(() => {
  init_Array();
  init_Predicate();
  init_redacted();
  SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
  SecretProto = {
    ...proto12,
    [SecretTypeId]: SecretTypeId
  };
});

// ../../node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config", ConfigTypeId, configVariance, proto13;
var init_config2 = __esm(() => {
  init_Chunk();
  init_ConfigError();
  init_Duration();
  init_Either();
  init_Function();
  init_HashSet();
  init_Option();
  init_Predicate();
  init_configError();
  init_core();
  init_defaultServices();
  init_effectable();
  init_redacted();
  init_secret();
  ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
  configVariance = {
    _A: (_) => _
  };
  proto13 = {
    ...CommitPrototype,
    [ConfigTypeId]: configVariance,
    commit() {
      return config(this);
    }
  };
});

// ../../node_modules/effect/dist/esm/Config.js
var init_Config = __esm(() => {
  init_config2();
});

// ../../node_modules/effect/dist/esm/ConfigProvider.js
var init_ConfigProvider = __esm(() => {
  init_configProvider();
});

// ../../node_modules/effect/dist/esm/ConfigProviderPathPatch.js
var init_ConfigProviderPathPatch = __esm(() => {
  init_pathPatch();
});

// ../../node_modules/effect/dist/esm/Console.js
var init_Console = __esm(() => {
  init_console2();
  init_console();
});

// ../../node_modules/effect/dist/esm/DateTime.js
var init_DateTime = __esm(() => {
  init_Context();
  init_Effect();
  init_Function();
  init_dateTime();
  init_Layer();
});

// ../../node_modules/effect/dist/esm/DefaultServices.js
var init_DefaultServices = __esm(() => {
  init_defaultServices();
});

// ../../node_modules/effect/dist/esm/internal/encoding/common.js
var init_common = __esm(() => {
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/internal/encoding/base64.js
var init_base64 = __esm(() => {
  init_Either();
  init_common();
});

// ../../node_modules/effect/dist/esm/internal/encoding/base64Url.js
var init_base64Url = __esm(() => {
  init_Either();
  init_base64();
  init_common();
});

// ../../node_modules/effect/dist/esm/internal/encoding/hex.js
var init_hex = __esm(() => {
  init_Either();
  init_common();
});

// ../../node_modules/effect/dist/esm/Encoding.js
var init_Encoding = __esm(() => {
  init_Either();
  init_base64();
  init_base64Url();
  init_common();
  init_hex();
});

// ../../node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId22, Proto3, makeProto = (steps) => {
  const self = Object.create(Proto3);
  self.steps = steps;
  return self;
};
var init_ExecutionPlan = __esm(() => {
  init_Effect();
  init_executionPlan();
  init_Layer();
  init_Pipeable();
  TypeId22 = TypeId20;
  Proto3 = {
    [TypeId22]: TypeId22,
    get withRequirements() {
      const self = this;
      return contextWith2((context7) => makeProto(self.steps.map((step4) => ({
        ...step4,
        provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context7)) : step4.provide
      }))));
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/FiberHandle.js
var TypeId23, Proto4;
var init_FiberHandle = __esm(() => {
  init_Cause();
  init_Deferred();
  init_Effect();
  init_Exit();
  init_Fiber();
  init_FiberId();
  init_Function();
  init_HashSet();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Runtime();
  TypeId23 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
  Proto4 = {
    [TypeId23]: TypeId23,
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberHandle",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/FiberMap.js
var TypeId24, Proto5;
var init_FiberMap = __esm(() => {
  init_Cause();
  init_Deferred();
  init_Effect();
  init_Exit();
  init_Fiber();
  init_FiberId();
  init_Function();
  init_HashSet();
  init_Inspectable();
  init_Iterable();
  init_MutableHashMap();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Runtime();
  TypeId24 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
  Proto5 = {
    [TypeId24]: TypeId24,
    [Symbol.iterator]() {
      if (this.state._tag === "Closed") {
        return empty();
      }
      return this.state.backing[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberMap",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/FiberSet.js
var TypeId25, Proto6;
var init_FiberSet = __esm(() => {
  init_Cause();
  init_Deferred();
  init_Effect();
  init_Exit();
  init_Fiber();
  init_FiberId();
  init_Function();
  init_HashSet();
  init_Inspectable();
  init_Iterable();
  init_Pipeable();
  init_Predicate();
  init_Runtime();
  TypeId25 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
  Proto6 = {
    [TypeId25]: TypeId25,
    [Symbol.iterator]() {
      if (this.state._tag === "Closed") {
        return empty();
      }
      return this.state.backing[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberMap",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy", GroupByTypeId, groupByVariance, isGroupBy = (u) => hasProperty(u, GroupByTypeId), evaluate2, make59 = (grouped2) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped2
}), groupBy, mapEffectOptions, bindEffect, mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f), MapDequeue, groupByKey, groupByIterable;
var init_groupBy = __esm(() => {
  init_Cause();
  init_Chunk();
  init_Deferred();
  init_Effect();
  init_Effectable();
  init_Exit();
  init_Function();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_Queue();
  init_Ref();
  init_Scope();
  init_channel();
  init_channelExecutor();
  init_core_stream();
  init_stream();
  init_take();
  GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
  groupByVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _K: (_) => _,
    _V: (_) => _
  };
  evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self, f, options) => flatMap17(self.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
    shutdown: true
  }))), {
    concurrency: "unbounded",
    bufferSize: options?.bufferSize ?? 16
  }));
  groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => make59(unwrapScoped4(gen3(function* () {
    const decider = yield* make19();
    const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
    const ref = yield* make29(new Map);
    const add7 = yield* pipe(mapEffectSequential(self, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap12(_await(decider), (f2) => f2(key, value)), (exit3) => offer3(output, exit3)));
    yield* succeed2(decider, (key, _) => pipe(get12(ref), map17((map26) => fromNullable(map26.get(key))), flatMap12(match2({
      onNone: () => flatMap12(add7, ([index, queue]) => zipRight6(update3(ref, (map26) => map26.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map11((tuple4) => of2(tuple4[1])))))])), as5((n) => n === index)))),
      onSome: (index) => succeed10((n) => n === index)
    }))));
    return flattenExitOption(fromQueue2(output, {
      shutdown: true
    }));
  }))));
  mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
    if (options?.key) {
      return evaluate2(groupByKey(self, options.key, {
        bufferSize: options.bufferSize
      }), (_, s) => mapEffectSequential(s, f));
    }
    return matchConcurrency(options?.concurrency, () => mapEffectSequential(self, f), (n) => options?.unordered ? flatMap17(self, (a) => fromEffect8(f(a)), {
      concurrency: n
    }) : mapEffectPar(self, n, f));
  });
  bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag, f, options) => mapEffectOptions(self, (k) => map17(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  MapDequeue = class MapDequeue extends Class {
    dequeue;
    f;
    [DequeueTypeId2] = {
      _Out: (_) => _
    };
    constructor(dequeue, f) {
      super();
      this.dequeue = dequeue;
      this.f = f;
    }
    capacity() {
      return capacity5(this.dequeue);
    }
    get size() {
      return size15(this.dequeue);
    }
    unsafeSize() {
      return this.dequeue.unsafeSize();
    }
    get awaitShutdown() {
      return awaitShutdown4(this.dequeue);
    }
    isActive() {
      return this.dequeue.isActive();
    }
    get isShutdown() {
      return isShutdown4(this.dequeue);
    }
    get shutdown() {
      return shutdown4(this.dequeue);
    }
    get isFull() {
      return isFull4(this.dequeue);
    }
    get isEmpty() {
      return isEmpty13(this.dequeue);
    }
    get take() {
      return pipe(take3(this.dequeue), map17((a) => this.f(a)));
    }
    get takeAll() {
      return pipe(takeAll2(this.dequeue), map17(map4((a) => this.f(a))));
    }
    takeUpTo(max6) {
      return pipe(takeUpTo2(this.dequeue, max6), map17(map4((a) => this.f(a))));
    }
    takeBetween(min4, max6) {
      return pipe(takeBetween2(this.dequeue, min4, max6), map17(map4((a) => this.f(a))));
    }
    takeN(n) {
      return pipe(takeN2(this.dequeue, n), map17(map4((a) => this.f(a))));
    }
    poll() {
      return pipe(poll6(this.dequeue), map17(map2((a) => this.f(a))));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
  };
  groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
    const loop3 = (map26, outerQueue) => readWithCause({
      onInput: (input) => flatMap14(fromEffect5(forEach9(groupByIterable(input, f), ([key, values4]) => {
        const innerQueue = map26.get(key);
        if (innerQueue === undefined) {
          return pipe(bounded5(options?.bufferSize ?? 16), flatMap12((innerQueue2) => pipe(sync5(() => {
            map26.set(key, innerQueue2);
          }), zipRight6(offer3(outerQueue, of5([key, innerQueue2]))), zipRight6(pipe(offer3(innerQueue2, chunk2(values4)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
        }
        return catchSomeCause2(offer3(innerQueue, chunk2(values4)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
      }, {
        discard: true
      })), () => loop3(map26, outerQueue)),
      onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause12(cause3))),
      onDone: () => pipe(fromEffect5(pipe(forEach9(map26.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
        discard: true
      }), zipRight6(offer3(outerQueue, end4)))))
    });
    return make59(unwrapScopedWith3((scope5) => gen3(function* () {
      const map26 = new Map;
      const queue = yield* unbounded5();
      yield* addFinalizer2(scope5, shutdown4(queue));
      return yield* toChannel2(self).pipe(pipeTo(loop3(map26, queue)), drain, runIn(scope5), forkIn2(scope5), as5(flattenTake(fromQueue2(queue, {
        shutdown: true
      }))));
    })));
  });
  groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
    const builder = [];
    const iterator = iterable[Symbol.iterator]();
    const map26 = new Map;
    let next4;
    while ((next4 = iterator.next()) && !next4.done) {
      const value = next4.value;
      const key = f(value);
      if (map26.has(key)) {
        const innerBuilder = map26.get(key);
        innerBuilder.push(value);
      } else {
        const innerBuilder = [value];
        builder.push([key, innerBuilder]);
        map26.set(key, innerBuilder);
      }
    }
    return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
  });
});

// ../../node_modules/effect/dist/esm/GroupBy.js
var init_GroupBy = __esm(() => {
  init_groupBy();
});

// ../../node_modules/effect/dist/esm/HKT.js
var init_HKT = () => {};

// ../../node_modules/effect/dist/esm/ParseResult.js
class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var ParseErrorTypeId2, ParseError2, parseError = (issue) => new ParseError2({
  issue
}), succeed18, fail18, isEither4, flatMap18, map26, mapError7, orElse12, mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
}, getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
}, getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
}, validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options), decodeMemoMap, encodeMemoMap, goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse12(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
}, getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast)), getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast)), go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap18(orElse12(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap18(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap18(mapError7(from(i, options), (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap18(mapError7(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation(ast, i, "Transformation", e)), (i2) => mapError7(to(i2, options), (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse2 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse2(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head6, ...tail2] = rest;
          for (;i < len - tail2.length; i++) {
            const te = head6(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail2.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail2[j](input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap12(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap12(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is) => [goMemo(is.parameter, isDecoding), goMemo(is.type, isDecoding), is.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is) => is.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither4(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither4(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap12(either4(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap12(either4(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys5 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys5.indexOf(name) === -1) {
                keys5.push(name);
              }
            }
            const out = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap12(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map27 = new Map;
      for (let i = 0;i < astTypesLen; i++) {
        map27.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0;i < ownKeysLen; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map27.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap12(either4(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap12(forEach9(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
}, fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u)), getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
}, getSearchTree = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0;j < tags.length; j++) {
        const [key, literal2] = tags[j];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise,
    candidates
  };
}, dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast, handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect4, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess(exit3)) {
      return right2(exit3.value);
    }
    const cause3 = exit3.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
}, compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0, getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map26(out, f);
        }
        return out;
      };
  }
}, makeTree = (value, forest = []) => ({
  value,
  forest
}), TreeFormatter, drawTree = (tree) => tree.value + draw(`
`, tree.forest), draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
}, formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
}, formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
}, getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2(), Either_void, getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union12 = messageAnnotation(issue);
    if (isString(union12)) {
      return right2({
        message: union12,
        override: false
      });
    }
    if (isEffect2(union12)) {
      return map17(union12, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union12.message)) {
      return right2({
        message: union12.message,
        override: union12.override
      });
    }
    return map17(union12.message, (message) => ({
      message,
      override: union12.override
    }));
  }
})), createParseIssueGuard = (tag) => (issue) => issue._tag === tag, isComposite2, isRefinement2, isTransformation, getMessage = (issue) => flatMap18(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
}), getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined), formatTypeMessage = (issue) => map26(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue)), getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast), formatForbiddenMessage = (issue) => issue.message ?? "is forbidden", formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected", formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
}, formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map26(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map26(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap18(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map26(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap18(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map26(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map26(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap18(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map26(forEach9(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map26(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var init_ParseResult = __esm(() => {
  init_Array();
  init_Cause();
  init_Data();
  init_Effect();
  init_Either();
  init_Exit();
  init_Function();
  init_GlobalValue();
  init_Inspectable();
  init_util2();
  init_Option();
  init_Predicate();
  init_Scheduler();
  init_SchemaAST();
  ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
  ParseError2 = class ParseError2 extends (/* @__PURE__ */ TaggedError("ParseError")) {
    [ParseErrorTypeId2] = ParseErrorTypeId2;
    get message() {
      return this.toString();
    }
    toString() {
      return TreeFormatter.formatIssueSync(this.issue);
    }
    toJSON() {
      return {
        _id: "ParseError",
        message: this.toString()
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  succeed18 = right2;
  fail18 = left2;
  isEither4 = isEither2;
  flatMap18 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? match(self, {
      onLeft: left2,
      onRight: f
    }) : flatMap12(self, f);
  });
  map26 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? map(self, f) : map17(self, f);
  });
  mapError7 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? mapLeft(self, f) : mapError3(self, f);
  });
  orElse12 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? match(self, {
      onLeft: f,
      onRight: right2
    }) : catchAll3(self, f);
  });
  decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
  encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
  TreeFormatter = {
    formatIssue: (issue) => map26(formatTree(issue), drawTree),
    formatIssueSync: (issue) => {
      const e = TreeFormatter.formatIssue(issue);
      return isEither4(e) ? getOrThrow(e) : runSync(e);
    },
    formatError: (error2) => TreeFormatter.formatIssue(error2.issue),
    formatErrorSync: (error2) => TreeFormatter.formatIssueSync(error2.issue)
  };
  Either_void = /* @__PURE__ */ right2(undefined);
  isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
  isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
  isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
});

// ../../node_modules/effect/dist/esm/JSONSchema.js
var init_JSONSchema = __esm(() => {
  init_Array();
  init_errors2();
  init_Option();
  init_ParseResult();
  init_Predicate();
  init_Record();
  init_SchemaAST();
});

// ../../node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId, poolVariance, PoolImpl, reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_2;
});
var init_pool = __esm(() => {
  init_Context();
  init_Duration();
  init_Effectable();
  init_Function();
  init_Iterable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_core_effect();
  init_core();
  init_defaultServices();
  init_circular();
  init_fiberRuntime();
  init_queue();
  PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
  poolVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  PoolImpl = class PoolImpl extends Class {
    scope;
    acquire;
    concurrency;
    minSize;
    maxSize;
    strategy;
    targetUtilization;
    [PoolTypeId];
    isShuttingDown = false;
    semaphore;
    items = /* @__PURE__ */ new Set;
    available = /* @__PURE__ */ new Set;
    availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
    invalidated = /* @__PURE__ */ new Set;
    waiters = 0;
    constructor(scope5, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
      super();
      this.scope = scope5;
      this.acquire = acquire;
      this.concurrency = concurrency;
      this.minSize = minSize;
      this.maxSize = maxSize;
      this.strategy = strategy;
      this.targetUtilization = targetUtilization;
      this[PoolTypeId] = poolVariance;
      this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
    }
    allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit, flatMap9((exit3) => {
      const item = {
        exit: exit3,
        finalizer: catchAllCause(scope5.close(exit3), reportUnhandledError),
        refCount: 0,
        disableReclaim: false
      };
      this.items.add(item);
      this.available.add(item);
      return as2(exit3._tag === "Success" ? this.strategy.onAcquire(item) : zipRight2(item.finalizer, this.strategy.onAcquire(item)), item);
    })), (scope5, exit3) => exit3._tag === "Failure" ? scope5.close(exit3) : void_2);
    get currentUsage() {
      let count5 = this.waiters;
      for (const item of this.items) {
        count5 += item.refCount;
      }
      return count5;
    }
    get targetSize() {
      if (this.isShuttingDown)
        return 0;
      const utilization = this.currentUsage / this.targetUtilization;
      const target = Math.ceil(utilization / this.concurrency);
      return Math.min(Math.max(this.minSize, target), this.maxSize);
    }
    get activeSize() {
      return this.items.size - this.invalidated.size;
    }
    resizeLoop = /* @__PURE__ */ suspend(() => {
      if (this.activeSize >= this.targetSize) {
        return void_2;
      }
      const toAcquire = this.targetSize - this.activeSize;
      return this.strategy.reclaim(this).pipe(flatMap9(match2({
        onNone: () => this.allocate,
        onSome: succeed
      })), replicateEffect(toAcquire, {
        concurrency: toAcquire
      }), zipLeft2(this.availableLatch.open), flatMap9((items) => items.some((_) => _.exit._tag === "Failure") ? void_2 : this.resizeLoop));
    });
    resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
    resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
    getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight2(scopeTag), flatMap9((scope5) => suspend(() => {
      this.waiters++;
      if (this.isShuttingDown) {
        return interrupt2;
      } else if (this.targetSize > this.activeSize) {
        const self = this;
        return flatMap9(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), function loop() {
          if (self.isShuttingDown) {
            return interrupt2;
          } else if (self.available.size > 0) {
            return succeed(unsafeHead(self.available));
          }
          self.availableLatch.unsafeClose();
          return flatMap9(self.availableLatch.await, loop);
        });
      }
      return succeed(unsafeHead(this.available));
    }).pipe(ensuring(sync(() => this.waiters--)), tap2((item) => {
      if (item.exit._tag === "Failure") {
        this.items.delete(item);
        this.invalidated.delete(item);
        this.available.delete(item);
        return this.semaphore.release(1);
      }
      item.refCount++;
      this.available.delete(item);
      if (item.refCount < this.concurrency) {
        this.available.add(item);
      }
      return scope5.addFinalizer(() => zipRight2(suspend(() => {
        item.refCount--;
        if (this.invalidated.has(item)) {
          return this.invalidatePoolItem(item);
        }
        this.available.add(item);
        return exitVoid;
      }), this.semaphore.release(1)));
    }), onInterrupt(() => this.semaphore.release(1))))));
    commit() {
      return this.get;
    }
    get = /* @__PURE__ */ flatMap9(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
    invalidate(item) {
      return suspend(() => {
        if (this.isShuttingDown)
          return void_2;
        for (const poolItem of this.items) {
          if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
            poolItem.disableReclaim = true;
            return uninterruptible(this.invalidatePoolItem(poolItem));
          }
        }
        return void_2;
      });
    }
    invalidatePoolItem(poolItem) {
      return suspend(() => {
        if (!this.items.has(poolItem)) {
          return void_2;
        } else if (poolItem.refCount === 0) {
          this.items.delete(poolItem);
          this.available.delete(poolItem);
          this.invalidated.delete(poolItem);
          return zipRight2(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
        }
        this.invalidated.add(poolItem);
        this.available.delete(poolItem);
        return void_2;
      });
    }
    get shutdown() {
      return suspend(() => {
        if (this.isShuttingDown)
          return void_2;
        this.isShuttingDown = true;
        const size18 = this.items.size;
        const semaphore = unsafeMakeSemaphore(size18);
        return forEachSequentialDiscard(this.items, (item) => {
          if (item.refCount > 0) {
            item.finalizer = zipLeft2(item.finalizer, semaphore.release(1));
            this.invalidated.add(item);
            return semaphore.take(1);
          }
          this.items.delete(item);
          this.available.delete(item);
          this.invalidated.delete(item);
          return item.finalizer;
        }).pipe(zipRight2(this.semaphore.releaseAll), zipRight2(this.availableLatch.open), zipRight2(semaphore.take(size18)));
      });
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/internal/keyedPool.js
var init_keyedPool = __esm(() => {
  init_Duration();
  init_Equal();
  init_Function();
  init_Hash();
  init_HashMap();
  init_MutableRef();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_core();
  init_fiberRuntime();
  init_pool();
});

// ../../node_modules/effect/dist/esm/KeyedPool.js
var init_KeyedPool = __esm(() => {
  init_keyedPool();
});

// ../../node_modules/effect/dist/esm/internal/rcMap.js
var init_rcMap = __esm(() => {
  init_Context();
  init_Duration();
  init_Function();
  init_MutableHashMap();
  init_Pipeable();
  init_core_effect();
  init_core();
  init_circular();
  init_fiberRuntime();
});

// ../../node_modules/effect/dist/esm/RcMap.js
var init_RcMap = __esm(() => {
  init_rcMap();
});

// ../../node_modules/effect/dist/esm/LayerMap.js
var init_LayerMap = __esm(() => {
  init_Context();
  init_Effect();
  init_FiberRefsPatch();
  init_Function();
  init_core();
  init_Layer();
  init_RcMap();
  init_Runtime();
  init_Scope();
});

// ../../node_modules/effect/dist/esm/internal/logger-circular.js
var init_logger_circular = __esm(() => {
  init_Cause();
  init_Function();
  init_HashMap();
  init_List();
  init_core();
  init_fiberId();
  init_fiberRefs();
});

// ../../node_modules/effect/dist/esm/Logger.js
var init_Logger = __esm(() => {
  init_fiberRuntime();
  init_circular3();
  init_logger_circular();
  init_logger();
});

// ../../node_modules/effect/dist/esm/internal/mailbox.js
var init_mailbox = __esm(() => {
  init_Array();
  init_Cause();
  init_Chunk();
  init_Effectable();
  init_Function();
  init_Inspectable();
  init_Iterable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_channel();
  init_channelExecutor();
  init_core_stream();
  init_core();
  init_circular();
  init_fiberRuntime();
  init_stream();
});

// ../../node_modules/effect/dist/esm/Mailbox.js
var init_Mailbox = __esm(() => {
  init_mailbox();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/internal/managedRuntime.js
var ManagedRuntimeProto;
var init_managedRuntime = __esm(() => {
  init_Effectable();
  init_Pipeable();
  init_Predicate();
  init_Scope();
  init_core();
  init_fiberRuntime();
  init_layer();
  init_circular2();
  init_runtime();
  ManagedRuntimeProto = {
    ...CommitPrototype2,
    [TypeId17]: TypeId17,
    pipe() {
      return pipeArguments(this, arguments);
    },
    commit() {
      return this.runtimeEffect;
    }
  };
});

// ../../node_modules/effect/dist/esm/ManagedRuntime.js
var init_ManagedRuntime = __esm(() => {
  init_managedRuntime();
  init_circular2();
});

// ../../node_modules/effect/dist/esm/internal/matcher.js
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
function makeValueMatcher(provided, value) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value;
  return matcher;
}
var TypeId28, TypeMatcherProto, ValueMatcherProto;
var init_matcher = __esm(() => {
  init_Either();
  init_Function();
  init_Option();
  init_Pipeable();
  TypeId28 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
  TypeMatcherProto = {
    [TypeId28]: {
      _input: identity,
      _filters: identity,
      _remaining: identity,
      _result: identity,
      _return: identity
    },
    _tag: "TypeMatcher",
    add(_case2) {
      return makeTypeMatcher([...this.cases, _case2]);
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  ValueMatcherProto = {
    [TypeId28]: {
      _input: identity,
      _filters: identity,
      _remaining: identity,
      _result: identity,
      _provided: identity,
      _return: identity
    },
    _tag: "ValueMatcher",
    add(_case2) {
      if (this.value._tag === "Right") {
        return this;
      }
      if (_case2._tag === "When" && _case2.guard(this.provided) === true) {
        return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
      } else if (_case2._tag === "Not" && _case2.guard(this.provided) === false) {
        return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
      }
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/Match.js
var init_Match = __esm(() => {
  init_matcher();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/MergeState.js
var init_MergeState = __esm(() => {
  init_mergeState();
});

// ../../node_modules/effect/dist/esm/MergeStrategy.js
var init_MergeStrategy = __esm(() => {
  init_mergeStrategy();
});

// ../../node_modules/effect/dist/esm/Metric.js
var init_Metric = __esm(() => {
  init_fiberRuntime();
  init_metric();
});

// ../../node_modules/effect/dist/esm/MetricBoundaries.js
var init_MetricBoundaries = __esm(() => {
  init_boundaries();
});

// ../../node_modules/effect/dist/esm/MetricHook.js
var init_MetricHook = __esm(() => {
  init_hook();
});

// ../../node_modules/effect/dist/esm/MetricKey.js
var init_MetricKey = __esm(() => {
  init_key();
});

// ../../node_modules/effect/dist/esm/MetricKeyType.js
var init_MetricKeyType = __esm(() => {
  init_keyType();
});

// ../../node_modules/effect/dist/esm/MetricLabel.js
var init_MetricLabel = __esm(() => {
  init_label();
});

// ../../node_modules/effect/dist/esm/MetricPair.js
var init_MetricPair = __esm(() => {
  init_pair();
});

// ../../node_modules/effect/dist/esm/internal/metric/polling.js
var init_polling = __esm(() => {
  init_Function();
  init_Pipeable();
  init_core();
  init_metric();
  init_schedule();
});

// ../../node_modules/effect/dist/esm/MetricPolling.js
var init_MetricPolling = __esm(() => {
  init_polling();
});

// ../../node_modules/effect/dist/esm/MetricRegistry.js
var init_MetricRegistry = __esm(() => {
  init_registry();
});

// ../../node_modules/effect/dist/esm/MetricState.js
var init_MetricState = __esm(() => {
  init_state();
});

// ../../node_modules/effect/dist/esm/ModuleVersion.js
var init_ModuleVersion = () => {};

// ../../node_modules/effect/dist/esm/MutableHashSet.js
var TypeId29, MutableHashSetProto;
var init_MutableHashSet = __esm(() => {
  init_Function();
  init_Inspectable();
  init_MutableHashMap();
  init_Pipeable();
  TypeId29 = /* @__PURE__ */ Symbol.for("effect/MutableHashSet");
  MutableHashSetProto = {
    [TypeId29]: TypeId29,
    [Symbol.iterator]() {
      return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableHashSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});
// ../../node_modules/effect/dist/esm/Ordering.js
var init_Ordering = __esm(() => {
  init_Function();
});

// ../../node_modules/effect/dist/esm/Pool.js
var init_Pool = __esm(() => {
  init_pool();
});

// ../../node_modules/effect/dist/esm/Pretty.js
var init_Pretty = __esm(() => {
  init_Array();
  init_errors2();
  init_util2();
  init_Option();
  init_ParseResult();
  init_SchemaAST();
});

// ../../node_modules/effect/dist/esm/PrimaryKey.js
var init_PrimaryKey = () => {};

// ../../node_modules/effect/dist/esm/internal/rateLimiter.js
var init_rateLimiter = __esm(() => {
  init_Duration();
  init_Effect();
  init_FiberRef();
  init_Function();
  init_GlobalValue();
});

// ../../node_modules/effect/dist/esm/RateLimiter.js
var init_RateLimiter = __esm(() => {
  init_rateLimiter();
});

// ../../node_modules/effect/dist/esm/Redacted.js
var init_Redacted = __esm(() => {
  init_Equivalence();
  init_redacted();
});

// ../../node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef", ScopedRefTypeId, scopedRefVariance, proto14, get21 = (self) => map10(get11(self.ref), (tuple4) => tuple4[1]);
var init_scopedRef = __esm(() => {
  init_Context();
  init_Function();
  init_core();
  init_circular();
  init_effectable();
  init_fiberRuntime();
  init_ref();
  init_synchronizedRef();
  ScopedRefTypeId = /* @__PURE__ */ Symbol.for(ScopedRefSymbolKey);
  scopedRefVariance = {
    _A: (_) => _
  };
  proto14 = {
    ...CommitPrototype,
    commit() {
      return get21(this);
    },
    [ScopedRefTypeId]: scopedRefVariance
  };
});

// ../../node_modules/effect/dist/esm/internal/reloadable.js
var init_reloadable = __esm(() => {
  init_Context();
  init_Function();
  init_core_effect();
  init_core();
  init_fiberRuntime();
  init_layer();
  init_schedule();
  init_scopedRef();
});

// ../../node_modules/effect/dist/esm/Reloadable.js
var init_Reloadable = __esm(() => {
  init_reloadable();
});

// ../../node_modules/effect/dist/esm/RequestBlock.js
var init_RequestBlock = __esm(() => {
  init_blockedRequests();
});

// ../../node_modules/effect/dist/esm/internal/dataSource.js
var init_dataSource = __esm(() => {
  init_Array();
  init_Cause();
  init_Chunk();
  init_Effect();
  init_Function();
  init_core();
  init_fiberRuntime();
  init_request();
});

// ../../node_modules/effect/dist/esm/RequestResolver.js
var init_RequestResolver = __esm(() => {
  init_Context();
  init_Effect();
  init_core();
  init_dataSource();
});

// ../../node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource", ResourceTypeId, resourceVariance, proto15, get23 = (self) => flatMap9(get21(self.scopedRef), identity);
var init_resource = __esm(() => {
  init_Function();
  init_core();
  init_effectable();
  init_fiberRuntime();
  init_schedule();
  init_scopedRef();
  ResourceTypeId = /* @__PURE__ */ Symbol.for(ResourceSymbolKey);
  resourceVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  proto15 = {
    ...CommitPrototype,
    commit() {
      return get23(this);
    },
    [ResourceTypeId]: resourceVariance
  };
});

// ../../node_modules/effect/dist/esm/Resource.js
var init_Resource = __esm(() => {
  init_resource();
});

// ../../node_modules/effect/dist/esm/RuntimeFlags.js
var init_RuntimeFlags = __esm(() => {
  init_circular3();
  init_runtimeFlags();
});

// ../../node_modules/effect/dist/esm/STM.js
var init_STM = __esm(() => {
  init_Cause();
  init_Chunk();
  init_core2();
  init_stm();
});

// ../../node_modules/effect/dist/esm/Struct.js
var init_Struct = __esm(() => {
  init_Equivalence();
  init_Function();
  init_Order();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/Schema.js
function make72(ast) {
  return class SchemaClass {
    [TypeId30] = variance10;
    static ast = ast;
    static annotations(annotations2) {
      return make72(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId30] = variance10;
  };
}
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make72(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
function makeRefineClass(from, filter14, ast) {
  return class RefineClass extends make72(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter14;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
function filter14(predicate, annotations2) {
  return (self) => {
    function filter15(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter15, toASTAnnotations(annotations2));
    return makeRefineClass(self, filter15, ast);
  };
}
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var TypeId30, variance10, builtInAnnotations, toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id3 = builtInAnnotations[key];
      out[id3] = annotations2[key];
      delete out[key];
    }
  }
  return out;
}, mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2)), declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make72)), (...typeParameters2) => options.encode(...typeParameters2.map(make72)), toASTAnnotations(annotations2))), declarePrimitive = (is3, annotations2) => {
  const decodeUnknown3 = () => (input, _, ast) => is3(input) ? succeed18(input) : fail18(new Type2(ast, input));
  const encodeUnknown2 = decodeUnknown3;
  return makeDeclareClass([], new Declaration([], decodeUnknown3, encodeUnknown2, toASTAnnotations(annotations2)));
}, declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options, annotations3);
  }
  const is3 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is3, annotations2);
}, String$, RefineSchemaId, fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
}, toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
}, PatternSchemaId, pattern = (regex, annotations2) => (self) => {
  const source = regex.source;
  return self.pipe(filter14((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations2
  }));
}, UUIDSchemaId, uuidRegexp, UUID, DateFromSelfSchemaId2, DateFromSelf;
var init_Schema = __esm(() => {
  init_Array();
  init_BigDecimal();
  init_BigInt();
  init_Boolean();
  init_Cause();
  init_Chunk();
  init_Config();
  init_ConfigError();
  init_Data();
  init_DateTime();
  init_Duration();
  init_Effect();
  init_Either();
  init_Encoding();
  init_Equal();
  init_Equivalence();
  init_Exit();
  init_FastCheck();
  init_FiberId();
  init_Function();
  init_GlobalValue();
  init_HashMap();
  init_HashSet();
  init_cause();
  init_errors2();
  init_schemaId();
  init_util2();
  init_List();
  init_Number();
  init_Option();
  init_ParseResult();
  init_Pipeable();
  init_Predicate();
  init_Redacted();
  init_Request();
  init_Scheduler();
  init_SchemaAST();
  init_SortedSet();
  init_String();
  init_Struct();
  init_ParseResult();
  TypeId30 = /* @__PURE__ */ Symbol.for("effect/Schema");
  variance10 = {
    _A: (_) => _,
    _I: (_) => _,
    _R: (_) => _
  };
  builtInAnnotations = {
    schemaId: SchemaIdAnnotationId,
    message: MessageAnnotationId,
    missingMessage: MissingMessageAnnotationId,
    identifier: IdentifierAnnotationId,
    title: TitleAnnotationId,
    description: DescriptionAnnotationId,
    examples: ExamplesAnnotationId,
    default: DefaultAnnotationId,
    documentation: DocumentationAnnotationId,
    jsonSchema: JSONSchemaAnnotationId,
    arbitrary: ArbitraryAnnotationId,
    pretty: PrettyAnnotationId,
    equivalence: EquivalenceAnnotationId,
    concurrency: ConcurrencyAnnotationId,
    batching: BatchingAnnotationId,
    parseIssueTitle: ParseIssueTitleAnnotationId,
    parseOptions: ParseOptionsAnnotationId,
    decodingFallback: DecodingFallbackAnnotationId
  };
  String$ = class String$ extends (/* @__PURE__ */ make72(stringKeyword)) {
  };
  RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
  PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
  UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
  uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  UUID = class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
    schemaId: UUIDSchemaId,
    identifier: "UUID",
    jsonSchema: {
      format: "uuid",
      pattern: uuidRegexp.source
    },
    description: "a Universally Unique Identifier",
    arbitrary: () => (fc) => fc.uuid()
  }))) {
  };
  DateFromSelfSchemaId2 = DateFromSelfSchemaId;
  DateFromSelf = class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId2,
    [DateFromSelfSchemaId2]: {
      noInvalidDate: false
    },
    description: "a potentially invalid Date instance",
    pretty: () => (date2) => `new Date(${JSON.stringify(date2)})`,
    arbitrary: () => (fc) => fc.date({
      noInvalidDate: false
    }),
    equivalence: () => Date2
  })) {
  };
});

// ../../node_modules/effect/dist/esm/internal/scopedCache.js
var init_scopedCache = __esm(() => {
  init_Context();
  init_Data();
  init_Duration();
  init_Equal();
  init_Exit();
  init_Function();
  init_HashSet();
  init_MutableHashMap();
  init_MutableQueue();
  init_MutableRef();
  init_Option();
  init_Pipeable();
  init_Scope();
  init_cache();
  init_core_effect();
  init_core();
  init_fiberRuntime();
});

// ../../node_modules/effect/dist/esm/ScopedCache.js
var init_ScopedCache = __esm(() => {
  init_scopedCache();
});

// ../../node_modules/effect/dist/esm/ScopedRef.js
var init_ScopedRef = __esm(() => {
  init_scopedRef();
});

// ../../node_modules/effect/dist/esm/Secret.js
var init_Secret = __esm(() => {
  init_secret();
});

// ../../node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var init_SingleProducerAsyncInput = __esm(() => {
  init_singleProducerAsyncInput();
});

// ../../node_modules/effect/dist/esm/Sink.js
var init_Sink = __esm(() => {
  init_sink();
});

// ../../node_modules/effect/dist/esm/SortedMap.js
var TypeId31, SortedMapProto, isSortedMap = (u) => hasProperty(u, TypeId31);
var init_SortedMap = __esm(() => {
  init_Equal();
  init_Function();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  init_RedBlackTree();
  TypeId31 = /* @__PURE__ */ Symbol.for("effect/SortedMap");
  SortedMapProto = {
    [TypeId31]: {
      _K: (_) => _,
      _V: (_) => _
    },
    [symbol]() {
      return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
    },
    [symbol2](that) {
      return isSortedMap(that) && equals(this.tree, that.tree);
    },
    [Symbol.iterator]() {
      return this.tree[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "SortedMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/Stream.js
var exports_Stream = {};
__export(exports_Stream, {
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithNext: () => zipWithNext2,
  zipWithIndex: () => zipWithIndex2,
  zipWithChunks: () => zipWithChunks2,
  zipWith: () => zipWith16,
  zipRight: () => zipRight13,
  zipLeft: () => zipLeft12,
  zipLatestWith: () => zipLatestWith2,
  zipLatestAll: () => zipLatestAll2,
  zipLatest: () => zipLatest2,
  zipFlatten: () => zipFlatten2,
  zipAllWith: () => zipAllWith2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllRight: () => zipAllRight2,
  zipAllLeft: () => zipAllLeft2,
  zipAll: () => zipAll2,
  zip: () => zip16,
  withSpan: () => withSpan7,
  withExecutionPlan: () => withExecutionPlan4,
  whenEffect: () => whenEffect4,
  whenCaseEffect: () => whenCaseEffect2,
  whenCase: () => whenCase2,
  when: () => when6,
  void: () => void_10,
  updateService: () => updateService6,
  unwrapScopedWith: () => unwrapScopedWith4,
  unwrapScoped: () => unwrapScoped6,
  unwrap: () => unwrap5,
  unfoldEffect: () => unfoldEffect2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldChunk: () => unfoldChunk2,
  unfold: () => unfold5,
  transduce: () => transduce2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStream: () => toReadableStream2,
  toQueueOfElements: () => toQueueOfElements2,
  toQueue: () => toQueue3,
  toPull: () => toPull3,
  toPubSub: () => toPubSub3,
  toChannel: () => toChannel4,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterable: () => toAsyncIterable2,
  timeoutTo: () => timeoutTo4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutFail: () => timeoutFail4,
  timeout: () => timeout4,
  tick: () => tick2,
  throttleEffect: () => throttleEffect2,
  throttle: () => throttle2,
  tapSink: () => tapSink2,
  tapErrorCause: () => tapErrorCause6,
  tapError: () => tapError7,
  tapBoth: () => tapBoth5,
  tap: () => tap8,
  takeWhile: () => takeWhile5,
  takeUntilEffect: () => takeUntilEffect2,
  takeUntil: () => takeUntil4,
  takeRight: () => takeRight3,
  take: () => take9,
  sync: () => sync15,
  suspend: () => suspend11,
  succeed: () => succeed22,
  splitOnChunk: () => splitOnChunk2,
  splitLines: () => splitLines3,
  split: () => split3,
  someOrFail: () => someOrFail2,
  someOrElse: () => someOrElse2,
  some: () => some10,
  slidingSize: () => slidingSize2,
  sliding: () => sliding8,
  share: () => share2,
  scopedWith: () => scopedWith5,
  scoped: () => scoped7,
  scheduleWith: () => scheduleWith2,
  schedule: () => schedule3,
  scanReduceEffect: () => scanReduceEffect2,
  scanReduce: () => scanReduce2,
  scanEffect: () => scanEffect2,
  scan: () => scan2,
  runSum: () => runSum2,
  runScoped: () => runScoped3,
  runLast: () => runLast2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoPubSub: () => runIntoPubSub2,
  runHead: () => runHead2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachScoped: () => runForEachScoped2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachChunk: () => runForEachChunk2,
  runForEach: () => runForEach2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldEffect: () => runFoldEffect2,
  runFold: () => runFold2,
  runDrain: () => runDrain3,
  runCount: () => runCount2,
  runCollect: () => runCollect3,
  run: () => run5,
  retry: () => retry8,
  repeatWith: () => repeatWith2,
  repeatValue: () => repeatValue2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatElements: () => repeatElements2,
  repeatEither: () => repeatEither2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffect: () => repeatEffect2,
  repeat: () => repeat4,
  refineOrDieWith: () => refineOrDieWith4,
  refineOrDie: () => refineOrDie4,
  rechunk: () => rechunk2,
  range: () => range3,
  raceAll: () => raceAll4,
  race: () => race6,
  provideSomeLayer: () => provideSomeLayer4,
  provideSomeContext: () => provideSomeContext4,
  provideServiceStream: () => provideServiceStream2,
  provideServiceEffect: () => provideServiceEffect4,
  provideService: () => provideService9,
  provideLayer: () => provideLayer3,
  provideContext: () => provideContext10,
  prepend: () => prepend5,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThrough: () => pipeThrough2,
  peel: () => peel2,
  partitionEither: () => partitionEither2,
  partition: () => partition8,
  paginateEffect: () => paginateEffect2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateChunk: () => paginateChunk2,
  paginate: () => paginate2,
  orElseSucceed: () => orElseSucceed5,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseFail: () => orElseFail5,
  orElseEither: () => orElseEither7,
  orElse: () => orElse16,
  orDieWith: () => orDieWith6,
  orDie: () => orDie8,
  onStart: () => onStart2,
  onError: () => onError4,
  onEnd: () => onEnd2,
  onDone: () => onDone2,
  never: () => never9,
  mkString: () => mkString3,
  mergeWithTag: () => mergeWithTag2,
  mergeWith: () => mergeWith4,
  mergeRight: () => mergeRight2,
  mergeLeft: () => mergeLeft2,
  mergeEither: () => mergeEither2,
  mergeAll: () => mergeAll10,
  merge: () => merge11,
  mapInputContext: () => mapInputContext9,
  mapErrorCause: () => mapErrorCause5,
  mapError: () => mapError10,
  mapEffect: () => mapEffect7,
  mapConcatEffect: () => mapConcatEffect2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcat: () => mapConcat2,
  mapChunksEffect: () => mapChunksEffect2,
  mapChunks: () => mapChunks2,
  mapBoth: () => mapBoth10,
  mapAccumEffect: () => mapAccumEffect2,
  mapAccum: () => mapAccum6,
  map: () => map29,
  make: () => make76,
  let: () => let_7,
  iterate: () => iterate5,
  intersperseAffixes: () => intersperseAffixes2,
  intersperse: () => intersperse2,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  interruptWhen: () => interruptWhen3,
  interruptAfter: () => interruptAfter2,
  interleaveWith: () => interleaveWith2,
  interleave: () => interleave2,
  identity: () => identity4,
  haltWhenDeferred: () => haltWhenDeferred2,
  haltWhen: () => haltWhen2,
  haltAfter: () => haltAfter2,
  groupedWithin: () => groupedWithin2,
  grouped: () => grouped2,
  groupByKey: () => groupByKey2,
  groupBy: () => groupBy2,
  groupAdjacentBy: () => groupAdjacentBy2,
  fromTQueue: () => fromTQueue2,
  fromTPubSub: () => fromTPubSub2,
  fromSchedule: () => fromSchedule2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromReadableStream: () => fromReadableStream2,
  fromQueue: () => fromQueue4,
  fromPull: () => fromPull3,
  fromPubSub: () => fromPubSub4,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromIterableEffect: () => fromIterableEffect2,
  fromIterable: () => fromIterable17,
  fromEventListener: () => fromEventListener2,
  fromEffectOption: () => fromEffectOption2,
  fromEffect: () => fromEffect10,
  fromChunks: () => fromChunks2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunk: () => fromChunk2,
  fromChannel: () => fromChannel3,
  fromAsyncIterable: () => fromAsyncIterable2,
  forever: () => forever6,
  flattenTake: () => flattenTake2,
  flattenIterables: () => flattenIterables2,
  flattenExitOption: () => flattenExitOption2,
  flattenEffect: () => flattenEffect2,
  flattenChunks: () => flattenChunks2,
  flatten: () => flatten15,
  flatMap: () => flatMap19,
  findEffect: () => findEffect3,
  find: () => find3,
  finalizer: () => finalizer2,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapEffect: () => filterMapEffect2,
  filterMap: () => filterMap9,
  filterEffect: () => filterEffect2,
  filter: () => filter15,
  failSync: () => failSync10,
  failCauseSync: () => failCauseSync9,
  failCause: () => failCause16,
  fail: () => fail19,
  execute: () => execute2,
  ensuringWith: () => ensuringWith4,
  ensuring: () => ensuring9,
  encodeText: () => encodeText2,
  empty: () => empty37,
  either: () => either9,
  dropWhileEffect: () => dropWhileEffect3,
  dropWhile: () => dropWhile6,
  dropUntilEffect: () => dropUntilEffect3,
  dropUntil: () => dropUntil5,
  dropRight: () => dropRight3,
  drop: () => drop5,
  drainFork: () => drainFork2,
  drain: () => drain4,
  distributedWithDynamic: () => distributedWithDynamic2,
  distributedWith: () => distributedWith2,
  dieSync: () => dieSync9,
  dieMessage: () => dieMessage6,
  die: () => die13,
  decodeText: () => decodeText2,
  debounce: () => debounce2,
  crossWith: () => crossWith2,
  crossRight: () => crossRight2,
  crossLeft: () => crossLeft2,
  cross: () => cross2,
  contextWithStream: () => contextWithStream2,
  contextWithEffect: () => contextWithEffect6,
  contextWith: () => contextWith7,
  context: () => context9,
  concatAll: () => concatAll3,
  concat: () => concat3,
  combineChunks: () => combineChunks2,
  combine: () => combine13,
  chunksWith: () => chunksWith2,
  chunks: () => chunks2,
  changesWithEffect: () => changesWithEffect2,
  changesWith: () => changesWith2,
  changes: () => changes2,
  catchTags: () => catchTags5,
  catchTag: () => catchTag5,
  catchSomeCause: () => catchSomeCause4,
  catchSome: () => catchSome5,
  catchAllCause: () => catchAllCause7,
  catchAll: () => catchAll8,
  bufferChunks: () => bufferChunks2,
  buffer: () => buffer3,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcast: () => broadcast2,
  branchAfter: () => branchAfter2,
  bindTo: () => bindTo7,
  bindEffect: () => bindEffect2,
  bind: () => bind7,
  asyncScoped: () => asyncScoped2,
  asyncPush: () => asyncPush2,
  asyncEffect: () => asyncEffect4,
  async: () => _async2,
  as: () => as11,
  aggregateWithinEither: () => aggregateWithinEither2,
  aggregateWithin: () => aggregateWithin2,
  aggregate: () => aggregate2,
  acquireRelease: () => acquireRelease4,
  accumulateChunks: () => accumulateChunks2,
  accumulate: () => accumulate2,
  StreamTypeId: () => StreamTypeId3,
  Do: () => Do5,
  DefaultChunkSize: () => DefaultChunkSize2
});
var StreamTypeId3, DefaultChunkSize2, accumulate2, accumulateChunks2, acquireRelease4, aggregate2, aggregateWithin2, aggregateWithinEither2, as11, _async2, asyncEffect4, asyncPush2, asyncScoped2, branchAfter2, broadcast2, share2, broadcastDynamic2, broadcastedQueues2, broadcastedQueuesDynamic2, buffer3, bufferChunks2, catchAll8, catchAllCause7, catchSome5, catchTag5, catchTags5, catchSomeCause4, changes2, changesWith2, changesWithEffect2, chunks2, chunksWith2, combine13, combineChunks2, concat3, concatAll3, cross2, crossLeft2, crossRight2, crossWith2, debounce2, die13, dieSync9, dieMessage6, distributedWith2, distributedWithDynamic2, drain4, drainFork2, drop5, dropRight3, dropUntil5, dropUntilEffect3, dropWhile6, dropWhileEffect3, either9, empty37, ensuring9, ensuringWith4, context9, contextWith7, contextWithEffect6, contextWithStream2, execute2, fail19, failSync10, failCause16, failCauseSync9, filter15, filterEffect2, filterMap9, filterMapEffect2, filterMapWhile4, filterMapWhileEffect2, finalizer2, find3, findEffect3, flatMap19, flatten15, flattenChunks2, flattenEffect2, flattenExitOption2, flattenIterables2, flattenTake2, forever6, fromAsyncIterable2, fromChannel3, toChannel4, fromChunk2, fromChunkPubSub2, fromChunkQueue2, fromChunks2, fromEffect10, fromEffectOption2, fromPubSub4, fromTPubSub2, fromIterable17, fromIterableEffect2, fromIteratorSucceed2, fromPull3, fromQueue4, fromTQueue2, fromReadableStream2, fromReadableStreamByob2, fromSchedule2, groupAdjacentBy2, groupBy2, groupByKey2, grouped2, groupedWithin2, haltAfter2, haltWhen2, haltWhenDeferred2, identity4, interleave2, interleaveWith2, intersperse2, intersperseAffixes2, interruptAfter2, interruptWhen3, interruptWhenDeferred3, iterate5, make76, map29, mapAccum6, mapAccumEffect2, mapBoth10, mapChunks2, mapChunksEffect2, mapConcat2, mapConcatChunk2, mapConcatChunkEffect2, mapConcatEffect2, mapEffect7, mapError10, mapErrorCause5, merge11, mergeAll10, mergeWithTag2, mergeWith4, mergeEither2, mergeLeft2, mergeRight2, mkString3, never9, onEnd2, onError4, onDone2, onStart2, orDie8, orDieWith6, orElse16, orElseEither7, orElseFail5, orElseIfEmpty2, orElseIfEmptyChunk2, orElseIfEmptyStream2, orElseSucceed5, paginate2, paginateChunk2, paginateChunkEffect2, paginateEffect2, partition8, partitionEither2, peel2, pipeThrough2, pipeThroughChannel2, pipeThroughChannelOrFail2, prepend5, provideContext10, provideSomeContext4, provideLayer3, provideService9, provideServiceEffect4, provideServiceStream2, mapInputContext9, provideSomeLayer4, race6, raceAll4, range3, rechunk2, refineOrDie4, refineOrDieWith4, repeat4, repeatEffect2, repeatEffectChunk2, repeatEffectChunkOption2, repeatEffectOption2, repeatEffectWithSchedule2, repeatEither2, repeatElements2, repeatElementsWith2, repeatValue2, repeatWith2, retry8, withExecutionPlan4, run5, runCollect3, runCount2, runDrain3, runFold2, runFoldEffect2, runFoldScoped2, runFoldScopedEffect2, runFoldWhile2, runFoldWhileEffect2, runFoldWhileScoped2, runFoldWhileScopedEffect2, runForEach2, runForEachChunk2, runForEachChunkScoped2, runForEachScoped2, runForEachWhile2, runForEachWhileScoped2, runHead2, runIntoPubSub2, runIntoPubSubScoped2, runIntoQueue2, runIntoQueueElementsScoped2, runIntoQueueScoped2, runLast2, runScoped3, runSum2, scan2, scanEffect2, scanReduce2, scanReduceEffect2, schedule3, scheduleWith2, scoped7, scopedWith5, sliding8, slidingSize2, some10, someOrElse2, someOrFail2, split3, splitOnChunk2, splitLines3, succeed22, sync15, suspend11, take9, takeRight3, takeUntil4, takeUntilEffect2, takeWhile5, tap8, tapBoth5, tapError7, tapErrorCause6, tapSink2, throttle2, throttleEffect2, tick2, timeout4, timeoutFail4, timeoutFailCause4, timeoutTo4, toPubSub3, toPull3, toQueue3, toQueueOfElements2, toReadableStream2, toReadableStreamEffect2, toReadableStreamRuntime2, toAsyncIterableRuntime2, toAsyncIterableEffect2, toAsyncIterable2, transduce2, unfold5, unfoldChunk2, unfoldChunkEffect2, unfoldEffect2, void_10, unwrap5, unwrapScoped6, unwrapScopedWith4, updateService6, when6, whenCase2, whenCaseEffect2, whenEffect4, withSpan7, zip16, zipFlatten2, zipAll2, zipAllLeft2, zipAllRight2, zipAllSortedByKey2, zipAllSortedByKeyLeft2, zipAllSortedByKeyRight2, zipAllSortedByKeyWith2, zipAllWith2, zipLatest2, zipLatestAll2, zipLatestWith2, zipLeft12, zipRight13, zipWith16, zipWithChunks2, zipWithNext2, zipWithPrevious2, zipWithPreviousAndNext2, zipWithIndex2, Do5, bind7, bindEffect2, bindTo7, let_7, decodeText2, encodeText2, fromEventListener2;
var init_Stream = __esm(() => {
  init_groupBy();
  init_stream();
  StreamTypeId3 = StreamTypeId2;
  DefaultChunkSize2 = DefaultChunkSize;
  accumulate2 = accumulate;
  accumulateChunks2 = accumulateChunks;
  acquireRelease4 = acquireRelease3;
  aggregate2 = aggregate;
  aggregateWithin2 = aggregateWithin;
  aggregateWithinEither2 = aggregateWithinEither;
  as11 = as9;
  _async2 = _async;
  asyncEffect4 = asyncEffect3;
  asyncPush2 = asyncPush;
  asyncScoped2 = asyncScoped;
  branchAfter2 = branchAfter;
  broadcast2 = broadcast;
  share2 = share;
  broadcastDynamic2 = broadcastDynamic;
  broadcastedQueues2 = broadcastedQueues;
  broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
  buffer3 = buffer;
  bufferChunks2 = bufferChunks;
  catchAll8 = catchAll7;
  catchAllCause7 = catchAllCause6;
  catchSome5 = catchSome3;
  catchTag5 = catchTag3;
  catchTags5 = catchTags3;
  catchSomeCause4 = catchSomeCause3;
  changes2 = changes;
  changesWith2 = changesWith;
  changesWithEffect2 = changesWithEffect;
  chunks2 = chunks;
  chunksWith2 = chunksWith;
  combine13 = combine12;
  combineChunks2 = combineChunks;
  concat3 = concat2;
  concatAll3 = concatAll2;
  cross2 = cross;
  crossLeft2 = crossLeft;
  crossRight2 = crossRight;
  crossWith2 = crossWith;
  debounce2 = debounce;
  die13 = die11;
  dieSync9 = dieSync7;
  dieMessage6 = dieMessage4;
  distributedWith2 = distributedWith;
  distributedWithDynamic2 = distributedWithDynamic;
  drain4 = drain3;
  drainFork2 = drainFork;
  drop5 = drop3;
  dropRight3 = dropRight2;
  dropUntil5 = dropUntil3;
  dropUntilEffect3 = dropUntilEffect;
  dropWhile6 = dropWhile4;
  dropWhileEffect3 = dropWhileEffect;
  either9 = either6;
  empty37 = empty35;
  ensuring9 = ensuring7;
  ensuringWith4 = ensuringWith2;
  context9 = context5;
  contextWith7 = contextWith3;
  contextWithEffect6 = contextWithEffect3;
  contextWithStream2 = contextWithStream;
  execute2 = execute;
  fail19 = fail16;
  failSync10 = failSync8;
  failCause16 = failCause14;
  failCauseSync9 = failCauseSync7;
  filter15 = filter10;
  filterEffect2 = filterEffect;
  filterMap9 = filterMap8;
  filterMapEffect2 = filterMapEffect;
  filterMapWhile4 = filterMapWhile3;
  filterMapWhileEffect2 = filterMapWhileEffect;
  finalizer2 = finalizer;
  find3 = find2;
  findEffect3 = findEffect;
  flatMap19 = flatMap17;
  flatten15 = flatten14;
  flattenChunks2 = flattenChunks;
  flattenEffect2 = flattenEffect;
  flattenExitOption2 = flattenExitOption;
  flattenIterables2 = flattenIterables;
  flattenTake2 = flattenTake;
  forever6 = forever5;
  fromAsyncIterable2 = fromAsyncIterable;
  fromChannel3 = fromChannel2;
  toChannel4 = toChannel2;
  fromChunk2 = fromChunk;
  fromChunkPubSub2 = fromChunkPubSub;
  fromChunkQueue2 = fromChunkQueue;
  fromChunks2 = fromChunks;
  fromEffect10 = fromEffect8;
  fromEffectOption2 = fromEffectOption;
  fromPubSub4 = fromPubSub;
  fromTPubSub2 = fromTPubSub;
  fromIterable17 = fromIterable12;
  fromIterableEffect2 = fromIterableEffect;
  fromIteratorSucceed2 = fromIteratorSucceed;
  fromPull3 = fromPull2;
  fromQueue4 = fromQueue2;
  fromTQueue2 = fromTQueue;
  fromReadableStream2 = fromReadableStream;
  fromReadableStreamByob2 = fromReadableStreamByob;
  fromSchedule2 = fromSchedule;
  groupAdjacentBy2 = groupAdjacentBy;
  groupBy2 = groupBy;
  groupByKey2 = groupByKey;
  grouped2 = grouped;
  groupedWithin2 = groupedWithin;
  haltAfter2 = haltAfter;
  haltWhen2 = haltWhen;
  haltWhenDeferred2 = haltWhenDeferred;
  identity4 = identityStream;
  interleave2 = interleave;
  interleaveWith2 = interleaveWith;
  intersperse2 = intersperse;
  intersperseAffixes2 = intersperseAffixes;
  interruptAfter2 = interruptAfter;
  interruptWhen3 = interruptWhen2;
  interruptWhenDeferred3 = interruptWhenDeferred2;
  iterate5 = iterate3;
  make76 = make55;
  map29 = map23;
  mapAccum6 = mapAccum5;
  mapAccumEffect2 = mapAccumEffect;
  mapBoth10 = mapBoth6;
  mapChunks2 = mapChunks;
  mapChunksEffect2 = mapChunksEffect;
  mapConcat2 = mapConcat;
  mapConcatChunk2 = mapConcatChunk;
  mapConcatChunkEffect2 = mapConcatChunkEffect;
  mapConcatEffect2 = mapConcatEffect;
  mapEffect7 = mapEffectOptions;
  mapError10 = mapError6;
  mapErrorCause5 = mapErrorCause4;
  merge11 = merge9;
  mergeAll10 = mergeAll8;
  mergeWithTag2 = mergeWithTag;
  mergeWith4 = mergeWith3;
  mergeEither2 = mergeEither;
  mergeLeft2 = mergeLeft;
  mergeRight2 = mergeRight;
  mkString3 = mkString2;
  never9 = never5;
  onEnd2 = onEnd;
  onError4 = onError3;
  onDone2 = onDone;
  onStart2 = onStart;
  orDie8 = orDie5;
  orDieWith6 = orDieWith4;
  orElse16 = orElse9;
  orElseEither7 = orElseEither5;
  orElseFail5 = orElseFail3;
  orElseIfEmpty2 = orElseIfEmpty;
  orElseIfEmptyChunk2 = orElseIfEmptyChunk;
  orElseIfEmptyStream2 = orElseIfEmptyStream;
  orElseSucceed5 = orElseSucceed3;
  paginate2 = paginate;
  paginateChunk2 = paginateChunk;
  paginateChunkEffect2 = paginateChunkEffect;
  paginateEffect2 = paginateEffect;
  partition8 = partition6;
  partitionEither2 = partitionEither;
  peel2 = peel;
  pipeThrough2 = pipeThrough;
  pipeThroughChannel2 = pipeThroughChannel;
  pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
  prepend5 = prepend4;
  provideContext10 = provideContext6;
  provideSomeContext4 = provideSomeContext2;
  provideLayer3 = provideLayer;
  provideService9 = provideService6;
  provideServiceEffect4 = provideServiceEffect3;
  provideServiceStream2 = provideServiceStream;
  mapInputContext9 = mapInputContext6;
  provideSomeLayer4 = provideSomeLayer2;
  race6 = race3;
  raceAll4 = raceAll3;
  range3 = range2;
  rechunk2 = rechunk;
  refineOrDie4 = refineOrDie;
  refineOrDieWith4 = refineOrDieWith;
  repeat4 = repeat2;
  repeatEffect2 = repeatEffect;
  repeatEffectChunk2 = repeatEffectChunk;
  repeatEffectChunkOption2 = repeatEffectChunkOption;
  repeatEffectOption2 = repeatEffectOption;
  repeatEffectWithSchedule2 = repeatEffectWithSchedule;
  repeatEither2 = repeatEither;
  repeatElements2 = repeatElements;
  repeatElementsWith2 = repeatElementsWith;
  repeatValue2 = repeatValue;
  repeatWith2 = repeatWith;
  retry8 = retry6;
  withExecutionPlan4 = withExecutionPlan3;
  run5 = run4;
  runCollect3 = runCollect;
  runCount2 = runCount;
  runDrain3 = runDrain2;
  runFold2 = runFold;
  runFoldEffect2 = runFoldEffect;
  runFoldScoped2 = runFoldScoped;
  runFoldScopedEffect2 = runFoldScopedEffect;
  runFoldWhile2 = runFoldWhile;
  runFoldWhileEffect2 = runFoldWhileEffect;
  runFoldWhileScoped2 = runFoldWhileScoped;
  runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
  runForEach2 = runForEach;
  runForEachChunk2 = runForEachChunk;
  runForEachChunkScoped2 = runForEachChunkScoped;
  runForEachScoped2 = runForEachScoped;
  runForEachWhile2 = runForEachWhile;
  runForEachWhileScoped2 = runForEachWhileScoped;
  runHead2 = runHead;
  runIntoPubSub2 = runIntoPubSub;
  runIntoPubSubScoped2 = runIntoPubSubScoped;
  runIntoQueue2 = runIntoQueue;
  runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
  runIntoQueueScoped2 = runIntoQueueScoped;
  runLast2 = runLast;
  runScoped3 = runScoped2;
  runSum2 = runSum;
  scan2 = scan;
  scanEffect2 = scanEffect;
  scanReduce2 = scanReduce;
  scanReduceEffect2 = scanReduceEffect;
  schedule3 = schedule2;
  scheduleWith2 = scheduleWith;
  scoped7 = scoped6;
  scopedWith5 = scopedWith4;
  sliding8 = sliding7;
  slidingSize2 = slidingSize;
  some10 = some7;
  someOrElse2 = someOrElse;
  someOrFail2 = someOrFail;
  split3 = split2;
  splitOnChunk2 = splitOnChunk;
  splitLines3 = splitLines2;
  succeed22 = succeed16;
  sync15 = sync10;
  suspend11 = suspend9;
  take9 = take7;
  takeRight3 = takeRight2;
  takeUntil4 = takeUntil3;
  takeUntilEffect2 = takeUntilEffect;
  takeWhile5 = takeWhile4;
  tap8 = tap7;
  tapBoth5 = tapBoth3;
  tapError7 = tapError5;
  tapErrorCause6 = tapErrorCause5;
  tapSink2 = tapSink;
  throttle2 = throttle;
  throttleEffect2 = throttleEffect;
  tick2 = tick;
  timeout4 = timeout3;
  timeoutFail4 = timeoutFail3;
  timeoutFailCause4 = timeoutFailCause3;
  timeoutTo4 = timeoutTo3;
  toPubSub3 = toPubSub2;
  toPull3 = toPull2;
  toQueue3 = toQueue2;
  toQueueOfElements2 = toQueueOfElements;
  toReadableStream2 = toReadableStream;
  toReadableStreamEffect2 = toReadableStreamEffect;
  toReadableStreamRuntime2 = toReadableStreamRuntime;
  toAsyncIterableRuntime2 = toAsyncIterableRuntime;
  toAsyncIterableEffect2 = toAsyncIterableEffect;
  toAsyncIterable2 = toAsyncIterable;
  transduce2 = transduce;
  unfold5 = unfold4;
  unfoldChunk2 = unfoldChunk;
  unfoldChunkEffect2 = unfoldChunkEffect;
  unfoldEffect2 = unfoldEffect;
  void_10 = void_9;
  unwrap5 = unwrap2;
  unwrapScoped6 = unwrapScoped4;
  unwrapScopedWith4 = unwrapScopedWith3;
  updateService6 = updateService4;
  when6 = when3;
  whenCase2 = whenCase;
  whenCaseEffect2 = whenCaseEffect;
  whenEffect4 = whenEffect3;
  withSpan7 = withSpan6;
  zip16 = zip9;
  zipFlatten2 = zipFlatten;
  zipAll2 = zipAll;
  zipAllLeft2 = zipAllLeft;
  zipAllRight2 = zipAllRight;
  zipAllSortedByKey2 = zipAllSortedByKey;
  zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
  zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
  zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
  zipAllWith2 = zipAllWith;
  zipLatest2 = zipLatest;
  zipLatestAll2 = zipLatestAll;
  zipLatestWith2 = zipLatestWith;
  zipLeft12 = zipLeft8;
  zipRight13 = zipRight11;
  zipWith16 = zipWith14;
  zipWithChunks2 = zipWithChunks;
  zipWithNext2 = zipWithNext;
  zipWithPrevious2 = zipWithPrevious;
  zipWithPreviousAndNext2 = zipWithPreviousAndNext;
  zipWithIndex2 = zipWithIndex;
  Do5 = Do4;
  bind7 = bind5;
  bindEffect2 = bindEffect;
  bindTo7 = bindTo5;
  let_7 = let_5;
  decodeText2 = decodeText;
  encodeText2 = encodeText;
  fromEventListener2 = fromEventListener;
});

// ../../node_modules/effect/dist/esm/StreamEmit.js
var init_StreamEmit = () => {};

// ../../node_modules/effect/dist/esm/Streamable.js
var init_Streamable = __esm(() => {
  init_Pipeable();
  init_Stream();
});

// ../../node_modules/effect/dist/esm/Subscribable.js
var TypeId32, Proto7;
var init_Subscribable = __esm(() => {
  init_Effect();
  init_Function();
  init_Pipeable();
  init_Predicate();
  init_Readable();
  init_Stream();
  TypeId32 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
  Proto7 = {
    [TypeId14]: TypeId14,
    [TypeId32]: TypeId32,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
});

// ../../node_modules/effect/dist/esm/SynchronizedRef.js
var init_SynchronizedRef = __esm(() => {
  init_circular();
  init_ref();
  init_synchronizedRef();
});

// ../../node_modules/effect/dist/esm/internal/subscriptionRef.js
var init_subscriptionRef = __esm(() => {
  init_Effect();
  init_Effectable();
  init_Function();
  init_PubSub();
  init_Readable();
  init_Ref();
  init_Subscribable();
  init_SynchronizedRef();
  init_circular();
  init_ref();
  init_stream();
});

// ../../node_modules/effect/dist/esm/SubscriptionRef.js
var init_SubscriptionRef = __esm(() => {
  init_subscriptionRef();
  init_Ref();
  init_SynchronizedRef();
});

// ../../node_modules/effect/dist/esm/Supervisor.js
var init_Supervisor = __esm(() => {
  init_core();
  init_circular3();
  init_supervisor();
});

// ../../node_modules/effect/dist/esm/Symbol.js
var init_Symbol = __esm(() => {
  init_Equivalence();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/internal/stm/tArray.js
var init_tArray = __esm(() => {
  init_Equal();
  init_Function();
  init_Option();
  init_Order();
  init_core2();
  init_stm();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TArray.js
var init_TArray = __esm(() => {
  init_tArray();
});

// ../../node_modules/effect/dist/esm/internal/stm/tDeferred.js
var init_tDeferred = __esm(() => {
  init_Either();
  init_Function();
  init_Option();
  init_core2();
  init_stm();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TDeferred.js
var init_TDeferred = __esm(() => {
  init_tDeferred();
});

// ../../node_modules/effect/dist/esm/internal/stm/tMap.js
var init_tMap = __esm(() => {
  init_Array();
  init_Chunk();
  init_Equal();
  init_Function();
  init_Hash();
  init_HashMap();
  init_Option();
  init_Predicate();
  init_STM();
  init_core2();
  init_stm();
  init_tArray();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TMap.js
var init_TMap = __esm(() => {
  init_tMap();
});

// ../../node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var init_tPriorityQueue = __esm(() => {
  init_Array();
  init_Chunk();
  init_Function();
  init_Option();
  init_SortedMap();
  init_core2();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TPriorityQueue.js
var init_TPriorityQueue = __esm(() => {
  init_tPriorityQueue();
});

// ../../node_modules/effect/dist/esm/internal/stm/tRandom.js
var init_tRandom = __esm(() => {
  init_Context();
  init_Function();
  init_Layer();
  init_Utils();
  init_core2();
  init_stm();
  init_tArray();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TRandom.js
var init_TRandom = __esm(() => {
  init_tRandom();
});

// ../../node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var init_tReentrantLock = __esm(() => {
  init_Effect();
  init_Equal();
  init_FiberId();
  init_Function();
  init_HashMap();
  init_Option();
  init_core2();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TReentrantLock.js
var init_TReentrantLock = __esm(() => {
  init_tReentrantLock();
});

// ../../node_modules/effect/dist/esm/TRef.js
var init_TRef = __esm(() => {
  init_tRef();
});

// ../../node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var init_tSemaphore = __esm(() => {
  init_Cause();
  init_Effect();
  init_Function();
  init_STM();
  init_core2();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TSemaphore.js
var init_TSemaphore = __esm(() => {
  init_tSemaphore();
});

// ../../node_modules/effect/dist/esm/internal/stm/tSet.js
var init_tSet = __esm(() => {
  init_Array();
  init_Chunk();
  init_Function();
  init_HashSet();
  init_Predicate();
  init_STM();
  init_core2();
  init_tMap();
});

// ../../node_modules/effect/dist/esm/TSet.js
var init_TSet = __esm(() => {
  init_tSet();
});

// ../../node_modules/effect/dist/esm/internal/stm/tSubscriptionRef.js
var init_tSubscriptionRef = __esm(() => {
  init_Effect();
  init_Function();
  init_Option();
  init_Pipeable();
  init_STM();
  init_TPubSub();
  init_TQueue();
  init_TRef();
  init_stream();
  init_tQueue();
  init_tRef();
});

// ../../node_modules/effect/dist/esm/TSubscriptionRef.js
var init_TSubscriptionRef = __esm(() => {
  init_tSubscriptionRef();
});

// ../../node_modules/effect/dist/esm/Take.js
var init_Take = __esm(() => {
  init_take();
});

// ../../node_modules/effect/dist/esm/TestAnnotation.js
var init_TestAnnotation = __esm(() => {
  init_Chunk();
  init_Either();
  init_Equal();
  init_Function();
  init_Hash();
  init_HashSet();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/TestAnnotationMap.js
var init_TestAnnotationMap = __esm(() => {
  init_Function();
  init_HashMap();
  init_Predicate();
});

// ../../node_modules/effect/dist/esm/TestAnnotations.js
var init_TestAnnotations = __esm(() => {
  init_Array();
  init_Context();
  init_Equal();
  init_Function();
  init_core_effect();
  init_core();
  init_fiber();
  init_MutableRef();
  init_Predicate();
  init_Ref();
  init_SortedSet();
  init_TestAnnotation();
  init_TestAnnotationMap();
});

// ../../node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var init_suspendedWarningData = () => {};

// ../../node_modules/effect/dist/esm/internal/testing/warningData.js
var init_warningData = () => {};

// ../../node_modules/effect/dist/esm/TestLive.js
var init_TestLive = __esm(() => {
  init_Context();
  init_core();
  init_defaultServices();
});

// ../../node_modules/effect/dist/esm/TestClock.js
var warning, suspendedWarning;
var init_TestClock = __esm(() => {
  init_Chunk();
  init_Context();
  init_DateTime();
  init_Duration();
  init_Equal();
  init_FiberStatus();
  init_Function();
  init_HashMap();
  init_clock();
  init_core_effect();
  init_core();
  init_defaultServices();
  init_circular();
  init_fiberRuntime();
  init_layer();
  init_ref();
  init_synchronizedRef();
  init_suspendedWarningData();
  init_warningData();
  init_Number();
  init_Option();
  init_Order();
  init_TestAnnotations();
  init_TestLive();
  warning = "Warning: A test is using time, but is not advancing " + "the test clock, which may result in the test hanging. Use TestClock.adjust to " + "manually advance the time.";
  suspendedWarning = "Warning: A test is advancing the test clock, " + "but a fiber is not suspending, which may result in the test hanging. Use " + "TestAspect.diagnose to identity the fiber that is not suspending.";
});

// ../../node_modules/effect/dist/esm/TestConfig.js
var init_TestConfig = __esm(() => {
  init_Context();
});

// ../../node_modules/effect/dist/esm/TestSized.js
var init_TestSized = __esm(() => {
  init_Context();
  init_core();
});

// ../../node_modules/effect/dist/esm/TestServices.js
var init_TestServices = __esm(() => {
  init_Context();
  init_Effect();
  init_Function();
  init_core();
  init_defaultServices();
  init_fiberRuntime();
  init_layer();
  init_ref();
  init_TestAnnotationMap();
  init_TestAnnotations();
  init_TestConfig();
  init_TestLive();
  init_TestSized();
});

// ../../node_modules/effect/dist/esm/TestContext.js
var init_TestContext = __esm(() => {
  init_Function();
  init_defaultServices();
  init_layer();
  init_TestClock();
  init_TestServices();
});

// ../../node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie", TrieTypeId, trieVariance, TrieProto, TrieIterator, isTrie = (u) => hasProperty(u, TrieTypeId);
var init_trie = __esm(() => {
  init_Equal();
  init_Function();
  init_Hash();
  init_Inspectable();
  init_Option();
  init_Pipeable();
  init_Predicate();
  TrieTypeId = /* @__PURE__ */ Symbol.for(TrieSymbolKey);
  trieVariance = {
    _Value: (_) => _
  };
  TrieProto = {
    [TrieTypeId]: trieVariance,
    [Symbol.iterator]() {
      return new TrieIterator(this, (k, v) => [k, v], () => true);
    },
    [symbol]() {
      let hash2 = hash(TrieSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
      }
      return cached(this, hash2);
    },
    [symbol2](that) {
      if (isTrie(that)) {
        const entries3 = Array.from(that);
        return Array.from(this).every((itemSelf, i) => {
          const itemThat = entries3[i];
          return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
        });
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Trie",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  TrieIterator = class TrieIterator {
    trie;
    f;
    filter;
    stack = [];
    constructor(trie, f, filter17) {
      this.trie = trie;
      this.f = f;
      this.filter = filter17;
      const root = trie._root !== undefined ? trie._root : undefined;
      if (root !== undefined) {
        this.stack.push([root, "", false]);
      }
    }
    next() {
      while (this.stack.length > 0) {
        const [node, keyString, isAdded] = this.stack.pop();
        if (isAdded) {
          const value6 = node.value;
          if (value6 !== undefined) {
            const key = keyString + node.key;
            if (this.filter(key, value6)) {
              return {
                done: false,
                value: this.f(key, value6)
              };
            }
          }
        } else {
          this.addToStack(node, keyString);
        }
      }
      return {
        done: true,
        value: undefined
      };
    }
    addToStack(node, keyString) {
      if (node.right !== undefined) {
        this.stack.push([node.right, keyString, false]);
      }
      if (node.mid !== undefined) {
        this.stack.push([node.mid, keyString + node.key, false]);
      }
      this.stack.push([node, keyString, true]);
      if (node.left !== undefined) {
        this.stack.push([node.left, keyString, false]);
      }
    }
    [Symbol.iterator]() {
      return new TrieIterator(this.trie, this.f, this.filter);
    }
  };
});

// ../../node_modules/effect/dist/esm/Trie.js
var init_Trie = __esm(() => {
  init_trie();
});

// ../../node_modules/effect/dist/esm/Types.js
var init_Types = () => {};

// ../../node_modules/effect/dist/esm/Unify.js
var init_Unify = __esm(() => {
  init_Function();
});

// ../../node_modules/effect/dist/esm/UpstreamPullRequest.js
var init_UpstreamPullRequest = __esm(() => {
  init_upstreamPullRequest();
});

// ../../node_modules/effect/dist/esm/UpstreamPullStrategy.js
var init_UpstreamPullStrategy = __esm(() => {
  init_upstreamPullStrategy();
});

// ../../node_modules/effect/dist/esm/index.js
var init_esm2 = __esm(() => {
  init_Function();
  init_Arbitrary();
  init_Array();
  init_BigDecimal();
  init_BigInt();
  init_Boolean();
  init_Brand();
  init_Cache();
  init_Cause();
  init_Channel();
  init_ChildExecutorDecision();
  init_Chunk();
  init_Clock();
  init_Config();
  init_ConfigError();
  init_ConfigProvider();
  init_ConfigProviderPathPatch();
  init_Console();
  init_Context();
  init_Cron();
  init_Data();
  init_DateTime();
  init_DefaultServices();
  init_Deferred();
  init_Differ();
  init_Duration();
  init_Effect();
  init_Effectable();
  init_Either();
  init_Encoding();
  init_Equal();
  init_Equivalence();
  init_ExecutionPlan();
  init_ExecutionStrategy();
  init_Exit();
  init_FastCheck();
  init_Fiber();
  init_FiberHandle();
  init_FiberId();
  init_FiberMap();
  init_FiberRef();
  init_FiberRefs();
  init_FiberRefsPatch();
  init_FiberSet();
  init_FiberStatus();
  init_Function();
  init_GlobalValue();
  init_GroupBy();
  init_HKT();
  init_Hash();
  init_HashMap();
  init_HashSet();
  init_Inspectable();
  init_Iterable();
  init_JSONSchema();
  init_KeyedPool();
  init_Layer();
  init_LayerMap();
  init_List();
  init_LogLevel();
  init_LogSpan();
  init_Logger();
  init_Mailbox();
  init_ManagedRuntime();
  init_Match();
  init_MergeDecision();
  init_MergeState();
  init_MergeStrategy();
  init_Metric();
  init_MetricBoundaries();
  init_MetricHook();
  init_MetricKey();
  init_MetricKeyType();
  init_MetricLabel();
  init_MetricPair();
  init_MetricPolling();
  init_MetricRegistry();
  init_MetricState();
  init_Micro();
  init_ModuleVersion();
  init_MutableHashMap();
  init_MutableHashSet();
  init_MutableList();
  init_MutableQueue();
  init_MutableRef();
  init_Number();
  init_Option();
  init_Order();
  init_Ordering();
  init_ParseResult();
  init_Pipeable();
  init_Pool();
  init_Predicate();
  init_Pretty();
  init_PrimaryKey();
  init_PubSub();
  init_Queue();
  init_Random();
  init_RateLimiter();
  init_RcMap();
  init_RcRef();
  init_Readable();
  init_Record();
  init_RedBlackTree();
  init_Redacted();
  init_Ref();
  init_RegExp();
  init_Reloadable();
  init_Request();
  init_RequestBlock();
  init_RequestResolver();
  init_Resource();
  init_Runtime();
  init_RuntimeFlags();
  init_RuntimeFlagsPatch();
  init_STM();
  init_Schedule();
  init_ScheduleDecision();
  init_ScheduleInterval();
  init_ScheduleIntervals();
  init_Scheduler();
  init_Schema();
  init_SchemaAST();
  init_Scope();
  init_ScopedCache();
  init_ScopedRef();
  init_Secret();
  init_SingleProducerAsyncInput();
  init_Sink();
  init_SortedMap();
  init_SortedSet();
  init_Stream();
  init_StreamEmit();
  init_StreamHaltStrategy();
  init_Streamable();
  init_String();
  init_Struct();
  init_Subscribable();
  init_SubscriptionRef();
  init_Supervisor();
  init_Symbol();
  init_SynchronizedRef();
  init_TArray();
  init_TDeferred();
  init_TMap();
  init_TPriorityQueue();
  init_TPubSub();
  init_TQueue();
  init_TRandom();
  init_TReentrantLock();
  init_TRef();
  init_TSemaphore();
  init_TSet();
  init_TSubscriptionRef();
  init_Take();
  init_TestAnnotation();
  init_TestAnnotationMap();
  init_TestAnnotations();
  init_TestClock();
  init_TestConfig();
  init_TestContext();
  init_TestLive();
  init_TestServices();
  init_TestSized();
  init_Tracer();
  init_Trie();
  init_Tuple();
  init_Types();
  init_Unify();
  init_UpstreamPullRequest();
  init_UpstreamPullStrategy();
  init_Utils();
});

// ../../src/core/errors.ts
var TerminalError, InputError, RenderError, StorageError, ConfigError, ComponentError, ApplicationError, ValidationError, RecoveryStrategies, withErrorBoundary = (effect4, config2) => {
  const handleError = (error2) => exports_Effect.gen(function* (_) {
    if (config2.onError) {
      yield* _(config2.onError(error2));
    }
    if (config2.logErrors) {
      yield* _(exports_Effect.logError("Error caught by error boundary", error2));
    }
    return yield* _(config2.fallback(error2));
  });
  const result = exports_Effect.catchAll(effect4, handleError);
  return config2.catchDefects ? exports_Effect.catchAllDefect(result, (defect) => {
    const error2 = new ApplicationError({
      phase: "runtime",
      operation: "defect",
      cause: defect,
      context: { defect: String(defect) }
    });
    return handleError(error2);
  }) : result;
}, withRecovery = (effect4, strategy) => effect4.pipe(exports_Effect.catchAll((error2) => strategy.canRecover(error2) ? strategy.recover(error2) : exports_Effect.fail(error2)), strategy.maxRetries && strategy.maxRetries > 1 ? exports_Effect.retry(exports_Schedule.recurs(strategy.maxRetries - 1)) : (effect5) => effect5), ErrorUtils;
var init_errors3 = __esm(() => {
  init_esm2();
  TerminalError = class TerminalError extends exports_Data.TaggedError("TerminalError") {
    constructor(props) {
      super({
        message: `Terminal operation failed: ${props.operation}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  InputError = class InputError extends exports_Data.TaggedError("InputError") {
    constructor(props) {
      super({
        message: `Input error on ${props.device}${props.operation ? `: ${props.operation}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  RenderError = class RenderError extends exports_Data.TaggedError("RenderError") {
    constructor(props) {
      super({
        message: `Render error in ${props.phase}${props.operation ? `: ${props.operation}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  StorageError = class StorageError extends exports_Data.TaggedError("StorageError") {
    constructor(props) {
      super({
        message: `Storage ${props.operation} failed${props.path ? ` for ${props.path}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  ConfigError = class ConfigError extends exports_Data.TaggedError("ConfigError") {
    constructor(props) {
      super({
        message: `Configuration error${props.key ? ` for key '${props.key}'` : ""}${props.expected ? `: expected ${props.expected}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  ComponentError = class ComponentError extends exports_Data.TaggedError("ComponentError") {
    constructor(props) {
      super({
        message: `Component error in ${props.componentType} during ${props.phase}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  ApplicationError = class ApplicationError extends exports_Data.TaggedError("ApplicationError") {
    constructor(props) {
      super({
        message: `Application error during ${props.phase}${props.operation ? `: ${props.operation}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  ValidationError = class ValidationError extends exports_Data.TaggedError("ValidationError") {
    constructor(props) {
      super({
        message: `Validation failed${props.field ? ` for field '${props.field}'` : ""}${props.rules ? `: ${props.rules.join(", ")}` : ""}`,
        timestamp: new Date,
        ...props
      });
    }
  };
  RecoveryStrategies = {
    retry: (maxRetries = 3, initialDelay = 100) => ({
      canRecover: () => true,
      recover: (error2) => exports_Effect.sleep(`${initialDelay} millis`).pipe(exports_Effect.andThen(exports_Effect.fail(error2))),
      maxRetries,
      retryDelay: initialDelay
    }),
    fallback: (fallbackValue) => ({
      canRecover: () => true,
      recover: () => exports_Effect.succeed(fallbackValue),
      maxRetries: 1
    }),
    ignore: () => ({
      canRecover: () => true,
      recover: () => exports_Effect.succeed(null),
      maxRetries: 1
    }),
    restoreTerminal: () => ({
      canRecover: (error2) => error2.operation !== "fatal",
      recover: () => exports_Effect.sync(() => {
        process.stdout.write("\x1B[?1049l");
        process.stdout.write("\x1B[?25h");
        process.stdout.write("\x1B[0m");
        if (process.stdin.isTTY) {
          process.stdin.setRawMode(false);
        }
      }),
      maxRetries: 1
    })
  };
  ErrorUtils = {
    isCritical: (error2) => {
      return error2._tag === "TerminalError" || error2._tag === "ApplicationError";
    },
    isRecoverable: (error2) => {
      return !ErrorUtils.isCritical(error2);
    },
    fromUnknown: (cause3, context10) => {
      if (cause3 instanceof TerminalError || cause3 instanceof InputError || cause3 instanceof RenderError || cause3 instanceof StorageError || cause3 instanceof ConfigError || cause3 instanceof ComponentError || cause3 instanceof ApplicationError || cause3 instanceof ValidationError) {
        return cause3;
      }
      if (cause3 instanceof Error) {
        return new ApplicationError({
          phase: "runtime",
          operation: context10?.operation || "unknown",
          cause: cause3,
          component: context10?.component,
          context: {
            errorName: cause3.name,
            errorMessage: cause3.message,
            ...context10?.additionalContext
          }
        });
      }
      return new ApplicationError({
        phase: "runtime",
        operation: context10?.operation || "unknown",
        cause: cause3,
        component: context10?.component,
        context: {
          causeType: typeof cause3,
          causeString: String(cause3),
          ...context10?.additionalContext
        }
      });
    },
    getUserMessage: (error2) => {
      switch (error2._tag) {
        case "TerminalError":
          return "Terminal operation failed. Please check your terminal settings.";
        case "InputError":
          return "Input error occurred. Please try again.";
        case "RenderError":
          return "Display error occurred. The interface may not appear correctly.";
        case "StorageError":
          return "File operation failed. Please check file permissions.";
        case "ConfigError":
          return "Configuration error. Please check your settings.";
        case "ComponentError":
          return "Component error occurred. The interface may not work correctly.";
        case "ApplicationError":
          return "Application error occurred.";
        case "ValidationError":
          return "Invalid input. Please check your entry and try again.";
        default:
          return "An unexpected error occurred.";
      }
    },
    getDebugInfo: (error2) => ({
      tag: error2._tag,
      type: error2._tag,
      message: error2.message,
      operation: error2.operation,
      timestamp: error2.timestamp.toISOString(),
      component: error2.component,
      context: error2.context,
      cause: error2.cause ? String(error2.cause) : undefined,
      stack: error2.cause instanceof Error ? error2.cause.stack : undefined
    }),
    logError: (error2, level = "error") => exports_Effect.gen(function* (_) {
      const debugInfo = ErrorUtils.getDebugInfo(error2);
      switch (level) {
        case "error":
          yield* _(exports_Effect.logError("TUI Error", debugInfo));
          break;
        case "warn":
          yield* _(exports_Effect.logWarning("TUI Warning", debugInfo));
          break;
        case "debug":
          yield* _(exports_Effect.logDebug("TUI Debug", debugInfo));
          break;
      }
    })
  };
});

// ../../src/services/terminal.ts
var TerminalService;
var init_terminal = __esm(() => {
  init_esm2();
  TerminalService = class TerminalService extends exports_Context.Tag("TerminalService")() {
  };
});

// ../../src/services/input.ts
var InputService;
var init_input = __esm(() => {
  init_esm2();
  InputService = class InputService extends exports_Context.Tag("InputService")() {
  };
});

// ../../src/services/renderer.ts
var RendererService;
var init_renderer = __esm(() => {
  init_esm2();
  RendererService = class RendererService extends exports_Context.Tag("RendererService")() {
  };
});

// ../../src/services/storage.ts
var StorageService, StorageUtils;
var init_storage = __esm(() => {
  init_esm2();
  StorageService = class StorageService extends exports_Context.Tag("StorageService")() {
  };
  StorageUtils = {
    getConfigPaths: (appName) => {
      const home = process.env.HOME || process.env.USERPROFILE || "~";
      const platform = process.platform;
      switch (platform) {
        case "darwin":
          return [
            `${home}/Library/Application Support/${appName}/config.json`,
            `${home}/.config/${appName}/config.json`,
            `${home}/.${appName}rc`
          ];
        case "win32":
          const appData = process.env.APPDATA || `${home}/AppData/Roaming`;
          return [
            `${appData}/${appName}/config.json`,
            `${home}/.config/${appName}/config.json`,
            `${home}/.${appName}rc`
          ];
        default:
          const xdgConfig = process.env.XDG_CONFIG_HOME || `${home}/.config`;
          return [
            `${xdgConfig}/${appName}/config.json`,
            `${home}/.config/${appName}/config.json`,
            `${home}/.${appName}rc`
          ];
      }
    },
    getDataPaths: (appName) => {
      const home = process.env.HOME || process.env.USERPROFILE || "~";
      const platform = process.platform;
      switch (platform) {
        case "darwin":
          return [
            `${home}/Library/Application Support/${appName}`,
            `${home}/.local/share/${appName}`
          ];
        case "win32":
          const appData = process.env.APPDATA || `${home}/AppData/Roaming`;
          return [
            `${appData}/${appName}`,
            `${home}/.local/share/${appName}`
          ];
        default:
          const xdgData = process.env.XDG_DATA_HOME || `${home}/.local/share`;
          return [
            `${xdgData}/${appName}`,
            `${home}/.local/share/${appName}`
          ];
      }
    },
    getCachePaths: (appName) => {
      const home = process.env.HOME || process.env.USERPROFILE || "~";
      const platform = process.platform;
      switch (platform) {
        case "darwin":
          return [
            `${home}/Library/Caches/${appName}`,
            `${home}/.cache/${appName}`
          ];
        case "win32":
          const localAppData = process.env.LOCALAPPDATA || `${home}/AppData/Local`;
          return [
            `${localAppData}/${appName}/Cache`,
            `${home}/.cache/${appName}`
          ];
        default:
          const xdgCache = process.env.XDG_CACHE_HOME || `${home}/.cache`;
          return [
            `${xdgCache}/${appName}`,
            `${home}/.cache/${appName}`
          ];
      }
    },
    generateBackupName: (originalPath, suffix) => {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const customSuffix = suffix || timestamp;
      return `${originalPath}.backup.${customSuffix}`;
    },
    isSafePath: (path) => {
      const normalized = path.replace(/\\/g, "/");
      return !normalized.includes("../") && !normalized.includes("/..");
    },
    ensureDirectory: async (path) => {
      try {
        await Bun.file(path).exists();
      } catch {
        const parts2 = path.split("/");
        let current2 = "";
        for (const part of parts2) {
          current2 += part + "/";
          try {
            await Bun.file(current2).exists();
          } catch {
            await Bun.spawn(["mkdir", "-p", current2]);
          }
        }
      }
    }
  };
});

// ../../src/services/hit-test.ts
var HitTestService, pointInRect = (x, y, bounds) => x >= bounds.x && x < bounds.x + bounds.width && y >= bounds.y && y < bounds.y + bounds.height, boundsToHitResult = (x, y, bounds) => ({
  componentId: bounds.componentId,
  bounds,
  localX: x - bounds.x,
  localY: y - bounds.y
}), findHitsAtPoint = (x, y, components) => components.filter((bounds) => pointInRect(x, y, bounds)).map((bounds) => boundsToHitResult(x, y, bounds)), HitTestServiceLive, createBounds = (componentId, x, y, width, height, zIndex = 0) => ({
  componentId,
  x,
  y,
  width,
  height,
  zIndex
});
var init_hit_test = __esm(() => {
  init_esm2();
  HitTestService = exports_Context.GenericTag("HitTestService");
  HitTestServiceLive = exports_Effect.gen(function* (_) {
    const componentsRef = yield* _(exports_Ref.make([]));
    return {
      registerComponent: (bounds) => exports_Ref.update(componentsRef, (components) => {
        const filtered = components.filter((c) => c.componentId !== bounds.componentId);
        return [...filtered, bounds].sort((a, b) => a.zIndex - b.zIndex);
      }),
      unregisterComponent: (componentId) => exports_Ref.update(componentsRef, (components) => components.filter((c) => c.componentId !== componentId)),
      clearComponents: exports_Ref.set(componentsRef, []),
      hitTest: (x, y) => exports_Effect.gen(function* (_2) {
        const components = yield* _2(exports_Ref.get(componentsRef));
        const hits = findHitsAtPoint(x, y, components);
        return hits.length > 0 ? hits[hits.length - 1] : null;
      }),
      hitTestAll: (x, y) => exports_Effect.gen(function* (_2) {
        const components = yield* _2(exports_Ref.get(componentsRef));
        return findHitsAtPoint(x, y, components);
      }),
      getAllBounds: exports_Ref.get(componentsRef)
    };
  });
});

// ../../src/services/mouse-router.ts
var MouseRouterService, routeToComponent = (mouseEvent, handlersRef) => exports_Effect.gen(function* (_) {
  const hitTest = yield* _(HitTestService);
  const handlers = yield* _(exports_Ref.get(handlersRef));
  const hitResult = yield* _(hitTest.hitTest(mouseEvent.x, mouseEvent.y));
  if (!hitResult)
    return null;
  const handlerOption = exports_HashMap.get(handlers, hitResult.componentId);
  if (exports_Option.isNone(handlerOption))
    return null;
  const handler = handlerOption.value;
  const message = handler(mouseEvent, hitResult.localX, hitResult.localY);
  if (!message)
    return null;
  return {
    componentId: hitResult.componentId,
    message,
    localX: hitResult.localX,
    localY: hitResult.localY
  };
}), registerWithServices = (componentId, bounds, handler, handlersRef) => exports_Effect.gen(function* (_) {
  const hitTest = yield* _(HitTestService);
  yield* _(hitTest.registerComponent(bounds));
  yield* _(exports_Ref.update(handlersRef, (handlers) => exports_HashMap.set(handlers, componentId, handler)));
}), unregisterFromServices = (componentId, handlersRef) => exports_Effect.gen(function* (_) {
  const hitTest = yield* _(HitTestService);
  yield* _(hitTest.unregisterComponent(componentId));
  yield* _(exports_Ref.update(handlersRef, (handlers) => exports_HashMap.remove(handlers, componentId)));
}), MouseRouterServiceLive;
var init_mouse_router = __esm(() => {
  init_esm2();
  init_hit_test();
  MouseRouterService = exports_Context.GenericTag("MouseRouterService");
  MouseRouterServiceLive = exports_Effect.gen(function* (_) {
    const handlersRef = yield* _(exports_Ref.make(exports_HashMap.empty()));
    return {
      registerComponent: (componentId, bounds, handler) => registerWithServices(componentId, bounds, handler, handlersRef),
      unregisterComponent: (componentId) => unregisterFromServices(componentId, handlersRef),
      updateComponentBounds: (componentId, bounds) => exports_Effect.gen(function* (_2) {
        const hitTest = yield* _2(HitTestService);
        yield* _2(hitTest.registerComponent(bounds));
      }),
      routeMouseEvent: (mouseEvent) => routeToComponent(mouseEvent, handlersRef),
      clearAll: exports_Effect.gen(function* (_2) {
        const hitTest = yield* _2(HitTestService);
        yield* _2(hitTest.clearComponents);
        yield* _2(exports_Ref.set(handlersRef, exports_HashMap.empty()));
      })
    };
  });
});

// ../../src/services/focus.ts
var FocusService, initialState, blurCurrentComponent = (state) => exports_Effect.gen(function* (_) {
  if (exports_Option.isSome(state.currentFocus)) {
    const current2 = state.components.get(state.currentFocus.value);
    if (current2?.onBlur) {
      yield* _(current2.onBlur());
    }
  }
}), findComponentInDirection = (components, currentId, direction) => {
  if (components.length === 0)
    return exports_Option.none();
  if (exports_Option.isNone(currentId)) {
    return exports_Option.some(direction === "next" ? components[0] : components[components.length - 1]);
  }
  const currentIndex = components.findIndex((c) => c.id === currentId.value);
  if (currentIndex === -1) {
    return exports_Option.some(direction === "next" ? components[0] : components[components.length - 1]);
  }
  const nextIndex = direction === "next" ? (currentIndex + 1) % components.length : currentIndex === 0 ? components.length - 1 : currentIndex - 1;
  return exports_Option.some(components[nextIndex]);
}, navigateFocus = (direction, stateRef, setFocus) => exports_Effect.gen(function* (_) {
  const state = yield* _(exports_Ref.get(stateRef));
  const trapId = exports_Option.getOrNull(state.focusTrap);
  const components = getSortedComponents(state.components, trapId);
  const target = findComponentInDirection(components, state.currentFocus, direction);
  if (exports_Option.isSome(target)) {
    yield* _(setFocus(target.value.id));
    return exports_Option.some(target.value.id);
  }
  return exports_Option.none();
}), getSortedComponents = (components, trapId) => {
  let comps = Array.from(components.values()).filter((c) => c.focusable).sort((a, b) => a.tabIndex - b.tabIndex);
  if (trapId) {
    comps = comps.filter((c) => c.id === trapId || c.trapped);
  }
  return comps;
}, FocusServiceLive;
var init_focus = __esm(() => {
  init_esm2();
  FocusService = exports_Context.GenericTag("@app/FocusService");
  initialState = {
    components: new Map,
    currentFocus: exports_Option.none(),
    focusTrap: exports_Option.none(),
    savedFocus: exports_Option.none()
  };
  FocusServiceLive = exports_Effect.gen(function* (_) {
    const stateRef = yield* _(exports_Ref.make(initialState));
    const register = (component) => exports_Ref.update(stateRef, (state) => ({
      ...state,
      components: new Map(state.components).set(component.id, component)
    }));
    const unregister = (id3) => exports_Ref.update(stateRef, (state) => {
      const components = new Map(state.components);
      components.delete(id3);
      return {
        ...state,
        components,
        currentFocus: exports_Option.filter(state.currentFocus, (focusId) => focusId !== id3)
      };
    });
    const getCurrentFocus = () => exports_Ref.get(stateRef).pipe(exports_Effect.map((state) => state.currentFocus));
    const setFocus = (id3) => exports_Effect.gen(function* (_2) {
      const state = yield* _2(exports_Ref.get(stateRef));
      const component = state.components.get(id3);
      if (!component || !component.focusable) {
        return false;
      }
      yield* _2(blurCurrentComponent(state));
      yield* _2(exports_Ref.update(stateRef, (s) => ({
        ...s,
        currentFocus: exports_Option.some(id3)
      })));
      if (component.onFocus) {
        yield* _2(component.onFocus());
      }
      return true;
    });
    const clearFocus = () => exports_Effect.gen(function* (_2) {
      const state = yield* _2(exports_Ref.get(stateRef));
      yield* _2(blurCurrentComponent(state));
      yield* _2(exports_Ref.update(stateRef, (s) => ({
        ...s,
        currentFocus: exports_Option.none()
      })));
    });
    const focusNext = () => navigateFocus("next", stateRef, setFocus);
    const focusPrevious = () => navigateFocus("previous", stateRef, setFocus);
    const trapFocus = (containerId) => exports_Effect.gen(function* (_2) {
      const state = yield* _2(exports_Ref.get(stateRef));
      yield* _2(exports_Ref.update(stateRef, (s) => ({
        ...s,
        focusTrap: exports_Option.some(containerId),
        savedFocus: s.currentFocus
      })));
      const component = state.components.get(containerId);
      if (component && component.focusable) {
        yield* _2(setFocus(containerId));
      }
    });
    const releaseTrap = () => exports_Effect.gen(function* (_2) {
      const state = yield* _2(exports_Ref.get(stateRef));
      yield* _2(exports_Ref.update(stateRef, (s) => ({
        ...s,
        focusTrap: exports_Option.none()
      })));
      if (exports_Option.isSome(state.savedFocus)) {
        yield* _2(setFocus(state.savedFocus.value));
      }
    });
    const saveFocusState = () => exports_Ref.update(stateRef, (state) => ({
      ...state,
      savedFocus: state.currentFocus
    }));
    const restoreFocusState = () => exports_Effect.gen(function* (_2) {
      const state = yield* _2(exports_Ref.get(stateRef));
      if (exports_Option.isSome(state.savedFocus)) {
        yield* _2(setFocus(state.savedFocus.value));
      }
    });
    const getTabOrder = () => exports_Ref.get(stateRef).pipe(exports_Effect.map((state) => {
      const trapId = exports_Option.getOrNull(state.focusTrap);
      return getSortedComponents(state.components, trapId);
    }));
    const hasFocus = (id3) => exports_Ref.get(stateRef).pipe(exports_Effect.map((state) => exports_Option.isSome(state.currentFocus) && state.currentFocus.value === id3));
    return FocusService.of({
      register,
      unregister,
      getCurrentFocus,
      setFocus,
      clearFocus,
      focusNext,
      focusPrevious,
      trapFocus,
      releaseTrap,
      saveFocusState,
      restoreFocusState,
      getTabOrder,
      hasFocus
    });
  });
});

// ../../src/services/index.ts
var init_services = __esm(() => {
  init_terminal();
  init_input();
  init_renderer();
  init_storage();
  init_hit_test();
  init_mouse_router();
  init_focus();
});

// ../../src/core/runtime.ts
class Runtime2 {
  component;
  config;
  constructor(component, config2 = {}) {
    this.component = component;
    this.config = config2;
    this.config = {
      fps: 60,
      debug: false,
      quitOnEscape: false,
      quitOnCtrlC: true,
      enableMouse: false,
      fullscreen: true,
      ...config2
    };
  }
  run = () => {
    const self = this;
    return exports_Effect.gen(function* (_) {
      const terminal2 = yield* _(TerminalService);
      const input2 = yield* _(InputService);
      const renderer2 = yield* _(RendererService);
      yield* _(terminal2.setRawMode(true));
      if (self.config.fullscreen ?? true) {
        yield* _(terminal2.setAlternateScreen(true));
      }
      yield* _(terminal2.hideCursor);
      yield* _(terminal2.clear);
      if (self.config.enableMouse) {
        yield* _(input2.enableMouse);
      }
      const [initialModel, initialCmds] = yield* _(self.component.init);
      const msgQueue = yield* _(exports_Queue.unbounded());
      const state = yield* _(exports_Ref.make({
        model: initialModel,
        running: true,
        lastRenderTime: Date.now(),
        frameCount: 0
      }));
      yield* _(processCmds(initialCmds, msgQueue));
      const signalHandlers = yield* _(setupSignalHandlers(msgQueue, terminal2, self.config));
      const quitFiber = self.config.quitOnCtrlC || self.config.quitOnEscape ? yield* _(handleAutomaticQuitKeys(input2, msgQueue, self.config).pipe(exports_Effect.fork, exports_Effect.interruptible)) : null;
      const subFiber = yield* _(handleSubscriptions(self.component, state, msgQueue).pipe(exports_Effect.fork, exports_Effect.interruptible));
      const renderFiber = yield* _(renderLoop(self.component, renderer2, state, self.config).pipe(exports_Effect.fork, exports_Effect.interruptible));
      yield* _(exports_Stream.fromQueue(msgQueue).pipe(exports_Stream.takeWhile((msg) => msg._tag !== "Quit"), exports_Stream.runForEach((msg) => processMessage(self.component, state, msgQueue, msg, self.config))));
      yield* _(signalHandlers.cleanup);
      const fibersToInterrupt = quitFiber ? [quitFiber, subFiber, renderFiber] : [subFiber, renderFiber];
      yield* _(exports_Fiber.interruptAll(fibersToInterrupt));
      yield* _(cleanup(terminal2, self.config));
    }).pipe(exports_Effect.scoped, exports_Effect.catchAllDefect((defect) => exports_Effect.gen(function* (_) {
      emergencyTerminalCleanup(self.config);
      const terminal2 = yield* _(TerminalService);
      yield* _(cleanup(terminal2, self.config));
      yield* _(exports_Effect.die(defect));
    })), exports_Effect.catchAll((error2) => exports_Effect.gen(function* (_) {
      emergencyTerminalCleanup(self.config);
      const terminal2 = yield* _(TerminalService);
      yield* _(cleanup(terminal2, self.config));
      yield* _(exports_Effect.fail(error2));
    })));
  };
}
var processMessage = (component, state, msgQueue, sysMsg, config2) => exports_Effect.gen(function* (_) {
  const currentState = yield* _(exports_Ref.get(state));
  let msg;
  switch (sysMsg._tag) {
    case "UserMsg":
      msg = sysMsg.msg;
      break;
    case "WindowResized":
      return;
    case "KeyPressed":
      return;
    case "MouseEvent":
      const mouseRouter = yield* _(MouseRouterService);
      const routingResult = yield* _(mouseRouter.routeMouseEvent(sysMsg.event));
      if (config2.debug) {
        if (routingResult) {
          console.log(`Mouse routed to ${routingResult.componentId}: ${sysMsg.event.type} ${sysMsg.event.button} at (${sysMsg.event.x}, ${sysMsg.event.y})`);
        } else {
          console.log(`Mouse not routed: ${sysMsg.event.type} ${sysMsg.event.button} at (${sysMsg.event.x}, ${sysMsg.event.y})`);
        }
      }
      if (routingResult) {
        yield* _(exports_Queue.offer(msgQueue, { _tag: "UserMsg", msg: routingResult.message }));
      }
      return;
    case "Tick":
      return;
    case "Quit":
      yield* _(exports_Ref.update(state, (s) => ({ ...s, running: false })));
      return;
  }
  const [newModel, cmds] = yield* _(component.update(msg, currentState.model));
  yield* _(exports_Ref.update(state, (s) => ({ ...s, model: newModel })));
  yield* _(processCmds(cmds, msgQueue));
}), processCmds = (cmds, msgQueue) => exports_Effect.forEach(cmds, (cmd) => cmd.pipe(exports_Effect.flatMap((msg) => {
  if (typeof msg === "object" && msg !== null && "_tag" in msg && msg._tag === "Quit") {
    return exports_Queue.offer(msgQueue, { _tag: "Quit" });
  } else {
    return exports_Queue.offer(msgQueue, { _tag: "UserMsg", msg });
  }
}), exports_Effect.catchAll(() => exports_Effect.void))), emergencyTerminalCleanup = (config2) => {
  try {
    if (process.stdin.isTTY && "setRawMode" in process.stdin) {
      process.stdin.setRawMode(false);
    }
    process.stdout.write("\x1B[?25h");
    if (config2.fullscreen ?? true) {
      process.stdout.write("\x1B[?1049l");
    }
    process.stdout.write("\x1B[0m");
    process.stdout.write("\x1B[2J");
    process.stdout.write("\x1B[H");
  } catch {}
}, setupSignalHandlers = (msgQueue, terminal2, config2) => exports_Effect.gen(function* (_) {
  let isShuttingDown = false;
  const handleGracefulShutdown = () => {
    if (isShuttingDown)
      return;
    isShuttingDown = true;
    exports_Effect.runSync(exports_Queue.offer(msgQueue, { _tag: "Quit" }));
  };
  const handleEmergencyShutdown = (reason) => {
    if (isShuttingDown)
      return;
    isShuttingDown = true;
    if (reason) {
      console.error("Emergency shutdown:", reason);
    }
    emergencyTerminalCleanup(config2);
    exports_Effect.runSync(cleanup(terminal2, config2).pipe(exports_Effect.catchAll(() => exports_Effect.void)));
    process.exit(1);
  };
  process.on("SIGINT", handleGracefulShutdown);
  process.on("SIGTERM", handleGracefulShutdown);
  process.on("exit", () => emergencyTerminalCleanup(config2));
  process.on("beforeExit", () => emergencyTerminalCleanup(config2));
  process.on("uncaughtException", (error2) => {
    handleEmergencyShutdown(`Uncaught exception: ${error2.message}`);
  });
  process.on("unhandledRejection", (reason) => {
    handleEmergencyShutdown(`Unhandled rejection: ${reason}`);
  });
  return {
    cleanup: exports_Effect.sync(() => {
      process.removeListener("SIGINT", handleGracefulShutdown);
      process.removeListener("SIGTERM", handleGracefulShutdown);
      process.removeListener("exit", emergencyTerminalCleanup);
      process.removeListener("beforeExit", emergencyTerminalCleanup);
      process.removeListener("uncaughtException", handleEmergencyShutdown);
      process.removeListener("unhandledRejection", handleEmergencyShutdown);
    })
  };
}), handleAutomaticQuitKeys = (input2, msgQueue, config2) => exports_Effect.gen(function* (_) {
  yield* _(input2.filterKeys((key) => {
    const isQuit = config2.quitOnCtrlC && key.ctrl && key.key === "ctrl+c" || config2.quitOnEscape && key.key === "escape";
    return isQuit;
  }).pipe(exports_Stream.runForEach(() => exports_Queue.offer(msgQueue, { _tag: "Quit" }))));
}), handleSubscriptions = (component, state, msgQueue) => exports_Effect.gen(function* (_) {
  if (!component.subscriptions)
    return;
  let currentSubFiber = null;
  let lastModel = null;
  const startSubscription = (model) => exports_Effect.gen(function* (_2) {
    if (currentSubFiber) {
      yield* _2(exports_Fiber.interrupt(currentSubFiber));
    }
    if (!component.subscriptions)
      return;
    const sub = yield* _2(component.subscriptions(model));
    currentSubFiber = yield* _2(sub.pipe(exports_Stream.takeWhile(() => exports_Effect.gen(function* (_3) {
      const currentState = yield* _3(exports_Ref.get(state));
      return currentState.running;
    })), exports_Stream.runForEach((msg) => exports_Queue.offer(msgQueue, { _tag: "UserMsg", msg }))).pipe(exports_Effect.fork));
    lastModel = model;
  });
  const initialState2 = yield* _(exports_Ref.get(state));
  yield* _(startSubscription(initialState2.model));
  yield* _(exports_Effect.repeat(exports_Effect.gen(function* (_2) {
    const currentState = yield* _2(exports_Ref.get(state));
    if (!currentState.running) {
      if (currentSubFiber) {
        yield* _2(exports_Fiber.interrupt(currentSubFiber));
      }
      return;
    }
    if (currentState.model !== lastModel) {
      yield* _2(startSubscription(currentState.model));
    }
    yield* _2(exports_Effect.sleep(16));
  }), exports_Schedule.whileEffect(() => exports_Effect.gen(function* (_2) {
    const currentState = yield* _2(exports_Ref.get(state));
    return currentState.running;
  }))));
}), renderLoop = (component, renderer2, state, config2) => exports_Effect.gen(function* (_) {
  const targetFrameTime = 1000 / (config2.fps || 60);
  yield* _(exports_Effect.repeat(exports_Effect.gen(function* (_2) {
    const currentState = yield* _2(exports_Ref.get(state));
    if (!currentState.running)
      return;
    const startTime = Date.now();
    const view = component.view(currentState.model);
    yield* _2(renderer2.beginFrame);
    yield* _2(renderer2.render(view));
    yield* _2(renderer2.endFrame);
    const endTime = Date.now();
    const frameTime = endTime - startTime;
    yield* _2(exports_Ref.update(state, (s) => ({
      ...s,
      lastRenderTime: endTime,
      frameCount: s.frameCount + 1
    })));
    if (config2.debug && frameTime > targetFrameTime) {
      yield* _2(exports_Effect.logWarning(`Slow frame: ${frameTime}ms`));
    }
  }), exports_Schedule.fixed(`${Math.floor(targetFrameTime)} millis`)));
}), cleanup = (terminal2, config2) => exports_Effect.gen(function* (_) {
  if (config2.enableMouse) {
    const input2 = yield* _(InputService);
    yield* _(input2.disableMouse);
  }
  yield* _(terminal2.write("\x1B[0m"));
  yield* _(terminal2.showCursor);
  yield* _(terminal2.setRawMode(false));
  if (config2.fullscreen ?? true) {
    yield* _(terminal2.setAlternateScreen(false));
  }
  yield* _(terminal2.clear);
}), runApp = (component, config2) => {
  const runtime5 = new Runtime2(component, config2);
  return runtime5.run();
};
var init_runtime2 = __esm(() => {
  init_esm2();
  init_services();
});

// ../../src/core/keys.ts
function getKeyName(event) {
  if (event.type && event.type !== "runes" /* Runes */) {
    return event.key;
  }
  const parts2 = [];
  if (event.ctrl)
    parts2.push("ctrl");
  if (event.alt)
    parts2.push("alt");
  if (event.shift && event.runes && event.runes !== event.runes.toLowerCase()) {
    parts2.push("shift");
  }
  if (event.meta)
    parts2.push("meta");
  if (event.runes) {
    parts2.push(event.runes.toLowerCase());
  }
  return parts2.join("+");
}
function generateKeyCode(char) {
  if (char.match(/[a-zA-Z]/)) {
    return `Key${char.toUpperCase()}`;
  }
  if (char.match(/[0-9]/)) {
    return `Digit${char}`;
  }
  const specialCodes = {
    " ": "Space",
    "-": "Minus",
    "=": "Equal",
    "[": "BracketLeft",
    "]": "BracketRight",
    "\\": "Backslash",
    ";": "Semicolon",
    "'": "Quote",
    "`": "Backquote",
    ",": "Comma",
    ".": "Period",
    "/": "Slash"
  };
  return specialCodes[char];
}
function parseChar(char, ctrl = false, alt = false, shift2 = false) {
  const code = char.charCodeAt(0);
  if (code < 32) {
    const ctrlChar = String.fromCharCode(code + 96);
    const keyName = `ctrl+${ctrlChar}`;
    let keyType;
    switch (char) {
      case "\t":
        keyType = "tab" /* Tab */;
        break;
      case "\r":
      case `
`:
        keyType = "enter" /* Enter */;
        break;
      case "\x1B":
        keyType = "escape" /* Escape */;
        break;
      case " ":
        keyType = "space" /* Space */;
        break;
      case "\x7F":
        keyType = "delete" /* Delete */;
        break;
      case "\b":
        keyType = "backspace" /* Backspace */;
        break;
      default:
        keyType = "runes" /* Runes */;
        break;
    }
    return {
      type: keyType,
      key: keyName,
      code: `Key${ctrlChar.toUpperCase()}`,
      runes: keyType === "runes" /* Runes */ ? char : undefined,
      ctrl: true,
      alt,
      shift: shift2,
      meta: false
    };
  }
  return {
    type: "runes" /* Runes */,
    key: getKeyName({
      type: "runes" /* Runes */,
      runes: char,
      ctrl,
      alt,
      shift: shift2,
      meta: false,
      key: ""
    }),
    code: generateKeyCode(char),
    runes: char,
    ctrl,
    alt,
    shift: shift2,
    meta: false
  };
}
var ANSI_SEQUENCES, KeyUtils;
var init_keys = __esm(() => {
  ANSI_SEQUENCES = new Map([
    ["\x1B[A", { type: "up" /* Up */, key: "up", code: "ArrowUp" }],
    ["\x1B[B", { type: "down" /* Down */, key: "down", code: "ArrowDown" }],
    ["\x1B[C", { type: "right" /* Right */, key: "right", code: "ArrowRight" }],
    ["\x1B[D", { type: "left" /* Left */, key: "left", code: "ArrowLeft" }],
    ["\x1BOA", { type: "up" /* Up */, key: "up", code: "ArrowUp" }],
    ["\x1BOB", { type: "down" /* Down */, key: "down", code: "ArrowDown" }],
    ["\x1BOC", { type: "right" /* Right */, key: "right", code: "ArrowRight" }],
    ["\x1BOD", { type: "left" /* Left */, key: "left", code: "ArrowLeft" }],
    ["\x1B[1;2A", { type: "shift+up" /* ShiftUp */, key: "shift+up", shift: true }],
    ["\x1B[1;2B", { type: "shift+down" /* ShiftDown */, key: "shift+down", shift: true }],
    ["\x1B[1;2C", { type: "shift+right" /* ShiftRight */, key: "shift+right", shift: true }],
    ["\x1B[1;2D", { type: "shift+left" /* ShiftLeft */, key: "shift+left", shift: true }],
    ["\x1B[1;3A", { type: "alt+up" /* AltUp */, key: "alt+up", alt: true }],
    ["\x1B[1;3B", { type: "alt+down" /* AltDown */, key: "alt+down", alt: true }],
    ["\x1B[1;3C", { type: "alt+right" /* AltRight */, key: "alt+right", alt: true }],
    ["\x1B[1;3D", { type: "alt+left" /* AltLeft */, key: "alt+left", alt: true }],
    ["\x1B[1;5A", { type: "ctrl+up" /* CtrlUp */, key: "ctrl+up", ctrl: true }],
    ["\x1B[1;5B", { type: "ctrl+down" /* CtrlDown */, key: "ctrl+down", ctrl: true }],
    ["\x1B[1;5C", { type: "ctrl+right" /* CtrlRight */, key: "ctrl+right", ctrl: true }],
    ["\x1B[1;5D", { type: "ctrl+left" /* CtrlLeft */, key: "ctrl+left", ctrl: true }],
    ["\x1BOP", { type: "f1" /* F1 */, key: "f1" }],
    ["\x1BOQ", { type: "f2" /* F2 */, key: "f2" }],
    ["\x1BOR", { type: "f3" /* F3 */, key: "f3" }],
    ["\x1BOS", { type: "f4" /* F4 */, key: "f4" }],
    ["\x1B[15~", { type: "f5" /* F5 */, key: "f5" }],
    ["\x1B[17~", { type: "f6" /* F6 */, key: "f6" }],
    ["\x1B[18~", { type: "f7" /* F7 */, key: "f7" }],
    ["\x1B[19~", { type: "f8" /* F8 */, key: "f8" }],
    ["\x1B[20~", { type: "f9" /* F9 */, key: "f9" }],
    ["\x1B[21~", { type: "f10" /* F10 */, key: "f10" }],
    ["\x1B[23~", { type: "f11" /* F11 */, key: "f11" }],
    ["\x1B[24~", { type: "f12" /* F12 */, key: "f12" }],
    ["\x1B[H", { type: "home" /* Home */, key: "home" }],
    ["\x1B[F", { type: "end" /* End */, key: "end" }],
    ["\x1B[5~", { type: "pageup" /* PageUp */, key: "pageup" }],
    ["\x1B[6~", { type: "pagedown" /* PageDown */, key: "pagedown" }],
    ["\x1B[2~", { type: "runes" /* Runes */, key: "insert" }],
    ["\x1B[3~", { type: "delete" /* Delete */, key: "delete", code: "Delete" }],
    ["\x1B[Z", { type: "shift+tab" /* ShiftTab */, key: "shift+tab", shift: true }],
    ["\x1B", { type: "escape" /* Escape */, key: "escape", code: "Escape" }],
    ["\r", { type: "enter" /* Enter */, key: "enter", code: "Enter" }],
    [`
`, { type: "enter" /* Enter */, key: "enter", code: "Enter" }],
    ["\t", { type: "tab" /* Tab */, key: "tab", code: "Tab" }],
    ["\x7F", { type: "backspace" /* Backspace */, key: "backspace", code: "Backspace" }],
    ["\b", { type: "backspace" /* Backspace */, key: "backspace", code: "Backspace" }],
    [" ", { type: "space" /* Space */, key: "space", code: "Space" }]
  ]);
  KeyUtils = {
    matches: (event, ...patterns) => {
      return patterns.includes(event.key);
    },
    binding: (keys9, help) => ({
      keys: keys9,
      help,
      matches: (event) => keys9.includes(event.key)
    }),
    bindings: {
      quit: { keys: ["ctrl+c", "q"], help: { key: "q", desc: "quit" } },
      help: { keys: ["?", "h"], help: { key: "?", desc: "help" } },
      up: { keys: ["up", "k"], help: { key: "\u2191/k", desc: "up" } },
      down: { keys: ["down", "j"], help: { key: "\u2193/j", desc: "down" } },
      left: { keys: ["left", "h"], help: { key: "\u2190/h", desc: "left" } },
      right: { keys: ["right", "l"], help: { key: "\u2192/l", desc: "right" } },
      confirm: { keys: ["enter", "y"], help: { key: "enter", desc: "confirm" } },
      cancel: { keys: ["escape", "n"], help: { key: "esc", desc: "cancel" } }
    }
  };
});

// ../../src/utils/string-width.ts
var EMOJI_OVERRIDES, stringWidth = (str) => {
  if (str in EMOJI_OVERRIDES) {
    return EMOJI_OVERRIDES[str];
  }
  return Bun.stringWidth(str);
};
var init_string_width = __esm(() => {
  EMOJI_OVERRIDES = {
    "\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08": 2
  };
});

// ../../src/styling/borders.ts
var BorderSide, hasSide = (sides, side) => (sides & side) === side, combineSides = (...sides) => sides.reduce((acc, side) => acc | side, 0 /* None */), createUniformBorder = (char) => ({
  top: char,
  bottom: char,
  left: char,
  right: char,
  topLeft: char,
  topRight: char,
  bottomLeft: char,
  bottomRight: char
}), createBorder = (chars) => ({
  top: chars.top ?? " ",
  bottom: chars.bottom ?? " ",
  left: chars.left ?? " ",
  right: chars.right ?? " ",
  topLeft: chars.topLeft ?? " ",
  topRight: chars.topRight ?? " ",
  bottomLeft: chars.bottomLeft ?? " ",
  bottomRight: chars.bottomRight ?? " ",
  middleLeft: chars.middleLeft,
  middleRight: chars.middleRight,
  middleTop: chars.middleTop,
  middleBottom: chars.middleBottom,
  middle: chars.middle
}), Borders, getBorderChar = (border, position, sides) => {
  if (sides === 0 /* None */)
    return " ";
  switch (position) {
    case "topLeft":
      if (!hasSide(sides, 1 /* Top */) && !hasSide(sides, 8 /* Left */))
        return " ";
      if (!hasSide(sides, 1 /* Top */))
        return border.left;
      if (!hasSide(sides, 8 /* Left */))
        return border.top;
      return border.topLeft;
    case "topRight":
      if (!hasSide(sides, 1 /* Top */) && !hasSide(sides, 2 /* Right */))
        return " ";
      if (!hasSide(sides, 1 /* Top */))
        return border.right;
      if (!hasSide(sides, 2 /* Right */))
        return border.top;
      return border.topRight;
    case "bottomLeft":
      if (!hasSide(sides, 4 /* Bottom */) && !hasSide(sides, 8 /* Left */))
        return " ";
      if (!hasSide(sides, 4 /* Bottom */))
        return border.left;
      if (!hasSide(sides, 8 /* Left */))
        return border.bottom;
      return border.bottomLeft;
    case "bottomRight":
      if (!hasSide(sides, 4 /* Bottom */) && !hasSide(sides, 2 /* Right */))
        return " ";
      if (!hasSide(sides, 4 /* Bottom */))
        return border.right;
      if (!hasSide(sides, 2 /* Right */))
        return border.bottom;
      return border.bottomRight;
    case "top":
      return hasSide(sides, 1 /* Top */) ? border.top : " ";
    case "bottom":
      return hasSide(sides, 4 /* Bottom */) ? border.bottom : " ";
    case "left":
      return hasSide(sides, 8 /* Left */) ? border.left : " ";
    case "right":
      return hasSide(sides, 2 /* Right */) ? border.right : " ";
    default:
      return border[position] ?? " ";
  }
}, renderBox = (content, border, sides = 15 /* All */, width) => {
  if (content.length === 0)
    return [];
  const contentWidth = width ?? Math.max(...content.map((line) => stringWidth(line)));
  const result = [];
  if (hasSide(sides, 1 /* Top */)) {
    const topLine = getBorderChar(border, "topLeft", sides) + getBorderChar(border, "top", sides).repeat(contentWidth) + getBorderChar(border, "topRight", sides);
    result.push(topLine);
  }
  for (const line of content) {
    const currentWidth = stringWidth(line);
    const padding = Math.max(0, contentWidth - currentWidth);
    const paddedLine = line + " ".repeat(padding);
    const contentLine = getBorderChar(border, "left", sides) + paddedLine + getBorderChar(border, "right", sides);
    result.push(contentLine);
  }
  if (hasSide(sides, 4 /* Bottom */)) {
    const bottomLine = getBorderChar(border, "bottomLeft", sides) + getBorderChar(border, "bottom", sides).repeat(contentWidth) + getBorderChar(border, "bottomRight", sides);
    result.push(bottomLine);
  }
  return result;
}, mergeBorders = (base, overlay) => ({
  top: overlay.top ?? base.top,
  bottom: overlay.bottom ?? base.bottom,
  left: overlay.left ?? base.left,
  right: overlay.right ?? base.right,
  topLeft: overlay.topLeft ?? base.topLeft,
  topRight: overlay.topRight ?? base.topRight,
  bottomLeft: overlay.bottomLeft ?? base.bottomLeft,
  bottomRight: overlay.bottomRight ?? base.bottomRight,
  middleLeft: overlay.middleLeft ?? base.middleLeft,
  middleRight: overlay.middleRight ?? base.middleRight,
  middleTop: overlay.middleTop ?? base.middleTop,
  middleBottom: overlay.middleBottom ?? base.middleBottom,
  middle: overlay.middle ?? base.middle
}), borderFromPattern = (pattern2) => {
  if (pattern2.length < 8) {
    throw new Error("Border pattern must have at least 8 characters");
  }
  return {
    topLeft: pattern2[0] ?? "",
    top: pattern2[1] ?? "",
    topRight: pattern2[2] ?? "",
    left: pattern2[3] ?? "",
    right: pattern2[4] ?? "",
    bottomLeft: pattern2[5] ?? "",
    bottom: pattern2[6] ?? "",
    bottomRight: pattern2[7] ?? ""
  };
};
var init_borders = __esm(() => {
  init_string_width();
  ((BorderSide2) => {
    BorderSide2[BorderSide2["None"] = 0] = "None";
    BorderSide2[BorderSide2["Top"] = 1] = "Top";
    BorderSide2[BorderSide2["Right"] = 2] = "Right";
    BorderSide2[BorderSide2["Bottom"] = 4] = "Bottom";
    BorderSide2[BorderSide2["Left"] = 8] = "Left";
    BorderSide2[BorderSide2["All"] = 15] = "All";
  })(BorderSide ||= {});
  Borders = {
    None: createUniformBorder(" "),
    Normal: {
      top: "\u2500",
      bottom: "\u2500",
      left: "\u2502",
      right: "\u2502",
      topLeft: "\u250C",
      topRight: "\u2510",
      bottomLeft: "\u2514",
      bottomRight: "\u2518",
      middleLeft: "\u251C",
      middleRight: "\u2524",
      middleTop: "\u252C",
      middleBottom: "\u2534",
      middle: "\u253C"
    },
    Rounded: {
      top: "\u2500",
      bottom: "\u2500",
      left: "\u2502",
      right: "\u2502",
      topLeft: "\u256D",
      topRight: "\u256E",
      bottomLeft: "\u2570",
      bottomRight: "\u256F",
      middleLeft: "\u251C",
      middleRight: "\u2524",
      middleTop: "\u252C",
      middleBottom: "\u2534",
      middle: "\u253C"
    },
    Thick: {
      top: "\u2501",
      bottom: "\u2501",
      left: "\u2503",
      right: "\u2503",
      topLeft: "\u250F",
      topRight: "\u2513",
      bottomLeft: "\u2517",
      bottomRight: "\u251B",
      middleLeft: "\u2523",
      middleRight: "\u252B",
      middleTop: "\u2533",
      middleBottom: "\u253B",
      middle: "\u254B"
    },
    Double: {
      top: "\u2550",
      bottom: "\u2550",
      left: "\u2551",
      right: "\u2551",
      topLeft: "\u2554",
      topRight: "\u2557",
      bottomLeft: "\u255A",
      bottomRight: "\u255D",
      middleLeft: "\u2560",
      middleRight: "\u2563",
      middleTop: "\u2566",
      middleBottom: "\u2569",
      middle: "\u256C"
    },
    ASCII: {
      top: "-",
      bottom: "-",
      left: "|",
      right: "|",
      topLeft: "+",
      topRight: "+",
      bottomLeft: "+",
      bottomRight: "+",
      middleLeft: "+",
      middleRight: "+",
      middleTop: "+",
      middleBottom: "+",
      middle: "+"
    },
    Block: {
      top: "\u2588",
      bottom: "\u2588",
      left: "\u2588",
      right: "\u2588",
      topLeft: "\u2588",
      topRight: "\u2588",
      bottomLeft: "\u2588",
      bottomRight: "\u2588"
    },
    Minimal: {
      top: " ",
      bottom: " ",
      left: " ",
      right: " ",
      topLeft: "\u250C",
      topRight: "\u2510",
      bottomLeft: "\u2514",
      bottomRight: "\u2518"
    }
  };
});

// ../../src/styling/types.ts
var Position, normalizeSpacing = (top, right3, bottom, left3) => {
  if (right3 === undefined) {
    return [top, top, top, top];
  } else if (bottom === undefined) {
    return [top, right3, top, right3];
  } else if (left3 === undefined) {
    return [top, right3, bottom, right3];
  } else {
    return [top, right3, bottom, left3];
  }
}, HorizontalAlign, VerticalAlign, INHERITABLE_PROPS, isInheritable = (prop) => INHERITABLE_PROPS.has(prop);
var init_types2 = __esm(() => {
  Position = {
    of: (n) => n >= 0 && n <= 1 ? n : null,
    Start: 0,
    Center: 0.5,
    End: 1,
    Left: 0,
    Top: 0,
    Middle: 0.5,
    Right: 1,
    Bottom: 1
  };
  ((HorizontalAlign2) => {
    HorizontalAlign2["Left"] = "left";
    HorizontalAlign2["Center"] = "center";
    HorizontalAlign2["Right"] = "right";
    HorizontalAlign2["Justify"] = "justify";
  })(HorizontalAlign ||= {});
  ((VerticalAlign2) => {
    VerticalAlign2["Top"] = "top";
    VerticalAlign2["Middle"] = "middle";
    VerticalAlign2["Bottom"] = "bottom";
  })(VerticalAlign ||= {});
  INHERITABLE_PROPS = new Set([
    "foreground",
    "background",
    "bold",
    "italic",
    "underline",
    "strikethrough",
    "inverse",
    "blink",
    "faint",
    "transform",
    "wordBreak"
  ]);
});

// ../../src/styling/style.ts
var Style, style = () => new Style({
  props: {},
  parent: exports_Option.none()
}), styleFrom = (props) => new Style({
  props,
  parent: exports_Option.none()
}), Styles;
var init_style = __esm(() => {
  init_esm2();
  init_borders();
  init_types2();
  Style = class Style extends exports_Data.Class {
    foreground(color) {
      return new Style({
        ...this,
        props: { ...this.props, foreground: color }
      });
    }
    background(color) {
      return new Style({
        ...this,
        props: { ...this.props, background: color }
      });
    }
    border(border, sides = 15 /* All */) {
      return new Style({
        ...this,
        props: {
          ...this.props,
          border,
          borderSides: sides
        }
      });
    }
    borderSides(sides) {
      return new Style({
        ...this,
        props: { ...this.props, borderSides: sides }
      });
    }
    borderTop(enable4 = true) {
      const current2 = this.props.borderSides || 15 /* All */;
      const newSides = enable4 ? current2 | 1 /* Top */ : current2 & ~1 /* Top */;
      return this.borderSides(newSides);
    }
    borderRight(enable4 = true) {
      const current2 = this.props.borderSides || 15 /* All */;
      const newSides = enable4 ? current2 | 2 /* Right */ : current2 & ~2 /* Right */;
      return this.borderSides(newSides);
    }
    borderBottom(enable4 = true) {
      const current2 = this.props.borderSides || 15 /* All */;
      const newSides = enable4 ? current2 | 4 /* Bottom */ : current2 & ~4 /* Bottom */;
      return this.borderSides(newSides);
    }
    borderLeft(enable4 = true) {
      const current2 = this.props.borderSides || 15 /* All */;
      const newSides = enable4 ? current2 | 8 /* Left */ : current2 & ~8 /* Left */;
      return this.borderSides(newSides);
    }
    borderForeground(color) {
      return new Style({
        ...this,
        props: { ...this.props, borderForeground: color }
      });
    }
    borderBackground(color) {
      return new Style({
        ...this,
        props: { ...this.props, borderBackground: color }
      });
    }
    padding(top, right3, bottom, left3) {
      const [t, r, b, l] = normalizeSpacing(top, right3, bottom, left3);
      return new Style({
        ...this,
        props: {
          ...this.props,
          padding: { top: t, right: r, bottom: b, left: l }
        }
      });
    }
    paddingSides(padding) {
      const current2 = this.props.padding || { top: 0, right: 0, bottom: 0, left: 0 };
      return new Style({
        ...this,
        props: {
          ...this.props,
          padding: { ...current2, ...padding }
        }
      });
    }
    paddingTop(value6) {
      return this.paddingSides({ top: value6 });
    }
    paddingRight(value6) {
      return this.paddingSides({ right: value6 });
    }
    paddingBottom(value6) {
      return this.paddingSides({ bottom: value6 });
    }
    paddingLeft(value6) {
      return this.paddingSides({ left: value6 });
    }
    margin(top, right3, bottom, left3) {
      const [t, r, b, l] = normalizeSpacing(top, right3, bottom, left3);
      return new Style({
        ...this,
        props: {
          ...this.props,
          margin: { top: t, right: r, bottom: b, left: l }
        }
      });
    }
    marginSides(margin) {
      const current2 = this.props.margin || { top: 0, right: 0, bottom: 0, left: 0 };
      return new Style({
        ...this,
        props: {
          ...this.props,
          margin: { ...current2, ...margin }
        }
      });
    }
    marginTop(value6) {
      return this.marginSides({ top: value6 });
    }
    marginRight(value6) {
      return this.marginSides({ right: value6 });
    }
    marginBottom(value6) {
      return this.marginSides({ bottom: value6 });
    }
    marginLeft(value6) {
      return this.marginSides({ left: value6 });
    }
    bold(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, bold: value6 }
      });
    }
    italic(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, italic: value6 }
      });
    }
    underline(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, underline: value6 }
      });
    }
    strikethrough(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, strikethrough: value6 }
      });
    }
    inverse(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, inverse: value6 }
      });
    }
    reverse(value6 = true) {
      return this.inverse(value6);
    }
    blink(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, blink: value6 }
      });
    }
    faint(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, faint: value6 }
      });
    }
    dim(value6 = true) {
      return this.faint(value6);
    }
    hidden(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, hidden: value6 }
      });
    }
    inline(value6 = true) {
      return new Style({
        ...this,
        props: { ...this.props, inline: value6 }
      });
    }
    width(width) {
      return new Style({
        ...this,
        props: { ...this.props, width }
      });
    }
    height(height) {
      return new Style({
        ...this,
        props: { ...this.props, height }
      });
    }
    minWidth(minWidth) {
      return new Style({
        ...this,
        props: { ...this.props, minWidth }
      });
    }
    minHeight(minHeight) {
      return new Style({
        ...this,
        props: { ...this.props, minHeight }
      });
    }
    maxWidth(maxWidth) {
      return new Style({
        ...this,
        props: { ...this.props, maxWidth }
      });
    }
    maxHeight(maxHeight) {
      return new Style({
        ...this,
        props: { ...this.props, maxHeight }
      });
    }
    align(align) {
      return new Style({
        ...this,
        props: { ...this.props, horizontalAlign: align }
      });
    }
    valign(align) {
      return new Style({
        ...this,
        props: { ...this.props, verticalAlign: align }
      });
    }
    verticalAlign(align) {
      return this.valign(align);
    }
    center() {
      return this.align("center" /* Center */);
    }
    middle() {
      return this.valign("middle" /* Middle */);
    }
    transform(transform5) {
      return new Style({
        ...this,
        props: { ...this.props, transform: transform5 }
      });
    }
    uppercase() {
      return this.transform({ _tag: "uppercase" });
    }
    lowercase() {
      return this.transform({ _tag: "lowercase" });
    }
    capitalize() {
      return this.transform({ _tag: "capitalize" });
    }
    textTransform(transform5) {
      return this.transform({ _tag: transform5 });
    }
    overflow(overflow) {
      return new Style({
        ...this,
        props: { ...this.props, overflow }
      });
    }
    wordBreak(wordBreak) {
      return new Style({
        ...this,
        props: { ...this.props, wordBreak }
      });
    }
    wordWrap(enable4 = true) {
      return this.overflow(enable4 ? "wrap" : "visible");
    }
    position(type2, x, y) {
      return new Style({
        ...this,
        props: {
          ...this.props,
          transform: { _tag: "custom", fn: (text) => text }
        }
      });
    }
    inherit(parent) {
      return new Style({
        ...this,
        parent: exports_Option.some(parent)
      });
    }
    merge(other) {
      return new Style({
        props: { ...this.getResolvedProps(), ...other.getResolvedProps() },
        parent: exports_Option.none()
      });
    }
    copy() {
      return new Style({
        props: { ...this.props },
        parent: this.parent
      });
    }
    reset() {
      return new Style({
        props: {},
        parent: exports_Option.none()
      });
    }
    getResolvedProps() {
      if (exports_Option.isNone(this.parent)) {
        return this.props;
      }
      const parentProps = this.parent.value.getResolvedProps();
      const resolved = { ...this.props };
      for (const key in parentProps) {
        const prop = key;
        if (isInheritable(prop) && resolved[prop] === undefined) {
          resolved[prop] = parentProps[prop];
        }
      }
      return resolved;
    }
    has(prop) {
      return this.props[prop] !== undefined;
    }
    get(prop) {
      return this.getResolvedProps()[prop];
    }
    toJSON() {
      return {
        props: this.props,
        parent: exports_Option.isSome(this.parent) ? this.parent.value.toJSON() : null
      };
    }
  };
  Styles = {
    Base: style(),
    Bold: style().bold(),
    Italic: style().italic(),
    Underline: style().underline(),
    Strikethrough: style().strikethrough(),
    Faint: style().faint(),
    Center: style().center().middle(),
    Hidden: style().hidden()
  };
});

// ../../src/styling/color.ts
var Color2, ColorProfile, Colors, hexToRgb = (hex) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (result) {
    return exports_Option.some({
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    });
  }
  return exports_Option.none();
}, rgbToAnsi256 = (r, g, b) => {
  if (r === g && g === b) {
    if (r < 8)
      return 16;
    if (r > 248)
      return 231;
    return Math.round((r - 8) / 247 * 24) + 232;
  }
  const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
  return ansi;
}, rgbToAnsi = (r, g, b) => {
  const ansiColors = [
    [0, 0, 0],
    [205, 0, 0],
    [0, 205, 0],
    [205, 205, 0],
    [0, 0, 238],
    [205, 0, 205],
    [0, 205, 205],
    [229, 229, 229],
    [127, 127, 127],
    [255, 0, 0],
    [0, 255, 0],
    [255, 255, 0],
    [92, 92, 255],
    [255, 0, 255],
    [0, 255, 255],
    [255, 255, 255]
  ];
  let minDistance = Infinity;
  let closestColor = 0;
  for (let i = 0;i < ansiColors.length; i++) {
    const [cr, cg, cb] = ansiColors[i];
    const distance2 = Math.sqrt(Math.pow(r - cr, 2) + Math.pow(g - cg, 2) + Math.pow(b - cb, 2));
    if (distance2 < minDistance) {
      minDistance = distance2;
      closestColor = i;
    }
  }
  return closestColor;
}, toAnsiSequence = (color, profile, background = false) => {
  const base = background ? 40 : 30;
  const brightBase = background ? 100 : 90;
  switch (color._tag) {
    case "NoColor":
      return "";
    case "ANSI": {
      const { code } = color;
      if (code < 8) {
        return `\x1B[${base + code}m`;
      } else {
        return `\x1B[${brightBase + (code - 8)}m`;
      }
    }
    case "ANSI256": {
      if (profile < 2 /* ANSI256 */) {
        const { code } = color;
        if (code < 16) {
          return toAnsiSequence(Color2.ANSI(code), profile, background);
        }
        const ansiCode = code < 8 ? 0 : code < 16 ? code - 8 + 90 : 7;
        return `\x1B[${ansiCode}m`;
      }
      return `\x1B[${background ? 48 : 38};5;${color.code}m`;
    }
    case "Hex": {
      const rgb = hexToRgb(color.value);
      if (exports_Option.isNone(rgb))
        return "";
      const { r, g, b } = rgb.value;
      return toAnsiSequence(Color2.RGB(r, g, b), profile, background);
    }
    case "RGB": {
      const { r, g, b } = color;
      if (profile === 3 /* TrueColor */) {
        return `\x1B[${background ? 48 : 38};2;${r};${g};${b}m`;
      } else if (profile === 2 /* ANSI256 */) {
        const code = rgbToAnsi256(r, g, b);
        return toAnsiSequence(Color2.ANSI256(code), profile, background);
      } else if (profile === 1 /* ANSI */) {
        const code = rgbToAnsi(r, g, b);
        return toAnsiSequence(Color2.ANSI(code), profile, background);
      }
      return "";
    }
    case "Adaptive":
      return toAnsiSequence(color.dark, profile, background);
  }
}, isVisible = (color) => color._tag !== "NoColor", blend = (fg, bg, alpha) => {
  if (fg._tag === "RGB" && bg._tag === "RGB") {
    const a = Math.max(0, Math.min(1, alpha));
    return Color2.RGB(Math.round(fg.r * a + bg.r * (1 - a)), Math.round(fg.g * a + bg.g * (1 - a)), Math.round(fg.b * a + bg.b * (1 - a)));
  }
  return alpha > 0.5 ? fg : bg;
}, lighten = (color, amount) => {
  if (color._tag === "RGB") {
    const factor = 1 + Math.max(0, Math.min(1, amount));
    return Color2.RGB(Math.min(255, Math.round(color.r * factor)), Math.min(255, Math.round(color.g * factor)), Math.min(255, Math.round(color.b * factor)));
  }
  return color;
}, darken = (color, amount) => {
  if (color._tag === "RGB") {
    const factor = 1 - Math.max(0, Math.min(1, amount));
    return Color2.RGB(Math.round(color.r * factor), Math.round(color.g * factor), Math.round(color.b * factor));
  }
  return color;
}, gradient = (start5, end6, steps) => {
  if (steps <= 1)
    return [start5];
  if (steps === 2)
    return [start5, end6];
  if (start5._tag !== "RGB" || end6._tag !== "RGB") {
    return Array(steps).fill(start5);
  }
  const result = [];
  for (let i = 0;i < steps; i++) {
    const t = i / (steps - 1);
    result.push(Color2.RGB(Math.round(start5.r + (end6.r - start5.r) * t), Math.round(start5.g + (end6.g - start5.g) * t), Math.round(start5.b + (end6.b - start5.b) * t)));
  }
  return result;
};
var init_color = __esm(() => {
  init_esm2();
  Color2 = {
    NoColor: () => ({ _tag: "NoColor" }),
    ANSI: (code) => ({ _tag: "ANSI", code }),
    ANSI256: (code) => ({ _tag: "ANSI256", code }),
    Hex: (value6) => ({ _tag: "Hex", value: value6 }),
    RGB: (r, g, b) => ({ _tag: "RGB", r, g, b }),
    Adaptive: (light, dark) => ({ _tag: "Adaptive", light, dark })
  };
  ((ColorProfile2) => {
    ColorProfile2[ColorProfile2["NoColor"] = 0] = "NoColor";
    ColorProfile2[ColorProfile2["ANSI"] = 1] = "ANSI";
    ColorProfile2[ColorProfile2["ANSI256"] = 2] = "ANSI256";
    ColorProfile2[ColorProfile2["TrueColor"] = 3] = "TrueColor";
  })(ColorProfile ||= {});
  Colors = {
    none: () => Color2.NoColor(),
    hex: (value6) => {
      const normalized = value6.startsWith("#") ? value6 : `#${value6}`;
      if (/^#[0-9A-Fa-f]{6}$/.test(normalized)) {
        return exports_Option.some(Color2.Hex(normalized));
      }
      return exports_Option.none();
    },
    rgb: (r, g, b) => {
      if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
        return exports_Option.some(Color2.RGB(r, g, b));
      }
      return exports_Option.none();
    },
    ansi: (code) => {
      if (code >= 0 && code <= 15) {
        return exports_Option.some(Color2.ANSI(code));
      }
      return exports_Option.none();
    },
    ansi256: (code) => {
      if (code >= 0 && code <= 255) {
        return exports_Option.some(Color2.ANSI256(code));
      }
      return exports_Option.none();
    },
    adaptive: (light, dark) => Color2.Adaptive(light, dark),
    black: Color2.ANSI(0),
    red: Color2.ANSI(1),
    green: Color2.ANSI(2),
    yellow: Color2.ANSI(3),
    blue: Color2.ANSI(4),
    magenta: Color2.ANSI(5),
    cyan: Color2.ANSI(6),
    white: Color2.ANSI(7),
    brightBlack: Color2.ANSI(8),
    brightRed: Color2.ANSI(9),
    brightGreen: Color2.ANSI(10),
    brightYellow: Color2.ANSI(11),
    brightBlue: Color2.ANSI(12),
    brightMagenta: Color2.ANSI(13),
    brightCyan: Color2.ANSI(14),
    brightWhite: Color2.ANSI(15),
    gray: Color2.ANSI(8),
    grey: Color2.ANSI(8),
    orange: Color2.RGB(255, 140, 0),
    deepOrange: Color2.RGB(255, 87, 34),
    lightOrange: Color2.RGB(255, 183, 77),
    darkOrange: Color2.RGB(230, 81, 0),
    purple: Color2.RGB(128, 0, 128),
    deepPurple: Color2.RGB(103, 58, 183),
    lightPurple: Color2.RGB(186, 104, 200),
    darkPurple: Color2.RGB(74, 20, 140),
    indigo: Color2.RGB(63, 81, 181),
    violet: Color2.RGB(238, 130, 238),
    pink: Color2.RGB(233, 30, 99),
    lightPink: Color2.RGB(244, 143, 177),
    deepPink: Color2.RGB(255, 20, 147),
    hotPink: Color2.RGB(255, 105, 180),
    teal: Color2.RGB(0, 150, 136),
    lightTeal: Color2.RGB(77, 182, 172),
    darkTeal: Color2.RGB(0, 77, 64),
    aqua: Color2.RGB(0, 255, 255),
    turquoise: Color2.RGB(64, 224, 208),
    brown: Color2.RGB(121, 85, 72),
    lightBrown: Color2.RGB(161, 136, 127),
    darkBrown: Color2.RGB(62, 39, 35),
    lime: Color2.RGB(205, 220, 57),
    lightGreen: Color2.RGB(139, 195, 74),
    darkGreen: Color2.RGB(27, 94, 32),
    forest: Color2.RGB(34, 139, 34),
    mint: Color2.RGB(152, 251, 152),
    olive: Color2.RGB(128, 128, 0),
    lightBlue: Color2.RGB(3, 169, 244),
    darkBlue: Color2.RGB(13, 71, 161),
    navy: Color2.RGB(0, 0, 128),
    royal: Color2.RGB(65, 105, 225),
    sky: Color2.RGB(135, 206, 235),
    steel: Color2.RGB(70, 130, 180),
    crimson: Color2.RGB(220, 20, 60),
    scarlet: Color2.RGB(255, 36, 0),
    maroon: Color2.RGB(128, 0, 0),
    coral: Color2.RGB(255, 127, 80),
    gold: Color2.RGB(255, 215, 0),
    amber: Color2.RGB(255, 193, 7),
    lemon: Color2.RGB(255, 244, 67),
    lightGray: Color2.RGB(189, 189, 189),
    darkGray: Color2.RGB(66, 66, 66),
    silver: Color2.RGB(192, 192, 192),
    charcoal: Color2.RGB(54, 69, 79),
    neonGreen: Color2.RGB(57, 255, 20),
    neonBlue: Color2.RGB(0, 149, 255),
    neonPink: Color2.RGB(255, 16, 240),
    neonYellow: Color2.RGB(255, 255, 0),
    neonOrange: Color2.RGB(255, 128, 0),
    neonPurple: Color2.RGB(177, 3, 252),
    pastelPink: Color2.RGB(255, 209, 220),
    pastelBlue: Color2.RGB(174, 198, 207),
    pastelGreen: Color2.RGB(162, 210, 162),
    pastelYellow: Color2.RGB(255, 254, 162),
    pastelPurple: Color2.RGB(221, 160, 221),
    pastelOrange: Color2.RGB(255, 179, 71)
  };
});

// ../../src/styling/render.ts
var RESET = "\x1B[0m", BOLD = "\x1B[1m", FAINT = "\x1B[2m", ITALIC = "\x1B[3m", UNDERLINE = "\x1B[4m", BLINK = "\x1B[5m", INVERSE = "\x1B[7m", STRIKETHROUGH = "\x1B[9m", applyTransform = (text, style2) => {
  const transform5 = style2.get("transform");
  if (!transform5)
    return text;
  switch (transform5._tag) {
    case "none":
      return text;
    case "uppercase":
      return text.toUpperCase();
    case "lowercase":
      return text.toLowerCase();
    case "capitalize":
      return text.replace(/\b\w/g, (char) => char.toUpperCase());
    case "custom":
      return transform5.fn(text);
  }
}, justifyText = (line, totalSpace) => {
  const words = line.split(" ");
  if (words.length <= 1)
    return line;
  const gaps = words.length - 1;
  const spacePerGap = Math.floor(totalSpace / gaps);
  const extraSpaces = totalSpace % gaps;
  let result = words[0] ?? "";
  for (let i = 1;i < words.length; i++) {
    const spaces = spacePerGap + (i <= extraSpaces ? 1 : 0);
    result += " ".repeat(spaces + 1) + (words[i] ?? "");
  }
  return result;
}, createEmptyLines = (count6, content = "") => count6 > 0 ? Array(count6).fill(content) : [], alignHorizontal = (line, width, align) => {
  const lineWidth = stringWidth(line);
  if (lineWidth >= width)
    return line;
  const space = width - lineWidth;
  switch (align) {
    case "left" /* Left */:
      return line + " ".repeat(space);
    case "right" /* Right */:
      return " ".repeat(space) + line;
    case "center" /* Center */: {
      const left3 = Math.floor(space / 2);
      const right3 = space - left3;
      return " ".repeat(left3) + line + " ".repeat(right3);
    }
    case "justify" /* Justify */:
      return justifyText(line, space);
  }
}, alignVertical = (lines, height, align) => {
  if (lines.length >= height)
    return lines.slice(0, height);
  const space = height - lines.length;
  switch (align) {
    case "top" /* Top */:
      return [...lines, ...createEmptyLines(space)];
    case "bottom" /* Bottom */:
      return [...createEmptyLines(space), ...lines];
    case "middle" /* Middle */: {
      const top = Math.floor(space / 2);
      const bottom = space - top;
      return [
        ...createEmptyLines(top),
        ...lines,
        ...createEmptyLines(bottom)
      ];
    }
  }
}, applyPadding = (lines, style2) => {
  const padding = style2.get("padding");
  if (!padding)
    return lines;
  const { top, right: right3, bottom, left: left3 } = padding;
  const paddedLines = lines.map((line) => " ".repeat(left3) + line + " ".repeat(right3));
  const width = paddedLines[0]?.length || 0;
  const emptyLine = " ".repeat(width);
  return [
    ...createEmptyLines(top, emptyLine),
    ...paddedLines,
    ...createEmptyLines(bottom, emptyLine)
  ];
}, applyBorder = (lines, style2) => {
  const border = style2.get("border");
  const sides = style2.get("borderSides") ?? 15 /* All */;
  if (!border || sides === 0 /* None */)
    return lines;
  return renderBox(lines, border, sides);
}, buildDecorationSequence = (style2) => {
  let sequence = "";
  if (style2.get("bold"))
    sequence += BOLD;
  if (style2.get("faint"))
    sequence += FAINT;
  if (style2.get("italic"))
    sequence += ITALIC;
  if (style2.get("underline"))
    sequence += UNDERLINE;
  if (style2.get("blink"))
    sequence += BLINK;
  if (style2.get("inverse"))
    sequence += INVERSE;
  if (style2.get("strikethrough"))
    sequence += STRIKETHROUGH;
  return sequence;
}, applyColors = (text, style2, colorProfile) => {
  let sequence = "";
  const fg = style2.get("foreground");
  if (fg) {
    sequence += toAnsiSequence(fg, colorProfile, false);
  }
  const bg = style2.get("background");
  if (bg) {
    sequence += toAnsiSequence(bg, colorProfile, true);
  }
  sequence += buildDecorationSequence(style2);
  if (!sequence)
    return text;
  return sequence + text + RESET;
}, renderStyled = (text, style2, options = {}) => exports_Effect.gen(function* (_) {
  const colorProfile = options.colorProfile ?? 3 /* TrueColor */;
  const transformed = applyTransform(text, style2);
  let lines = transformed.split(`
`);
  const styleWidth = style2.get("width");
  const maxWidth = style2.get("maxWidth");
  const effectiveWidth = options.width ?? styleWidth ?? maxWidth;
  if (effectiveWidth) {
    lines = lines.flatMap((line) => {
      if (stringWidth(line) <= effectiveWidth)
        return [line];
      const words = line.split(" ");
      const wrapped = [];
      let current2 = "";
      for (const word of words) {
        const test2 = current2 ? `${current2} ${word}` : word;
        if (stringWidth(test2) <= effectiveWidth) {
          current2 = test2;
        } else {
          if (current2)
            wrapped.push(current2);
          current2 = word;
        }
      }
      if (current2)
        wrapped.push(current2);
      return wrapped;
    });
  }
  const horizontalAlign = style2.get("horizontalAlign");
  if (horizontalAlign && effectiveWidth) {
    lines = lines.map((line) => alignHorizontal(line, effectiveWidth, horizontalAlign));
  }
  const styleHeight = style2.get("height");
  const effectiveHeight = options.height ?? styleHeight;
  const verticalAlign = style2.get("verticalAlign");
  if (effectiveHeight && verticalAlign) {
    lines = alignVertical(lines, effectiveHeight, verticalAlign);
  }
  lines = applyPadding(lines, style2);
  lines = applyBorder(lines, style2);
  const styledLines = lines.map((line) => applyColors(line, style2, colorProfile));
  const margin = style2.get("margin");
  if (margin) {
    const { top, bottom, left: left3 } = margin;
    const marginLeft = " ".repeat(left3);
    const margined = styledLines.map((line) => marginLeft + line);
    const result = [
      ...createEmptyLines(top),
      ...margined,
      ...createEmptyLines(bottom)
    ];
    return result.join(`
`);
  }
  return styledLines.join(`
`);
}), renderStyledSync = (text, style2, options = {}) => {
  const colorProfile = options.colorProfile ?? 3 /* TrueColor */;
  const transformed = applyTransform(text, style2);
  let lines = transformed.split(`
`);
  lines = applyPadding(lines, style2);
  lines = applyBorder(lines, style2);
  const styledLines = lines.map((line) => applyColors(line, style2, colorProfile));
  return styledLines.join(`
`);
};
var init_render = __esm(() => {
  init_esm2();
  init_string_width();
  init_color();
  init_borders();
  init_types2();
});

// ../../src/styling/gradients.ts
var colorToRgb = (color) => {
  switch (color._tag) {
    case "RGB":
      return [color.r, color.g, color.b];
    case "Hex":
      const hex = color.value.replace("#", "");
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      return [r, g, b];
    case "ANSI":
      const ansiToRgb = {
        0: [0, 0, 0],
        1: [128, 0, 0],
        2: [0, 128, 0],
        3: [128, 128, 0],
        4: [0, 0, 128],
        5: [128, 0, 128],
        6: [0, 128, 128],
        7: [192, 192, 192],
        8: [128, 128, 128],
        9: [255, 0, 0],
        10: [0, 255, 0],
        11: [255, 255, 0],
        12: [0, 0, 255],
        13: [255, 0, 255],
        14: [0, 255, 255],
        15: [255, 255, 255]
      };
      return ansiToRgb[color.code] || [128, 128, 128];
    case "ANSI256":
      if (color.code < 16) {
        return colorToRgb({ _tag: "ANSI", code: color.code });
      } else if (color.code < 232) {
        const index = color.code - 16;
        const r2 = Math.floor(index / 36);
        const g2 = Math.floor(index % 36 / 6);
        const b2 = index % 6;
        return [r2 * 51, g2 * 51, b2 * 51];
      } else {
        const gray = (color.code - 232) * 10 + 8;
        return [gray, gray, gray];
      }
    case "NoColor":
      return [0, 0, 0];
    case "Adaptive":
      return colorToRgb(color.light);
    default:
      return [128, 128, 128];
  }
}, lerp = (a, b, t) => a + (b - a) * t, applyEasing = (t, easing) => {
  switch (easing) {
    case "linear":
      return t;
    case "ease-in":
      return t * t;
    case "ease-out":
      return 1 - (1 - t) * (1 - t);
    case "ease-in-out":
      return t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);
    default:
      return t;
  }
}, interpolateColors = (color1, color2, t) => {
  const [r1, g1, b1] = colorToRgb(color1);
  const [r2, g2, b2] = colorToRgb(color2);
  return {
    _tag: "RGB",
    r: Math.round(lerp(r1, r2, t)),
    g: Math.round(lerp(g1, g2, t)),
    b: Math.round(lerp(b1, b2, t))
  };
}, getColorAtPosition = (gradient2, position) => {
  const easedPosition = applyEasing(position, gradient2.interpolation);
  const sortedStops = [...gradient2.stops].sort((a, b) => a.position - b.position);
  if (sortedStops.length === 0) {
    return { _tag: "NoColor" };
  }
  if (sortedStops.length === 1 || easedPosition <= sortedStops[0].position) {
    return sortedStops[0].color;
  }
  if (easedPosition >= sortedStops[sortedStops.length - 1].position) {
    return sortedStops[sortedStops.length - 1].color;
  }
  for (let i = 0;i < sortedStops.length - 1; i++) {
    const currentStop = sortedStops[i];
    const nextStop = sortedStops[i + 1];
    if (currentStop && nextStop && easedPosition >= currentStop.position && easedPosition <= nextStop.position) {
      const range4 = nextStop.position - currentStop.position;
      const localPosition = range4 > 0 ? (easedPosition - currentStop.position) / range4 : 0;
      return interpolateColors(currentStop.color, nextStop.color, localPosition);
    }
  }
  return sortedStops[0]?.color || { _tag: "NoColor" };
}, textGradient = (options) => {
  const { gradient: gradient2, text, preserveSpaces = false } = options;
  const chars = [...text];
  return chars.map((char, index) => {
    if (!preserveSpaces && char === " ") {
      return char;
    }
    const position = chars.length > 1 ? index / (chars.length - 1) : 0;
    const color = getColorAtPosition(gradient2, position);
    const styledChar = style().foreground(color);
    return char;
  }).join("");
}, backgroundGradient = (options) => {
  const { gradient: gradient2, width, height, char = "\u2588" } = options;
  const lines = [];
  for (let y = 0;y < height; y++) {
    let line = "";
    for (let x = 0;x < width; x++) {
      let position;
      switch (gradient2.direction) {
        case "horizontal":
          position = x / (width - 1);
          break;
        case "vertical":
          position = y / (height - 1);
          break;
        case "diagonal-down":
          position = (x + y) / (width + height - 2);
          break;
        case "diagonal-up":
          position = (x + (height - 1 - y)) / (width + height - 2);
          break;
        default:
          position = x / (width - 1);
      }
      const color = getColorAtPosition(gradient2, Math.min(1, Math.max(0, position)));
      line += char;
    }
    lines.push(line);
  }
  return lines;
}, rainbowGradient = (direction = "horizontal") => ({
  stops: [
    { position: 0, color: { _tag: "RGB", r: 255, g: 0, b: 0 } },
    { position: 0.17, color: { _tag: "RGB", r: 255, g: 165, b: 0 } },
    { position: 0.33, color: { _tag: "RGB", r: 255, g: 255, b: 0 } },
    { position: 0.5, color: { _tag: "RGB", r: 0, g: 255, b: 0 } },
    { position: 0.67, color: { _tag: "RGB", r: 0, g: 0, b: 255 } },
    { position: 0.83, color: { _tag: "RGB", r: 75, g: 0, b: 130 } },
    { position: 1, color: { _tag: "RGB", r: 148, g: 0, b: 211 } }
  ],
  direction,
  interpolation: "linear"
}), sunsetGradient = (direction = "horizontal") => ({
  stops: [
    { position: 0, color: { _tag: "RGB", r: 255, g: 94, b: 77 } },
    { position: 0.5, color: { _tag: "RGB", r: 255, g: 154, b: 0 } },
    { position: 1, color: { _tag: "RGB", r: 255, g: 206, b: 84 } }
  ],
  direction,
  interpolation: "ease-out"
}), oceanGradient = (direction = "vertical") => ({
  stops: [
    { position: 0, color: { _tag: "RGB", r: 0, g: 119, b: 190 } },
    { position: 0.5, color: { _tag: "RGB", r: 0, g: 180, b: 216 } },
    { position: 1, color: { _tag: "RGB", r: 144, g: 224, b: 239 } }
  ],
  direction,
  interpolation: "ease-in-out"
}), createGradient = (stops, direction = "horizontal", interpolation = "linear") => ({
  stops,
  direction,
  interpolation
}), reverseGradient = (gradient2) => ({
  ...gradient2,
  stops: gradient2.stops.map((stop3) => ({
    ...stop3,
    position: 1 - stop3.position
  })).reverse()
});
var init_gradients = __esm(() => {
  init_style();
});

// ../../src/styling/advanced.ts
var createDropShadow = (content, config2) => {
  const { offset } = config2;
  const result = [];
  const maxWidth = Math.max(...content.map((line) => line.length));
  const shadowLines = content.map((line) => {
    const paddedLine = line.padEnd(maxWidth);
    return paddedLine.split("").map((char) => char === " " ? " " : "\u2591").join("");
  });
  if (offset.y > 0) {
    result.push(...content);
    for (let i = 0;i < offset.y && i < shadowLines.length; i++) {
      result.push(" ".repeat(offset.x) + (shadowLines[i] ?? ""));
    }
  } else if (offset.y < 0) {
    for (let i = 0;i < -offset.y && i < shadowLines.length; i++) {
      result.push(shadowLines[i] ?? "");
    }
    result.push(...content);
  } else {
    result.push(...content);
  }
  return result;
}, createInnerShadow = (content, config2) => {
  return content.map((line, y) => {
    return line.split("").map((char, x) => {
      const isEdge = x === 0 || x === line.length - 1 || y === 0 || y === content.length - 1;
      return isEdge && char !== " " ? "\u2593" : char;
    }).join("");
  });
}, createGlow = (content, config2) => {
  const { radius, intensity } = config2;
  const glowChars = ["\u2591", "\u2592", "\u2593"];
  const glowChar = glowChars[Math.min(Math.floor(intensity * 3), 2)] ?? "\u2591";
  const result = [];
  const maxWidth = Math.max(...content.map((line) => line.length));
  const padding = Math.ceil(radius);
  for (let i = 0;i < padding; i++) {
    result.push(glowChar.repeat(maxWidth + padding * 2));
  }
  content.forEach((line) => {
    result.push(glowChar.repeat(padding) + line.padEnd(maxWidth) + glowChar.repeat(padding));
  });
  for (let i = 0;i < padding; i++) {
    result.push(glowChar.repeat(maxWidth + padding * 2));
  }
  return result;
}, generatePattern = (width, height, config2) => {
  const pattern2 = [];
  const { type: type2, scale: scale2 } = config2;
  for (let y = 0;y < height; y++) {
    const row = [];
    for (let x = 0;x < width; x++) {
      let usePattern = false;
      switch (type2) {
        case "dots":
          usePattern = x % scale2 === 0 && y % scale2 === 0;
          break;
        case "stripes":
          usePattern = x % scale2 < scale2 / 2;
          break;
        case "checkerboard":
          usePattern = (Math.floor(x / scale2) + Math.floor(y / scale2)) % 2 === 0;
          break;
        case "diagonal":
          usePattern = (x + y) % scale2 < scale2 / 2;
          break;
        case "cross":
          usePattern = x % scale2 === Math.floor(scale2 / 2) || y % scale2 === Math.floor(scale2 / 2);
          break;
        case "wave":
          usePattern = Math.sin(x / scale2) * Math.cos(y / scale2) > 0;
          break;
      }
      row.push(usePattern ? "\u2588" : " ");
    }
    pattern2.push(row);
  }
  return pattern2;
}, applyPattern = (content, config2) => {
  const maxWidth = Math.max(...content.map((line) => line.length));
  const pattern2 = generatePattern(maxWidth, content.length, config2);
  return content.map((line, y) => {
    return line.split("").map((char, x) => {
      const patternChar = pattern2[y]?.[x];
      return patternChar && patternChar !== " " && char === " " ? patternChar : char;
    }).join("");
  });
}, createStyledBorder = (content, borderStyle) => {
  const { type: type2, width } = borderStyle;
  const maxWidth = Math.max(...content.map((line) => line.length));
  const result = [];
  const getBorderChar3 = () => {
    switch (type2) {
      case "solid":
        return "\u2588";
      case "dashed":
        return "\u2500";
      case "dotted":
        return "\xB7";
      case "double":
        return "\u2550";
      default:
        return "\u2588";
    }
  };
  const borderChar = getBorderChar3();
  for (let i = 0;i < width; i++) {
    result.push(borderChar.repeat(maxWidth + width * 2));
  }
  content.forEach((line) => {
    result.push(borderChar.repeat(width) + line.padEnd(maxWidth) + borderChar.repeat(width));
  });
  for (let i = 0;i < width; i++) {
    result.push(borderChar.repeat(maxWidth + width * 2));
  }
  return result;
}, applyLayerEffect = (base, overlay, effect4) => {
  const { type: type2, opacity } = effect4;
  return base.map((baseLine, y) => {
    const overlayLine = overlay[y] || "";
    return baseLine.split("").map((baseChar, x) => {
      const overlayChar = overlayLine[x] || " ";
      if (overlayChar === " " || Math.random() > opacity) {
        return baseChar;
      }
      switch (type2) {
        case "overlay":
          return overlayChar;
        case "multiply":
          return baseChar !== " " && overlayChar !== " " ? "\u2593" : " ";
        case "screen":
          return baseChar !== " " || overlayChar !== " " ? overlayChar : " ";
        default:
          return overlayChar;
      }
    }).join("");
  });
}, createPulse = (text, phase) => {
  const intensity = (Math.sin(phase * Math.PI * 2) + 1) / 2;
  const color = {
    _tag: "RGB",
    r: Math.floor(255 * intensity),
    g: Math.floor(255 * intensity),
    b: Math.floor(255 * intensity)
  };
  return style().foreground(color);
}, createShake = (text, intensity) => {
  return text.split("").map((char) => {
    if (char === " " || Math.random() > intensity)
      return char;
    const offset = Math.random() > 0.5 ? " " : "";
    return offset + char;
  }).join("");
}, createTypewriter = (text, progress) => {
  const revealLength = Math.floor(text.length * progress);
  return text.substring(0, revealLength) + "\u2588".repeat(progress < 1 ? 1 : 0);
}, createRainbowText = (text) => {
  const colors2 = [
    Colors.red,
    Colors.yellow,
    Colors.green,
    Colors.cyan,
    Colors.blue,
    Colors.magenta
  ];
  return text.split("").map((char, i) => {
    const colorIndex = i % colors2.length;
    return style().foreground(colors2[colorIndex]);
  });
}, createBounce = (text, phase, height = 3) => {
  const lines = Array(height).fill("");
  const bounce = Math.abs(Math.sin(phase * Math.PI));
  const yPos = Math.floor(bounce * (height - 1));
  lines[yPos] = text;
  return lines;
}, createWaveText = (text, phase, amplitude = 2) => {
  const lines = Array(amplitude * 2 + 1).fill("");
  text.split("").forEach((char, i) => {
    const offset = Math.sin((i / text.length + phase) * Math.PI * 2) * amplitude;
    const yPos = Math.floor(amplitude + offset);
    if (!lines[yPos])
      lines[yPos] = " ".repeat(i);
    lines[yPos] += char;
  });
  return lines.filter((line) => line.trim());
}, createNeonEffect = (text, color) => {
  return style().foreground(color).bold().background(Colors.black);
}, createMatrixEffect = (width, height, density = 0.1) => {
  const chars = "01";
  const lines = [];
  for (let y = 0;y < height; y++) {
    let line = "";
    for (let x = 0;x < width; x++) {
      if (Math.random() < density) {
        line += chars[Math.floor(Math.random() * chars.length)];
      } else {
        line += " ";
      }
    }
    lines.push(line);
  }
  return lines;
}, createHologramEffect = (content, phase) => {
  const scanLineY = Math.floor(phase * content.length);
  return content.map((line, y) => {
    if (y === scanLineY || y === scanLineY - 1) {
      return line.split("").map((char) => char === " " ? " " : "\u2593").join("");
    }
    return line;
  });
};
var init_advanced = __esm(() => {
  init_color();
  init_style();
});

// ../../src/styling/index.ts
var init_styling = __esm(() => {
  init_style();
  init_render();
  init_color();
  init_borders();
  init_types2();
  init_gradients();
  init_advanced();
});

// ../../src/core/view.ts
var exports_view = {};
__export(exports_view, {
  yellow: () => yellow,
  white: () => white,
  vstack: () => vstack,
  underline: () => underline,
  text: () => text,
  styledText: () => styledText,
  styled: () => styled,
  renderView: () => renderView,
  red: () => red,
  measureView: () => measureView,
  magenta: () => magenta,
  italic: () => italic,
  isView: () => isView,
  hstack: () => hstack,
  green: () => green,
  empty: () => empty46,
  dim: () => dim,
  cyan: () => cyan,
  createView: () => createView,
  center: () => center,
  box: () => box,
  bold: () => bold,
  blue: () => blue
});
var text = (content) => ({
  render: () => exports_Effect.succeed(content),
  width: content.split(`
`).reduce((max6, line) => Math.max(max6, stringWidth(line)), 0),
  height: content.split(`
`).length
}), empty46, createView, isView = (obj) => {
  return obj !== null && typeof obj === "object" && "render" in obj && typeof obj.render === "function";
}, measureView = (view) => exports_Effect.succeed({
  width: view.width || 0,
  height: view.height || 0
}), renderView = (view) => view.render(), vstack = (...views) => ({
  render: () => exports_Effect.gen(function* (_) {
    const rendered = yield* _(exports_Effect.forEach(views, (v) => v.render()));
    return rendered.join(`
`);
  }),
  width: Math.max(...views.map((v) => v.width || 0)),
  height: views.reduce((sum3, v) => sum3 + (v.height || 1), 0)
}), hstack = (...views) => ({
  render: () => exports_Effect.gen(function* (_) {
    const renderedViews = yield* _(exports_Effect.forEach(views, (v, index) => exports_Effect.gen(function* (_2) {
      const content = yield* _2(v.render());
      return { content, width: v.width || 0, index };
    })));
    const viewData = renderedViews.map(({ content, width }) => {
      const lines = content.split(`
`);
      return { lines, width };
    });
    const maxHeight = Math.max(...viewData.map(({ lines }) => lines.length));
    const aligned = viewData.map(({ lines, width }) => {
      const paddedLines = lines.map((line) => {
        const lineWidth = stringWidth(line);
        if (lineWidth < width) {
          return line + " ".repeat(width - lineWidth);
        }
        return line;
      });
      const height = paddedLines.length;
      if (height < maxHeight) {
        const emptyLine = " ".repeat(width);
        const padding = maxHeight - height;
        return [...paddedLines, ...Array(padding).fill(emptyLine)];
      }
      return paddedLines;
    });
    const result = [];
    for (let i = 0;i < maxHeight; i++) {
      const line = aligned.map((lines) => lines[i] ?? "").join("");
      result.push(line);
    }
    return result.join(`
`);
  }),
  width: views.reduce((sum3, v) => sum3 + (v.width || 0), 0),
  height: Math.max(...views.map((v) => v.height || 1))
}), box = (view) => ({
  render: () => exports_Effect.gen(function* (_) {
    const content = yield* _(view.render());
    const lines = content.split(`
`);
    const width = Math.max(...lines.map((l) => stringWidth(l)));
    const top = "\u250C" + "\u2500".repeat(width + 2) + "\u2510";
    const bottom = "\u2514" + "\u2500".repeat(width + 2) + "\u2518";
    const boxedLines = lines.map((line) => {
      const lineWidth = stringWidth(line);
      const padding = width - lineWidth;
      return "\u2502 " + line + " ".repeat(padding) + " \u2502";
    });
    return [top, ...boxedLines, bottom].join(`
`);
  }),
  width: (view.width || 0) + 4,
  height: (view.height || 0) + 2
}), center = (view, totalWidth) => ({
  render: () => exports_Effect.gen(function* (_) {
    const content = yield* _(view.render());
    const lines = content.split(`
`);
    return lines.map((line) => {
      const lineWidth = stringWidth(line);
      const padding = Math.max(0, totalWidth - lineWidth);
      const leftPad = Math.floor(padding / 2);
      const rightPad = padding - leftPad;
      return " ".repeat(leftPad) + line + " ".repeat(rightPad);
    }).join(`
`);
  }),
  width: totalWidth,
  height: view.height
}), styled = (view, style2) => ({
  render: () => exports_Effect.gen(function* (_) {
    const content = yield* _(view.render());
    return `${style2}${content}\x1B[0m`;
  }),
  width: view.width,
  height: view.height
}), bold = (view) => styled(view, "\x1B[1m"), dim = (view) => styled(view, "\x1B[2m"), italic = (view) => styled(view, "\x1B[3m"), underline = (view) => styled(view, "\x1B[4m"), red = (view) => styled(view, "\x1B[31m"), green = (view) => styled(view, "\x1B[32m"), yellow = (view) => styled(view, "\x1B[33m"), blue = (view) => styled(view, "\x1B[34m"), magenta = (view) => styled(view, "\x1B[35m"), cyan = (view) => styled(view, "\x1B[36m"), white = (view) => styled(view, "\x1B[37m"), styledText = (content, style2) => ({
  render: () => exports_Effect.succeed(renderStyledSync(content, style2)),
  width: style2.get("width") || content.split(`
`).reduce((max6, line) => Math.max(max6, stringWidth(line)), 0),
  height: style2.get("height") || content.split(`
`).length
});
var init_view = __esm(() => {
  init_esm2();
  init_string_width();
  init_styling();
  empty46 = text("");
  createView = text;
});

// ../../src/core/view-cache.ts
var exports_view_cache = {};
__export(exports_view_cache, {
  memoizeRender: () => memoizeRender,
  globalViewCache: () => globalViewCache,
  ViewCache: () => ViewCache
});

class ViewCache {
  cache = new Map;
  maxSize = 1000;
  maxAge = 30 * 1000;
  constructor(options) {
    if (options?.maxSize)
      this.maxSize = options.maxSize;
    if (options?.maxAge)
      this.maxAge = options.maxAge;
  }
  async renderCached(key, view) {
    const cached4 = this.cache.get(key);
    const now2 = Date.now();
    if (cached4 && now2 - cached4.timestamp < this.maxAge) {
      cached4.accessCount++;
      return cached4.rendered;
    }
    const rendered = await exports_Effect.runPromise(view.render());
    this.cache.set(key, {
      rendered,
      timestamp: now2,
      accessCount: 1
    });
    this.evictIfNeeded();
    return rendered;
  }
  generateKey(view, props) {
    const parts2 = [
      view.constructor.name,
      `w:${view.width || 0}`,
      `h:${view.height || 0}`,
      this.getViewIdentifier(view),
      props ? JSON.stringify(props) : ""
    ];
    const keyString = parts2.join("|");
    return this.hashString(keyString);
  }
  getViewIdentifier(view) {
    try {
      const viewObj = view;
      if (viewObj.render && typeof viewObj.render === "function") {
        const renderStr = viewObj.render.toString();
        const successMatch = renderStr.match(/Effect\.succeed\(['"`]([^'"`]+)['"`]\)/);
        if (successMatch) {
          return `content:${successMatch[1]}`;
        }
        return `render:${this.hashString(renderStr.substring(0, 100))}`;
      }
      return "unknown";
    } catch {
      return "error";
    }
  }
  hashString(str) {
    let hash2 = 0;
    for (let i = 0;i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash2 = (hash2 << 5) - hash2 + char;
      hash2 = hash2 & hash2;
    }
    return hash2.toString(36);
  }
  evictIfNeeded() {
    const now2 = Date.now();
    const entries4 = Array.from(this.cache.entries());
    for (const [key, entry] of entries4) {
      if (now2 - entry.timestamp > this.maxAge) {
        this.cache.delete(key);
      }
    }
    if (this.cache.size > this.maxSize) {
      const sorted = Array.from(this.cache.entries()).sort((a, b) => a[1].accessCount - b[1].accessCount);
      const toRemove = sorted.slice(0, this.cache.size - this.maxSize);
      for (const [key] of toRemove) {
        this.cache.delete(key);
      }
    }
  }
  clear() {
    this.cache.clear();
  }
  getStats() {
    const entries4 = Array.from(this.cache.values());
    const now2 = Date.now();
    return {
      size: this.cache.size,
      totalAccess: entries4.reduce((sum3, entry) => sum3 + entry.accessCount, 0),
      avgAge: entries4.length > 0 ? entries4.reduce((sum3, entry) => sum3 + Math.max(0, now2 - entry.timestamp), 0) / entries4.length : 0
    };
  }
}
function memoizeRender(renderFn, keyFn) {
  return (view) => {
    const key = keyFn ? keyFn(view) : globalViewCache.generateKey(view);
    const customView = {
      render: () => renderFn(view),
      width: view.width,
      height: view.height
    };
    return exports_Effect.tryPromise(() => globalViewCache.renderCached(key, customView)).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(error2)));
  };
}
var globalViewCache;
var init_view_cache = __esm(() => {
  init_esm2();
  globalViewCache = new ViewCache;
});

// ../../src/core/index.ts
var init_core3 = __esm(() => {
  init_schemas();
  init_errors3();
  init_esm2();
  init_esm();
  init_runtime2();
  init_keys();
  init_view();
  init_view_cache();
});

// ../../src/services/impl/terminal-impl.ts
var ESC = "\x1B", CSI, ANSI, getPlatform = () => ({
  stdout: process.stdout,
  stdin: process.stdin,
  env: process.env,
  platform: process.platform
}), TerminalServiceLive, TerminalServiceTest;
var init_terminal_impl = __esm(() => {
  init_esm2();
  init_terminal();
  init_errors3();
  CSI = `${ESC}[`;
  ANSI = {
    cursorTo: (x, y) => `${CSI}${y};${x}H`,
    cursorUp: (n) => `${CSI}${n}A`,
    cursorDown: (n) => `${CSI}${n}B`,
    cursorForward: (n) => `${CSI}${n}C`,
    cursorBack: (n) => `${CSI}${n}D`,
    cursorHide: `${CSI}?25l`,
    cursorShow: `${CSI}?25h`,
    cursorSave: `${ESC}7`,
    cursorRestore: `${ESC}8`,
    clear: `${CSI}2J${CSI}H`,
    clearLine: `${CSI}2K`,
    clearToEOL: `${CSI}0K`,
    clearToSOL: `${CSI}1K`,
    clearToEOS: `${CSI}0J`,
    clearToSOS: `${CSI}1J`,
    scrollUp: (n) => `${CSI}${n}S`,
    scrollDown: (n) => `${CSI}${n}T`,
    alternateScreenEnable: `${CSI}?1049h`,
    alternateScreenDisable: `${CSI}?1049l`,
    mouseTrackingEnable: `${CSI}?1000h`,
    mouseTrackingDisable: `${CSI}?1000l`,
    reset: `${CSI}0m`,
    bold: `${CSI}1m`,
    dim: `${CSI}2m`,
    italic: `${CSI}3m`,
    underline: `${CSI}4m`,
    bell: "\x07",
    setTitle: (title) => `${ESC}]0;${title}\x07`,
    requestCursorPosition: `${CSI}6n`,
    cursorBlock: `${CSI}1 q`,
    cursorUnderline: `${CSI}3 q`,
    cursorBar: `${CSI}5 q`,
    cursorBlinkingBlock: `${CSI}0 q`,
    cursorBlinkingUnderline: `${CSI}4 q`,
    cursorBlinkingBar: `${CSI}6 q`
  };
  TerminalServiceLive = exports_Layer.effect(TerminalService, exports_Effect.gen(function* (_) {
    const platform = getPlatform();
    const isRawMode = yield* _(exports_Ref.make(false));
    const isAlternateScreen = yield* _(exports_Ref.make(false));
    const write2 = (data) => exports_Effect.try({
      try: () => {
        platform.stdout.write(data);
      },
      catch: (error2) => new TerminalError({
        operation: "write",
        cause: error2
      })
    });
    const detectCapabilities = () => {
      const env = platform.env;
      const colorSupport = (() => {
        if (env.COLORTERM === "truecolor")
          return "truecolor";
        if (env.TERM?.includes("256color"))
          return "256";
        if (env.TERM && !env.NO_COLOR)
          return "basic";
        return "none";
      })();
      return {
        colors: colorSupport,
        unicode: platform.platform !== "win32",
        mouse: true,
        clipboard: false,
        sixel: false,
        kitty: env.TERM === "xterm-kitty",
        iterm2: env.TERM_PROGRAM === "iTerm.app",
        windowTitle: true,
        columns: platform.stdout.columns || 80,
        rows: platform.stdout.rows || 24
      };
    };
    return {
      clear: write2(ANSI.clear),
      write: (text2) => write2(text2),
      writeLine: (text2) => write2(text2 + `
`),
      moveCursor: (x, y) => write2(ANSI.cursorTo(x, y)),
      moveCursorRelative: (dx, dy) => exports_Effect.gen(function* (_2) {
        if (dx > 0)
          yield* _2(write2(ANSI.cursorForward(dx)));
        else if (dx < 0)
          yield* _2(write2(ANSI.cursorBack(-dx)));
        if (dy > 0)
          yield* _2(write2(ANSI.cursorDown(dy)));
        else if (dy < 0)
          yield* _2(write2(ANSI.cursorUp(-dy)));
      }),
      hideCursor: write2(ANSI.cursorHide),
      showCursor: write2(ANSI.cursorShow),
      getSize: exports_Effect.sync(() => ({
        width: platform.stdout.columns || 80,
        height: platform.stdout.rows || 24
      })),
      setRawMode: (enabled2) => exports_Effect.gen(function* (_2) {
        const currentRawMode = yield* _2(exports_Ref.get(isRawMode));
        if (currentRawMode === enabled2)
          return;
        yield* _2(exports_Effect.try({
          try: () => {
            if (platform.stdin.isTTY && platform.stdin.setRawMode) {
              platform.stdin.setRawMode(enabled2);
            }
          },
          catch: (error2) => new TerminalError({
            operation: "setRawMode",
            cause: error2
          })
        }));
        yield* _2(exports_Ref.set(isRawMode, enabled2));
      }),
      setAlternateScreen: (enabled2) => exports_Effect.gen(function* (_2) {
        const current2 = yield* _2(exports_Ref.get(isAlternateScreen));
        if (current2 === enabled2)
          return;
        yield* _2(write2(enabled2 ? ANSI.alternateScreenEnable : ANSI.alternateScreenDisable));
        yield* _2(exports_Ref.set(isAlternateScreen, enabled2));
      }),
      saveCursor: write2(ANSI.cursorSave),
      restoreCursor: write2(ANSI.cursorRestore),
      getCapabilities: exports_Effect.sync(detectCapabilities),
      supportsTrueColor: exports_Effect.sync(() => detectCapabilities().colors === "truecolor"),
      supports256Colors: exports_Effect.sync(() => {
        const colors2 = detectCapabilities().colors;
        return colors2 === "256" || colors2 === "truecolor";
      }),
      supportsUnicode: exports_Effect.sync(() => detectCapabilities().unicode),
      clearToEndOfLine: write2(ANSI.clearToEOL),
      clearToStartOfLine: write2(ANSI.clearToSOL),
      clearLine: write2(ANSI.clearLine),
      clearToEndOfScreen: write2(ANSI.clearToEOS),
      clearToStartOfScreen: write2(ANSI.clearToSOS),
      scrollUp: (lines) => write2(ANSI.scrollUp(lines)),
      scrollDown: (lines) => write2(ANSI.scrollDown(lines)),
      setTitle: (title) => write2(ANSI.setTitle(title)),
      bell: write2(ANSI.bell),
      getCursorPosition: exports_Effect.gen(function* (_2) {
        try {
          yield* _2(write2(ANSI.requestCursorPosition));
          const size23 = yield* _2(exports_Effect.sync(() => ({
            width: platform.stdout.columns || 80,
            height: platform.stdout.rows || 24
          })));
          return { x: 1, y: 1 };
        } catch {
          return { x: 1, y: 1 };
        }
      }),
      setCursorShape: (shape) => write2(shape === "block" ? ANSI.cursorBlock : shape === "underline" ? ANSI.cursorUnderline : ANSI.cursorBar),
      setCursorBlink: (enabled2) => write2(enabled2 ? ANSI.cursorBlinkingBlock : ANSI.cursorBlock)
    };
  }));
  TerminalServiceTest = exports_Layer.succeed(TerminalService, {
    clear: exports_Effect.void,
    write: (_text) => exports_Effect.void,
    writeLine: (_text) => exports_Effect.void,
    moveCursor: (_x, _y) => exports_Effect.void,
    moveCursorRelative: (_dx, _dy) => exports_Effect.void,
    hideCursor: exports_Effect.void,
    showCursor: exports_Effect.void,
    getSize: exports_Effect.succeed({ width: 80, height: 24 }),
    setRawMode: (_enabled) => exports_Effect.void,
    setAlternateScreen: (_enabled) => exports_Effect.void,
    saveCursor: exports_Effect.void,
    restoreCursor: exports_Effect.void,
    getCapabilities: exports_Effect.succeed({
      colors: "truecolor",
      unicode: true,
      mouse: true,
      clipboard: false,
      sixel: false,
      kitty: false,
      iterm2: false,
      windowTitle: true,
      columns: 80,
      rows: 24
    }),
    supportsTrueColor: exports_Effect.succeed(true),
    supports256Colors: exports_Effect.succeed(true),
    supportsUnicode: exports_Effect.succeed(true),
    clearToEndOfLine: exports_Effect.void,
    clearToStartOfLine: exports_Effect.void,
    clearLine: exports_Effect.void,
    clearToEndOfScreen: exports_Effect.void,
    clearToStartOfScreen: exports_Effect.void,
    scrollUp: (_lines) => exports_Effect.void,
    scrollDown: (_lines) => exports_Effect.void,
    setTitle: (_title) => exports_Effect.void,
    bell: exports_Effect.void,
    getCursorPosition: exports_Effect.succeed({ x: 1, y: 1 }),
    setCursorShape: (_shape) => exports_Effect.void,
    setCursorBlink: (_enabled) => exports_Effect.void
  });
});

// ../../src/services/impl/input-impl.ts
var getPlatform2 = () => ({
  stdin: process.stdin,
  stdout: process.stdout
}), parseMouseEvent2 = (sequence) => {
  let match26 = sequence.match(/^\x1b\[<(\d+);(-?\d+);(-?\d+)([Mm])/);
  if (match26) {
    const info2 = parseInt(match26[1]);
    const x = parseInt(match26[2]);
    const y = parseInt(match26[3]);
    const isPress = match26[4] === "M";
    const button = info2 & 3;
    const shift2 = !!(info2 & 4);
    const alt = !!(info2 & 8);
    const ctrl = !!(info2 & 16);
    const isWheel = !!(info2 & 64);
    let buttonName;
    let eventType;
    if (isWheel) {
      buttonName = info2 & 1 ? "wheel-down" : "wheel-up";
      eventType = "wheel";
    } else {
      buttonName = button === 0 ? "left" : button === 1 ? "middle" : button === 2 ? "right" : "none";
      eventType = isPress ? "press" : "release";
    }
    return {
      type: eventType,
      button: buttonName,
      x,
      y,
      ctrl,
      alt,
      shift: shift2
    };
  }
  match26 = sequence.match(/^\x1b\[M(.)(.)(.)/);
  if (match26) {
    const info2 = match26[1]?.charCodeAt(0) ?? 32 - 32;
    const x = match26[2]?.charCodeAt(0) ?? 32 - 32;
    const y = match26[3]?.charCodeAt(0) ?? 32 - 32;
    const button = info2 & 3;
    const shift2 = !!(info2 & 4);
    const alt = !!(info2 & 8);
    const ctrl = !!(info2 & 16);
    const motion = !!(info2 & 32);
    const release2 = !!(info2 & true);
    let buttonName;
    let eventType;
    if (motion) {
      buttonName = "none";
      eventType = "motion";
    } else if (release2) {
      buttonName = "none";
      eventType = "release";
    } else {
      buttonName = button === 0 ? "left" : button === 1 ? "middle" : "right";
      eventType = "press";
    }
    return {
      type: eventType,
      button: buttonName,
      x,
      y,
      ctrl,
      alt,
      shift: shift2
    };
  }
  return null;
}, parseBuffer = (buffer4, keyPubSub, mousePubSub) => {
  while (buffer4.length > 0) {
    const sgrMatch = buffer4.match(/^\x1b\[<(\d+);(\d+);(\d+)[Mm]/);
    if (sgrMatch) {
      const mouseSeq = sgrMatch[0];
      buffer4 = buffer4.slice(mouseSeq.length);
      const mouseEvent = parseMouseEvent2(mouseSeq);
      if (mouseEvent) {
        exports_Effect.runSync(exports_PubSub.publish(mousePubSub, mouseEvent));
      }
      continue;
    }
    if (buffer4.startsWith("\x1B[M") && buffer4.length >= 6) {
      const mouseSeq = buffer4.slice(0, 6);
      buffer4 = buffer4.slice(6);
      const mouseEvent = parseMouseEvent2(mouseSeq);
      if (mouseEvent) {
        exports_Effect.runSync(exports_PubSub.publish(mousePubSub, mouseEvent));
      }
      continue;
    }
    let matched = false;
    const sortedSequences = Array.from(ANSI_SEQUENCES.entries()).sort((a, b) => b[0].length - a[0].length);
    for (const [seq2, partial2] of sortedSequences) {
      if (buffer4.startsWith(seq2)) {
        const keyEvent = {
          type: partial2.type || "runes" /* Runes */,
          key: partial2.key || "",
          runes: partial2.type === "runes" /* Runes */ ? seq2 : undefined,
          ctrl: partial2.ctrl || false,
          alt: partial2.alt || false,
          shift: partial2.shift || false,
          meta: false,
          sequence: seq2
        };
        exports_Effect.runSync(exports_PubSub.publish(keyPubSub, keyEvent));
        buffer4 = buffer4.slice(seq2.length);
        matched = true;
        break;
      }
    }
    if (matched)
      continue;
    if (buffer4.startsWith("\x1B") && buffer4.length > 1 && buffer4[1] !== "[") {
      const char = buffer4[1];
      const baseKey = parseChar(char);
      const keyEvent = {
        ...baseKey,
        alt: true,
        key: `alt+${baseKey.runes || baseKey.key}`,
        sequence: buffer4.slice(0, 2)
      };
      exports_Effect.runSync(exports_PubSub.publish(keyPubSub, keyEvent));
      buffer4 = buffer4.slice(2);
      continue;
    }
    if (!buffer4.startsWith("\x1B") || buffer4.length === 1) {
      const char = buffer4[0];
      const keyEvent = parseChar(char);
      exports_Effect.runSync(exports_PubSub.publish(keyPubSub, {
        ...keyEvent,
        sequence: char
      }));
      buffer4 = buffer4.slice(1);
      continue;
    }
    if (buffer4.startsWith("\x1B") && buffer4.length < 6) {
      break;
    }
    console.debug("Unknown ANSI sequence:", buffer4.slice(0, Math.min(10, buffer4.length)));
    buffer4 = buffer4.slice(1);
  }
  return buffer4;
}, InputServiceLive;
var init_input_impl = __esm(() => {
  init_esm2();
  init_input();
  init_errors3();
  init_keys();
  InputServiceLive = exports_Layer.scoped(InputService, exports_Effect.gen(function* (_) {
    const platform = getPlatform2();
    const stdin = platform.stdin;
    const keyPubSub = yield* _(exports_PubSub.unbounded());
    const mousePubSub = yield* _(exports_PubSub.unbounded());
    yield* _(exports_Effect.acquireRelease(exports_Effect.sync(() => {
      stdin.setEncoding("utf8");
      const hasTTY = stdin.isTTY && "setRawMode" in stdin;
      if (hasTTY) {
        stdin.setRawMode(true);
      }
      let buffer4 = "";
      stdin.on("data", (chunk4) => {
        buffer4 += chunk4;
        buffer4 = parseBuffer(buffer4, keyPubSub, mousePubSub);
      });
    }), () => exports_Effect.sync(() => {
      stdin.removeAllListeners("data");
      if (stdin.isTTY && "setRawMode" in stdin) {
        stdin.setRawMode(false);
      }
    })));
    return {
      keyEvents: exports_Stream.fromPubSub(keyPubSub),
      mouseEvents: exports_Stream.fromPubSub(mousePubSub),
      readKey: exports_Stream.fromPubSub(keyPubSub).pipe(exports_Stream.take(1), exports_Stream.runHead, exports_Effect.flatMap((opt) => exports_Option.isSome(opt) ? exports_Effect.succeed(opt.value) : exports_Effect.fail(new InputError({ operation: "readKey", cause: "No key event available" })))),
      readLine: exports_Effect.fail(new InputError({ operation: "readLine", cause: "Not implemented" })),
      inputAvailable: exports_Effect.succeed(false),
      flushInput: exports_Effect.void,
      filterKeys: (predicate) => exports_Stream.fromPubSub(keyPubSub).pipe(exports_Stream.filter(predicate)),
      mapKeys: (mapper) => exports_Stream.fromPubSub(keyPubSub).pipe(exports_Stream.filterMap((key) => {
        const result = mapper(key);
        return result !== null ? exports_Option.some(result) : exports_Option.none();
      })),
      debounceKeys: (ms) => exports_Stream.fromPubSub(keyPubSub).pipe(exports_Stream.debounce(ms)),
      parseAnsiSequence: (sequence) => exports_Effect.sync(() => {
        const partial2 = ANSI_SEQUENCES.get(sequence);
        if (!partial2)
          return null;
        return {
          type: partial2.type || "runes" /* Runes */,
          key: partial2.key || "",
          runes: partial2.type === "runes" /* Runes */ ? sequence : undefined,
          ctrl: partial2.ctrl || false,
          alt: partial2.alt || false,
          shift: partial2.shift || false,
          meta: false,
          sequence
        };
      }),
      rawInput: exports_Stream.async((emit2) => {
        stdin.on("data", (chunk4) => {
          if (chunk4 instanceof Buffer) {
            emit2(exports_Effect.succeed(exports_Chunk.of(new Uint8Array(chunk4))));
          } else if (typeof chunk4 === "string") {
            emit2(exports_Effect.succeed(exports_Chunk.of(new TextEncoder().encode(chunk4))));
          }
        });
      }),
      setEcho: (enabled2) => exports_Effect.try({
        try: () => {
          if (stdin.isTTY && "setRawMode" in stdin) {
            stdin.setRawMode(!enabled2);
          }
        },
        catch: (error2) => new InputError({
          device: "keyboard",
          cause: error2
        })
      }),
      enableMouse: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1000h");
          platform.stdout.write("\x1B[?1002h");
          platform.stdout.write("\x1B[?1015h");
          platform.stdout.write("\x1B[?1006h");
        },
        catch: (error2) => new InputError({
          device: "mouse",
          cause: error2
        })
      }),
      disableMouse: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1000l");
          platform.stdout.write("\x1B[?1002l");
          platform.stdout.write("\x1B[?1015l");
          platform.stdout.write("\x1B[?1006l");
        },
        catch: (error2) => new InputError({
          device: "mouse",
          cause: error2
        })
      }),
      enableMouseMotion: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1003h");
        },
        catch: (error2) => new InputError({
          device: "mouse",
          cause: error2
        })
      }),
      disableMouseMotion: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1003l");
        },
        catch: (error2) => new InputError({
          device: "mouse",
          cause: error2
        })
      }),
      resizeEvents: exports_Stream.async((emit2) => {
        const handleResize = () => {
          emit2(exports_Effect.succeed(exports_Chunk.of({
            width: platform.stdout.columns || 80,
            height: platform.stdout.rows || 24
          })));
        };
        platform.stdout.on("resize", handleResize);
        return exports_Effect.sync(() => {
          platform.stdout.removeListener("resize", handleResize);
        });
      }),
      pasteEvents: exports_Stream.empty,
      enableBracketedPaste: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?2004h");
        },
        catch: (error2) => new InputError({
          operation: "enableBracketedPaste",
          cause: error2
        })
      }),
      disableBracketedPaste: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?2004l");
        },
        catch: (error2) => new InputError({
          operation: "disableBracketedPaste",
          cause: error2
        })
      }),
      enableFocusTracking: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1004h");
        },
        catch: (error2) => new InputError({
          operation: "enableFocusTracking",
          cause: error2
        })
      }),
      disableFocusTracking: exports_Effect.try({
        try: () => {
          platform.stdout.write("\x1B[?1004l");
        },
        catch: (error2) => new InputError({
          operation: "disableFocusTracking",
          cause: error2
        })
      }),
      focusEvents: exports_Stream.empty
    };
  }));
});

// ../../src/services/impl/renderer-impl.ts
class Buffer2 {
  width;
  height;
  cells;
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.cells = Array(height).fill(null).map(() => Array(width).fill(null).map(() => ({ char: " " })));
  }
  get(x, y) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return;
    }
    return this.cells[y]?.[x];
  }
  set(x, y, cell) {
    if (x >= 0 && x < this.width && y >= 0 && y < this.height) {
      if (this.cells[y])
        this.cells[y][x] = cell;
    }
  }
  clear() {
    for (let y = 0;y < this.height; y++) {
      for (let x = 0;x < this.width; x++) {
        if (this.cells[y])
          this.cells[y][x] = { char: " " };
      }
    }
  }
  writeText(x, y, text2, style2) {
    let currentX = x;
    let currentY = y;
    const lines = text2.split(`
`);
    for (let lineIndex = 0;lineIndex < lines.length; lineIndex++) {
      if (lineIndex > 0) {
        currentY++;
        currentX = x;
      }
      const line = lines[lineIndex];
      if (!line)
        continue;
      let remainingText = line;
      let segmentX = currentX;
      let currentStyle = style2;
      while (remainingText) {
        const ansiMatch = remainingText.match(/^(\x1b\[[0-9;]*m)/);
        if (ansiMatch) {
          const ansiCode = ansiMatch[1];
          if (ansiCode === "\x1B[0m") {
            currentStyle = undefined;
          } else {
            currentStyle = ansiCode;
          }
          remainingText = remainingText.slice(ansiMatch[0].length);
          continue;
        }
        let char = remainingText[0];
        let charLength = 1;
        const codePoint = remainingText.codePointAt(0);
        if (codePoint && codePoint > 65535) {
          charLength = 2;
          char = remainingText.slice(0, 2);
        } else if (codePoint && codePoint >= 126976) {
          let pos = 1;
          while (pos < remainingText.length) {
            const nextCode = remainingText.codePointAt(pos);
            if (nextCode === 65039 || nextCode === 8205 || nextCode >= 127995 && nextCode <= 127999 || nextCode >= 126976) {
              pos += nextCode > 65535 ? 2 : 1;
            } else {
              break;
            }
          }
          charLength = pos;
          char = remainingText.slice(0, pos);
        }
        remainingText = remainingText.slice(charLength);
        const charWidth = stringWidth(char);
        if (segmentX < this.width && currentY < this.height) {
          this.set(segmentX, currentY, { char, style: currentStyle ?? "" });
          for (let i = 1;i < charWidth; i++) {
            if (segmentX + i < this.width) {
              this.set(segmentX + i, currentY, { char: "", style: currentStyle });
            }
          }
        }
        segmentX += charWidth;
      }
    }
  }
  diff(other) {
    const patches = [];
    for (let y = 0;y < this.height; y++) {
      let runStart = -1;
      let runCells = [];
      for (let x = 0;x < this.width; x++) {
        const oldCell = this.get(x, y);
        const newCell = other.get(x, y);
        const different = oldCell?.char !== newCell?.char || oldCell?.style !== newCell?.style;
        if (different && newCell) {
          if (runStart === -1) {
            runStart = x;
          }
          runCells.push(newCell);
        } else if (runStart !== -1) {
          patches.push({
            x: runStart,
            y,
            cells: runCells
          });
          runStart = -1;
          runCells = [];
        }
      }
      if (runStart !== -1) {
        patches.push({
          x: runStart,
          y,
          cells: runCells
        });
      }
    }
    return patches;
  }
}
var RendererServiceLive;
var init_renderer_impl = __esm(() => {
  init_esm2();
  init_string_width();
  init_renderer();
  init_terminal();
  init_errors3();
  RendererServiceLive = exports_Layer.effect(RendererService, exports_Effect.gen(function* (_) {
    const defaultSize = { width: 80, height: 24 };
    const frontBuffer = yield* _(exports_Ref.make(new Buffer2(defaultSize.width, defaultSize.height)));
    const backBuffer = yield* _(exports_Ref.make(new Buffer2(defaultSize.width, defaultSize.height)));
    const viewportStack = yield* _(exports_Ref.make([{
      x: 0,
      y: 0,
      width: defaultSize.width,
      height: defaultSize.height
    }]));
    const stats = yield* _(exports_Ref.make({
      framesRendered: 0,
      averageFrameTime: 0,
      lastFrameTime: 0,
      dirtyRegionCount: 0,
      bufferSwitches: 0
    }));
    const dirtyRegions = yield* _(exports_Ref.make([]));
    const layers = yield* _(exports_Ref.make(new Map));
    const applyPatches = (patches) => exports_Effect.forEach(patches, (patch12) => exports_Effect.gen(function* (_2) {
      const terminal2 = yield* _2(TerminalService);
      yield* _2(terminal2.moveCursor(patch12.x + 1, patch12.y + 1));
      let text2 = "";
      let currentStyle;
      for (const cell of patch12.cells) {
        if (cell.style !== currentStyle) {
          if (text2) {
            yield* _2(terminal2.write(text2));
            text2 = "";
          }
          if (cell.style) {
            yield* _2(terminal2.write(cell.style));
          }
          currentStyle = cell.style;
        }
        text2 += cell.char;
      }
      if (text2) {
        yield* _2(terminal2.write(text2));
      }
      if (currentStyle) {
        yield* _2(terminal2.write("\x1B[0m"));
      }
    }));
    return {
      beginFrame: exports_Effect.gen(function* (_2) {
        const terminal2 = yield* _2(TerminalService);
        const size23 = yield* _2(terminal2.getSize);
        let back = yield* _2(exports_Ref.get(backBuffer));
        if (back.width !== size23.width || back.height !== size23.height) {
          const newBack = new Buffer2(size23.width, size23.height);
          const newFront = new Buffer2(size23.width, size23.height);
          yield* _2(exports_Ref.set(backBuffer, newBack));
          yield* _2(exports_Ref.set(frontBuffer, newFront));
          back = newBack;
          yield* _2(exports_Ref.set(viewportStack, [{
            x: 0,
            y: 0,
            width: size23.width,
            height: size23.height
          }]));
        }
        back.clear();
      }),
      endFrame: exports_Effect.gen(function* (_2) {
        const front = yield* _2(exports_Ref.get(frontBuffer));
        const back = yield* _2(exports_Ref.get(backBuffer));
        const patches = front.diff(back);
        yield* _2(applyPatches(patches));
        yield* _2(exports_Ref.set(frontBuffer, back));
        yield* _2(exports_Ref.set(backBuffer, front));
        yield* _2(exports_Ref.update(stats, (s) => ({
          framesRendered: s.framesRendered + 1,
          averageFrameTime: s.averageFrameTime,
          lastFrameTime: 0,
          dirtyRegionCount: patches.length,
          bufferSwitches: s.bufferSwitches + 1
        })));
      }),
      render: (view) => exports_Effect.gen(function* (_2) {
        const startTime = Date.now();
        const viewports = yield* _2(exports_Ref.get(viewportStack));
        const viewport = viewports[viewports.length - 1];
        const back = yield* _2(exports_Ref.get(backBuffer));
        const rendered = yield* _2(view.render());
        back.writeText(viewport.x, viewport.y, rendered);
        const endTime = Date.now();
        yield* _2(exports_Ref.update(stats, (s) => ({
          ...s,
          lastFrameTime: endTime - startTime
        })));
      }),
      forceRedraw: exports_Effect.gen(function* (_2) {
        const terminal2 = yield* _2(TerminalService);
        const front = yield* _2(exports_Ref.get(frontBuffer));
        const size23 = yield* _2(terminal2.getSize);
        yield* _2(terminal2.clear);
        yield* _2(terminal2.moveCursor(1, 1));
        front.clear();
        for (let y = 0;y < size23.height; y++) {
          yield* _2(terminal2.moveCursor(1, y + 1));
          yield* _2(terminal2.write(" ".repeat(size23.width)));
        }
        yield* _2(terminal2.moveCursor(1, 1));
      }),
      setViewport: (viewport) => exports_Effect.gen(function* (_2) {
        const stack = yield* _2(exports_Ref.get(viewportStack));
        yield* _2(exports_Ref.set(viewportStack, [viewport]));
      }),
      getViewport: exports_Effect.gen(function* (_2) {
        const stack = yield* _2(exports_Ref.get(viewportStack));
        return stack[stack.length - 1];
      }),
      pushViewport: (viewport) => exports_Ref.update(viewportStack, (stack) => [...stack, viewport]),
      popViewport: exports_Effect.gen(function* (_2) {
        yield* _2(exports_Ref.update(viewportStack, (stack) => stack.length > 1 ? stack.slice(0, -1) : stack));
      }),
      clearDirtyRegions: exports_Ref.set(dirtyRegions, []),
      markDirty: (region) => exports_Ref.update(dirtyRegions, (regions) => [...regions, region]),
      getDirtyRegions: exports_Ref.get(dirtyRegions),
      optimizeDirtyRegions: exports_Effect.gen(function* (_2) {
        const regions = yield* _2(exports_Ref.get(dirtyRegions));
        if (regions.length <= 1) {
          return;
        }
        const sorted = [...regions].sort((a, b) => {
          if (a.y !== b.y)
            return a.y - b.y;
          return a.x - b.x;
        });
        const merged = [];
        let current2 = sorted[0];
        for (let i = 1;i < sorted.length; i++) {
          const next5 = sorted[i];
          const overlapX = current2.x <= next5.x && next5.x <= current2.x + current2.width;
          const overlapY = current2.y <= next5.y && next5.y <= current2.y + current2.height;
          const adjacentX = current2.x + current2.width === next5.x && current2.y === next5.y;
          const adjacentY = current2.y + current2.height === next5.y && current2.x === next5.x;
          if (overlapX && overlapY || adjacentX || adjacentY) {
            const minX = Math.min(current2.x, next5.x);
            const minY = Math.min(current2.y, next5.y);
            const maxX = Math.max(current2.x + current2.width, next5.x + next5.width);
            const maxY = Math.max(current2.y + current2.height, next5.y + next5.height);
            current2 = {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
          } else {
            merged.push(current2);
            current2 = next5;
          }
        }
        merged.push(current2);
        yield* _2(exports_Ref.set(dirtyRegions, merged));
      }),
      getStats: exports_Ref.get(stats),
      resetStats: exports_Ref.set(stats, {
        framesRendered: 0,
        averageFrameTime: 0,
        lastFrameTime: 0,
        dirtyRegionCount: 0,
        bufferSwitches: 0
      }),
      setProfilingEnabled: (enabled2) => exports_Effect.gen(function* (_2) {
        yield* _2(exports_Ref.update(stats, (s) => ({ ...s, profilingEnabled: enabled2 })));
      }),
      renderAt: (view, x, y) => exports_Effect.gen(function* (_2) {
        const rendered = yield* _2(view.render());
        const back = yield* _2(exports_Ref.get(backBuffer));
        back.writeText(x, y, rendered);
      }),
      renderBatch: (views) => exports_Effect.gen(function* (_2) {
        const back = yield* _2(exports_Ref.get(backBuffer));
        const rendered = yield* _2(exports_Effect.all(views.map(({ view, x, y }) => view.render().pipe(exports_Effect.map((content) => ({ content, x, y }))))));
        for (const { content, x, y } of rendered) {
          back.writeText(x, y, content);
        }
      }),
      setClipRegion: (region) => exports_Effect.gen(function* (_2) {
        if (region === null) {
          const terminal2 = yield* _2(TerminalService);
          const size23 = yield* _2(terminal2.getSize);
          yield* _2(exports_Ref.set(viewportStack, [{
            x: 0,
            y: 0,
            width: size23.width,
            height: size23.height
          }]));
        } else {
          yield* _2(exports_Ref.set(viewportStack, [region]));
        }
      }),
      saveState: exports_Effect.gen(function* (_2) {
        const currentViewports = yield* _2(exports_Ref.get(viewportStack));
        const currentStats = yield* _2(exports_Ref.get(stats));
        const currentDirty = yield* _2(exports_Ref.get(dirtyRegions));
        const currentLayers = yield* _2(exports_Ref.get(layers));
        yield* _2(exports_Effect.log("Renderer state saved"));
      }),
      restoreState: exports_Effect.gen(function* (_2) {
        yield* _2(exports_Effect.log("Renderer state restored"));
      }),
      measureText: (text2) => exports_Effect.sync(() => {
        const lines = text2.split(`
`);
        const width = Math.max(...lines.map((l) => l.length));
        return {
          width,
          height: lines.length,
          lineCount: lines.length
        };
      }),
      wrapText: (text2, width, _options) => exports_Effect.sync(() => {
        const words = text2.split(" ");
        const lines = [];
        let currentLine = "";
        for (const word of words) {
          if (currentLine.length + word.length + 1 <= width) {
            currentLine += (currentLine ? " " : "") + word;
          } else {
            if (currentLine)
              lines.push(currentLine);
            currentLine = word;
          }
        }
        if (currentLine)
          lines.push(currentLine);
        return lines;
      }),
      truncateText: (text2, width, ellipsis = "...") => exports_Effect.sync(() => text2.length <= width ? text2 : text2.slice(0, width - ellipsis.length) + ellipsis),
      createLayer: (name, zIndex) => exports_Effect.gen(function* (_2) {
        const terminal2 = yield* _2(TerminalService);
        const size23 = yield* _2(terminal2.getSize);
        const layer = {
          name,
          buffer: new Buffer2(size23.width, size23.height),
          visible: true,
          zIndex: zIndex || 0
        };
        yield* _2(exports_Ref.update(layers, (map33) => {
          const newMap = new Map(map33);
          newMap.set(name, layer);
          return newMap;
        }));
      }),
      removeLayer: (name) => exports_Ref.update(layers, (map33) => {
        const newMap = new Map(map33);
        newMap.delete(name);
        return newMap;
      }),
      renderToLayer: (layerName, view, x, y) => exports_Effect.gen(function* (_2) {
        const layerMap = yield* _2(exports_Ref.get(layers));
        const layer = layerMap.get(layerName);
        if (!layer) {
          yield* _2(exports_Effect.fail(new RenderError({
            phase: "render",
            cause: `Layer ${layerName} not found`
          })));
        }
        const rendered = yield* _2(view.render());
        layer.buffer.writeText(x, y, rendered);
      }),
      setLayerVisible: (layerName, visible) => exports_Effect.gen(function* (_2) {
        yield* _2(exports_Ref.update(layers, (map33) => {
          const layer = map33.get(layerName);
          if (layer) {
            layer.visible = visible;
          }
          return map33;
        }));
      }),
      compositeLayers: exports_Effect.gen(function* (_2) {
        const layerMap = yield* _2(exports_Ref.get(layers));
        const sortedLayers = Array.from(layerMap.values()).filter((l) => l.visible).sort((a, b) => a.zIndex - b.zIndex);
        const back = yield* _2(exports_Ref.get(backBuffer));
        for (const layer of sortedLayers) {
          for (let y = 0;y < layer.buffer.height; y++) {
            for (let x = 0;x < layer.buffer.width; x++) {
              const cell = layer.buffer.get(x, y);
              if (cell && cell.char !== " ") {
                back.set(x, y, cell);
              }
            }
          }
        }
      })
    };
  }));
});

// ../../src/services/impl/storage-impl.ts
import * as fs from "fs/promises";
import * as path from "path";
var StorageServiceLive;
var init_storage_impl = __esm(() => {
  init_esm2();
  init_storage();
  init_errors3();
  StorageServiceLive = exports_Layer.effect(StorageService, exports_Effect.gen(function* (_) {
    const stateStore = yield* _(exports_Ref.make(new Map));
    const cacheStore = yield* _(exports_Ref.make(new Map));
    const configStore = yield* _(exports_Ref.make(new Map));
    const transactions = yield* _(exports_Ref.make(new Map));
    const getAppDataDir = (appName) => {
      const dataPaths = StorageUtils.getDataPaths(appName);
      return dataPaths[0] ?? "";
    };
    const getStateFilePath = (key) => {
      return path.join(getAppDataDir("cli-kit"), "state", `${key}.json`);
    };
    const getCacheDir = () => {
      const cachePaths = StorageUtils.getCachePaths("cli-kit");
      return cachePaths[0] ?? "";
    };
    return {
      saveState: (key, data, options) => exports_Effect.gen(function* (_2) {
        if (options?.schema) {
          try {
            options.schema.parse(data);
          } catch (error2) {
            yield* _2(exports_Effect.fail(new StorageError({ operation: "validate", cause: error2 })));
          }
        }
        const content = options?.pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
        yield* _2(exports_Ref.update(stateStore, (store) => {
          const newStore = new Map(store);
          newStore.set(key, content);
          return newStore;
        }));
        const filePath = getStateFilePath(key);
        yield* _2(exports_Effect.tryPromise({
          try: async () => {
            await fs.mkdir(path.dirname(filePath), { recursive: true });
            await fs.writeFile(filePath, content);
          },
          catch: (error2) => new StorageError({
            operation: "write",
            path: filePath,
            cause: error2
          })
        }));
      }),
      loadState: (key, schema) => exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(stateStore));
        let content = store.get(key);
        if (!content) {
          const filePath = getStateFilePath(key);
          const exists5 = yield* _2(exports_Effect.tryPromise({
            try: async () => {
              await fs.access(filePath);
              return true;
            },
            catch: () => false
          }));
          if (!exists5) {
            return null;
          }
          content = yield* _2(exports_Effect.tryPromise({
            try: () => fs.readFile(filePath, "utf-8"),
            catch: (error2) => new StorageError({
              operation: "read",
              path: filePath,
              cause: error2
            })
          }));
          yield* _2(exports_Ref.update(stateStore, (store2) => {
            const newStore = new Map(store2);
            if (content) {
              newStore.set(key, content);
            }
            return newStore;
          }));
        }
        try {
          const parsed = JSON.parse(content);
          return schema.parse(parsed);
        } catch {
          return null;
        }
      }),
      clearState: (key) => exports_Effect.gen(function* (_2) {
        yield* _2(exports_Ref.update(stateStore, (store) => {
          const newStore = new Map(store);
          newStore.delete(key);
          return newStore;
        }));
        const filePath = getStateFilePath(key);
        yield* _2(exports_Effect.tryPromise({
          try: () => fs.unlink(filePath),
          catch: () => {}
        }));
      }),
      hasState: (key) => exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(stateStore));
        if (store.has(key)) {
          return true;
        }
        const filePath = getStateFilePath(key);
        return yield* _2(exports_Effect.tryPromise({
          try: async () => {
            await fs.access(filePath);
            return true;
          },
          catch: () => false
        }));
      }),
      listStateKeys: exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(stateStore));
        const memoryKeys = Array.from(store.keys());
        const stateDir = path.join(getAppDataDir("cli-kit"), "state");
        const fileKeys = yield* _2(exports_Effect.tryPromise({
          try: async () => {
            try {
              const files = await fs.readdir(stateDir);
              return files.filter((file) => file.endsWith(".json")).map((file) => file.slice(0, -5));
            } catch {
              return [];
            }
          },
          catch: () => []
        }));
        const allKeys = [...new Set([...memoryKeys, ...fileKeys])];
        return allKeys;
      }),
      loadConfig: (appName, schema, defaults) => exports_Effect.gen(function* (_2) {
        const configPaths = StorageUtils.getConfigPaths(appName);
        for (const configPath of configPaths) {
          const exists5 = yield* _2(exports_Effect.tryPromise({
            try: async () => {
              await fs.access(configPath);
              return true;
            },
            catch: () => false
          }));
          if (exists5) {
            const content = yield* _2(exports_Effect.tryPromise({
              try: () => fs.readFile(configPath, "utf-8"),
              catch: () => null
            }));
            if (content) {
              try {
                const parsed = JSON.parse(content);
                const validated = schema.parse(parsed);
                yield* _2(exports_Ref.update(configStore, (store) => {
                  const newStore = new Map(store);
                  newStore.set(appName, validated);
                  return newStore;
                }));
                return validated;
              } catch {}
            }
          }
        }
        yield* _2(exports_Ref.update(configStore, (store) => {
          const newStore = new Map(store);
          newStore.set(appName, defaults);
          return newStore;
        }));
        return defaults;
      }),
      saveConfig: (appName, config2, schema) => exports_Effect.gen(function* (_2) {
        try {
          const validated = schema.parse(config2);
          yield* _2(exports_Ref.update(configStore, (store) => {
            const newStore = new Map(store);
            newStore.set(appName, validated);
            return newStore;
          }));
          const configPaths = StorageUtils.getConfigPaths(appName);
          const configPath = configPaths[0];
          const content = JSON.stringify(validated, null, 2);
          yield* _2(exports_Effect.tryPromise({
            try: async () => {
              await fs.mkdir(path.dirname(configPath), { recursive: true });
              await fs.writeFile(configPath, content);
            },
            catch: (error2) => new StorageError({
              operation: "write",
              path: configPath,
              cause: error2
            })
          }));
        } catch (error2) {
          yield* _2(exports_Effect.fail(new StorageError({ operation: "validate", cause: error2 })));
        }
      }),
      getConfigPath: (appName) => exports_Effect.succeed(StorageUtils.getConfigPaths(appName)[0]),
      watchConfig: (appName, schema) => exports_Effect.succeed(exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(configStore));
        const config2 = store.get(appName);
        if (config2) {
          return schema.parse(config2);
        }
        return {};
      })),
      setCache: (key, data, ttlSeconds) => exports_Effect.gen(function* (_2) {
        const expires = ttlSeconds ? Date.now() + ttlSeconds * 1000 : null;
        const entry = {
          data,
          expires,
          createdAt: Date.now()
        };
        yield* _2(exports_Ref.update(cacheStore, (store) => {
          const newStore = new Map(store);
          newStore.set(key, entry);
          return newStore;
        }));
      }),
      getCache: (key, schema) => exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(cacheStore));
        const entry = store.get(key);
        if (!entry) {
          return null;
        }
        if (entry.expires && entry.expires < Date.now()) {
          yield* _2(exports_Ref.update(cacheStore, (store2) => {
            const newStore = new Map(store2);
            newStore.delete(key);
            return newStore;
          }));
          return null;
        }
        try {
          return schema.parse(entry.data);
        } catch {
          return null;
        }
      }),
      clearCache: (key) => exports_Effect.gen(function* (_2) {
        yield* _2(exports_Ref.update(cacheStore, (store) => {
          const newStore = new Map(store);
          newStore.delete(key);
          return newStore;
        }));
      }),
      clearExpiredCache: exports_Effect.gen(function* (_2) {
        const now2 = Date.now();
        yield* _2(exports_Ref.update(cacheStore, (store) => {
          const newStore = new Map(store);
          for (const [key, entry] of newStore.entries()) {
            if (entry.expires && entry.expires < now2) {
              newStore.delete(key);
            }
          }
          return newStore;
        }));
      }),
      getCacheStats: exports_Effect.gen(function* (_2) {
        const store = yield* _2(exports_Ref.get(cacheStore));
        const now2 = Date.now();
        let expiredCount = 0;
        for (const entry of store.values()) {
          if (entry.expires && entry.expires < now2) {
            expiredCount++;
          }
        }
        return {
          totalEntries: store.size,
          expiredEntries: expiredCount,
          totalSize: JSON.stringify([...store.entries()]).length
        };
      }),
      readTextFile: (filePath, schema) => exports_Effect.gen(function* (_2) {
        const content = yield* _2(exports_Effect.tryPromise({
          try: () => fs.readFile(filePath, "utf-8"),
          catch: (error2) => new StorageError({
            operation: "read",
            path: filePath,
            cause: error2
          })
        }));
        if (schema) {
          try {
            return schema.parse(content);
          } catch (error2) {
            yield* _2(exports_Effect.fail(new StorageError({
              operation: "validate",
              path: filePath,
              cause: error2
            })));
          }
        }
        return content;
      }),
      writeTextFile: (filePath, content, options) => exports_Effect.gen(function* (_2) {
        if (options?.backup) {
          const exists5 = yield* _2(exports_Effect.tryPromise({
            try: async () => {
              await fs.access(filePath);
              return true;
            },
            catch: () => false
          }));
          if (exists5) {
            const backupPath = StorageUtils.generateBackupName(filePath);
            yield* _2(exports_Effect.tryPromise({
              try: () => fs.copyFile(filePath, backupPath),
              catch: (error2) => new StorageError({
                operation: "write",
                path: backupPath,
                cause: error2
              })
            }));
          }
        }
        yield* _2(exports_Effect.tryPromise({
          try: async () => {
            if (options?.createDirs) {
              await fs.mkdir(path.dirname(filePath), { recursive: true });
            }
            await fs.writeFile(filePath, content);
          },
          catch: (error2) => new StorageError({
            operation: "write",
            path: filePath,
            cause: error2
          })
        }));
      }),
      readJsonFile: (filePath, schema) => exports_Effect.gen(function* (_2) {
        const content = yield* _2(exports_Effect.tryPromise({
          try: () => fs.readFile(filePath, "utf-8"),
          catch: (error2) => new StorageError({
            operation: "read",
            path: filePath,
            cause: error2
          })
        }));
        try {
          const parsed = JSON.parse(content);
          return schema.parse(parsed);
        } catch (error2) {
          yield* _2(exports_Effect.fail(new StorageError({
            operation: "validate",
            path: filePath,
            cause: error2
          })));
        }
      }),
      writeJsonFile: (filePath, data, options) => exports_Effect.gen(function* (_2) {
        const content = options?.pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
        if (options?.backup) {
          const exists5 = yield* _2(exports_Effect.tryPromise({
            try: async () => {
              await fs.access(filePath);
              return true;
            },
            catch: () => false
          }));
          if (exists5) {
            const backupPath = StorageUtils.generateBackupName(filePath);
            yield* _2(exports_Effect.tryPromise({
              try: () => fs.copyFile(filePath, backupPath),
              catch: (error2) => new StorageError({
                operation: "write",
                path: backupPath,
                cause: error2
              })
            }));
          }
        }
        yield* _2(exports_Effect.tryPromise({
          try: async () => {
            if (options?.createDirs) {
              await fs.mkdir(path.dirname(filePath), { recursive: true });
            }
            await fs.writeFile(filePath, content);
          },
          catch: (error2) => new StorageError({
            operation: "write",
            path: filePath,
            cause: error2
          })
        }));
      }),
      fileExists: (filePath) => exports_Effect.tryPromise({
        try: async () => {
          await fs.access(filePath);
          return true;
        },
        catch: () => false
      }),
      createDirectory: (dirPath) => exports_Effect.tryPromise({
        try: () => fs.mkdir(dirPath, { recursive: true }),
        catch: (error2) => new StorageError({
          operation: "write",
          path: dirPath,
          cause: error2
        })
      }).pipe(exports_Effect.void),
      getFileStats: (filePath) => exports_Effect.tryPromise({
        try: async () => {
          const stats = await fs.stat(filePath);
          return {
            size: stats.size,
            modified: stats.mtime,
            created: stats.birthtime,
            isFile: stats.isFile(),
            isDirectory: stats.isDirectory()
          };
        },
        catch: (error2) => new StorageError({
          operation: "read",
          path: filePath,
          cause: error2
        })
      }),
      createBackup: (filePath, backupSuffix) => exports_Effect.gen(function* (_2) {
        const exists5 = yield* _2(exports_Effect.tryPromise({
          try: async () => {
            await fs.access(filePath);
            return true;
          },
          catch: () => false
        }));
        if (!exists5) {
          yield* _2(exports_Effect.fail(new StorageError({
            operation: "read",
            path: filePath,
            cause: new Error("File does not exist")
          })));
        }
        const backupPath = StorageUtils.generateBackupName(filePath, backupSuffix);
        yield* _2(exports_Effect.tryPromise({
          try: () => fs.copyFile(filePath, backupPath),
          catch: (error2) => new StorageError({
            operation: "write",
            path: backupPath,
            cause: error2
          })
        }));
        return backupPath;
      }),
      restoreBackup: (filePath, backupPath) => exports_Effect.tryPromise({
        try: () => fs.copyFile(backupPath, filePath),
        catch: (error2) => new StorageError({
          operation: "write",
          path: filePath,
          cause: error2
        })
      }).pipe(exports_Effect.void),
      listBackups: (filePath) => exports_Effect.gen(function* (_2) {
        const dir2 = path.dirname(filePath);
        const basename2 = path.basename(filePath);
        const files = yield* _2(exports_Effect.tryPromise({
          try: () => fs.readdir(dir2),
          catch: () => []
        }));
        return files.filter((file) => file.startsWith(`${basename2}.backup`)).map((file) => path.join(dir2, file));
      }),
      cleanupBackups: (filePath, keepCount) => exports_Effect.gen(function* (_2) {
        const backups = yield* _2(exports_Effect.tryPromise({
          try: async () => {
            const dir2 = path.dirname(filePath);
            const basename2 = path.basename(filePath);
            const files = await fs.readdir(dir2);
            const backupFiles = files.filter((file) => file.startsWith(`${basename2}.backup`)).map((file) => path.join(dir2, file)).sort();
            return backupFiles;
          },
          catch: () => []
        }));
        const toDelete = backups.slice(0, -keepCount);
        for (const backup of toDelete) {
          yield* _2(exports_Effect.tryPromise({
            try: () => fs.unlink(backup),
            catch: () => {}
          }));
        }
      }),
      beginTransaction: exports_Effect.gen(function* (_2) {
        const txId = `tx-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        yield* _2(exports_Ref.update(transactions, (txs) => {
          const newTxs = new Map(txs);
          newTxs.set(txId, []);
          return newTxs;
        }));
        return txId;
      }),
      addToTransaction: (transactionId, operation, filePath, content) => exports_Effect.gen(function* (_2) {
        const txs = yield* _2(exports_Ref.get(transactions));
        const tx = txs.get(transactionId);
        if (!tx) {
          yield* _2(exports_Effect.fail(new StorageError({
            operation: "validate",
            cause: new Error("Transaction not found")
          })));
        }
        yield* _2(exports_Ref.update(transactions, (txs2) => {
          const newTxs = new Map(txs2);
          const ops = [...newTxs.get(transactionId) || []];
          ops.push({ operation, path: filePath, content });
          newTxs.set(transactionId, ops);
          return newTxs;
        }));
      }),
      commitTransaction: (transactionId) => exports_Effect.gen(function* (_2) {
        const txs = yield* _2(exports_Ref.get(transactions));
        const tx = txs.get(transactionId);
        if (!tx) {
          yield* _2(exports_Effect.fail(new StorageError({
            operation: "validate",
            cause: new Error("Transaction not found")
          })));
        }
        for (const op of tx) {
          if (op.operation === "write" && op.content !== undefined) {
            yield* _2(exports_Effect.tryPromise({
              try: async () => {
                await fs.mkdir(path.dirname(op.path), { recursive: true });
                await fs.writeFile(op.path, op.content);
              },
              catch: (error2) => new StorageError({
                operation: "write",
                path: op.path,
                cause: error2
              })
            }));
          } else if (op.operation === "delete") {
            yield* _2(exports_Effect.tryPromise({
              try: () => fs.unlink(op.path),
              catch: () => {}
            }));
          }
        }
        yield* _2(exports_Ref.update(transactions, (txs2) => {
          const newTxs = new Map(txs2);
          newTxs.delete(transactionId);
          return newTxs;
        }));
      }),
      rollbackTransaction: (transactionId) => exports_Effect.gen(function* (_2) {
        const txs = yield* _2(exports_Ref.get(transactions));
        if (!txs.has(transactionId)) {
          yield* _2(exports_Effect.fail(new StorageError({
            operation: "validate",
            cause: new Error("Transaction not found")
          })));
        }
        yield* _2(exports_Ref.update(transactions, (txs2) => {
          const newTxs = new Map(txs2);
          newTxs.delete(transactionId);
          return newTxs;
        }));
      })
    };
  }));
});

// ../../src/services/impl/index.ts
var LiveServices, TestServices;
var init_impl = __esm(() => {
  init_esm2();
  init_services();
  init_terminal_impl();
  init_input_impl();
  init_renderer_impl();
  init_storage_impl();
  init_hit_test();
  init_mouse_router();
  init_terminal_impl();
  init_input_impl();
  init_renderer_impl();
  init_storage_impl();
  LiveServices = TerminalServiceLive.pipe(exports_Layer.merge(InputServiceLive), exports_Layer.merge(StorageServiceLive), exports_Layer.merge(RendererServiceLive), exports_Layer.merge(exports_Layer.effect(HitTestService, HitTestServiceLive)), exports_Layer.merge(exports_Layer.effect(MouseRouterService, MouseRouterServiceLive)));
  TestServices = exports_Layer.mergeAll(exports_Layer.succeed(TerminalService, {
    clear: exports_Effect.void,
    write: () => exports_Effect.void,
    writeLine: () => exports_Effect.void,
    moveCursor: () => exports_Effect.void,
    moveCursorRelative: () => exports_Effect.void,
    hideCursor: exports_Effect.void,
    showCursor: exports_Effect.void,
    getSize: exports_Effect.succeed({ width: 80, height: 24 }),
    setRawMode: () => exports_Effect.void,
    setAlternateScreen: () => exports_Effect.void,
    saveCursor: exports_Effect.void,
    restoreCursor: exports_Effect.void,
    getCapabilities: exports_Effect.succeed({
      colors: "basic",
      unicode: true,
      mouse: false,
      clipboard: false,
      sixel: false,
      kitty: false,
      iterm2: false,
      windowTitle: false,
      columns: 80,
      rows: 24
    }),
    supportsTrueColor: exports_Effect.succeed(false),
    supports256Colors: exports_Effect.succeed(false),
    supportsUnicode: exports_Effect.succeed(true),
    clearToEndOfLine: exports_Effect.void,
    clearToStartOfLine: exports_Effect.void,
    clearLine: exports_Effect.void,
    clearToEndOfScreen: exports_Effect.void,
    clearToStartOfScreen: exports_Effect.void,
    scrollUp: () => exports_Effect.void,
    scrollDown: () => exports_Effect.void,
    setTitle: () => exports_Effect.void,
    bell: exports_Effect.void,
    getCursorPosition: exports_Effect.succeed({ x: 1, y: 1 }),
    setCursorShape: () => exports_Effect.void,
    setCursorBlink: () => exports_Effect.void
  }), exports_Layer.succeed(InputService, {
    keyEvents: exports_Stream.never,
    mouseEvents: exports_Stream.never,
    resizeEvents: exports_Stream.never,
    pasteEvents: exports_Stream.never,
    enableMouse: exports_Effect.void,
    disableMouse: exports_Effect.void,
    enableMouseMotion: exports_Effect.void,
    disableMouseMotion: exports_Effect.void,
    enableBracketedPaste: exports_Effect.void,
    disableBracketedPaste: exports_Effect.void,
    enableFocusTracking: exports_Effect.void,
    disableFocusTracking: exports_Effect.void,
    focusEvents: exports_Stream.never,
    readKey: exports_Effect.fail(new Error("Not implemented in test")),
    readLine: exports_Effect.fail(new Error("Not implemented in test")),
    inputAvailable: exports_Effect.succeed(false),
    flushInput: exports_Effect.void,
    filterKeys: () => exports_Stream.never,
    mapKeys: () => exports_Stream.never,
    debounceKeys: () => exports_Stream.never,
    parseAnsiSequence: () => exports_Effect.succeed(null),
    rawInput: exports_Stream.never,
    setEcho: () => exports_Effect.void
  }), exports_Layer.succeed(RendererService, {
    render: () => exports_Effect.void,
    beginFrame: exports_Effect.void,
    endFrame: exports_Effect.void,
    forceRedraw: exports_Effect.void,
    setViewport: () => exports_Effect.void,
    getViewport: exports_Effect.succeed({ x: 0, y: 0, width: 80, height: 24 }),
    pushViewport: () => exports_Effect.void,
    popViewport: exports_Effect.void,
    clearDirtyRegions: exports_Effect.void,
    markDirty: () => exports_Effect.void,
    getDirtyRegions: exports_Effect.succeed([]),
    optimizeDirtyRegions: exports_Effect.void,
    getStats: exports_Effect.succeed({
      framesRendered: 0,
      averageFrameTime: 0,
      lastFrameTime: 0,
      dirtyRegionCount: 0,
      bufferSwitches: 0
    }),
    resetStats: exports_Effect.void,
    setProfilingEnabled: () => exports_Effect.void,
    renderAt: () => exports_Effect.void,
    renderBatch: () => exports_Effect.void,
    setClipRegion: () => exports_Effect.void,
    saveState: exports_Effect.void,
    restoreState: exports_Effect.void,
    measureText: () => exports_Effect.succeed({ width: 0, height: 0, lineCount: 0 }),
    wrapText: () => exports_Effect.succeed([]),
    truncateText: () => exports_Effect.succeed(""),
    createLayer: () => exports_Effect.void,
    removeLayer: () => exports_Effect.void,
    renderToLayer: () => exports_Effect.void,
    setLayerVisible: () => exports_Effect.void,
    compositeLayers: exports_Effect.void
  }), exports_Layer.succeed(StorageService, {
    saveState: () => exports_Effect.void,
    loadState: () => exports_Effect.succeed(null),
    clearState: () => exports_Effect.void,
    hasState: () => exports_Effect.succeed(false),
    listStateKeys: exports_Effect.succeed([]),
    loadConfig: () => exports_Effect.fail(new Error("Not implemented in test")),
    saveConfig: () => exports_Effect.void,
    getConfigPath: () => exports_Effect.succeed("/tmp/test"),
    watchConfig: () => exports_Effect.fail(new Error("Not implemented in test")),
    setCache: () => exports_Effect.void,
    getCache: () => exports_Effect.succeed(null),
    clearCache: () => exports_Effect.void,
    clearExpiredCache: exports_Effect.void,
    getCacheStats: exports_Effect.succeed({ totalEntries: 0, expiredEntries: 0, totalSize: 0 }),
    readTextFile: () => exports_Effect.fail(new Error("Not implemented in test")),
    writeTextFile: () => exports_Effect.void,
    readJsonFile: () => exports_Effect.fail(new Error("Not implemented in test")),
    writeJsonFile: () => exports_Effect.void,
    fileExists: () => exports_Effect.succeed(false),
    createDirectory: () => exports_Effect.void,
    getFileStats: () => exports_Effect.fail(new Error("Not implemented in test")),
    createBackup: () => exports_Effect.succeed("/tmp/backup"),
    restoreBackup: () => exports_Effect.void,
    listBackups: () => exports_Effect.succeed([]),
    cleanupBackups: () => exports_Effect.void,
    beginTransaction: exports_Effect.succeed("test-transaction"),
    addToTransaction: () => exports_Effect.void,
    commitTransaction: () => exports_Effect.void,
    rollbackTransaction: () => exports_Effect.void
  }), exports_Layer.succeed(HitTestService, {
    registerComponent: () => exports_Effect.void,
    unregisterComponent: () => exports_Effect.void,
    clearComponents: exports_Effect.void,
    hitTest: () => exports_Effect.succeed(null),
    hitTestAll: () => exports_Effect.succeed([]),
    getAllBounds: exports_Effect.succeed([])
  }), exports_Layer.succeed(MouseRouterService, {
    registerComponent: () => exports_Effect.void,
    unregisterComponent: () => exports_Effect.void,
    updateComponentBounds: () => exports_Effect.void,
    routeMouseEvent: () => exports_Effect.succeed(null),
    clearAll: exports_Effect.void
  }));
});

// ../../src/core/interactive.ts
var InteractiveContext, InteractiveFiberRef, defaultConfig, InteractiveContextLive, isInteractive, runInteractive = (effect4, config2) => exports_Effect.gen(function* () {
  const ctx = yield* InteractiveContext;
  return yield* ctx.withInteractive(effect4, config2);
}), maybeInteractive = (effect4, shouldBeInteractive) => exports_Effect.gen(function* () {
  const interactive = typeof shouldBeInteractive === "boolean" ? shouldBeInteractive : yield* shouldBeInteractive;
  if (interactive) {
    return yield* runInteractive(effect4);
  } else {
    return yield* effect4;
  }
}), runViewInteractive = (view, config2) => exports_Effect.gen(function* () {
  const ctx = yield* InteractiveContext;
  yield* ctx.enter(config2);
  const component = {
    init: exports_Effect.succeed([{}, []]),
    update: () => exports_Effect.succeed([{}, []]),
    view: typeof view === "function" ? view : () => view,
    subscription: () => exports_Effect.succeed([])
  };
  yield* runApp(component).pipe(exports_Effect.provide(LiveServices), exports_Effect.catchAll(() => exports_Effect.void));
}), exitInteractive = (code = 0) => exports_Effect.gen(function* () {
  const ctx = yield* InteractiveContext;
  yield* ctx.exit(code);
}), Interactive;
var init_interactive = __esm(() => {
  init_esm2();
  init_runtime2();
  init_impl();
  InteractiveContext = class InteractiveContext extends exports_Context.Tag("InteractiveContext")() {
  };
  InteractiveFiberRef = exports_FiberRef.unsafeMake(false);
  defaultConfig = {
    enabled: false,
    exitOn: {
      error: true
    }
  };
  InteractiveContextLive = exports_Layer.effect(InteractiveContext, exports_Effect.gen(function* () {
    const config2 = yield* exports_Ref.make(defaultConfig);
    const isActive2 = yield* exports_Ref.make(false);
    return {
      config: config2,
      isActive: isActive2,
      enter: (overrides) => exports_Effect.gen(function* () {
        const currentConfig = yield* exports_Ref.get(config2);
        const newConfig = { ...currentConfig, ...overrides, enabled: true };
        yield* exports_Ref.set(config2, newConfig);
        yield* exports_Ref.set(isActive2, true);
        yield* exports_FiberRef.set(InteractiveFiberRef, true);
        if (newConfig.timeout) {
          yield* exports_Effect.fork(exports_Effect.sleep(newConfig.timeout).pipe(exports_Effect.zipRight(exports_Ref.set(isActive2, false)), exports_Effect.zipRight(exports_Effect.log("Interactive mode timed out"))));
        }
      }),
      exit: (code = 0) => exports_Effect.gen(function* () {
        yield* exports_Ref.set(isActive2, false);
        yield* exports_FiberRef.set(InteractiveFiberRef, false);
        const cfg = yield* exports_Ref.get(config2);
        if (cfg.onExit) {
          yield* exports_Effect.sync(() => cfg.onExit(code));
        }
        if (typeof process !== "undefined" && process.exit) {
          yield* exports_Effect.sync(() => process.exit(code));
        }
      }),
      withInteractive: (effect4, overrides) => exports_Effect.gen(function* () {
        const wasActive = yield* exports_Ref.get(isActive2);
        const oldConfig = yield* exports_Ref.get(config2);
        try {
          yield* exports_Effect.gen(function* () {
            const currentConfig = yield* exports_Ref.get(config2);
            const newConfig = { ...currentConfig, ...overrides, enabled: true };
            yield* exports_Ref.set(config2, newConfig);
            yield* exports_Ref.set(isActive2, true);
            yield* exports_FiberRef.set(InteractiveFiberRef, true);
          });
          return yield* effect4;
        } finally {
          yield* exports_Ref.set(isActive2, wasActive);
          yield* exports_Ref.set(config2, oldConfig);
          yield* exports_FiberRef.set(InteractiveFiberRef, wasActive);
        }
      })
    };
  }));
  isInteractive = exports_Effect.gen(function* () {
    return yield* exports_FiberRef.get(InteractiveFiberRef);
  });
  Interactive = {
    enter: (config2) => exports_Effect.gen(function* () {
      const ctx = yield* InteractiveContext;
      yield* ctx.enter(config2);
    }),
    exit: exitInteractive,
    isActive: isInteractive,
    run: runInteractive,
    runView: runViewInteractive,
    maybe: maybeInteractive,
    scope: (effect4, config2) => runInteractive(effect4, config2)
  };
});

// ../../src/core/event-bus.ts
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
}

class EventBus {
  handlers = new Map;
  constructor() {}
  publish(channel, event) {
    return exports_Effect.gen(function* () {
      const channelHandlers = this.handlers.get(channel);
      if (channelHandlers) {
        yield* exports_Effect.all(Array.from(channelHandlers).map((handler) => handler(event).pipe(exports_Effect.catchAll(() => exports_Effect.void))));
      }
    }.bind(this));
  }
  subscribe(channel, handler) {
    return exports_Effect.sync(() => {
      let channelHandlers = this.handlers.get(channel);
      if (!channelHandlers) {
        channelHandlers = new Set;
        this.handlers.set(channel, channelHandlers);
      }
      channelHandlers.add(handler);
      return () => exports_Effect.sync(() => {
        const handlers = this.handlers.get(channel);
        if (handlers) {
          handlers.delete(handler);
          if (handlers.size === 0) {
            this.handlers.delete(channel);
          }
        }
      });
    });
  }
  emit(channel, event) {
    return this.publish(channel, event);
  }
  subscribePattern(pattern2, handler) {
    return exports_Effect.gen(function* () {
      const unsubscribers = [];
      for (const channel of this.handlers.keys()) {
        if (pattern2.test(channel)) {
          const unsub = yield* this.subscribe(channel, handler);
          unsubscribers.push(unsub);
        }
      }
      return () => exports_Effect.all(unsubscribers.map((fn2) => fn2())).pipe(exports_Effect.asVoid);
    }.bind(this));
  }
  shutdown() {
    return exports_Effect.sync(() => {
      this.handlers.clear();
    });
  }
  getStats() {
    return exports_Effect.sync(() => {
      const channelStats = new Map;
      let totalSubscriptions = 0;
      for (const [channel, handlers] of this.handlers) {
        channelStats.set(channel, handlers.size);
        totalSubscriptions += handlers.size;
      }
      return {
        totalChannels: this.handlers.size,
        totalSubscriptions,
        channelQueueSizes: channelStats
      };
    });
  }
}
function getGlobalEventBus() {
  if (!globalEventBus) {
    globalEventBus = new EventBus;
  }
  return globalEventBus;
}
var globalEventBus = null;
var init_event_bus = __esm(() => {
  init_esm2();
});

// ../../src/core/module-base.ts
class ModuleError {
  module;
  message;
  cause;
  _tag = "ModuleError";
  constructor(module, message, cause3) {
    this.module = module;
    this.message = message;
    this.cause = cause3;
  }
}

class ModuleBase {
  eventBus;
  name;
  state = "uninitialized";
  subscriptions = [];
  constructor(eventBus, name) {
    this.eventBus = eventBus;
    this.name = name;
  }
  shutdown() {
    return exports_Effect.gen(function* () {
      this.state = "shutting-down";
      yield* exports_Effect.all(this.subscriptions.map((unsub) => unsub()));
      this.subscriptions = [];
      yield* this.onShutdown();
      this.state = "shutdown";
    }.bind(this));
  }
  onShutdown() {
    return exports_Effect.void;
  }
  emitEvent(channel, event) {
    const fullEvent = {
      ...event,
      timestamp: new Date,
      source: this.name
    };
    return this.eventBus.publish(channel, fullEvent);
  }
  subscribe(channel, handler) {
    return exports_Effect.gen(function* () {
      const unsubscribe = yield* this.eventBus.subscribe(channel, handler);
      this.subscriptions.push(unsubscribe);
    }.bind(this));
  }
  subscribeMany(subscriptions) {
    return exports_Effect.all(subscriptions.map(({ channel, handler }) => this.subscribe(channel, handler))).pipe(exports_Effect.asVoid);
  }
  getState() {
    return this.state;
  }
  isReady() {
    return this.state === "ready";
  }
  waitForReady(maxAttempts = 50) {
    return exports_Effect.gen(function* () {
      let attempts = 0;
      while (this.state !== "ready" && attempts < maxAttempts) {
        if (this.state === "shutdown" || this.state === "shutting-down") {
          yield* exports_Effect.fail(new ModuleError(this.name, "Module is shutting down or already shutdown"));
        }
        yield* exports_Effect.sleep(100);
        attempts++;
      }
      if (this.state !== "ready") {
        yield* exports_Effect.fail(new ModuleError(this.name, `Module did not become ready within ${maxAttempts * 100}ms`));
      }
    }.bind(this));
  }
  setReady() {
    return exports_Effect.sync(() => {
      this.state = "ready";
    });
  }
  generateId() {
    return `${this.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
var init_module_base = __esm(() => {
  init_esm2();
});

// ../../src/core/module-registry.ts
class ModuleRegistry {
  eventBus;
  modules = new Map;
  constructor(eventBus = getGlobalEventBus()) {
    this.eventBus = eventBus;
  }
  register(module) {
    return exports_Effect.gen(function* () {
      if (this.modules.has(module.name)) {
        yield* exports_Effect.fail(new ModuleError(module.name, `Module '${module.name}' is already registered`));
      }
      this.modules.set(module.name, {
        module,
        initialized: false
      });
    }.bind(this));
  }
  registerMany(modules) {
    return exports_Effect.all(modules.map((module) => this.register(module))).pipe(exports_Effect.asVoid);
  }
  initialize() {
    return exports_Effect.gen(function* () {
      const entries4 = Array.from(this.modules.entries());
      for (const [name, entry] of entries4) {
        if (!entry.initialized) {
          yield* entry.module.initialize().pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(new ModuleError(name, `Failed to initialize module: ${error2.message}`, error2))));
          entry.initialized = true;
        }
      }
      yield* exports_Effect.all(entries4.map(([_, entry]) => entry.module.waitForReady()));
    }.bind(this));
  }
  getModule(name) {
    const entry = this.modules.get(name);
    return entry?.module;
  }
  requireModule(name) {
    return exports_Effect.gen(function* () {
      const module = this.getModule(name);
      if (!module) {
        yield* exports_Effect.fail(new ModuleError(name, `Required module '${name}' not found`));
      }
      return module;
    }.bind(this));
  }
  hasModule(name) {
    return this.modules.has(name);
  }
  getAllModules() {
    return Array.from(this.modules.values()).map((entry) => entry.module);
  }
  getModuleNames() {
    return Array.from(this.modules.keys());
  }
  shutdown() {
    return exports_Effect.gen(function* () {
      const modules = Array.from(this.modules.values()).reverse();
      yield* exports_Effect.all(modules.map((entry) => entry.module.shutdown()));
      this.modules.clear();
    }.bind(this));
  }
  getStats() {
    const modules = Array.from(this.modules.entries());
    return {
      totalModules: modules.length,
      initializedModules: modules.filter(([_, entry]) => entry.initialized).length,
      moduleStates: Object.fromEntries(modules.map(([name, entry]) => [name, entry.module.getState()]))
    };
  }
  waitForAllReady() {
    return exports_Effect.all(Array.from(this.modules.values()).map((entry) => entry.module.waitForReady())).pipe(exports_Effect.asVoid);
  }
}
function getGlobalRegistry() {
  if (!globalRegistry) {
    globalRegistry = new ModuleRegistry;
  }
  return globalRegistry;
}
var globalRegistry = null;
var init_module_registry = __esm(() => {
  init_esm2();
  init_module_base();
  init_event_bus();
});

// ../../src/reactivity/events.ts
var ReactivityEventChannels;
var init_events = __esm(() => {
  ReactivityEventChannels = {
    RUNE: "reactivity-rune",
    LIFECYCLE: "reactivity-lifecycle",
    STATE: "reactivity-state",
    EFFECT: "reactivity-effect",
    DERIVED: "reactivity-derived"
  };
});

// ../../src/jsx/events.ts
var JSXEventChannels;
var init_events2 = __esm(() => {
  JSXEventChannels = {
    RENDER: "jsx-render",
    LIFECYCLE: "jsx-lifecycle",
    SCOPE: "jsx-scope",
    PLUGIN: "jsx-plugin",
    COMMAND: "jsx-command"
  };
});

// ../../src/reactivity/module.ts
class RuneHandleImpl {
  id;
  name;
  emitter;
  _value;
  subscribers = new Set;
  constructor(id3, name, initialValue, emitter) {
    this.id = id3;
    this.name = name;
    this.emitter = emitter;
    this._value = initialValue;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    const previousValue = this._value;
    this._value = newValue;
    this.subscribers.forEach((callback) => callback(newValue));
    exports_Effect.runSync(this.emitter({
      type: "rune-updated",
      timestamp: new Date,
      source: "reactivity",
      runeId: this.id,
      runeName: this.name,
      value: newValue,
      previousValue
    }));
  }
  subscribe(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  destroy() {
    this.subscribers.clear();
    exports_Effect.runSync(this.emitter({
      type: "rune-destroyed",
      timestamp: new Date,
      source: "reactivity",
      runeId: this.id,
      runeName: this.name
    }));
  }
}
var ReactivityModule;
var init_module = __esm(() => {
  init_esm2();
  init_module_base();
  init_events();
  init_events2();
  init_esm2();
  ReactivityModule = class ReactivityModule extends ModuleBase {
    runes = new Map;
    effects = new Map;
    constructor(eventBus) {
      super(eventBus, "reactivity");
    }
    initialize() {
      return exports_Effect.gen(function* () {
        this.state = "initializing";
        yield* this.subscribeToEvents();
        yield* this.setReady();
      }.bind(this));
    }
    subscribeToEvents() {
      return this.subscribeMany([
        {
          channel: JSXEventChannels.LIFECYCLE,
          handler: (event) => this.handleJSXLifecycle(event)
        },
        {
          channel: "cli-command",
          handler: (event) => this.handleCLICommand(event)
        }
      ]);
    }
    handleJSXLifecycle(event) {
      return exports_Effect.gen(function* () {
        if (event.type === "jsx-mount" && "componentId" in event) {
          yield* this.initializeComponentState(event.componentId);
        } else if (event.type === "jsx-unmount" && "componentId" in event) {
          yield* this.cleanupComponentState(event.componentId);
        }
      }.bind(this));
    }
    handleCLICommand(event) {
      return exports_Effect.gen(function* () {});
    }
    initializeComponentState(componentId) {
      return this.emitEvent(ReactivityEventChannels.LIFECYCLE, {
        type: "lifecycle-mount",
        componentId
      });
    }
    cleanupComponentState(componentId) {
      return exports_Effect.gen(function* () {
        const componentRunes = Array.from(this.runes.entries()).filter(([id3]) => id3.startsWith(componentId));
        for (const [id3, rune] of componentRunes) {
          rune.destroy();
          this.runes.delete(id3);
        }
        yield* this.emitEvent(ReactivityEventChannels.LIFECYCLE, {
          type: "lifecycle-unmount",
          componentId
        });
      }.bind(this));
    }
    createRune(name, initialValue) {
      return exports_Effect.gen(function* () {
        const runeId = this.generateId();
        const rune = new RuneHandleImpl(runeId, name, initialValue, (event) => this.eventBus.publish(ReactivityEventChannels.RUNE, event));
        this.runes.set(runeId, rune);
        yield* this.emitRuneCreated(runeId, name, initialValue);
        return rune;
      }.bind(this));
    }
    getRune(runeId) {
      return this.runes.get(runeId);
    }
    createEffect(effectId, effect4, dependencies) {
      return exports_Effect.gen(function* () {
        const existing = this.effects.get(effectId);
        if (existing) {
          yield* exports_Fiber.interrupt(existing);
        }
        yield* this.emitEffectScheduled(effectId, dependencies);
        const fiber = yield* exports_Effect.fork(effect4().pipe(exports_Effect.tap(() => this.emitEffectExecuted(effectId, dependencies)), exports_Effect.catchAll((error2) => this.emitEffectError(effectId, error2, dependencies))));
        this.effects.set(effectId, fiber);
      }.bind(this));
    }
    cleanupEffect(effectId) {
      return exports_Effect.gen(function* () {
        const fiber = this.effects.get(effectId);
        if (fiber) {
          yield* exports_Fiber.interrupt(fiber);
          this.effects.delete(effectId);
          yield* this.emitEffectCleanup(effectId);
        }
      }.bind(this));
    }
    emitStateChange(stateId, value6, source) {
      return this.emitEvent(ReactivityEventChannels.STATE, {
        type: "state-change",
        stateId,
        value: value6,
        source
      });
    }
    emitRuneCreated(runeId, runeName, value6) {
      return this.emitEvent(ReactivityEventChannels.RUNE, {
        type: "rune-created",
        runeId,
        runeName,
        value: value6
      });
    }
    emitEffectScheduled(effectId, dependencies) {
      return this.emitEvent(ReactivityEventChannels.EFFECT, {
        type: "effect-scheduled",
        effectId,
        dependencies
      });
    }
    emitEffectExecuted(effectId, dependencies) {
      return this.emitEvent(ReactivityEventChannels.EFFECT, {
        type: "effect-executed",
        effectId,
        dependencies
      });
    }
    emitEffectError(effectId, error2, dependencies) {
      return this.emitEvent(ReactivityEventChannels.EFFECT, {
        type: "effect-executed",
        effectId,
        dependencies,
        error: error2
      });
    }
    emitEffectCleanup(effectId) {
      return this.emitEvent(ReactivityEventChannels.EFFECT, {
        type: "effect-cleanup",
        effectId
      });
    }
    onShutdown() {
      return exports_Effect.gen(function* () {
        for (const rune of this.runes.values()) {
          rune.destroy();
        }
        this.runes.clear();
        yield* exports_Effect.all(Array.from(this.effects.values()).map((fiber) => exports_Fiber.interrupt(fiber)));
        this.effects.clear();
      }.bind(this));
    }
  };
});

// ../../src/reactivity/jsx-lifecycle.ts
function getCurrentComponent() {
  return componentStack[componentStack.length - 1];
}
function createComponentId() {
  return `component-${++componentIdCounter}`;
}
function initComponent() {
  const parent = getCurrentComponent();
  const component = {
    id: createComponentId(),
    mounted: false,
    destroyed: false,
    updateQueue: exports_Queue.unbounded(),
    effects: {
      pre: [],
      post: []
    },
    cleanups: [],
    mountCallbacks: [],
    destroyCallbacks: [],
    parent,
    children: new Set,
    renderCount: 0
  };
  if (parent) {
    parent.children.add(component);
  }
  components.set(component.id, component);
  componentStack.push(component);
  return component;
}
function cleanupComponent(component) {
  const index = componentStack.indexOf(component);
  if (index !== -1) {
    componentStack.splice(index, 1);
  }
}
function $effect2(fn2) {
  const component = getCurrentComponent();
  if (!component) {
    throw new Error("$effect called outside component context");
  }
  component.effects.post.push(fn2);
}
function onMount(fn2) {
  const component = getCurrentComponent();
  if (!component) {
    throw new Error("onMount called outside component context");
  }
  component.mountCallbacks.push(fn2);
}
function onDestroy(fn2) {
  const component = getCurrentComponent();
  if (!component) {
    throw new Error("onDestroy called outside component context");
  }
  component.destroyCallbacks.push(fn2);
}
function beforeUpdate(fn2) {
  const component = getCurrentComponent();
  if (!component) {
    throw new Error("beforeUpdate called outside component context");
  }
  $effect2.pre(() => {
    if (component.renderCount > 0) {
      fn2();
    }
  });
}
function afterUpdate(fn2) {
  const component = getCurrentComponent();
  if (!component) {
    throw new Error("afterUpdate called outside component context");
  }
  $effect2(() => {
    if (component.renderCount > 0) {
      fn2();
    }
  });
}
async function tick3() {
  if (!updatePromise) {
    updatePromise = exports_Deferred.make();
    queueMicrotask(() => {
      flushUpdates();
    });
  }
  return exports_Deferred.await(updatePromise);
}
function runEffects(component, type2) {
  const effects = component.effects[type2];
  const newCleanups = [];
  effects.forEach((effect4) => {
    const cleanup2 = effect4();
    if (typeof cleanup2 === "function") {
      newCleanups.push(cleanup2);
    }
  });
  component.cleanups.push(...newCleanups);
}
function runMountCallbacks(component) {
  if (component.mounted)
    return;
  component.mounted = true;
  component.mountCallbacks.forEach((callback) => {
    const cleanup2 = callback();
    if (typeof cleanup2 === "function") {
      component.destroyCallbacks.push(cleanup2);
    }
  });
}
function destroyComponent(component) {
  if (component.destroyed)
    return;
  component.destroyed = true;
  component.children.forEach((child) => destroyComponent(child));
  component.cleanups.forEach((cleanup2) => cleanup2());
  component.destroyCallbacks.forEach((callback) => callback());
  if (component.parent) {
    component.parent.children.delete(component);
  }
  components.delete(component.id);
}
function flushUpdates() {
  if (flushingUpdates)
    return;
  flushingUpdates = true;
  try {
    components.forEach((component) => {
      if (!component.destroyed) {
        runEffects(component, "pre");
      }
    });
    components.forEach((component) => {
      if (!component.destroyed) {
        runEffects(component, "post");
        component.renderCount++;
        if (component.renderCount === 1) {
          runMountCallbacks(component);
        }
      }
    });
    if (updatePromise) {
      exports_Deferred.succeed(updatePromise, undefined);
      updatePromise = null;
    }
  } finally {
    flushingUpdates = false;
  }
}
function untrack(fn2) {
  return fn2();
}
function withLifecycle(component) {
  return (props) => {
    const componentState = initComponent();
    try {
      const view = component(props);
      runEffects(componentState, "pre");
      queueMicrotask(() => {
        runEffects(componentState, "post");
        componentState.renderCount++;
        if (componentState.renderCount === 1) {
          runMountCallbacks(componentState);
        }
      });
      return view;
    } finally {
      cleanupComponent(componentState);
    }
  };
}
var components, componentStack, updatePromise = null, flushingUpdates = false, componentIdCounter = 0;
var init_jsx_lifecycle = __esm(() => {
  init_esm2();
  components = new Map;
  componentStack = [];
  $effect2.pre = function(fn2) {
    const component = getCurrentComponent();
    if (!component) {
      throw new Error("$effect.pre called outside component context");
    }
    component.effects.pre.push(fn2);
  };
  $effect2.root = function(fn2) {
    const rootComponent = initComponent();
    try {
      fn2();
      runEffects(rootComponent, "pre");
      runEffects(rootComponent, "post");
    } finally {
      cleanupComponent(rootComponent);
    }
    return () => {
      destroyComponent(rootComponent);
    };
  };
});

// ../../src/reactivity/runes.ts
function getReactivityModule() {
  if (!reactivityModule) {
    try {
      const registry = getGlobalRegistry();
      reactivityModule = registry.getModule("reactivity");
      if (!reactivityModule) {
        const eventBus = getGlobalEventBus();
        reactivityModule = new ReactivityModule(eventBus);
        exports_Effect.runSync(registry.register(reactivityModule));
        exports_Effect.runSync(reactivityModule.initialize());
      }
    } catch (error2) {}
  }
  return reactivityModule;
}
function $state(initial) {
  let value6 = initial;
  const listeners = new Set;
  const runeId = `state_${Date.now()}_${Math.random()}`;
  const module = getReactivityModule();
  if (module) {
    exports_Effect.runSync(module.emitStateChange(runeId, initial, "user"));
  }
  const rune = () => {
    return value6;
  };
  rune.$type = "state";
  rune.$set = (newValue) => {
    if (value6 !== newValue) {
      const previousValue = value6;
      value6 = newValue;
      if (module) {
        exports_Effect.runSync(module.emitStateChange(runeId, newValue, "user"));
      }
      listeners.forEach((listener) => listener(value6));
    }
  };
  rune.$update = (fn2) => {
    rune.$set(fn2(value6));
  };
  rune.$subscribe = (listener) => {
    listeners.add(listener);
    listener(value6);
    return () => {
      listeners.delete(listener);
    };
  };
  return rune;
}
function $bindable(initial, options = {}) {
  let value6 = initial;
  const listeners = new Set;
  const runeId = `bindable_${Date.now()}_${Math.random()}`;
  const module = getReactivityModule();
  if (module) {
    exports_Effect.runSync(module.emitStateChange(runeId, initial, "user"));
  }
  const rune = () => {
    return value6;
  };
  rune.$type = "bindable";
  rune.$bindable = true;
  rune.$validate = options.validate;
  rune.$transform = options.transform;
  rune.$set = (newValue) => {
    let finalValue = newValue;
    if (options.transform) {
      finalValue = options.transform(finalValue);
    }
    if (options.validate) {
      const result = options.validate(finalValue);
      if (result === false) {
        return;
      }
      if (typeof result === "string") {
        console.error(`Validation error: ${result}`);
        return;
      }
    }
    if (value6 !== finalValue) {
      const previousValue = value6;
      value6 = finalValue;
      if (module) {
        exports_Effect.runSync(module.emitStateChange(runeId, finalValue, "user"));
      }
      listeners.forEach((listener) => listener(value6));
    }
  };
  rune.$update = (fn2) => {
    rune.$set(fn2(value6));
  };
  rune.$subscribe = (listener) => {
    listeners.add(listener);
    listener(value6);
    return () => {
      listeners.delete(listener);
    };
  };
  return rune;
}
function $derived(fn2) {
  const rune = () => {
    return fn2();
  };
  rune.$type = "derived";
  return rune;
}
function isStateRune(value6) {
  return !!(value6 && typeof value6 === "function" && value6.$type === "state");
}
function isBindableRune(value6) {
  return !!(value6 && typeof value6 === "function" && value6.$type === "bindable" && value6.$bindable === true);
}
function isDerivedRune(value6) {
  return !!(value6 && typeof value6 === "function" && value6.$type === "derived");
}
function isRune(value6) {
  return !!(value6 && typeof value6 === "function" && typeof value6.$type === "string");
}
function getValue(rune) {
  return rune();
}
function toBindable(state, options = {}) {
  const bindable = $bindable(state(), options);
  const runeId = `toBindable_${Date.now()}_${Math.random()}`;
  const module = getReactivityModule();
  const originalSet = bindable.$set;
  bindable.$set = (value6) => {
    originalSet(value6);
    state.$set(value6);
    if (module) {
      exports_Effect.runSync(module.emitStateChange(runeId, value6, "sync"));
    }
  };
  state.$subscribe((value6) => {
    originalSet(value6);
    if (module) {
      exports_Effect.runSync(module.emitStateChange(runeId, value6, "sync"));
    }
  });
  return bindable;
}
var reactivityModule = null;
var init_runes = __esm(() => {
  init_esm2();
  init_event_bus();
  init_module_registry();
  init_module();
  init_jsx_lifecycle();
});

// ../../src/config/types.ts
var Config;
var init_types3 = __esm(() => {
  init_esm2();
  Config = exports_Context.GenericTag("tuix/Config");
});

// ../../src/config/loaders.ts
import * as path2 from "path";

class JSONLoader {
  canLoad(filePath) {
    const ext = path2.extname(filePath).toLowerCase();
    return ext === ".json" || filePath.endsWith("rc");
  }
  async load(filePath) {
    try {
      const file = Bun.file(filePath);
      const text2 = await file.text();
      if (!text2.trim()) {
        return {};
      }
      const cleaned = text2.split(`
`).map((line) => {
        const commentIndex = line.indexOf("//");
        if (commentIndex >= 0) {
          const beforeComment = line.slice(0, commentIndex);
          const quoteCount = (beforeComment.match(/"/g) || []).length;
          if (quoteCount % 2 === 0) {
            return beforeComment;
          }
        }
        return line;
      }).join(`
`).replace(/\/\*[\s\S]*?\*\//g, "");
      return JSON.parse(cleaned);
    } catch (error2) {
      throw new Error(`Failed to load JSON config from ${filePath}: ${error2}`);
    }
  }
  async save(filePath, config2) {
    const json = JSON.stringify(config2, null, 2);
    await Bun.write(filePath, json);
  }
}

class TypeScriptLoader {
  canLoad(filePath) {
    const ext = path2.extname(filePath).toLowerCase();
    return ext === ".ts" || ext === ".js" || ext === ".mjs";
  }
  async load(filePath) {
    try {
      delete __require.cache[filePath];
      const module = await import(filePath);
      const config2 = module.default || module.config || module;
      if (typeof config2 === "function") {
        const result = await config2();
        return this.normalizeConfig(result);
      }
      return this.normalizeConfig(config2);
    } catch (error2) {
      throw new Error(`Failed to load TypeScript config from ${filePath}: ${error2}`);
    }
  }
  async save(filePath, config2) {
    const content = `/**
 * Auto-generated configuration file
 * Generated at: ${new Date().toISOString()}
 */

export default ${JSON.stringify(config2, null, 2)}
`;
    await Bun.write(filePath, content);
  }
  normalizeConfig(config2) {
    if (!config2 || typeof config2 !== "object") {
      throw new Error("Config must be an object");
    }
    const normalized = {};
    for (const [key, value6] of Object.entries(config2)) {
      if (value6 === undefined || typeof value6 === "function") {
        continue;
      }
      if (value6 instanceof Date) {
        normalized[key] = value6.toISOString();
      } else if (value6 && typeof value6 === "object") {
        normalized[key] = this.normalizeConfig(value6);
      } else {
        normalized[key] = value6;
      }
    }
    return normalized;
  }
}

class YAMLLoader {
  canLoad(filePath) {
    const ext = path2.extname(filePath).toLowerCase();
    return ext === ".yaml" || ext === ".yml";
  }
  async load(filePath) {
    throw new Error("YAML support not implemented. Install a YAML parser to enable.");
  }
  async save(filePath, config2) {
    throw new Error("YAML support not implemented. Install a YAML parser to enable.");
  }
}

class TOMLLoader {
  canLoad(filePath) {
    const ext = path2.extname(filePath).toLowerCase();
    return ext === ".toml";
  }
  async load(filePath) {
    throw new Error("TOML support not implemented. Install a TOML parser to enable.");
  }
  async save(filePath, config2) {
    throw new Error("TOML support not implemented. Install a TOML parser to enable.");
  }
}

class EnvLoader {
  canLoad(filePath) {
    const basename3 = path2.basename(filePath);
    return basename3 === ".env" || basename3.startsWith(".env.");
  }
  async load(filePath) {
    try {
      const file = Bun.file(filePath);
      const text2 = await file.text();
      const config2 = {};
      const lines = text2.split(`
`);
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed || trimmed.startsWith("#")) {
          continue;
        }
        const equalIndex = trimmed.indexOf("=");
        if (equalIndex < 0) {
          continue;
        }
        const key = trimmed.slice(0, equalIndex).trim();
        let value6 = trimmed.slice(equalIndex + 1).trim();
        if (value6.startsWith('"') && value6.endsWith('"') || value6.startsWith("'") && value6.endsWith("'")) {
          value6 = value6.slice(1, -1);
        }
        const parts2 = key.split("_");
        let current2 = config2;
        for (let i = 0;i < parts2.length - 1; i++) {
          const part = parts2[i].toLowerCase();
          if (!current2[part]) {
            current2[part] = {};
          }
          current2 = current2[part];
        }
        const lastPart = parts2[parts2.length - 1].toLowerCase();
        if (value6 === "true") {
          current2[lastPart] = true;
        } else if (value6 === "false") {
          current2[lastPart] = false;
        } else if (value6 && !isNaN(Number(value6))) {
          current2[lastPart] = Number(value6);
        } else {
          current2[lastPart] = value6;
        }
      }
      return config2;
    } catch (error2) {
      throw new Error(`Failed to load env config from ${filePath}: ${error2}`);
    }
  }
  async save(filePath, config2) {
    const lines = [];
    const flatten16 = (obj, prefix = "") => {
      for (const [key, value6] of Object.entries(obj)) {
        const envKey = prefix ? `${prefix}_${key}` : key;
        if (value6 && typeof value6 === "object" && !Array.isArray(value6)) {
          flatten16(value6, envKey.toUpperCase());
        } else {
          const envValue = String(value6);
          lines.push(`${envKey.toUpperCase()}=${envValue}`);
        }
      }
    };
    flatten16(config2);
    const content = lines.join(`
`) + `
`;
    await Bun.write(filePath, content);
  }
}
var init_loaders = () => {};

// ../../src/config/utils.ts
import * as path3 from "path";
import { watch } from "fs";
function getValueByPath(obj, path4) {
  const parts2 = path4.split(".");
  let current2 = obj;
  for (const part of parts2) {
    if (current2 && typeof current2 === "object" && part in current2) {
      current2 = current2[part];
    } else {
      return;
    }
  }
  return current2;
}
function setValueByPath(obj, path4, value6) {
  const parts2 = path4.split(".");
  let current2 = obj;
  for (let i = 0;i < parts2.length - 1; i++) {
    const part = parts2[i];
    if (!(part in current2) || typeof current2[part] !== "object") {
      current2[part] = {};
    }
    current2 = current2[part];
  }
  current2[parts2[parts2.length - 1]] = value6;
}
function deleteValueByPath(obj, path4) {
  const parts2 = path4.split(".");
  let current2 = obj;
  for (let i = 0;i < parts2.length - 1; i++) {
    const part = parts2[i];
    if (current2 && typeof current2 === "object" && part in current2) {
      current2 = current2[part];
    } else {
      return false;
    }
  }
  const lastPart = parts2[parts2.length - 1];
  if (current2 && typeof current2 === "object" && lastPart in current2) {
    delete current2[lastPart];
    return true;
  }
  return false;
}
function mergeDeep(target, source) {
  const result = { ...target };
  for (const [key, value6] of Object.entries(source)) {
    if (value6 === undefined) {
      continue;
    }
    if (value6 && typeof value6 === "object" && !Array.isArray(value6) && result[key] && typeof result[key] === "object" && !Array.isArray(result[key])) {
      result[key] = mergeDeep(result[key], value6);
    } else {
      result[key] = value6;
    }
  }
  return result;
}
async function watchFile(filePath, callback) {
  try {
    if (typeof Bun !== "undefined" && Bun.file) {
      let lastModified = await Bun.file(filePath).lastModified || 0;
      const interval = setInterval(async () => {
        try {
          const currentModified = await Bun.file(filePath).lastModified || 0;
          if (currentModified > lastModified) {
            lastModified = currentModified;
            callback();
          }
        } catch {}
      }, 1000);
      return () => clearInterval(interval);
    }
    const watcher = watch(filePath, (eventType) => {
      if (eventType === "change") {
        callback();
      }
    });
    return () => watcher.close();
  } catch (error2) {
    return () => {};
  }
}
function expandEnvVars(str) {
  return str.replace(/\$\{([^}]+)\}/g, (match26, name) => {
    return process.env[name] || match26;
  });
}
function parseValue(value6) {
  if (value6 === "true")
    return true;
  if (value6 === "false")
    return false;
  if (value6 === "null")
    return null;
  if (!isNaN(Number(value6)) && value6 !== "") {
    return Number(value6);
  }
  if (value6.startsWith("[") && value6.endsWith("]")) {
    try {
      return JSON.parse(value6);
    } catch {}
  }
  if (value6.startsWith("{") && value6.endsWith("}")) {
    try {
      return JSON.parse(value6);
    } catch {}
  }
  return value6;
}
function toEnvFormat(key, value6) {
  const envKey = key.toUpperCase().replace(/\./g, "_");
  if (value6 === null) {
    return `${envKey}=`;
  }
  if (typeof value6 === "boolean") {
    return `${envKey}=${value6}`;
  }
  if (typeof value6 === "number") {
    return `${envKey}=${value6}`;
  }
  if (Array.isArray(value6) || value6 && typeof value6 === "object") {
    return `${envKey}=${JSON.stringify(value6)}`;
  }
  const strValue = String(value6);
  if (strValue.includes(" ") || strValue.includes("=")) {
    return `${envKey}="${strValue.replace(/"/g, "\\\"")}"`;
  }
  return `${envKey}=${strValue}`;
}
async function findConfigFile(startDir, fileNames) {
  let currentDir = path3.resolve(startDir);
  const root = path3.parse(currentDir).root;
  while (currentDir !== root) {
    for (const fileName of fileNames) {
      const filePath = path3.join(currentDir, fileName);
      try {
        const file = Bun.file(filePath);
        if (await file.exists()) {
          return filePath;
        }
      } catch {}
    }
    currentDir = path3.dirname(currentDir);
  }
  return null;
}
function validateConfig(config2, schema) {
  const errors2 = [];
  const validate5 = (obj, schema2, path4 = "") => {
    for (const [key, validator] of Object.entries(schema2)) {
      const fullPath = path4 ? `${path4}.${key}` : key;
      const value6 = obj[key];
      if (typeof validator === "function") {
        try {
          if (!validator(value6)) {
            errors2.push(`Invalid value at ${fullPath}`);
          }
        } catch (error2) {
          errors2.push(`Validation error at ${fullPath}: ${error2}`);
        }
      } else if (validator && typeof validator === "object") {
        if (value6 && typeof value6 === "object") {
          validate5(value6, validator, fullPath);
        } else {
          errors2.push(`Expected object at ${fullPath}`);
        }
      }
    }
  };
  validate5(config2, schema);
  return {
    valid: errors2.length === 0,
    errors: errors2
  };
}
var init_utils = () => {};

// ../../src/config/config.ts
import * as path4 from "path";
import * as os from "os";

class TuixConfig {
  options;
  data = new Map;
  schema;
  watchers = new Set;
  fileWatchers = new Map;
  namespacePrefix = "";
  constructor(options = {}, namespacePrefix) {
    this.options = options;
    this.schema = options.schema;
    this.namespacePrefix = namespacePrefix || "";
    if (options.defaults) {
      this.merge(options.defaults, "default");
    }
  }
  get(key) {
    const fullKey = this.getFullKey(key);
    const entry = this.data.get(fullKey);
    return entry?.value;
  }
  getOrDefault(key, defaultValue) {
    return this.get(key) ?? defaultValue;
  }
  getWithSource(key) {
    const fullKey = this.getFullKey(key);
    return this.data.get(fullKey);
  }
  set(key, value6, source = "runtime") {
    const fullKey = this.getFullKey(key);
    const oldEntry = this.data.get(fullKey);
    const entry = {
      value: value6,
      source,
      timestamp: new Date,
      schema: this.getSchemaForKey(key)
    };
    if (entry.schema) {
      const result = entry.schema.safeParse(value6);
      if (!result.success) {
        throw new Error(`Validation failed for ${key}: ${result.error.message}`);
      }
    }
    this.data.set(fullKey, entry);
    this.notifyWatchers({
      key: fullKey,
      oldValue: oldEntry?.value,
      newValue: value6,
      source,
      timestamp: new Date
    });
  }
  delete(key) {
    const fullKey = this.getFullKey(key);
    const oldEntry = this.data.get(fullKey);
    if (oldEntry) {
      this.data.delete(fullKey);
      this.notifyWatchers({
        key: fullKey,
        oldValue: oldEntry.value,
        newValue: undefined,
        source: "runtime",
        timestamp: new Date
      });
    }
  }
  has(key) {
    const fullKey = this.getFullKey(key);
    return this.data.has(fullKey);
  }
  keys() {
    const keys9 = [];
    for (const key of this.data.keys()) {
      if (this.namespacePrefix && key.startsWith(this.namespacePrefix)) {
        keys9.push(key.slice(this.namespacePrefix.length + 1));
      } else if (!this.namespacePrefix) {
        keys9.push(key);
      }
    }
    return keys9;
  }
  toObject() {
    const obj = {};
    for (const [key, entry] of this.data.entries()) {
      if (this.namespacePrefix && key.startsWith(this.namespacePrefix)) {
        const relativeKey = key.slice(this.namespacePrefix.length + 1);
        setValueByPath(obj, relativeKey, entry.value);
      } else if (!this.namespacePrefix) {
        setValueByPath(obj, key, entry.value);
      }
    }
    return obj;
  }
  merge(config2, source = "runtime") {
    const flatConfig = this.flattenObject(config2);
    for (const [key, value6] of Object.entries(flatConfig)) {
      this.set(key, value6, source);
    }
  }
  validate() {
    if (!this.schema) {
      return { success: true };
    }
    const errors2 = [];
    for (const [key, entry] of this.data.entries()) {
      if (entry.schema) {
        const result = entry.schema.safeParse(entry.value);
        if (!result.success) {
          errors2.push(result.error);
        }
      }
    }
    return {
      success: errors2.length === 0,
      errors: errors2.length > 0 ? errors2 : undefined
    };
  }
  watch(callback) {
    const handler = (event) => {
      callback(event.key, event.newValue, event.source);
    };
    this.watchers.add(handler);
    return () => {
      this.watchers.delete(handler);
    };
  }
  async loadFile(filePath) {
    const loader = this.getLoaderForFile(filePath);
    if (!loader) {
      throw new Error(`No loader found for file: ${filePath}`);
    }
    const config2 = await loader.load(filePath);
    this.merge(config2, "project");
    if (this.options.watch) {
      const cleanup2 = await watchFile(filePath, async () => {
        const newConfig = await loader.load(filePath);
        this.merge(newConfig, "project");
      });
      this.fileWatchers.set(filePath, cleanup2);
    }
  }
  async saveFile(filePath, keys9) {
    const loader = this.getLoaderForFile(filePath);
    if (!loader) {
      throw new Error(`No loader found for file: ${filePath}`);
    }
    let config2 = this.toObject();
    if (keys9 && keys9.length > 0) {
      const filtered = {};
      for (const key of keys9) {
        const value6 = getValueByPath(config2, key);
        if (value6 !== undefined) {
          setValueByPath(filtered, key, value6);
        }
      }
      config2 = filtered;
    }
    await loader.save(filePath, config2);
  }
  async reload() {
    this.data.clear();
    if (this.options.defaults) {
      this.merge(this.options.defaults, "default");
    }
    this.loadEnvironment();
    if (this.options.loadUserConfig) {
      await this.loadUserConfig();
    }
    if (this.options.loadProjectConfig) {
      await this.loadProjectConfig();
    }
    if (this.options.files) {
      for (const file of this.options.files) {
        try {
          await this.loadFile(file);
        } catch (error2) {
          console.warn(`Failed to load config file ${file}:`, error2);
        }
      }
    }
  }
  namespace(ns) {
    const prefix = this.namespacePrefix ? `${this.namespacePrefix}.${ns}` : ns;
    return new TuixConfig(this.options, prefix);
  }
  getFullKey(key) {
    return this.namespacePrefix ? `${this.namespacePrefix}.${key}` : key;
  }
  getSchemaForKey(key) {
    if (!this.schema)
      return;
    const parts2 = key.split(".");
    let current2 = this.schema;
    for (const part of parts2) {
      if (current2[part]) {
        current2 = current2[part];
      } else {
        return;
      }
    }
    return current2 instanceof exports_external.ZodSchema ? current2 : undefined;
  }
  flattenObject(obj, prefix = "") {
    const result = {};
    for (const [key, value6] of Object.entries(obj)) {
      const fullKey = prefix ? `${prefix}.${key}` : key;
      if (value6 && typeof value6 === "object" && !Array.isArray(value6)) {
        Object.assign(result, this.flattenObject(value6, fullKey));
      } else {
        result[fullKey] = value6;
      }
    }
    return result;
  }
  loadEnvironment() {
    const prefix = this.options.envPrefix || "TUIX_";
    for (const [key, value6] of Object.entries(process.env)) {
      if (key.startsWith(prefix)) {
        const configKey = key.slice(prefix.length).toLowerCase().replace(/_/g, ".");
        let parsedValue = value6;
        if (value6 === "true")
          parsedValue = true;
        else if (value6 === "false")
          parsedValue = false;
        else if (value6 && !isNaN(Number(value6)))
          parsedValue = Number(value6);
        this.set(configKey, parsedValue, "env");
      }
    }
  }
  async loadUserConfig() {
    const userConfigDir = path4.join(os.homedir(), ".config", "tuix");
    const userConfigFiles = [
      path4.join(userConfigDir, "settings.json"),
      path4.join(userConfigDir, "config.json"),
      path4.join(userConfigDir, "tuix.json")
    ];
    for (const file of userConfigFiles) {
      try {
        await this.loadFile(file);
        break;
      } catch {}
    }
  }
  async loadProjectConfig() {
    const searchPaths = this.options.searchPaths || [process.cwd()];
    const configFiles = [
      "tuix.config.ts",
      "tuix.config.js",
      "tuix.config.json",
      ".tuixrc.json",
      ".tuixrc"
    ];
    for (const searchPath of searchPaths) {
      for (const configFile of configFiles) {
        const filePath = path4.join(searchPath, configFile);
        try {
          await this.loadFile(filePath);
          return;
        } catch {}
      }
    }
  }
  getLoaderForFile(filePath) {
    const loaders = [
      new JSONLoader,
      new TypeScriptLoader,
      new YAMLLoader
    ];
    return loaders.find((loader) => loader.canLoad(filePath));
  }
  notifyWatchers(event) {
    for (const watcher of this.watchers) {
      try {
        watcher(event);
      } catch (error2) {
        console.error("Error in config watcher:", error2);
      }
    }
  }
  dispose() {
    for (const cleanup2 of this.fileWatchers.values()) {
      cleanup2();
    }
    this.fileWatchers.clear();
    this.watchers.clear();
  }
}

class TuixConfigBuilder {
  options = {};
  name(name) {
    this.options.name = name;
    return this;
  }
  file(path5) {
    this.options.files = this.options.files || [];
    this.options.files.push(path5);
    return this;
  }
  searchPath(path5) {
    this.options.searchPaths = this.options.searchPaths || [];
    this.options.searchPaths.push(path5);
    return this;
  }
  envPrefix(prefix) {
    this.options.envPrefix = prefix;
    return this;
  }
  schema(schema) {
    this.options.schema = schema;
    return this;
  }
  defaults(defaults) {
    this.options.defaults = defaults;
    return this;
  }
  withUserConfig() {
    this.options.loadUserConfig = true;
    return this;
  }
  withProjectConfig() {
    this.options.loadProjectConfig = true;
    return this;
  }
  withWatch() {
    this.options.watch = true;
    return this;
  }
  async build() {
    const config2 = new TuixConfig(this.options);
    await config2.reload();
    return config2;
  }
}
function createConfig() {
  return new TuixConfigBuilder;
}
var init_config3 = __esm(() => {
  init_esm();
  init_loaders();
  init_utils();
});

// ../../src/config/jsx-config.ts
function setGlobalConfig(config2) {
  globalConfig = config2;
}
function getGlobalConfig() {
  if (!globalConfig) {
    throw new Error("No global config set. Call setGlobalConfig() first or use createJSXConfigApp()");
  }
  return globalConfig;
}
function ConfigProvider(props) {
  if (props.config) {
    setGlobalConfig(props.config);
  } else {
    const createConfigAsync = async () => {
      const builder = createConfig();
      if (props.defaults)
        builder.defaults(props.defaults);
      if (props.schema)
        builder.schema(props.schema);
      if (props.envPrefix)
        builder.envPrefix(props.envPrefix);
      if (props.loadUserConfig)
        builder.withUserConfig();
      if (props.loadProjectConfig)
        builder.withProjectConfig();
      const config2 = await builder.build();
      setGlobalConfig(config2);
    };
    createConfigAsync().catch(console.error);
  }
  return null;
}
function getConfig() {
  return getGlobalConfig();
}
function getConfigValue(key, defaultValue) {
  const config2 = getGlobalConfig();
  return config2.getOrDefault(key, defaultValue);
}
function getConfigValues(keys9) {
  const config2 = getGlobalConfig();
  const values8 = {};
  for (const key of keys9) {
    values8[key] = config2.get(key);
  }
  return values8;
}
function ConfigField(props) {
  return null;
}
function ConfigDefinition(props) {
  return null;
}
function getConfigOptions() {
  const config2 = getGlobalConfig();
  return {
    getDefault: (key) => {
      return config2.get(`cli.defaults.${key}`);
    },
    applyDefaults: (options) => {
      const defaults = config2.get("cli.defaults") || {};
      return { ...defaults, ...options };
    },
    validateOptions: (options) => {
      const schema = config2.get("cli.schema");
      if (schema) {
        const result = schema.safeParse(options);
        if (!result.success) {
          throw result.error;
        }
        return result.data;
      }
      return options;
    }
  };
}
function SetConfig(props) {
  const config2 = getGlobalConfig();
  for (const [key, value6] of Object.entries(props)) {
    if (key !== "children") {
      config2.set(key, value6);
    }
  }
  return null;
}
function LoadConfig(props) {
  const config2 = getGlobalConfig();
  config2.loadFile(props.file).catch((error2) => {
    if (props.required) {
      throw error2;
    }
    console.warn(`Failed to load config file ${props.file}:`, error2);
  });
  return null;
}
function defineConfigSchema(schema) {
  return schema;
}
function createTypedConfig() {
  return {
    getConfig: () => getGlobalConfig(),
    getValue: (key) => {
      const config2 = getGlobalConfig();
      return config2.get(String(key));
    },
    getValues: () => {
      const config2 = getGlobalConfig();
      return config2.toObject();
    }
  };
}
async function createJSXConfigApp(AppComponent, configOptions) {
  const builder = createConfig();
  if (configOptions?.name)
    builder.name(configOptions.name);
  if (configOptions?.defaults)
    builder.defaults(configOptions.defaults);
  if (configOptions?.schema)
    builder.schema(configOptions.schema);
  if (configOptions?.envPrefix)
    builder.envPrefix(configOptions.envPrefix);
  if (configOptions?.loadUserConfig)
    builder.withUserConfig();
  if (configOptions?.loadProjectConfig)
    builder.withProjectConfig();
  const config2 = await builder.build();
  setGlobalConfig(config2);
  const app = typeof AppComponent === "function" ? AppComponent() : AppComponent;
  return { config: config2, app };
}
var globalConfig = null;
var init_jsx_config = __esm(() => {
  init_esm2();
  init_config3();
});

// ../../src/config/index.ts
async function loadConfig(appName = "tuix") {
  const configBuilder = createConfig().name(appName).withUserConfig().withProjectConfig().envPrefix(`${appName.toUpperCase()}_`).searchPath(process.cwd());
  return await configBuilder.build();
}
var ConfigLayer = (options) => exports_Layer.effect(Config, exports_Effect.gen(function* (_) {
  const builder = createConfig();
  if (options?.name)
    builder.name(options.name);
  if (options?.defaults)
    builder.defaults(options.defaults);
  if (options?.schema)
    builder.schema(options.schema);
  if (options?.envPrefix)
    builder.envPrefix(options.envPrefix);
  if (options?.loadUserConfig)
    builder.withUserConfig();
  if (options?.loadProjectConfig)
    builder.withProjectConfig();
  if (options?.watch)
    builder.withWatch();
  if (options?.files) {
    for (const file of options.files) {
      builder.file(file);
    }
  }
  if (options?.searchPaths) {
    for (const path5 of options.searchPaths) {
      builder.searchPath(path5);
    }
  }
  return yield* _(exports_Effect.promise(() => builder.build()));
})), config3, templates;
var init_config4 = __esm(() => {
  init_types3();
  init_config3();
  init_loaders();
  init_utils();
  init_jsx_config();
  init_esm2();
  init_types3();
  init_config3();
  config3 = {
    simple: (defaults) => createConfig().defaults(defaults).build(),
    standard: (name) => createConfig().name(name).withUserConfig().withProjectConfig().envPrefix(`${name.toUpperCase()}_`).build(),
    cli: (name, defaults) => createConfig().name(name).defaults(defaults || {}).withUserConfig().withProjectConfig().envPrefix(`${name.toUpperCase()}_`).searchPath(process.cwd()).build(),
    env: (prefix) => createConfig().envPrefix(prefix || "").build(),
    file: (path5) => createConfig().file(path5).build()
  };
  templates = {
    typescript: (appName) => `/**
 * Tuix Configuration
 * 
 * Configuration for ${appName}
 */

import { defineConfig } from 'tuix/config'

export default defineConfig({
  // Application name
  name: '${appName}',
  
  // Version
  version: '1.0.0',
  
  // Logger configuration
  logger: {
    level: 'info',
    format: 'pretty',
    showEmoji: true
  },
  
  // Process manager configuration
  processManager: {
    tuixDir: '.tuix',
    autoRestart: true,
    maxRestarts: 5
  },
  
  // CLI configuration
  cli: {
    // Default values for CLI options
    defaults: {
      verbose: false,
      quiet: false
    }
  },
  
  // Custom configuration
  custom: {
    // Add your app-specific config here
  }
})
`,
    json: (appName) => JSON.stringify({
      name: appName,
      version: "1.0.0",
      logger: {
        level: "info",
        format: "pretty",
        showEmoji: true
      },
      processManager: {
        tuixDir: ".tuix",
        autoRestart: true,
        maxRestarts: 5
      },
      cli: {
        defaults: {
          verbose: false,
          quiet: false
        }
      },
      custom: {}
    }, null, 2),
    env: (appName) => `# ${appName} Environment Configuration

# Logger
${appName.toUpperCase()}_LOGGER_LEVEL=info
${appName.toUpperCase()}_LOGGER_FORMAT=pretty
${appName.toUpperCase()}_LOGGER_SHOW_EMOJI=true

# Process Manager
${appName.toUpperCase()}_PROCESS_MANAGER_TUIX_DIR=.tuix
${appName.toUpperCase()}_PROCESS_MANAGER_AUTO_RESTART=true
${appName.toUpperCase()}_PROCESS_MANAGER_MAX_RESTARTS=5

# Custom configuration
# ${appName.toUpperCase()}_CUSTOM_KEY=value
`
  };
});

// ../../src/scope/types.ts
var ScopeError, ScopeNotFoundError, ScopeExistsError;
var init_types4 = __esm(() => {
  init_esm2();
  ScopeError = class ScopeError extends Error {
    code;
    scopeId;
    constructor(message, code, scopeId) {
      super(message);
      this.code = code;
      this.scopeId = scopeId;
      this.name = "ScopeError";
    }
  };
  ScopeNotFoundError = class ScopeNotFoundError extends ScopeError {
    constructor(scopeId) {
      super(`Scope not found: ${scopeId}`, "SCOPE_NOT_FOUND", scopeId);
    }
  };
  ScopeExistsError = class ScopeExistsError extends ScopeError {
    constructor(scopeId) {
      super(`Scope already exists: ${scopeId}`, "SCOPE_EXISTS", scopeId);
    }
  };
});

// ../../src/scope/manager.ts
class ScopeManager {
  scopes = new Map;
  activeScopes = new Set;
  jsxModule = null;
  constructor() {
    this.initializeJSXModule();
  }
  initializeJSXModule() {
    try {
      const registry = getGlobalRegistry();
      this.jsxModule = registry.getModule("jsx") || null;
    } catch {}
  }
  registerScope(def) {
    return exports_Effect.gen(function* () {
      if (this.scopes.has(def.id)) {
        const existing = this.scopes.get(def.id);
        if (existing.def.name === def.name && existing.def.type === def.type && existing.def.path.join("/") === def.path.join("/")) {
          existing.def = def;
          return;
        }
        return yield* exports_Effect.fail(new ScopeExistsError(def.id));
      }
      const state = {
        def,
        status: "unmounted",
        isActive: false,
        context: {},
        transient: {},
        childIds: []
      };
      if (def.path.length > 1) {
        const parentPath = def.path.slice(0, -1);
        const parent = this.findScopeByPath(parentPath);
        if (parent) {
          state.parentId = parent.def.id;
          parent.childIds.push(def.id);
        }
      }
      for (const [id3, existingState] of this.scopes) {
        const existingPath = existingState.def.path;
        if (existingPath.length === def.path.length + 1 && existingPath.slice(0, -1).join("/") === def.path.join("/")) {
          state.childIds.push(id3);
          existingState.parentId = def.id;
        }
      }
      this.scopes.set(def.id, state);
    }.bind(this));
  }
  activateScope(id3) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      this.activeScopes.add(id3);
      state.isActive = true;
      let parentId = state.parentId;
      while (parentId) {
        const parent = this.scopes.get(parentId);
        if (parent) {
          this.activeScopes.add(parentId);
          parent.isActive = true;
          parentId = parent.parentId;
        } else {
          break;
        }
      }
    }.bind(this));
  }
  deactivateScope(id3) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      this.activeScopes.delete(id3);
      state.isActive = false;
      for (const childId of state.childIds) {
        yield* this.deactivateScope(childId);
      }
    }.bind(this));
  }
  isScopeActive(id3) {
    const state = this.scopes.get(id3);
    if (!state)
      return false;
    if (state.isActive)
      return true;
    for (const childId of state.childIds) {
      if (this.isScopeActive(childId))
        return true;
    }
    return false;
  }
  setScopeStatus(id3, status3) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      state.status = status3;
    }.bind(this));
  }
  getScopeStatus(id3) {
    const state = this.scopes.get(id3);
    return state ? state.status : null;
  }
  setScopeContext(id3, data) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      state.context = { ...state.context, ...data };
    }.bind(this));
  }
  getScopeContext(id3) {
    const state = this.scopes.get(id3);
    return state ? state.context : null;
  }
  setTransientState(id3, data) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      state.transient = { ...state.transient, ...data };
    }.bind(this));
  }
  resetTransientState(id3) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return yield* exports_Effect.fail(new ScopeNotFoundError(id3));
      }
      state.transient = {};
    }.bind(this));
  }
  getScopeDef(id3) {
    const state = this.scopes.get(id3);
    return state ? state.def : null;
  }
  getChildScopes(id3) {
    if (!id3) {
      return Array.from(this.scopes.values()).filter((state2) => !state2.parentId).map((state2) => state2.def);
    }
    const state = this.scopes.get(id3);
    if (!state)
      return [];
    return state.childIds.map((childId) => this.scopes.get(childId)).filter(Boolean).map((state2) => state2.def);
  }
  getParentScope(id3) {
    const state = this.scopes.get(id3);
    if (!state || !state.parentId)
      return null;
    const parent = this.scopes.get(state.parentId);
    return parent ? parent.def : null;
  }
  findScopeByPath(path5) {
    for (const [_, state] of this.scopes) {
      if (state.def.path.join("/") === path5.join("/")) {
        return state;
      }
    }
    return null;
  }
  removeScope(id3) {
    return exports_Effect.gen(function* () {
      const state = this.scopes.get(id3);
      if (!state) {
        return;
      }
      if (state.parentId) {
        const parent = this.scopes.get(state.parentId);
        if (parent) {
          parent.childIds = parent.childIds.filter((childId) => childId !== id3);
        }
      }
      for (const childId of state.childIds) {
        const child = this.scopes.get(childId);
        if (child) {
          child.parentId = state.parentId;
          if (state.parentId) {
            const parent = this.scopes.get(state.parentId);
            if (parent && !parent.childIds.includes(childId)) {
              parent.childIds.push(childId);
            }
          }
        }
      }
      this.activeScopes.delete(id3);
      this.scopes.delete(id3);
    }.bind(this));
  }
  clear() {
    this.scopes.clear();
    this.activeScopes.clear();
  }
  getAllScopes() {
    return Array.from(this.scopes.values()).map((state) => state.def);
  }
  setScopeDef(def) {
    return exports_Effect.gen(function* () {
      yield* this.registerScope(def);
      if (def.executable) {
        if (!this.jsxModule) {
          this.initializeJSXModule();
        }
        if (this.jsxModule) {
          const scopeContext = {
            id: def.id,
            type: def.type,
            name: def.name,
            path: def.path,
            children: [],
            metadata: def.metadata || {},
            description: def.description,
            hidden: def.hidden,
            aliases: def.aliases,
            executable: def.executable,
            handler: def.handler,
            args: def.args,
            flags: def.flags,
            options: def.options
          };
          yield* exports_Effect.catchAll(this.jsxModule.emitScopeCreated(scopeContext), (error2) => exports_Effect.sync(() => {
            console.warn("Failed to emit scope created event:", error2);
          }));
        }
      }
    }.bind(this));
  }
  setScopeDefSync(def) {
    const result = exports_Effect.runSync(this.registerScope(def));
    if (def.executable && this.jsxModule) {
      const scopeContext = {
        id: def.id,
        type: def.type,
        name: def.name,
        path: def.path,
        children: [],
        metadata: def.metadata || {},
        description: def.description,
        hidden: def.hidden,
        aliases: def.aliases,
        executable: def.executable,
        handler: def.handler,
        args: def.args,
        flags: def.flags,
        options: def.options
      };
      exports_Effect.runSync(exports_Effect.catchAll(this.jsxModule.emitScopeCreated(scopeContext), (error2) => exports_Effect.sync(() => {
        console.warn("Failed to emit scope created event:", error2);
      })));
    }
  }
  markScopeRendered(id3) {
    const state = this.scopes.get(id3);
    if (state) {
      state.status = "rendered";
      let parentId = state.parentId;
      while (parentId) {
        const parent = this.scopes.get(parentId);
        if (parent && parent.status !== "rendered") {
          parent.status = "rendered";
          parentId = parent.parentId;
        } else {
          break;
        }
      }
    }
  }
  hasRenderedContent(id3) {
    const state = this.scopes.get(id3);
    if (!state)
      return false;
    if (state.status === "rendered")
      return true;
    return state.childIds.some((childId) => this.hasRenderedContent(childId));
  }
}
var scopeManager, setScopeDef = (def) => scopeManager.setScopeDefSync(def), markScopeRendered = (id3) => scopeManager.markScopeRendered(id3), hasRenderedContent = (id3) => scopeManager.hasRenderedContent(id3);
var init_manager = __esm(() => {
  init_esm2();
  init_types4();
  init_module_registry();
  scopeManager = new ScopeManager;
});

// ../../src/scope/jsx/stores/index.ts
class CurrentScopeStore {
  scope = $state(null);
  get() {
    return this.scope();
  }
  set(scope5) {
    this.scope(scope5);
  }
}

class ParentScopeStore {
  get() {
    const current2 = currentScopeStore.get();
    if (!current2)
      return null;
    return scopeManager.getParentScope(current2.id);
  }
}

class RootScopeStore {
  get() {
    const current2 = currentScopeStore.get();
    if (!current2)
      return null;
    let root = current2;
    let parent = scopeManager.getParentScope(root.id);
    while (parent) {
      root = parent;
      parent = scopeManager.getParentScope(root.id);
    }
    return root;
  }
}
var currentScopeStore, parentScopeStore, rootScopeStore;
var init_stores = __esm(() => {
  init_runes();
  init_manager();
  currentScopeStore = new CurrentScopeStore;
  parentScopeStore = new ParentScopeStore;
  rootScopeStore = new RootScopeStore;
});

// ../../src/scope/jsx/hooks/useScope.ts
function useCurrentScope() {
  return currentScopeStore.get();
}
var init_useScope = __esm(() => {
  init_esm2();
  init_runes();
  init_manager();
  init_stores();
});

// ../../src/scope/jsx/hooks/index.ts
var init_hooks = __esm(() => {
  init_useScope();
});

// ../../src/scope/jsx/cli/CommandLineHelp.tsx
function CommandLineHelp(props) {
  const currentScope = props.scopeId ? scopeManager.getScopeDef(props.scopeId) : useCurrentScope();
  if (!currentScope) {
    return text("No help available");
  }
  const elements = [];
  const commandPath = currentScope.path.length > 0 ? currentScope.path.join(" ") : currentScope.name;
  elements.push(vstack(styledText(commandPath, style({ foreground: Colors.cyan, bold: true })), currentScope.description ? styledText(currentScope.description, style({ foreground: Colors.white, faint: true })) : text("")));
  const childScopes = scopeManager.getChildScopes(currentScope.id);
  if (childScopes.length > 0) {
    elements.push(text(""));
    elements.push(styledText("COMMANDS:", style({ foreground: Colors.yellow, bold: true })));
    const maxNameLength = Math.max(...childScopes.map((cmd) => cmd.name.length));
    childScopes.filter((child) => !child.metadata?.hidden).sort((a, b) => a.name.localeCompare(b.name)).forEach((child) => {
      const paddedName = child.name.padEnd(maxNameLength + 4);
      elements.push(hstack(styledText(`  ${paddedName}`, style({ foreground: Colors.green })), styledText(child.description || "", style({ foreground: Colors.white, faint: true }))));
      if (child.aliases && child.aliases.length > 0) {
        elements.push(styledText(`      (alias: ${child.aliases.join(", ")})`, style({ foreground: Colors.gray, italic: true })));
      }
    });
    elements.push(text(""));
    let rootScope = currentScope;
    let parent = scopeManager.getParentScope(rootScope.id);
    while (parent) {
      rootScope = parent;
      parent = scopeManager.getParentScope(rootScope.id);
    }
    const cliName = rootScope.name;
    elements.push(styledText(`Run '${cliName} ${commandPath} COMMAND --help' for more information on a command.`, style({ foreground: Colors.gray, italic: true })));
  } else if (currentScope.type === "command") {
    elements.push(text(""));
    if (currentScope.args && Object.keys(currentScope.args).length > 0) {
      elements.push(styledText("ARGUMENTS:", style({ foreground: Colors.yellow, bold: true })));
      Object.entries(currentScope.args).forEach(([name, arg]) => {
        elements.push(hstack(styledText(`  ${name}`, style({ foreground: arg.required ? Colors.red : Colors.green })), styledText(arg.description || "", style({ foreground: Colors.white, faint: true }))));
      });
      elements.push(text(""));
    }
    if (currentScope.flags && Object.keys(currentScope.flags).length > 0) {
      elements.push(styledText("FLAGS:", style({ foreground: Colors.yellow, bold: true })));
      Object.entries(currentScope.flags).forEach(([name, flag]) => {
        const flagText = flag.alias ? `--${name}, -${flag.alias}` : `--${name}`;
        elements.push(hstack(styledText(`  ${flagText.padEnd(20)}`, style({ foreground: Colors.blue })), styledText(flag.description || "", style({ foreground: Colors.white, faint: true }))));
      });
    }
  }
  return vstack(...elements);
}
var init_CommandLineHelp = __esm(() => {
  init_manager();
  init_hooks();
  init_view();
  init_styling();
});

// ../../src/jsx/dev-runtime.ts
var init_dev_runtime = __esm(() => {
  init_runtime3();
});

// ../../src/scope/jsx/components/jsx-dev-runtime.ts
var init_jsx_dev_runtime = __esm(() => {
  init_dev_runtime();
});

// ../../src/scope/jsx/components/ScopeFallback.tsx
function ScopeFallback(props) {
  const { scopeId, fallback } = props;
  const childScopes = scopeManager.getChildScopes(scopeId);
  const anyChildWillRender = childScopes.some((child) => {
    const status3 = scopeManager.getScopeStatus(child.id);
    return status3 === "rendered";
  });
  if (anyChildWillRender) {
    return jsx("text", { children: "" });
  }
  if (fallback) {
    return fallback;
  }
  return /* @__PURE__ */ jsx(CommandLineHelp, {
    scopeId
  }, undefined, false, undefined, this);
}
var init_ScopeFallback = __esm(() => {
  init_manager();
  init_runtime3();
  init_CommandLineHelp();
  init_jsx_dev_runtime();
});

// ../../src/scope/jsx/components/Scope.tsx
function Scope3(props) {
  const scopeId = props.id || `scope_${props.type}_${props.name}_${Date.now()}`;
  const willRenderContent = $state(false);
  const hasRenderedChildren = $state(false);
  const scopeDef = {
    id: scopeId,
    type: props.type,
    name: props.name,
    path: props.path || [],
    description: props.description,
    executable: props.executable ?? (props.type === "command" || props.type === "plugin"),
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    aliases: props.aliases,
    metadata: props.metadata || {},
    children: []
  };
  const parentScope = parentScopeStore.get();
  if (parentScope && scopeDef.path.length === 0) {
    scopeDef.path = [...parentScope.path, props.name];
  }
  setScopeDef(scopeDef);
  currentScopeStore.set(scopeDef);
  try {
    onMount(() => {
      exports_Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
      return () => {
        currentScopeStore.set(null);
      };
    });
  } catch (error2) {
    exports_Effect.runSync(scopeManager.setScopeStatus(scopeId, "mounted"));
  }
  const isActive2 = scopeManager.isScopeActive(scopeId);
  const childScopes = scopeManager.getChildScopes(scopeId);
  const { children: children3, defaultContent, layout } = props;
  const childArray = Array.isArray(children3) ? children3 : children3 ? [children3] : [];
  const hasScopeContent = childArray.some((child) => child && typeof child === "object" && child.type === "ScopeContent");
  let content = null;
  if (!isActive2) {
    return jsx("text", { children: "" });
  }
  const shouldShowHelp = props.executable && !hasRenderedContent(scopeId);
  if (shouldShowHelp) {
    content = /* @__PURE__ */ jsx(ScopeFallback, {
      scopeId
    }, undefined, false, undefined, this);
  } else if (hasScopeContent) {
    content = /* @__PURE__ */ jsx(Fragment, {
      children: children3
    }, undefined, false, undefined, this);
  } else if (childScopes.length > 0 || defaultContent) {
    content = defaultContent || /* @__PURE__ */ jsx(Fragment, {
      children: children3
    }, undefined, false, undefined, this);
  } else {
    content = /* @__PURE__ */ jsx(Fragment, {
      children: children3
    }, undefined, false, undefined, this);
  }
  if (layout && content) {
    content = layout(content);
  }
  return content;
}
var init_Scope2 = __esm(() => {
  init_esm2();
  init_runtime3();
  init_jsx_lifecycle();
  init_runes();
  init_manager();
  init_stores();
  init_ScopeFallback();
  init_jsx_dev_runtime();
});

// ../../src/scope/jsx/components/ScopeContent.tsx
function ScopeContent(props) {
  const currentScope = currentScopeStore.get();
  if (!currentScope) {
    console.warn("ScopeContent used outside of Scope component");
    return null;
  }
  const isActive2 = scopeManager.isScopeActive(currentScope.id);
  if (!isActive2) {
    return null;
  }
  markScopeRendered(currentScope.id);
  try {
    onMount(() => {
      exports_Effect.runSync(scopeManager.setScopeStatus(currentScope.id, "rendered"));
    });
  } catch (error2) {
    exports_Effect.runSync(scopeManager.setScopeStatus(currentScope.id, "rendered"));
  }
  return /* @__PURE__ */ jsx(Fragment, {
    children: props.children
  }, undefined, false, undefined, this);
}
var init_ScopeContent = __esm(() => {
  init_esm2();
  init_jsx_lifecycle();
  init_manager();
  init_stores();
  init_jsx_dev_runtime();
});

// ../../src/scope/jsx/components/Scoped.tsx
var init_Scoped = __esm(() => {
  init_stores();
  init_manager();
  init_jsx_dev_runtime();
});

// ../../src/scope/jsx/components/Unscoped.tsx
var init_Unscoped = __esm(() => {
  init_jsx_dev_runtime();
});

// ../../src/scope/index.ts
var init_scope = __esm(() => {
  init_types4();
  init_manager();
  init_Scope2();
  init_ScopeContent();
  init_ScopeFallback();
  init_Scoped();
  init_Unscoped();
  init_stores();
});

// ../../src/scope/jsx/components/index.ts
var init_components = __esm(() => {
  init_Scope2();
  init_ScopeContent();
  init_ScopeFallback();
  init_Scoped();
  init_Unscoped();
});

// ../../src/cli/jsx/stores/command-store.ts
class CommandStore {
  #commandPath = $state([]);
  #commandContext = $state(null);
  #registeredCommands = $state(new Map);
  get currentPath() {
    return this.#commandPath;
  }
  get context() {
    return this.#commandContext;
  }
  get availableCommands() {
    return $derived(() => {
      const allScopes = scopeManager.getAllScopes();
      let currentScope;
      if (this.#commandPath.length === 0) {
        currentScope = allScopes.find((s) => s.type === "cli");
      } else {
        currentScope = allScopes.find((s) => s.path.length === this.#commandPath.length && s.path.every((segment, i) => segment === this.#commandPath[i]) && (s.type === "plugin" || s.type === "command"));
      }
      if (!currentScope)
        return [];
      const children3 = scopeManager.getChildScopes(currentScope.id);
      return children3.filter((child) => child.executable && (child.type === "plugin" || child.type === "command"));
    });
  }
  get hasCommands() {
    return $derived(() => this.availableCommands.length > 0);
  }
  setCommandPath(path5) {
    this.#commandPath = path5;
  }
  setCommandContext(path5, args2 = {}, flags = {}) {
    this.#commandPath = path5;
    this.#commandContext = {
      args: args2,
      flags,
      command: path5[path5.length - 1] || "",
      commandPath: path5
    };
  }
  clearCommandContext() {
    this.#commandPath = [];
    this.#commandContext = null;
  }
  registerCommand(command) {
    const key = command.path?.join("/") || command.name;
    this.#registeredCommands.set(key, command);
  }
  getCommandByPath(path5) {
    const allScopes = scopeManager.getAllScopes();
    if (path5.length === 0) {
      return allScopes.find((scope5) => scope5.type === "cli");
    }
    return allScopes.find((scope5) => scope5.path.length === path5.length && scope5.path.every((segment, i) => segment === path5[i]) && scope5.executable && (scope5.type === "command" || scope5.type === "plugin"));
  }
  getCommandConfig(path5) {
    const key = path5.join("/");
    return this.#registeredCommands.get(key);
  }
  commandExists(path5) {
    return !!this.getCommandByPath(path5);
  }
  getSubcommands(path5) {
    const command = this.getCommandByPath(path5);
    if (!command)
      return [];
    const children3 = scopeManager.getChildScopes(command.id);
    return children3.filter((child) => child.executable && (child.type === "command" || child.type === "plugin"));
  }
}
var commandStore;
var init_command_store = __esm(() => {
  init_runes();
  init_manager();
  commandStore = new CommandStore;
});

// ../../src/cli/jsx/stores/cli-store.ts
class CLIStore {
  #config = $state({});
  #isRunning = $state(false);
  #exitCode = $state(null);
  get config() {
    return this.#config;
  }
  get name() {
    return $derived(() => this.#config.name || "CLI Application");
  }
  get version() {
    return $derived(() => this.#config.version || "0.0.0");
  }
  get description() {
    return $derived(() => this.#config.description || "");
  }
  get isRunning() {
    return this.#isRunning;
  }
  get exitCode() {
    return this.#exitCode;
  }
  setConfig(config4) {
    this.#config = { ...this.#config, ...config4 };
  }
  start() {
    this.#isRunning = true;
    this.#exitCode = null;
  }
  stop(code = 0) {
    this.#isRunning = false;
    this.#exitCode = code;
  }
  reset() {
    this.#config = {};
    this.#isRunning = false;
    this.#exitCode = null;
  }
}
var cliStore;
var init_cli_store = __esm(() => {
  init_runes();
  cliStore = new CLIStore;
});

// ../../src/cli/jsx/stores/index.ts
var exports_stores = {};
__export(exports_stores, {
  stopCli: () => stopCli,
  startCli: () => startCli,
  setCommandContext: () => setCommandContext,
  setCliConfig: () => setCliConfig,
  registerCommand: () => registerCommand,
  hasCliCommands: () => hasCliCommands,
  getSubcommands: () => getSubcommands,
  getCommandConfig: () => getCommandConfig,
  getCommandByPath: () => getCommandByPath,
  currentCommandPath: () => currentCommandPath,
  commandStore: () => commandStore,
  commandExists: () => commandExists,
  commandContext: () => commandContext,
  cliStore: () => cliStore,
  cliConfig: () => cliConfig,
  clearCommandContext: () => clearCommandContext,
  availableCommands: () => availableCommands
});
var setCommandContext = (...args2) => commandStore.setCommandContext(...args2), clearCommandContext = () => commandStore.clearCommandContext(), getCommandByPath = (...args2) => commandStore.getCommandByPath(...args2), commandExists = (...args2) => commandStore.commandExists(...args2), getSubcommands = (...args2) => commandStore.getSubcommands(...args2), registerCommand = (...args2) => commandStore.registerCommand(...args2), getCommandConfig = (...args2) => commandStore.getCommandConfig(...args2), setCliConfig = (...args2) => cliStore.setConfig(...args2), startCli = () => cliStore.start(), stopCli = (...args2) => cliStore.stop(...args2), currentCommandPath = () => commandStore.currentPath, commandContext = () => commandStore.context, cliConfig = () => cliStore.getConfig(), hasCliCommands = () => commandStore.hasCommands, availableCommands = () => commandStore.availableCommands;
var init_stores2 = __esm(() => {
  init_command_store();
  init_cli_store();
});

// ../../src/scope/jsx/cli/jsx-dev-runtime.ts
var init_jsx_dev_runtime2 = __esm(() => {
  init_dev_runtime();
});

// ../../src/scope/jsx/cli/CommandLineScope.tsx
function CommandLineScope(props) {
  const currentCommandPath2 = commandStore.currentPath;
  const scopePath = props.path || [];
  const isActive2 = currentCommandPath2.length >= scopePath.length && scopePath.every((segment, i) => segment === currentCommandPath2[i]);
  const isHelpRequested = isActive2 && currentCommandPath2.length === scopePath.length + 1 && currentCommandPath2[currentCommandPath2.length - 1] === "help";
  const childWillHandle = isActive2 && currentCommandPath2.length > scopePath.length && !isHelpRequested;
  const shouldShowHelp = isActive2 && (isHelpRequested || !childWillHandle);
  const handler = shouldShowHelp ? () => /* @__PURE__ */ jsx(CommandLineHelp, {}, undefined, false, undefined, this) : props.handler;
  return /* @__PURE__ */ jsx(Scope3, {
    ...props,
    executable: true,
    handler,
    children: [
      props.children,
      /* @__PURE__ */ jsx(Scope3, {
        type: "command",
        name: "help",
        description: `Show help for ${props.name}`,
        handler: () => /* @__PURE__ */ jsx(CommandLineHelp, {}, undefined, false, undefined, this)
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
var init_CommandLineScope = __esm(() => {
  init_components();
  init_CommandLineHelp();
  init_stores2();
  init_jsx_dev_runtime2();
});

// ../../src/scope/jsx/cli/index.ts
var init_cli = __esm(() => {
  init_CommandLineScope();
  init_CommandLineHelp();
});

// ../../src/cli/jsx/components/jsx-dev-runtime.ts
var init_jsx_dev_runtime3 = __esm(() => {
  init_dev_runtime();
});

// ../../src/cli/jsx/components/CLI.tsx
function CLI(props) {
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "cli",
    name: props.name,
    path: [props.name],
    description: props.description,
    metadata: {
      alias: props.alias,
      version: props.version
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_CLI = __esm(() => {
  init_cli();
  init_jsx_dev_runtime3();
});

// ../../src/plugins/jsx/stores/plugin-store-simple.ts
class SimplePluginStore {
  plugins = new Map;
  activePlugin = null;
  get all() {
    return Array.from(this.plugins.values());
  }
  get enabled() {
    return this.all.filter((p) => p.enabled);
  }
  get disabled() {
    return this.all.filter((p) => !p.enabled);
  }
  register(plugin) {
    const registration = {
      id: plugin.name,
      name: plugin.name,
      version: plugin.version,
      description: plugin.description,
      enabled: false,
      config: {},
      plugin
    };
    this.plugins.set(registration.id, registration);
  }
  unregister(id3) {
    this.plugins.delete(id3);
    if (this.activePlugin === id3) {
      this.activePlugin = null;
    }
  }
  enable(id3) {
    const plugin = this.plugins.get(id3);
    if (plugin) {
      plugin.enabled = true;
    }
  }
  disable(id3) {
    const plugin = this.plugins.get(id3);
    if (plugin) {
      plugin.enabled = false;
    }
  }
  configure(id3, config4) {
    const plugin = this.plugins.get(id3);
    if (plugin) {
      plugin.config = { ...plugin.config, ...config4 };
    }
  }
  setActive(id3) {
    this.activePlugin = id3;
  }
  getPlugin(id3) {
    return this.plugins.get(id3);
  }
  getPluginConfig(id3) {
    return this.plugins.get(id3)?.config || {};
  }
  hasPlugin(id3) {
    return this.plugins.has(id3);
  }
  clear() {
    this.plugins.clear();
    this.activePlugin = null;
  }
}
var pluginStore;
var init_plugin_store_simple = __esm(() => {
  pluginStore = new SimplePluginStore;
});

// ../../src/plugins/jsx/stores/index.ts
var init_stores3 = __esm(() => {
  init_plugin_store_simple();
});

// ../../src/cli/jsx/components/Plugin.tsx
function Plugin(props) {
  try {
    onMount(() => {
      pluginStore.register({
        id: props.name,
        name: props.name,
        version: props.version,
        description: props.description,
        commands: []
      });
    });
  } catch {
    pluginStore.register({
      id: props.name,
      name: props.name,
      version: props.version,
      description: props.description,
      commands: []
    });
  }
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "plugin",
    name: props.name,
    description: props.description,
    metadata: {
      version: props.version
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_Plugin = __esm(() => {
  init_cli();
  init_stores3();
  init_jsx_lifecycle();
  init_jsx_dev_runtime3();
});

// ../../src/cli/jsx/components/Command.tsx
function Command(props) {
  if (props.handler) {
    try {
      onMount(() => {
        commandStore.registerCommand({
          name: props.name,
          description: props.description,
          handler: props.handler,
          args: props.args,
          flags: props.flags,
          aliases: props.aliases,
          path: []
        });
      });
    } catch {
      commandStore.registerCommand({
        name: props.name,
        description: props.description,
        handler: props.handler,
        args: props.args,
        flags: props.flags,
        aliases: props.aliases,
        path: []
      });
    }
  }
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "command",
    name: props.name,
    description: props.description,
    aliases: props.aliases,
    handler: props.handler,
    args: props.args,
    flags: props.flags,
    metadata: {
      hidden: props.hidden,
      interactive: props.interactive
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_Command = __esm(() => {
  init_cli();
  init_stores2();
  init_jsx_lifecycle();
  init_jsx_dev_runtime3();
});

// ../../src/cli/jsx/components/Arg.tsx
function Arg(props) {
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "arg",
    name: props.name,
    description: props.description,
    metadata: {
      required: props.required,
      type: props.type,
      choices: props.choices,
      default: props.default
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_Arg = __esm(() => {
  init_cli();
  init_jsx_dev_runtime3();
});

// ../../src/cli/jsx/components/Flag.tsx
function Flag(props) {
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "flag",
    name: props.name,
    description: props.description,
    metadata: {
      alias: props.alias,
      default: props.default
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_Flag = __esm(() => {
  init_cli();
  init_jsx_dev_runtime3();
});

// ../../src/cli/jsx/components/Option.tsx
function Option(props) {
  return /* @__PURE__ */ jsx(CommandLineScope, {
    type: "option",
    name: props.name,
    description: props.description,
    metadata: {
      alias: props.alias,
      type: props.type,
      default: props.default,
      choices: props.choices,
      required: props.required
    },
    children: props.children
  }, undefined, false, undefined, this);
}
var init_Option2 = __esm(() => {
  init_cli();
  init_jsx_dev_runtime3();
});

// ../../src/components/forms/text-input/jsx-dev-runtime.ts
var init_jsx_dev_runtime4 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/forms/text-input/TextInput.tsx
function TextInput(props) {
  const valueRune = props["bind:value"] || $state(props.value || "");
  const value6 = isBindableRune(valueRune) || isStateRune(valueRune) ? valueRune : $state(props.value || "");
  const cursor = $state(0);
  const offset = $state(0);
  const focused = $state(props.autoFocus || false);
  const showCursor = $state(true);
  const validationError = $state(null);
  const width = props.width || 30;
  const placeholder = props.placeholder || "";
  const echoMode = props.echoMode || "normal";
  const cursorStyle = props.cursorStyle || "bar";
  const charLimit = props.charLimit;
  const displayValue = $derived(() => {
    const val = getValue2(value6);
    if (echoMode === "password") {
      return "\u2022".repeat(val.length);
    } else if (echoMode === "none") {
      return "";
    }
    return val;
  });
  const visibleText = $derived(() => {
    const display = displayValue.value;
    const availableWidth = width - 2;
    if (stringWidth(display) <= availableWidth) {
      return display;
    }
    const beforeCursor = display.slice(0, cursor.value);
    const afterCursor = display.slice(cursor.value);
    if (stringWidth(beforeCursor) > availableWidth / 2) {
      const start5 = offset.value;
      return display.slice(start5, start5 + availableWidth);
    }
    return display.slice(offset.value, offset.value + availableWidth);
  });
  $effect2(() => {
    if (focused.value && cursorStyle === "blink") {
      const interval = setInterval(() => {
        showCursor.value = !showCursor.value;
      }, 500);
      return () => clearInterval(interval);
    }
  });
  $effect2(() => {
    if (props.validate) {
      const error2 = props.validate(getValue2(value6));
      validationError.value = error2;
    }
  });
  function getValue2(v) {
    if (isBindableRune(v) || isStateRune(v)) {
      return v.value;
    }
    return v || "";
  }
  function setValue(newValue) {
    if (charLimit && newValue.length > charLimit) {
      return;
    }
    if (props.transform) {
      newValue = props.transform(newValue);
    }
    if (isBindableRune(value6) || isStateRune(value6)) {
      value6.value = newValue;
    }
    props.onChange?.(newValue);
  }
  function handleKeyPress(key) {
    if (!focused.value || props.disabled)
      return;
    const currentValue = getValue2(value6);
    switch (key) {
      case "ArrowLeft":
        if (cursor.value > 0) {
          cursor.value--;
        }
        break;
      case "ArrowRight":
        if (cursor.value < currentValue.length) {
          cursor.value++;
        }
        break;
      case "Home":
        cursor.value = 0;
        offset.value = 0;
        break;
      case "End":
        cursor.value = currentValue.length;
        break;
      case "Backspace":
        if (cursor.value > 0) {
          const newValue = currentValue.slice(0, cursor.value - 1) + currentValue.slice(cursor.value);
          setValue(newValue);
          cursor.value--;
        }
        break;
      case "Delete":
        if (cursor.value < currentValue.length) {
          const newValue = currentValue.slice(0, cursor.value) + currentValue.slice(cursor.value + 1);
          setValue(newValue);
        }
        break;
      case "Enter":
        props.onSubmit?.(currentValue);
        break;
      default:
        if (key.length === 1) {
          const newValue = currentValue.slice(0, cursor.value) + key + currentValue.slice(cursor.value);
          setValue(newValue);
          cursor.value++;
        }
    }
  }
  const inputStyle = style({
    width,
    minHeight: 1,
    padding: { horizontal: 1 },
    border: focused.value ? "single" : "none",
    borderColor: validationError.value ? Colors.red : focused.value ? Colors.blue : Colors.gray,
    background: props.disabled ? Colors.gray : undefined
  });
  const cursorChar = getCursorChar(cursorStyle, showCursor.value);
  return jsx("interactive", {
    onKeyPress: handleKeyPress,
    onFocus: () => {
      focused.value = true;
      props.onFocus?.();
    },
    onBlur: () => {
      focused.value = false;
      props.onBlur?.();
    },
    focusable: !props.disabled,
    className: props.className,
    children: jsx("box", {
      style: inputStyle,
      children: renderInputContent()
    })
  });
  function renderInputContent() {
    const visible = visibleText.value;
    const cursorPos = cursor.value - offset.value;
    if (!visible && placeholder) {
      return jsx("text", {
        style: style({ color: Colors.gray, italic: true }),
        children: placeholder
      });
    }
    if (!focused.value || !showCursor.value) {
      return jsx("text", { children: visible });
    }
    const beforeCursor = visible.slice(0, cursorPos);
    const atCursor = visible[cursorPos] || " ";
    const afterCursor = visible.slice(cursorPos + 1);
    return jsx("hstack", {
      children: [
        beforeCursor && jsx("text", { children: beforeCursor }),
        jsx("text", {
          style: getCursorStyle(cursorStyle),
          children: cursorChar || atCursor
        }),
        afterCursor && jsx("text", { children: afterCursor })
      ].filter(Boolean)
    });
  }
  function getCursorChar(style2, show) {
    if (!show && style2 === "blink")
      return "";
    switch (style2) {
      case "block":
        return "\u2588";
      case "underline":
        return "_";
      case "bar":
        return "\u2502";
      case "blink":
        return "\u2502";
      default:
        return "\u2502";
    }
  }
  function getCursorStyle(cursorStyle2) {
    switch (cursorStyle2) {
      case "block":
        return style({ background: Colors.blue, color: Colors.black });
      case "underline":
        return style({ underline: true });
      default:
        return style({ color: Colors.blue });
    }
  }
}
var textInput = (props) => /* @__PURE__ */ jsx(TextInput, {
  ...props
}, undefined, false, undefined, this), passwordInput = (props) => /* @__PURE__ */ jsx(TextInput, {
  ...props,
  echoMode: "password"
}, undefined, false, undefined, this), emailInput = (props) => /* @__PURE__ */ jsx(TextInput, {
  ...props,
  placeholder: "email@example.com"
}, undefined, false, undefined, this), numberInput = (props) => /* @__PURE__ */ jsx(TextInput, {
  ...props,
  transform: (v) => v.replace(/[^0-9]/g, "")
}, undefined, false, undefined, this);
var init_TextInput = __esm(() => {
  init_jsx();
  init_runes();
  init_runes();
  init_styling();
  init_string_width();
  init_jsx_dev_runtime4();
});

// ../../src/components/forms/text-input/index.ts
var init_text_input = __esm(() => {
  init_TextInput();
});

// ../../src/components/forms/button/jsx-dev-runtime.ts
var init_jsx_dev_runtime5 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/forms/button/Button.tsx
function Button(props) {
  const focused = $state(props.autoFocus || false);
  const pressed = $state(false);
  const hovering = $state(false);
  const variant = props.variant || "secondary";
  const size23 = props.size || "medium";
  const disabled = props.disabled || props.loading;
  const buttonStyle = $derived(() => {
    const baseStyle = getVariantStyle(variant);
    const sizeStyle = getSizeStyle(size23);
    const stateStyle = getStateStyle(focused.value, pressed.value, hovering.value, disabled);
    return style({
      ...baseStyle,
      ...sizeStyle,
      ...stateStyle,
      width: props.fullWidth ? "100%" : undefined,
      cursor: disabled ? "not-allowed" : "pointer"
    });
  });
  async function handleClick() {
    if (disabled)
      return;
    pressed.value = true;
    try {
      await props.onClick?.();
    } finally {
      pressed.value = false;
    }
  }
  function handleKeyPress(key) {
    if (disabled)
      return;
    if (key === "Enter" || key === " ") {
      handleClick();
    }
  }
  function renderContent() {
    const content = props.loading ? renderLoadingSpinner() : props.children;
    if (!props.icon) {
      return typeof content === "string" ? jsx("text", { children: content }) : content;
    }
    const icon = typeof props.icon === "string" ? jsx("text", { children: props.icon }) : props.icon;
    const elements = props.iconPosition === "right" ? [content, icon] : [icon, content];
    return jsx("hstack", {
      gap: 1,
      children: elements
    });
  }
  function renderLoadingSpinner() {
    return jsx("spinner", {
      type: "dots",
      size: "small"
    });
  }
  return jsx("interactive", {
    onKeyPress: handleKeyPress,
    onMouseEnter: () => {
      hovering.value = true;
    },
    onMouseLeave: () => {
      hovering.value = false;
    },
    onFocus: () => {
      focused.value = true;
      props.onFocus?.();
    },
    onBlur: () => {
      focused.value = false;
      props.onBlur?.();
    },
    onClick: handleClick,
    focusable: !disabled,
    className: props.className,
    children: jsx("box", {
      style: buttonStyle.value,
      children: renderContent()
    })
  });
}
function getVariantStyle(variant) {
  const variants = {
    primary: {
      background: Colors.blue,
      color: Colors.white,
      borderColor: Colors.blue
    },
    secondary: {
      background: Colors.gray,
      color: Colors.white,
      borderColor: Colors.gray
    },
    success: {
      background: Colors.green,
      color: Colors.white,
      borderColor: Colors.green
    },
    danger: {
      background: Colors.red,
      color: Colors.white,
      borderColor: Colors.red
    },
    warning: {
      background: Colors.yellow,
      color: Colors.black,
      borderColor: Colors.yellow
    },
    info: {
      background: Colors.cyan,
      color: Colors.white,
      borderColor: Colors.cyan
    },
    ghost: {
      background: "transparent",
      color: Colors.white,
      borderColor: Colors.gray
    }
  };
  return variants[variant];
}
function getSizeStyle(size23) {
  const sizes = {
    small: {
      padding: { horizontal: 2, vertical: 0 },
      minHeight: 1
    },
    medium: {
      padding: { horizontal: 3, vertical: 1 },
      minHeight: 3
    },
    large: {
      padding: { horizontal: 4, vertical: 2 },
      minHeight: 5
    }
  };
  return sizes[size23];
}
function getStateStyle(focused, pressed, hovering, disabled) {
  const stateStyle = {
    border: "single",
    opacity: disabled ? 0.5 : 1
  };
  if (pressed) {
    stateStyle.transform = "scale(0.95)";
  }
  if (focused) {
    stateStyle.borderStyle = "double";
    stateStyle.borderColor = Colors.white;
  }
  if (hovering && !disabled) {
    stateStyle.brightness = 1.2;
  }
  return stateStyle;
}
function ButtonGroup({ children: children3 }) {
  return jsx("hstack", {
    gap: 2,
    children: children3
  });
}
function SubmitCancelButtons(props) {
  return /* @__PURE__ */ jsx(ButtonGroup, {
    children: [
      /* @__PURE__ */ jsx(Button, {
        variant: "primary",
        onClick: props.onSubmit,
        loading: props.loading,
        children: props.submitText || "Submit"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Button, {
        variant: "secondary",
        onClick: props.onCancel,
        disabled: props.loading,
        children: props.cancelText || "Cancel"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
var button = (props) => /* @__PURE__ */ jsx(Button, {
  ...props
}, undefined, false, undefined, this), primaryButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "primary"
}, undefined, false, undefined, this), secondaryButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "secondary"
}, undefined, false, undefined, this), successButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "success"
}, undefined, false, undefined, this), dangerButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "danger"
}, undefined, false, undefined, this), warningButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "warning"
}, undefined, false, undefined, this), infoButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "info"
}, undefined, false, undefined, this), ghostButton = (props) => /* @__PURE__ */ jsx(Button, {
  ...props,
  variant: "ghost"
}, undefined, false, undefined, this);
var init_Button = __esm(() => {
  init_jsx();
  init_runes();
  init_styling();
  init_jsx_dev_runtime5();
});

// ../../src/components/forms/button/index.ts
var init_button = __esm(() => {
  init_Button();
});

// ../../src/components/layout/box/jsx-dev-runtime.ts
var init_jsx_dev_runtime6 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/layout/box/Box.tsx
function Box(props) {
  const focused = $state(false);
  const hovering = $state(false);
  const boxStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.width !== undefined)
      baseStyle.width = props.width;
    if (props.height !== undefined)
      baseStyle.height = props.height;
    if (props.minWidth !== undefined)
      baseStyle.minWidth = props.minWidth;
    if (props.minHeight !== undefined)
      baseStyle.minHeight = props.minHeight;
    if (props.maxWidth !== undefined)
      baseStyle.maxWidth = props.maxWidth;
    if (props.maxHeight !== undefined)
      baseStyle.maxHeight = props.maxHeight;
    if (props.padding !== undefined) {
      if (typeof props.padding === "number") {
        baseStyle.padding = props.padding;
      } else {
        baseStyle.padding = props.padding;
      }
    }
    if (props.margin !== undefined) {
      if (typeof props.margin === "number") {
        baseStyle.margin = props.margin;
      } else {
        baseStyle.margin = props.margin;
      }
    }
    if (props.border) {
      baseStyle.border = props.border === true ? "single" : props.border;
    }
    if (props.borderColor)
      baseStyle.borderColor = props.borderColor;
    if (props.borderStyle)
      baseStyle.borderStyle = props.borderStyle;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient) {
      baseStyle.gradient = props.gradient;
    }
    if (props.align)
      baseStyle.align = props.align;
    if (props.justify)
      baseStyle.justify = props.justify;
    if (props.gap !== undefined)
      baseStyle.gap = props.gap;
    if (props.wrap !== undefined)
      baseStyle.wrap = props.wrap;
    if (props.hidden)
      baseStyle.display = "none";
    if (props.opacity !== undefined)
      baseStyle.opacity = props.opacity;
    if (focused.value && props.focusable) {
      baseStyle.borderColor = Colors.blue;
      baseStyle.borderStyle = "double";
    }
    if (hovering.value && props.onClick) {
      baseStyle.brightness = 1.1;
    }
    return style(baseStyle);
  });
  const Container = props.direction === "horizontal" ? "hstack" : "vstack";
  if (props.focusable || props.onClick) {
    return jsx("interactive", {
      focusable: props.focusable,
      onClick: props.onClick,
      onFocus: () => {
        focused.value = true;
        props.onFocus?.();
      },
      onBlur: () => {
        focused.value = false;
        props.onBlur?.();
      },
      onMouseEnter: () => {
        hovering.value = true;
      },
      onMouseLeave: () => {
        hovering.value = false;
      },
      className: props.className,
      children: jsx(Container, {
        style: boxStyle.value,
        gap: props.gap,
        wrap: props.wrap,
        children: props.children
      })
    });
  }
  return jsx(Container, {
    style: boxStyle.value,
    gap: props.gap,
    wrap: props.wrap,
    className: props.className,
    children: props.children
  });
}
var box2 = (props) => /* @__PURE__ */ jsx(Box, {
  ...props
}, undefined, false, undefined, this), card = (props) => /* @__PURE__ */ jsx(Box, {
  padding: 2,
  border: "rounded",
  borderColor: Colors.gray,
  background: Colors.black,
  ...props
}, undefined, false, undefined, this), centerBox = (props) => /* @__PURE__ */ jsx(Box, {
  align: "center",
  justify: "center",
  width: "100%",
  height: "100%",
  ...props
}, undefined, false, undefined, this), scrollBox = (props) => /* @__PURE__ */ jsx(Box, {
  scrollable: true,
  border: "single",
  borderColor: Colors.gray,
  ...props
}, undefined, false, undefined, this);
var init_Box = __esm(() => {
  init_runtime3();
  init_runes();
  init_styling();
  init_jsx_dev_runtime6();
});

// ../../src/components/display/text/jsx-dev-runtime.ts
var init_jsx_dev_runtime7 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/display/text/Text.tsx
function Text(props) {
  const content = String(props.children);
  const textStyle = $derived(() => {
    const baseStyle = {
      ...props.style
    };
    if (props.color)
      baseStyle.color = props.color;
    if (props.background)
      baseStyle.background = props.background;
    if (props.gradient)
      baseStyle.gradient = props.gradient;
    if (props.bold)
      baseStyle.bold = true;
    if (props.italic)
      baseStyle.italic = true;
    if (props.underline)
      baseStyle.underline = true;
    if (props.strikethrough)
      baseStyle.strikethrough = true;
    if (props.dim)
      baseStyle.dim = true;
    if (props.bright)
      baseStyle.bright = true;
    if (props.inverse)
      baseStyle.inverse = true;
    if (props.blink)
      baseStyle.blink = true;
    if (props.align)
      baseStyle.textAlign = props.align;
    if (props.width)
      baseStyle.width = props.width;
    return style(baseStyle);
  });
  const processedText = $derived(() => {
    let text2 = content;
    if (props.truncate && props.width) {
      const maxWidth = typeof props.truncate === "number" ? props.truncate : props.width;
      if (stringWidth(text2) > maxWidth) {
        const ellipsis = props.ellipsis || "...";
        const ellipsisWidth = stringWidth(ellipsis);
        const availableWidth = maxWidth - ellipsisWidth;
        while (stringWidth(text2) > availableWidth && text2.length > 0) {
          text2 = text2.slice(0, -1);
        }
        text2 += ellipsis;
      }
    }
    if (props.wrap && props.width) {}
    return text2;
  });
  if (props.rainbow) {
    return /* @__PURE__ */ jsx(RainbowText, {
      ...props,
      children: content
    }, undefined, false, undefined, this);
  }
  if (props.pulse) {
    return /* @__PURE__ */ jsx(PulsingText, {
      ...props,
      children: content
    }, undefined, false, undefined, this);
  }
  return jsx("text", {
    style: textStyle.value,
    className: props.className,
    children: processedText.value
  });
}
function RainbowText(props) {
  const colors2 = [
    Colors.red,
    Colors.yellow,
    Colors.green,
    Colors.cyan,
    Colors.blue,
    Colors.magenta
  ];
  const colorIndex = $state(0);
  $effect(() => {
    const interval = setInterval(() => {
      colorIndex.value = (colorIndex.value + 1) % colors2.length;
    }, 100);
    return () => clearInterval(interval);
  });
  return /* @__PURE__ */ jsx(Text, {
    ...props,
    color: colors2[colorIndex.value],
    rainbow: false
  }, undefined, false, undefined, this);
}
function PulsingText(props) {
  const bright = $state(false);
  $effect(() => {
    const interval = setInterval(() => {
      bright.value = !bright.value;
    }, 500);
    return () => clearInterval(interval);
  });
  return /* @__PURE__ */ jsx(Text, {
    ...props,
    bright: bright.value,
    pulse: false
  }, undefined, false, undefined, this);
}
function Heading(props) {
  const { level = 1, ...textProps } = props;
  const styles = {
    1: { bold: true, color: Colors.white },
    2: { bold: true, color: Colors.white },
    3: { bold: true, color: Colors.gray },
    4: { color: Colors.white },
    5: { color: Colors.gray },
    6: { color: Colors.gray, dim: true }
  };
  return /* @__PURE__ */ jsx(Text, {
    ...styles[level],
    ...textProps
  }, undefined, false, undefined, this);
}
function Code(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.green,
    background: Colors.black,
    style: { padding: { horizontal: 1 } },
    ...props
  }, undefined, false, undefined, this);
}
function Link(props) {
  const hovering = $state(false);
  return jsx("interactive", {
    onMouseEnter: () => {
      hovering.value = true;
    },
    onMouseLeave: () => {
      hovering.value = false;
    },
    onClick: props.onClick,
    children: /* @__PURE__ */ jsx(Text, {
      color: Colors.blue,
      underline: hovering.value,
      bright: hovering.value,
      ...props
    }, undefined, false, undefined, this)
  });
}
function Label(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.gray,
    ...props
  }, undefined, false, undefined, this);
}
function Success(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.green,
    ...props
  }, undefined, false, undefined, this);
}
function Error4(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.red,
    ...props
  }, undefined, false, undefined, this);
}
function Warning2(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.yellow,
    ...props
  }, undefined, false, undefined, this);
}
function Info2(props) {
  return /* @__PURE__ */ jsx(Text, {
    color: Colors.blue,
    ...props
  }, undefined, false, undefined, this);
}
var text2 = (props) => /* @__PURE__ */ jsx(Text, {
  ...props
}, undefined, false, undefined, this), heading = (props) => /* @__PURE__ */ jsx(Heading, {
  ...props
}, undefined, false, undefined, this), code = (props) => /* @__PURE__ */ jsx(Code, {
  ...props
}, undefined, false, undefined, this), link = (props) => /* @__PURE__ */ jsx(Link, {
  ...props
}, undefined, false, undefined, this);
var init_Text = __esm(() => {
  init_jsx();
  init_runes();
  init_styling();
  init_string_width();
  init_jsx_dev_runtime7();
});

// ../../src/components/layout/box/index.ts
var init_box = __esm(() => {
  init_Box();
});

// ../../src/components/layout/flex/jsx-dev-runtime.ts
var init_jsx_dev_runtime8 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/layout/flex/Flex.tsx
function Flex(props) {
  const {
    direction = "row",
    reverse: reverse4 = false,
    wrap = false,
    gap,
    align,
    justify,
    children: children3,
    ...boxProps
  } = props;
  const finalDirection = reverse4 ? direction === "row" ? "row-reverse" : "column-reverse" : direction;
  const container = direction === "row" ? "hstack" : "vstack";
  return jsx(container, {
    ...boxProps,
    gap,
    wrap: wrap === true ? true : wrap === "reverse" ? "reverse" : false,
    align,
    justify,
    children: children3
  });
}
function FlexItem(props) {
  const {
    grow,
    shrink,
    basis,
    alignSelf,
    children: children3,
    ...boxProps
  } = props;
  const style2 = {
    ...boxProps.style
  };
  if (grow !== undefined)
    style2.flexGrow = grow;
  if (shrink !== undefined)
    style2.flexShrink = shrink;
  if (basis !== undefined)
    style2.flexBasis = basis;
  if (alignSelf)
    style2.alignSelf = alignSelf;
  return /* @__PURE__ */ jsx(Box, {
    ...boxProps,
    style: style2,
    children: children3
  }, undefined, false, undefined, this);
}
function Row(props) {
  return /* @__PURE__ */ jsx(Flex, {
    ...props,
    direction: "row"
  }, undefined, false, undefined, this);
}
function Column(props) {
  return /* @__PURE__ */ jsx(Flex, {
    ...props,
    direction: "column"
  }, undefined, false, undefined, this);
}
function SpaceBetween(props) {
  return /* @__PURE__ */ jsx(Row, {
    ...props,
    justify: "between"
  }, undefined, false, undefined, this);
}
function Stack(props) {
  const { spacing, ...flexProps } = props;
  return /* @__PURE__ */ jsx(Column, {
    ...flexProps,
    gap: spacing
  }, undefined, false, undefined, this);
}
function Grid(props) {
  const { columns = 2, gap = 1, children: children3, ...boxProps } = props;
  const rows = [];
  for (let i = 0;i < children3.length; i += columns) {
    rows.push(children3.slice(i, i + columns));
  }
  return /* @__PURE__ */ jsx(Column, {
    gap,
    ...boxProps,
    children: rows.map((row, i) => /* @__PURE__ */ jsx(Row, {
      gap,
      children: row.map((child, j) => /* @__PURE__ */ jsx(FlexItem, {
        grow: 1,
        basis: 0,
        children: child
      }, j, false, undefined, this))
    }, i, false, undefined, this))
  }, undefined, false, undefined, this);
}
function Spacer({ size: size23 = 1 }) {
  return /* @__PURE__ */ jsx(FlexItem, {
    grow: size23
  }, undefined, false, undefined, this);
}
function Sidebar(props) {
  const { sidebar, sidebarWidth = 20, content, gap = 2, ...boxProps } = props;
  return /* @__PURE__ */ jsx(Row, {
    gap,
    ...boxProps,
    children: [
      /* @__PURE__ */ jsx(Box, {
        width: sidebarWidth,
        children: sidebar
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(FlexItem, {
        grow: 1,
        children: content
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
function Header(props) {
  const {
    header,
    content,
    footer,
    headerHeight = 3,
    footerHeight = 3,
    gap = 0,
    ...boxProps
  } = props;
  return /* @__PURE__ */ jsx(Column, {
    gap,
    height: "100%",
    ...boxProps,
    children: [
      /* @__PURE__ */ jsx(Box, {
        height: headerHeight,
        children: header
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(FlexItem, {
        grow: 1,
        children: content
      }, undefined, false, undefined, this),
      footer && /* @__PURE__ */ jsx(Box, {
        height: footerHeight,
        children: footer
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}
var init_Flex = __esm(() => {
  init_jsx();
  init_box();
  init_jsx_dev_runtime8();
});

// ../../src/tea/base.ts
var keyBinding = (keys9, help, msg, disabled = false) => ({
  keys: keys9,
  help: { key: help[0], desc: help[1] },
  msg,
  disabled
}), matchesKeyPattern = (key, pattern2) => {
  if (key.key === pattern2 || key.runes === pattern2) {
    return true;
  }
  if (pattern2.includes("+")) {
    const parts2 = pattern2.split("+");
    const mainKey = parts2[parts2.length - 1];
    const modifiers = parts2.slice(0, -1);
    const keyMatches = key.key === mainKey || key.runes === mainKey;
    const ctrlMatches = modifiers.includes("ctrl") === Boolean(key.ctrl);
    const altMatches = modifiers.includes("alt") === Boolean(key.alt);
    const shiftMatches = modifiers.includes("shift") === Boolean(key.shift);
    const metaMatches = modifiers.includes("meta") === Boolean(key.meta);
    return keyMatches && ctrlMatches && altMatches && shiftMatches && metaMatches;
  }
  return false;
}, matchKeyBinding = (key, keyMap) => {
  for (const binding of Object.values(keyMap)) {
    if (!binding || binding.disabled)
      continue;
    for (const pattern2 of binding.keys) {
      if (matchesKeyPattern(key, pattern2)) {
        return binding.msg;
      }
    }
  }
  return null;
}, generateComponentId = (prefix) => {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return `${prefix}-${crypto.randomUUID()}`;
  }
  return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}, createDefaultStyles = (overrides) => {
  const defaults = {
    base: style(),
    focused: style().bold().foreground(Colors.white).background(Colors.blue),
    disabled: style().faint(),
    ...overrides
  };
  return defaults;
}, mergeStyles = (...styles) => {
  return styles.reduce((merged, style2) => ({
    ...merged,
    ...style2
  }), createDefaultStyles());
}, createKeyMap = (bindings) => {
  const map33 = {};
  bindings?.forEach((binding) => {
    map33[binding.help.key.toLowerCase()] = binding;
  });
  return map33;
};
var init_base = __esm(() => {
  init_styling();
});

// ../../src/components/data/list/jsx-dev-runtime.ts
var init_jsx_dev_runtime9 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/data/list/List.tsx
var createKeyMap2 = () => ({
  up: keyBinding(["up", "k", "ctrl+p"], ["\u2191", "Move up"], { _tag: "CursorUp" }),
  down: keyBinding(["down", "j", "ctrl+n"], ["\u2193", "Move down"], { _tag: "CursorDown" }),
  home: keyBinding(["home", "g"], ["Home", "Go to first"], { _tag: "CursorFirst" }),
  end: keyBinding(["end", "G"], ["End", "Go to last"], { _tag: "CursorLast" }),
  pageUp: keyBinding(["pageup", "ctrl+b"], ["PgUp", "Page up"], { _tag: "PageUp" }),
  pageDown: keyBinding(["pagedown", "ctrl+f"], ["PgDn", "Page down"], { _tag: "PageDown" }),
  select: keyBinding(["enter", " "], ["Enter", "Select item"], { _tag: "Select" }),
  selectAll: keyBinding(["ctrl+a"], ["Ctrl+A", "Select all"], { _tag: "SelectAll" }),
  deselectAll: keyBinding(["ctrl+d"], ["Ctrl+D", "Deselect all"], { _tag: "DeselectAll" }),
  filter: keyBinding(["/"], ["/", "Toggle filter"], { _tag: "ToggleFilter" }),
  clearFilter: keyBinding(["escape"], ["Esc", "Clear filter"], { _tag: "ClearFilter" })
}), filterItems = (items, filter18) => {
  if (!filter18) {
    return items.map((_, i) => i);
  }
  const lowerFilter = filter18.toLowerCase();
  return items.map((item, index) => ({ item, index })).filter(({ item }) => item.label.toLowerCase().includes(lowerFilter)).map(({ index }) => index);
}, calculateViewport = (cursor, viewportStart, viewportHeight, totalItems) => {
  if (totalItems === 0)
    return 0;
  if (cursor < viewportStart) {
    return cursor;
  }
  if (cursor >= viewportStart + viewportHeight) {
    return Math.max(0, cursor - viewportHeight + 1);
  }
  return viewportStart;
}, updateCursorAndViewport = (model, newCursor, visibleItems) => {
  const newViewportStart = calculateViewport(newCursor, model.viewportStart, model.viewportHeight, visibleItems);
  return [{
    ...model,
    cursor: newCursor,
    viewportStart: newViewportStart
  }, []];
}, notifySelectionChange = (model, newSelected) => {
  if (model.props.onSelectionChange) {
    model.props.onSelectionChange(Array.from(newSelected));
  }
  if (model.props.onSelect) {
    const selectedItems = model.items.filter((item) => newSelected.has(item.id));
    model.props.onSelect(selectedItems);
  }
}, createListStyles = (overrides) => {
  const base = createDefaultStyles();
  return {
    ...base,
    item: style(),
    selectedItem: style().foreground(Colors.white).background(Colors.blue),
    cursorItem: style().bold(),
    disabledItem: style().faint(),
    statusBar: style().foreground(Colors.gray).italic(),
    filter: style().foreground(Colors.cyan),
    noItems: style().foreground(Colors.gray).italic(),
    container: style(),
    ...overrides
  };
}, FilterBar = ({ filter: filter18, focused, style: filterStyle }) => {
  const prefix = focused ? "> " : "/ ";
  const cursor = focused ? "\u2588" : "";
  return /* @__PURE__ */ jsx(Text, {
    style: filterStyle,
    children: [
      prefix,
      filter18,
      cursor
    ]
  }, undefined, true, undefined, this);
}, StatusBar = ({ model, style: statusStyle }) => {
  const selectedCount = model.selected.size;
  const totalCount = model.items.length;
  const filteredCount = model.filteredIndices.length;
  let status3 = `${model.cursor + 1}/${filteredCount}`;
  if (filteredCount !== totalCount) {
    status3 += ` (${totalCount} total)`;
  }
  if (selectedCount > 0) {
    status3 += ` \u2022 ${selectedCount} selected`;
  }
  return /* @__PURE__ */ jsx(Text, {
    style: statusStyle,
    children: status3
  }, undefined, false, undefined, this);
}, DefaultItemRenderer = ({
  item,
  isSelected,
  isCursor,
  multiSelect
}) => {
  const prefix = multiSelect ? isSelected ? "[x] " : "[ ] " : isCursor ? "> " : "  ";
  return /* @__PURE__ */ jsx(Text, {
    children: [
      prefix,
      item.label
    ]
  }, undefined, true, undefined, this);
}, List = (props = {}) => {
  const keyMap = createKeyMap2();
  const styles = createListStyles(props.styles);
  const items = props.items || [];
  return {
    id: generateComponentId("list"),
    init() {
      const filteredIndices = filterItems(items, "");
      return exports_Effect.succeed([
        {
          id: generateComponentId("list"),
          props,
          items,
          cursor: 0,
          selected: new Set,
          filter: "",
          filteredIndices,
          viewportStart: 0,
          viewportHeight: props.height ?? 10,
          filterFocused: false,
          focused: false,
          width: props.width ?? 40,
          height: props.height ?? 10
        },
        []
      ]);
    },
    update(msg, model) {
      return exports_Effect.succeed((() => {
        const visibleItems = model.filteredIndices.length;
        switch (msg._tag) {
          case "CursorUp": {
            if (visibleItems === 0)
              return [model, []];
            const newCursor = model.cursor > 0 ? model.cursor - 1 : visibleItems - 1;
            return updateCursorAndViewport(model, newCursor, visibleItems);
          }
          case "CursorDown": {
            if (visibleItems === 0)
              return [model, []];
            const newCursor = model.cursor < visibleItems - 1 ? model.cursor + 1 : 0;
            return updateCursorAndViewport(model, newCursor, visibleItems);
          }
          case "CursorFirst": {
            if (visibleItems === 0)
              return [model, []];
            return [{
              ...model,
              cursor: 0,
              viewportStart: 0
            }, []];
          }
          case "CursorLast": {
            if (visibleItems === 0)
              return [model, []];
            const lastIndex = visibleItems - 1;
            return updateCursorAndViewport(model, lastIndex, visibleItems);
          }
          case "PageUp": {
            if (visibleItems === 0)
              return [model, []];
            const newCursor = Math.max(0, model.cursor - model.viewportHeight);
            return updateCursorAndViewport(model, newCursor, visibleItems);
          }
          case "PageDown": {
            if (visibleItems === 0)
              return [model, []];
            const newCursor = Math.min(visibleItems - 1, model.cursor + model.viewportHeight);
            return updateCursorAndViewport(model, newCursor, visibleItems);
          }
          case "Select": {
            if (visibleItems === 0 || model.filterFocused)
              return [model, []];
            const actualIndex = model.filteredIndices[model.cursor];
            const item = model.items[actualIndex];
            if (!item || item.disabled)
              return [model, []];
            const newSelected = new Set(model.selected);
            if (model.props.multiSelect) {
              if (newSelected.has(item.id)) {
                newSelected.delete(item.id);
              } else {
                newSelected.add(item.id);
              }
            } else {
              newSelected.clear();
              newSelected.add(item.id);
            }
            notifySelectionChange(model, newSelected);
            return [{
              ...model,
              selected: newSelected
            }, []];
          }
          case "SelectAll": {
            if (!model.props.multiSelect)
              return [model, []];
            const newSelected = new Set;
            for (const index of model.filteredIndices) {
              const item = model.items[index];
              if (item && !item.disabled) {
                newSelected.add(item.id);
              }
            }
            notifySelectionChange(model, newSelected);
            return [{
              ...model,
              selected: newSelected
            }, []];
          }
          case "DeselectAll": {
            notifySelectionChange(model, new Set);
            return [{
              ...model,
              selected: new Set
            }, []];
          }
          case "SetFilter": {
            const newFilteredIndices = filterItems(model.items, msg.filter);
            const newCursor = Math.min(model.cursor, Math.max(0, newFilteredIndices.length - 1));
            return [{
              ...model,
              filter: msg.filter,
              filteredIndices: newFilteredIndices,
              cursor: newCursor,
              viewportStart: 0
            }, []];
          }
          case "ClearFilter": {
            const newFilteredIndices = filterItems(model.items, "");
            return [{
              ...model,
              filter: "",
              filteredIndices: newFilteredIndices,
              filterFocused: false,
              cursor: 0,
              viewportStart: 0
            }, []];
          }
          case "ToggleFilter": {
            return [{
              ...model,
              filterFocused: !model.filterFocused
            }, []];
          }
          case "Focus": {
            const filteredIndices = filterItems(model.items, model.filter);
            return [{
              ...model,
              focused: true,
              filteredIndices
            }, []];
          }
          case "Blur": {
            return [{
              ...model,
              focused: false,
              filterFocused: false
            }, []];
          }
          default:
            return [model, []];
        }
      })());
    },
    view(model) {
      const lines = [];
      if ((model.props.showFilter ?? false) && (model.filter || model.filterFocused)) {
        lines.push(/* @__PURE__ */ jsx(FilterBar, {
          filter: model.filter,
          focused: model.filterFocused,
          style: styles.filter
        }, undefined, false, undefined, this));
      }
      if (model.filteredIndices.length === 0) {
        const message = model.filter ? `No items match "${model.filter}"` : "No items";
        lines.push(/* @__PURE__ */ jsx(Text, {
          style: styles.noItems,
          children: message
        }, undefined, false, undefined, this));
      } else {
        const viewportEnd = Math.min(model.viewportStart + model.viewportHeight, model.filteredIndices.length);
        for (let i = model.viewportStart;i < viewportEnd; i++) {
          const actualIndex = model.filteredIndices[i];
          const item = model.items[actualIndex];
          if (!item)
            continue;
          const isSelected = model.selected.has(item.id);
          const isCursor = i === model.cursor;
          const isFocused = model.focused && isCursor;
          let itemView;
          if (model.props.itemRenderer) {
            itemView = model.props.itemRenderer(item, isSelected, isFocused);
          } else {
            itemView = /* @__PURE__ */ jsx(DefaultItemRenderer, {
              item,
              isSelected,
              isCursor,
              multiSelect: model.props.multiSelect ?? false
            }, undefined, false, undefined, this);
          }
          let itemStyle = styles.item;
          if (item.disabled) {
            itemStyle = itemStyle.merge(styles.disabledItem);
          } else if (isSelected) {
            itemStyle = itemStyle.merge(styles.selectedItem);
          }
          if (isCursor) {
            itemStyle = itemStyle.merge(styles.cursorItem);
          }
          if (isFocused) {
            itemStyle = itemStyle.merge(styles.focused);
          }
          lines.push(/* @__PURE__ */ jsx(Box, {
            width: model.width,
            style: itemStyle,
            children: itemView
          }, undefined, false, undefined, this));
        }
        const remainingLines = model.viewportHeight - (viewportEnd - model.viewportStart);
        for (let i = 0;i < remainingLines; i++) {
          lines.push(/* @__PURE__ */ jsx(Text, {
            children: " ".repeat(model.width)
          }, undefined, false, undefined, this));
        }
      }
      if (model.props.showStatusBar ?? true) {
        lines.push(/* @__PURE__ */ jsx(StatusBar, {
          model,
          style: styles.statusBar
        }, undefined, false, undefined, this));
      }
      return /* @__PURE__ */ jsx(Box, {
        style: styles.container,
        children: vstack(...lines)
      }, undefined, false, undefined, this);
    },
    focus() {
      return exports_Effect.succeed(exports_Effect.succeed({ _tag: "Focus" }));
    },
    blur() {
      return exports_Effect.succeed(exports_Effect.succeed({ _tag: "Blur" }));
    },
    focused(model) {
      return model.focused;
    },
    setSize(width, height) {
      return exports_Effect.void;
    },
    getSize(model) {
      return { width: model.width, height: model.height };
    },
    handleKey(key, model) {
      if (model.filterFocused) {
        if (key.key === "escape") {
          return { _tag: "ClearFilter" };
        } else if (key.key === "enter") {
          return { _tag: "ToggleFilter" };
        } else if (key.key === "backspace" && model.filter.length > 0) {
          return { _tag: "SetFilter", filter: model.filter.slice(0, -1) };
        } else if (key.runes && key.runes.length === 1 && !key.ctrl && !key.alt) {
          return { _tag: "SetFilter", filter: model.filter + key.runes };
        }
        return null;
      }
      return matchKeyBinding(key, keyMap);
    }
  };
}, SingleSelectList = ({
  items,
  ...props
}) => {
  return List({
    ...props,
    items,
    multiSelect: false
  });
}, MultiSelectList = ({
  items,
  ...props
}) => {
  return List({
    ...props,
    items,
    multiSelect: true
  });
};
var init_List2 = __esm(() => {
  init_esm2();
  init_styling();
  init_view();
  init_Text();
  init_Box();
  init_base();
  init_jsx_dev_runtime9();
});

// ../../src/components/feedback/spinner/jsx-dev-runtime.ts
var init_jsx_dev_runtime10 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/feedback/spinner/Spinner.tsx
function Spinner(props) {
  const type2 = props.type || "dots";
  const color = props.color || Colors.blue;
  const size23 = props.size || "medium";
  const speed = props.speed || 80;
  const frameIndex = $state(0);
  const frames = SPINNER_FRAMES[type2];
  $effect2(() => {
    const interval = setInterval(() => {
      frameIndex.value = (frameIndex.value + 1) % frames.length;
    }, speed);
    return () => clearInterval(interval);
  });
  const sizeStyles = {
    small: { fontSize: 12 },
    medium: { fontSize: 16 },
    large: { fontSize: 24 }
  };
  const spinnerStyle = style({
    color,
    ...sizeStyles[size23]
  });
  if (props.text) {
    return jsx("hstack", {
      gap: 1,
      className: props.className,
      children: [
        jsx("text", {
          style: spinnerStyle,
          children: frames[frameIndex.value]
        }),
        jsx("text", {
          children: props.text
        })
      ]
    });
  }
  return jsx("text", {
    style: spinnerStyle,
    className: props.className,
    children: frames[frameIndex.value]
  });
}
function SpinnerWithMessage(props) {
  const { message, messageColor = Colors.gray, ...spinnerProps } = props;
  return jsx("vstack", {
    align: "center",
    gap: 1,
    children: [
      /* @__PURE__ */ jsx(Spinner, {
        ...spinnerProps
      }, undefined, false, undefined, this),
      jsx("text", {
        style: style({ color: messageColor }),
        children: message
      })
    ]
  });
}
function LoadingOverlay(props) {
  if (!props.loading) {
    return props.children || jsx("text", { children: "" });
  }
  return jsx("box", {
    style: style({
      position: "absolute",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: "rgba(0, 0, 0, 0.7)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    }),
    children: jsx("vstack", {
      align: "center",
      gap: 2,
      children: [
        /* @__PURE__ */ jsx(Spinner, {
          size: "large",
          ...props.spinnerProps
        }, undefined, false, undefined, this),
        props.message && jsx("text", {
          style: style({ color: Colors.white }),
          children: props.message
        })
      ].filter(Boolean)
    })
  });
}
var SPINNER_FRAMES, spinner = (props) => /* @__PURE__ */ jsx(Spinner, {
  ...props
}, undefined, false, undefined, this), loadingSpinner = (props) => /* @__PURE__ */ jsx(Spinner, {
  ...props,
  text: "Loading..."
}, undefined, false, undefined, this), savingSpinner = (props) => /* @__PURE__ */ jsx(Spinner, {
  ...props,
  text: "Saving..."
}, undefined, false, undefined, this), processingSpinner = (props) => /* @__PURE__ */ jsx(Spinner, {
  ...props,
  text: "Processing..."
}, undefined, false, undefined, this);
var init_Spinner = __esm(() => {
  init_jsx();
  init_runes();
  init_styling();
  init_jsx_dev_runtime10();
  SPINNER_FRAMES = {
    dots: ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"],
    line: ["-", "\\", "|", "/"],
    circle: ["\u25D0", "\u25D3", "\u25D1", "\u25D2"],
    bounce: ["\u2801", "\u2802", "\u2804", "\u2802"],
    pulse: ["\xB7", "\u2022", "\u25CF", "\u2022"],
    wave: ["\u2581", "\u2582", "\u2583", "\u2584", "\u2585", "\u2586", "\u2587", "\u2588", "\u2587", "\u2586", "\u2585", "\u2584", "\u2583", "\u2582"]
  };
});

// ../../src/components/forms/file-picker/jsx-dev-runtime.ts
var init_jsx_dev_runtime11 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/forms/file-picker/FilePicker.tsx
var defaultProps, PathUtils, shouldShowFile = (item, props, showHidden) => {
  if (item.hidden && !showHidden) {
    return false;
  }
  if (props.allowedExtensions && !item.isDirectory) {
    const ext = PathUtils.getExtension(item.name);
    if (!props.allowedExtensions.includes(ext)) {
      return false;
    }
  }
  return true;
}, processItems = (items, props, showHidden) => {
  return items.filter((item) => shouldShowFile(item, props, showHidden)).sort((a, b) => {
    if (a.isDirectory && !b.isDirectory)
      return -1;
    if (!a.isDirectory && b.isDirectory)
      return 1;
    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
  });
}, formatFileSize = (bytes) => {
  if (!bytes)
    return "-";
  const units = ["B", "KB", "MB", "GB", "TB"];
  let size23 = bytes;
  let unitIndex = 0;
  while (size23 >= 1024 && unitIndex < units.length - 1) {
    size23 /= 1024;
    unitIndex++;
  }
  return `${size23.toFixed(unitIndex === 0 ? 0 : 1)}${units[unitIndex]}`;
}, formatDate2 = (date2) => {
  if (!date2)
    return "-";
  const now2 = new Date;
  const diffMs = now2.getTime() - date2.getTime();
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  if (diffDays === 0) {
    return date2.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  } else if (diffDays < 7) {
    return `${diffDays}d ago`;
  } else {
    return date2.toLocaleDateString([], { month: "short", day: "numeric" });
  }
}, getFileIcon = (item) => {
  if (item.isDirectory) {
    return item.name.startsWith(".") ? "\uD83D\uDCC1" : "\uD83D\uDCC2";
  }
  const ext = PathUtils.getExtension(item.name).toLowerCase();
  switch (ext) {
    case ".ts":
    case ".js":
    case ".tsx":
    case ".jsx":
      return "\uD83D\uDCDC";
    case ".json":
      return "\uD83D\uDCCB";
    case ".md":
    case ".txt":
      return "\uD83D\uDCC4";
    case ".png":
    case ".jpg":
    case ".gif":
    case ".svg":
      return "\uD83D\uDDBC\uFE0F";
    case ".zip":
    case ".tar":
    case ".gz":
      return "\uD83D\uDCE6";
    case ".exe":
    case ".app":
      return "\u2699\uFE0F";
    default:
      return "\uD83D\uDCC4";
  }
}, createDefaultFileSystemService = () => ({
  readDirectory: (path5) => {
    const baseItems = [
      {
        name: "..",
        path: PathUtils.join(path5, ".."),
        isDirectory: true,
        hidden: false
      }
    ];
    const commonFiles = [
      { name: "src", isDirectory: true, size: 0, lastModified: new Date, hidden: false },
      { name: "package.json", isDirectory: false, size: 1024, lastModified: new Date, hidden: false },
      { name: "README.md", isDirectory: false, size: 2048, lastModified: new Date, hidden: false },
      { name: ".gitignore", isDirectory: false, size: 512, lastModified: new Date, hidden: true }
    ];
    const items = [
      ...baseItems,
      ...commonFiles.map((item) => ({
        ...item,
        path: PathUtils.join(path5, item.name)
      }))
    ];
    return exports_Effect.succeed(items);
  }
}), Breadcrumbs = ({ path: path5, width }) => {
  const normalizedPath = PathUtils.normalize(path5);
  const parts2 = normalizedPath === "/" ? [] : normalizedPath.split("/").filter(Boolean);
  let breadcrumb = "/";
  if (parts2.length > 0) {
    const fullPath = "/" + parts2.join("/");
    if (fullPath.length > width - 10) {
      breadcrumb = "/.../" + parts2.slice(-2).join("/");
    } else {
      breadcrumb = fullPath;
    }
  }
  return /* @__PURE__ */ jsx(Text, {
    style: style().foreground(Colors.blue).bold(),
    children: [
      "\uD83D\uDCCD ",
      breadcrumb
    ]
  }, undefined, true, undefined, this);
}, FileItemRenderer = ({
  item,
  selected,
  focused,
  showFileInfo
}) => {
  const icon = getFileIcon(item);
  const name = item.name;
  const size23 = showFileInfo && !item.isDirectory ? formatFileSize(item.size) : "";
  const date2 = showFileInfo ? formatDate2(item.lastModified) : "";
  return /* @__PURE__ */ jsx(Flex, {
    direction: "horizontal",
    gap: 2,
    children: [
      /* @__PURE__ */ jsx(Text, {
        children: icon
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: focused ? style().bold() : style(),
        children: name
      }, undefined, false, undefined, this),
      showFileInfo && /* @__PURE__ */ jsx(Fragment, {
        children: [
          /* @__PURE__ */ jsx(Flex, {
            flex: 1
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            style: style().foreground(Colors.gray),
            children: size23
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            style: style().foreground(Colors.gray),
            children: date2
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
}, ErrorMessage = ({ error: error2 }) => /* @__PURE__ */ jsx(Box, {
  border: Borders.Rounded,
  padding: { vertical: 1, horizontal: 2 },
  style: style().background(Colors.red).foreground(Colors.white),
  children: /* @__PURE__ */ jsx(Text, {
    children: [
      "\u26A0\uFE0F Error: ",
      error2
    ]
  }, undefined, true, undefined, this)
}, undefined, false, undefined, this), LoadingIndicator = () => /* @__PURE__ */ jsx(Flex, {
  direction: "horizontal",
  gap: 1,
  justify: "center",
  align: "center",
  children: [
    /* @__PURE__ */ jsx(Spinner, {
      size: "small"
    }, undefined, false, undefined, this),
    /* @__PURE__ */ jsx(Text, {
      children: "Loading directory..."
    }, undefined, false, undefined, this)
  ]
}, undefined, true, undefined, this), FilePicker = (props = {}) => {
  const finalProps = { ...defaultProps, ...props };
  const fileSystemService = props.fileSystemService ?? createDefaultFileSystemService();
  const convertToListItems = (items) => {
    return items.map((item) => ({
      id: item.path,
      label: item.name,
      value: item
    }));
  };
  return {
    init: exports_Effect.gen(function* () {
      const startPath = finalProps.startPath ?? ".";
      const items = yield* fileSystemService.readDirectory(startPath);
      const initialModel = {
        props: finalProps,
        currentPath: startPath,
        items: processItems(items, finalProps, finalProps.showHidden ?? false),
        selectedItems: new Set,
        loading: false,
        showHidden: finalProps.showHidden ?? false
      };
      return [initialModel, []];
    }),
    update(msg, model) {
      switch (msg._tag) {
        case "SelectItem": {
          if (msg.item.isDirectory) {
            return exports_Effect.succeed([
              { ...model, loading: true },
              [exports_Effect.succeed({ _tag: "EnterDirectory", path: msg.item.path })]
            ]);
          }
          if (model.props.selectionMode === "file" || model.props.selectionMode === "both") {
            const selectedItems = model.props.multiSelect ? new Set(model.selectedItems).add(msg.item.path) : new Set([msg.item.path]);
            if (model.props.onSelect) {
              const selected = model.items.filter((item) => selectedItems.has(item.path));
              model.props.onSelect(selected);
            }
            return exports_Effect.succeed([
              { ...model, selectedItems },
              []
            ]);
          }
          return exports_Effect.succeed([model, []]);
        }
        case "EnterDirectory": {
          return exports_Effect.gen(function* () {
            try {
              const items = yield* fileSystemService.readDirectory(msg.path);
              const processedItems = processItems(items, model.props, model.showHidden);
              if (model.props.onPathChange) {
                model.props.onPathChange(msg.path);
              }
              return [{
                ...model,
                currentPath: msg.path,
                items: processedItems,
                selectedItems: new Set,
                loading: false,
                error: undefined
              }, []];
            } catch (error2) {
              return [{
                ...model,
                loading: false,
                error: String(error2)
              }, []];
            }
          });
        }
        case "GoBack": {
          const parentPath = PathUtils.getParent(model.currentPath);
          return exports_Effect.succeed([
            { ...model, loading: true },
            [exports_Effect.succeed({ _tag: "EnterDirectory", path: parentPath })]
          ]);
        }
        case "GoHome": {
          const homePath = process.env.HOME || "/";
          return exports_Effect.succeed([
            { ...model, loading: true },
            [exports_Effect.succeed({ _tag: "EnterDirectory", path: homePath })]
          ]);
        }
        case "ToggleHidden": {
          const newShowHidden = !model.showHidden;
          const processedItems = processItems(model.items, model.props, newShowHidden);
          return exports_Effect.succeed([{
            ...model,
            showHidden: newShowHidden,
            items: processedItems
          }, []]);
        }
        case "RefreshDirectory": {
          return exports_Effect.succeed([
            { ...model, loading: true },
            [exports_Effect.succeed({ _tag: "LoadDirectory", path: model.currentPath })]
          ]);
        }
        case "DirectoryLoaded": {
          const processedItems = processItems(msg.items, model.props, model.showHidden);
          return exports_Effect.succeed([{
            ...model,
            items: processedItems,
            loading: false,
            error: undefined
          }, []]);
        }
        case "LoadError": {
          return exports_Effect.succeed([{
            ...model,
            loading: false,
            error: msg.error
          }, []]);
        }
        default:
          return exports_Effect.succeed([model, []]);
      }
    },
    view(model) {
      const lines = [];
      if (model.props.showPath) {
        lines.push(/* @__PURE__ */ jsx(Breadcrumbs, {
          path: model.currentPath,
          width: model.props.width ?? 80
        }, undefined, false, undefined, this));
        lines.push(/* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this));
      }
      if (model.error) {
        lines.push(/* @__PURE__ */ jsx(ErrorMessage, {
          error: model.error
        }, undefined, false, undefined, this));
        return vstack(...lines);
      }
      if (model.loading) {
        lines.push(/* @__PURE__ */ jsx(LoadingIndicator, {}, undefined, false, undefined, this));
        return vstack(...lines);
      }
      const listItems = convertToListItems(model.items);
      const fileList = List({
        items: listItems,
        multiSelect: model.props.multiSelect,
        height: (model.props.height ?? 20) - (model.props.showPath ? 3 : 1),
        width: model.props.width,
        showStatusBar: true,
        itemRenderer: (item, selected, focused) => /* @__PURE__ */ jsx(FileItemRenderer, {
          item: item.value,
          selected,
          focused,
          showFileInfo: model.props.showFileInfo ?? true
        }, undefined, false, undefined, this),
        onSelect: (items) => {
          if (items.length > 0 && model.props.onSelect) {
            model.props.onSelect(items.map((item) => item.value));
          }
        }
      });
      const hiddenHint = model.showHidden ? /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.gray),
        children: "Press H to hide hidden files"
      }, undefined, false, undefined, this) : /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.gray),
        children: "Press H to show hidden files"
      }, undefined, false, undefined, this);
      return /* @__PURE__ */ jsx(Box, {
        width: model.props.width,
        height: model.props.height,
        border: Borders.Rounded,
        padding: 1,
        children: vstack(...lines, fileList.view(model), hiddenHint)
      }, undefined, false, undefined, this);
    },
    handleKey(key, model) {
      switch (key.key) {
        case "backspace":
        case "delete":
          return { _tag: "GoBack" };
        case "h":
          if (key.ctrl) {
            return { _tag: "GoHome" };
          } else {
            return { _tag: "ToggleHidden" };
          }
        case "r":
          if (key.ctrl) {
            return { _tag: "RefreshDirectory" };
          }
          break;
      }
      return null;
    }
  };
};
var init_FilePicker = __esm(() => {
  init_esm2();
  init_view();
  init_styling();
  init_Box();
  init_Text();
  init_Flex();
  init_List2();
  init_Spinner();
  init_jsx_dev_runtime11();
  defaultProps = {
    startPath: ".",
    width: 80,
    height: 20,
    showHidden: false,
    selectionMode: "file",
    showFileInfo: true,
    showPath: true,
    multiSelect: false
  };
  PathUtils = {
    getExtension: (filename) => {
      const lastDot = filename.lastIndexOf(".");
      return lastDot > 0 ? filename.substring(lastDot) : "";
    },
    join: (...parts2) => {
      return parts2.filter(Boolean).join("/").replace(/\/+/g, "/").replace(/\/$/, "") || "/";
    },
    getParent: (path5) => {
      if (path5 === "/" || path5 === ".")
        return path5;
      const parts2 = path5.split("/").filter(Boolean);
      return parts2.length <= 1 ? "/" : "/" + parts2.slice(0, -1).join("/");
    },
    normalize: (path5) => {
      return path5.replace(/\/+/g, "/").replace(/\/$/, "") || "/";
    }
  };
});

// ../../src/components/forms/file-picker/index.ts
var init_file_picker = __esm(() => {
  init_FilePicker();
});

// ../../src/components/forms/index.ts
var init_forms = __esm(() => {
  init_text_input();
  init_button();
  init_file_picker();
  init_text_input();
  init_button();
  init_file_picker();
});

// ../../src/components/layout/flex/index.ts
var init_flex = __esm(() => {
  init_Flex();
});

// ../../src/components/layout/index.ts
var init_layout = __esm(() => {
  init_box();
  init_flex();
  init_box();
  init_flex();
});

// ../../src/components/display/text/index.ts
var init_text = __esm(() => {
  init_Text();
});

// ../../node_modules/figlet/lib/figlet.js
var require_figlet = __commonJS((exports, module) => {
  var figlet = (() => {
    const FULL_WIDTH = 0, FITTING = 1, SMUSHING = 2, CONTROLLED_SMUSHING = 3;
    const figFonts = {};
    const figDefaults = {
      font: "Standard",
      fontPath: "./fonts"
    };
    function getSmushingRules(oldLayout, newLayout) {
      let rules = {};
      let val, index, len, code2;
      let codes = [
        [16384, "vLayout", SMUSHING],
        [8192, "vLayout", FITTING],
        [4096, "vRule5", true],
        [2048, "vRule4", true],
        [1024, "vRule3", true],
        [512, "vRule2", true],
        [256, "vRule1", true],
        [128, "hLayout", SMUSHING],
        [64, "hLayout", FITTING],
        [32, "hRule6", true],
        [16, "hRule5", true],
        [8, "hRule4", true],
        [4, "hRule3", true],
        [2, "hRule2", true],
        [1, "hRule1", true]
      ];
      val = newLayout !== null ? newLayout : oldLayout;
      index = 0;
      len = codes.length;
      while (index < len) {
        code2 = codes[index];
        if (val >= code2[0]) {
          val = val - code2[0];
          rules[code2[1]] = typeof rules[code2[1]] === "undefined" ? code2[2] : rules[code2[1]];
        } else if (code2[1] !== "vLayout" && code2[1] !== "hLayout") {
          rules[code2[1]] = false;
        }
        index++;
      }
      if (typeof rules["hLayout"] === "undefined") {
        if (oldLayout === 0) {
          rules["hLayout"] = FITTING;
        } else if (oldLayout === -1) {
          rules["hLayout"] = FULL_WIDTH;
        } else {
          if (rules["hRule1"] || rules["hRule2"] || rules["hRule3"] || rules["hRule4"] || rules["hRule5"] || rules["hRule6"]) {
            rules["hLayout"] = CONTROLLED_SMUSHING;
          } else {
            rules["hLayout"] = SMUSHING;
          }
        }
      } else if (rules["hLayout"] === SMUSHING) {
        if (rules["hRule1"] || rules["hRule2"] || rules["hRule3"] || rules["hRule4"] || rules["hRule5"] || rules["hRule6"]) {
          rules["hLayout"] = CONTROLLED_SMUSHING;
        }
      }
      if (typeof rules["vLayout"] === "undefined") {
        if (rules["vRule1"] || rules["vRule2"] || rules["vRule3"] || rules["vRule4"] || rules["vRule5"]) {
          rules["vLayout"] = CONTROLLED_SMUSHING;
        } else {
          rules["vLayout"] = FULL_WIDTH;
        }
      } else if (rules["vLayout"] === SMUSHING) {
        if (rules["vRule1"] || rules["vRule2"] || rules["vRule3"] || rules["vRule4"] || rules["vRule5"]) {
          rules["vLayout"] = CONTROLLED_SMUSHING;
        }
      }
      return rules;
    }
    function hRule1_Smush(ch1, ch2, hardBlank) {
      if (ch1 === ch2 && ch1 !== hardBlank) {
        return ch1;
      }
      return false;
    }
    function hRule2_Smush(ch1, ch2) {
      let rule2Str = "|/\\[]{}()<>";
      if (ch1 === "_") {
        if (rule2Str.indexOf(ch2) !== -1) {
          return ch2;
        }
      } else if (ch2 === "_") {
        if (rule2Str.indexOf(ch1) !== -1) {
          return ch1;
        }
      }
      return false;
    }
    function hRule3_Smush(ch1, ch2) {
      let rule3Classes = "| /\\ [] {} () <>";
      let r3_pos1 = rule3Classes.indexOf(ch1);
      let r3_pos2 = rule3Classes.indexOf(ch2);
      if (r3_pos1 !== -1 && r3_pos2 !== -1) {
        if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {
          const startPos = Math.max(r3_pos1, r3_pos2);
          const endPos = startPos + 1;
          return rule3Classes.substring(startPos, endPos);
        }
      }
      return false;
    }
    function hRule4_Smush(ch1, ch2) {
      let rule4Str = "[] {} ()";
      let r4_pos1 = rule4Str.indexOf(ch1);
      let r4_pos2 = rule4Str.indexOf(ch2);
      if (r4_pos1 !== -1 && r4_pos2 !== -1) {
        if (Math.abs(r4_pos1 - r4_pos2) <= 1) {
          return "|";
        }
      }
      return false;
    }
    function hRule5_Smush(ch1, ch2) {
      let rule5Str = "/\\ \\/ ><";
      let rule5Hash = { 0: "|", 3: "Y", 6: "X" };
      let r5_pos1 = rule5Str.indexOf(ch1);
      let r5_pos2 = rule5Str.indexOf(ch2);
      if (r5_pos1 !== -1 && r5_pos2 !== -1) {
        if (r5_pos2 - r5_pos1 === 1) {
          return rule5Hash[r5_pos1];
        }
      }
      return false;
    }
    function hRule6_Smush(ch1, ch2, hardBlank) {
      if (ch1 === hardBlank && ch2 === hardBlank) {
        return hardBlank;
      }
      return false;
    }
    function vRule1_Smush(ch1, ch2) {
      if (ch1 === ch2) {
        return ch1;
      }
      return false;
    }
    function vRule2_Smush(ch1, ch2) {
      let rule2Str = "|/\\[]{}()<>";
      if (ch1 === "_") {
        if (rule2Str.indexOf(ch2) !== -1) {
          return ch2;
        }
      } else if (ch2 === "_") {
        if (rule2Str.indexOf(ch1) !== -1) {
          return ch1;
        }
      }
      return false;
    }
    function vRule3_Smush(ch1, ch2) {
      let rule3Classes = "| /\\ [] {} () <>";
      let r3_pos1 = rule3Classes.indexOf(ch1);
      let r3_pos2 = rule3Classes.indexOf(ch2);
      if (r3_pos1 !== -1 && r3_pos2 !== -1) {
        if (r3_pos1 !== r3_pos2 && Math.abs(r3_pos1 - r3_pos2) !== 1) {
          const startPos = Math.max(r3_pos1, r3_pos2);
          const endPos = startPos + 1;
          return rule3Classes.substring(startPos, endPos);
        }
      }
      return false;
    }
    function vRule4_Smush(ch1, ch2) {
      if (ch1 === "-" && ch2 === "_" || ch1 === "_" && ch2 === "-") {
        return "=";
      }
      return false;
    }
    function vRule5_Smush(ch1, ch2) {
      if (ch1 === "|" && ch2 === "|") {
        return "|";
      }
      return false;
    }
    function uni_Smush(ch1, ch2, hardBlank) {
      if (ch2 === " " || ch2 === "") {
        return ch1;
      } else if (ch2 === hardBlank && ch1 !== " ") {
        return ch1;
      } else {
        return ch2;
      }
    }
    function canVerticalSmush(txt1, txt2, opts) {
      if (opts.fittingRules.vLayout === FULL_WIDTH) {
        return "invalid";
      }
      let ii, len = Math.min(txt1.length, txt2.length), ch1, ch2, endSmush = false, validSmush;
      if (len === 0) {
        return "invalid";
      }
      for (ii = 0;ii < len; ii++) {
        ch1 = txt1.substring(ii, ii + 1);
        ch2 = txt2.substring(ii, ii + 1);
        if (ch1 !== " " && ch2 !== " ") {
          if (opts.fittingRules.vLayout === FITTING) {
            return "invalid";
          } else if (opts.fittingRules.vLayout === SMUSHING) {
            return "end";
          } else {
            if (vRule5_Smush(ch1, ch2)) {
              endSmush = endSmush || false;
              continue;
            }
            validSmush = false;
            validSmush = opts.fittingRules.vRule1 ? vRule1_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule2 ? vRule2_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule3 ? vRule3_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule4 ? vRule4_Smush(ch1, ch2) : validSmush;
            endSmush = true;
            if (!validSmush) {
              return "invalid";
            }
          }
        }
      }
      if (endSmush) {
        return "end";
      } else {
        return "valid";
      }
    }
    function getVerticalSmushDist(lines1, lines2, opts) {
      let maxDist = lines1.length;
      let len1 = lines1.length;
      let len2 = lines2.length;
      let subLines1, subLines2, slen;
      let curDist = 1;
      let ii, ret, result;
      while (curDist <= maxDist) {
        subLines1 = lines1.slice(Math.max(0, len1 - curDist), len1);
        subLines2 = lines2.slice(0, Math.min(maxDist, curDist));
        slen = subLines2.length;
        result = "";
        for (ii = 0;ii < slen; ii++) {
          ret = canVerticalSmush(subLines1[ii], subLines2[ii], opts);
          if (ret === "end") {
            result = ret;
          } else if (ret === "invalid") {
            result = ret;
            break;
          } else {
            if (result === "") {
              result = "valid";
            }
          }
        }
        if (result === "invalid") {
          curDist--;
          break;
        }
        if (result === "end") {
          break;
        }
        if (result === "valid") {
          curDist++;
        }
      }
      return Math.min(maxDist, curDist);
    }
    function verticallySmushLines(line1, line2, opts) {
      let ii, len = Math.min(line1.length, line2.length);
      let ch1, ch2, result = "", validSmush;
      for (ii = 0;ii < len; ii++) {
        ch1 = line1.substring(ii, ii + 1);
        ch2 = line2.substring(ii, ii + 1);
        if (ch1 !== " " && ch2 !== " ") {
          if (opts.fittingRules.vLayout === FITTING) {
            result += uni_Smush(ch1, ch2);
          } else if (opts.fittingRules.vLayout === SMUSHING) {
            result += uni_Smush(ch1, ch2);
          } else {
            validSmush = false;
            validSmush = opts.fittingRules.vRule5 ? vRule5_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule1 ? vRule1_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule2 ? vRule2_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule3 ? vRule3_Smush(ch1, ch2) : validSmush;
            validSmush = !validSmush && opts.fittingRules.vRule4 ? vRule4_Smush(ch1, ch2) : validSmush;
            result += validSmush;
          }
        } else {
          result += uni_Smush(ch1, ch2);
        }
      }
      return result;
    }
    function verticalSmush(lines1, lines2, overlap, opts) {
      let len1 = lines1.length;
      let len2 = lines2.length;
      let piece1 = lines1.slice(0, Math.max(0, len1 - overlap));
      let piece2_1 = lines1.slice(Math.max(0, len1 - overlap), len1);
      let piece2_2 = lines2.slice(0, Math.min(overlap, len2));
      let ii, len, line, piece2 = [], piece3, result = [];
      len = piece2_1.length;
      for (ii = 0;ii < len; ii++) {
        if (ii >= len2) {
          line = piece2_1[ii];
        } else {
          line = verticallySmushLines(piece2_1[ii], piece2_2[ii], opts);
        }
        piece2.push(line);
      }
      piece3 = lines2.slice(Math.min(overlap, len2), len2);
      return result.concat(piece1, piece2, piece3);
    }
    function padLines(lines, numSpaces) {
      let ii, len = lines.length, padding = "";
      for (ii = 0;ii < numSpaces; ii++) {
        padding += " ";
      }
      for (ii = 0;ii < len; ii++) {
        lines[ii] += padding;
      }
    }
    function smushVerticalFigLines(output, lines, opts) {
      let len1 = output[0].length;
      let len2 = lines[0].length;
      let overlap;
      if (len1 > len2) {
        padLines(lines, len1 - len2);
      } else if (len2 > len1) {
        padLines(output, len2 - len1);
      }
      overlap = getVerticalSmushDist(output, lines, opts);
      return verticalSmush(output, lines, overlap, opts);
    }
    function getHorizontalSmushLength(txt1, txt2, opts) {
      if (opts.fittingRules.hLayout === FULL_WIDTH) {
        return 0;
      }
      let ii, len1 = txt1.length, len2 = txt2.length;
      let maxDist = len1;
      let curDist = 1;
      let breakAfter = false;
      let validSmush = false;
      let seg1, seg2, ch1, ch2;
      if (len1 === 0) {
        return 0;
      }
      distCal:
        while (curDist <= maxDist) {
          const seg1StartPos = len1 - curDist;
          seg1 = txt1.substring(seg1StartPos, seg1StartPos + curDist);
          seg2 = txt2.substring(0, Math.min(curDist, len2));
          for (ii = 0;ii < Math.min(curDist, len2); ii++) {
            ch1 = seg1.substring(ii, ii + 1);
            ch2 = seg2.substring(ii, ii + 1);
            if (ch1 !== " " && ch2 !== " ") {
              if (opts.fittingRules.hLayout === FITTING) {
                curDist = curDist - 1;
                break distCal;
              } else if (opts.fittingRules.hLayout === SMUSHING) {
                if (ch1 === opts.hardBlank || ch2 === opts.hardBlank) {
                  curDist = curDist - 1;
                }
                break distCal;
              } else {
                breakAfter = true;
                validSmush = false;
                validSmush = opts.fittingRules.hRule1 ? hRule1_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule2 ? hRule2_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule3 ? hRule3_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule4 ? hRule4_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule5 ? hRule5_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                validSmush = !validSmush && opts.fittingRules.hRule6 ? hRule6_Smush(ch1, ch2, opts.hardBlank) : validSmush;
                if (!validSmush) {
                  curDist = curDist - 1;
                  break distCal;
                }
              }
            }
          }
          if (breakAfter) {
            break;
          }
          curDist++;
        }
      return Math.min(maxDist, curDist);
    }
    function horizontalSmush(textBlock1, textBlock2, overlap, opts) {
      let ii, jj, outputFig = [], overlapStart, piece1, piece2, piece3, len1, len2, txt1, txt2;
      for (ii = 0;ii < opts.height; ii++) {
        txt1 = textBlock1[ii];
        txt2 = textBlock2[ii];
        len1 = txt1.length;
        len2 = txt2.length;
        overlapStart = len1 - overlap;
        piece1 = txt1.substr(0, Math.max(0, overlapStart));
        piece2 = "";
        const seg1StartPos = Math.max(0, len1 - overlap);
        var seg1 = txt1.substring(seg1StartPos, seg1StartPos + overlap);
        var seg2 = txt2.substring(0, Math.min(overlap, len2));
        for (jj = 0;jj < overlap; jj++) {
          var ch1 = jj < len1 ? seg1.substring(jj, jj + 1) : " ";
          var ch2 = jj < len2 ? seg2.substring(jj, jj + 1) : " ";
          if (ch1 !== " " && ch2 !== " ") {
            if (opts.fittingRules.hLayout === FITTING) {
              piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
            } else if (opts.fittingRules.hLayout === SMUSHING) {
              piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
            } else {
              var nextCh = "";
              nextCh = !nextCh && opts.fittingRules.hRule1 ? hRule1_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = !nextCh && opts.fittingRules.hRule2 ? hRule2_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = !nextCh && opts.fittingRules.hRule3 ? hRule3_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = !nextCh && opts.fittingRules.hRule4 ? hRule4_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = !nextCh && opts.fittingRules.hRule5 ? hRule5_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = !nextCh && opts.fittingRules.hRule6 ? hRule6_Smush(ch1, ch2, opts.hardBlank) : nextCh;
              nextCh = nextCh || uni_Smush(ch1, ch2, opts.hardBlank);
              piece2 += nextCh;
            }
          } else {
            piece2 += uni_Smush(ch1, ch2, opts.hardBlank);
          }
        }
        if (overlap >= len2) {
          piece3 = "";
        } else {
          piece3 = txt2.substring(overlap, overlap + Math.max(0, len2 - overlap));
        }
        outputFig[ii] = piece1 + piece2 + piece3;
      }
      return outputFig;
    }
    function newFigChar(len) {
      let outputFigText = [], row;
      for (row = 0;row < len; row++) {
        outputFigText[row] = "";
      }
      return outputFigText;
    }
    const figLinesWidth = function(textLines) {
      return Math.max.apply(Math, textLines.map(function(line, i) {
        return line.length;
      }));
    };
    function joinFigArray(array7, len, opts) {
      return array7.reduce(function(acc, data) {
        return horizontalSmush(acc, data.fig, data.overlap, opts);
      }, newFigChar(len));
    }
    function breakWord(figChars, len, opts) {
      const result = {};
      for (let i = figChars.length;--i; ) {
        let w = joinFigArray(figChars.slice(0, i), len, opts);
        if (figLinesWidth(w) <= opts.width) {
          result.outputFigText = w;
          if (i < figChars.length) {
            result.chars = figChars.slice(i);
          } else {
            result.chars = [];
          }
          break;
        }
      }
      return result;
    }
    function generateFigTextLines(txt, figChars, opts) {
      let charIndex, figChar, overlap = 0, row, outputFigText, len, height = opts.height, outputFigLines = [], maxWidth, nextFigChars, figWords = [], char, isSpace, textFigWord, textFigLine, tmpBreak;
      outputFigText = newFigChar(height);
      if (opts.width > 0 && opts.whitespaceBreak) {
        nextFigChars = {
          chars: [],
          overlap
        };
      }
      if (opts.printDirection === 1) {
        txt = txt.split("").reverse().join("");
      }
      len = txt.length;
      for (charIndex = 0;charIndex < len; charIndex++) {
        char = txt.substring(charIndex, charIndex + 1);
        isSpace = char.match(/\s/);
        figChar = figChars[char.charCodeAt(0)];
        textFigLine = null;
        if (figChar) {
          if (opts.fittingRules.hLayout !== FULL_WIDTH) {
            overlap = 1e4;
            for (row = 0;row < opts.height; row++) {
              overlap = Math.min(overlap, getHorizontalSmushLength(outputFigText[row], figChar[row], opts));
            }
            overlap = overlap === 1e4 ? 0 : overlap;
          }
          if (opts.width > 0) {
            if (opts.whitespaceBreak) {
              textFigWord = joinFigArray(nextFigChars.chars.concat([
                {
                  fig: figChar,
                  overlap
                }
              ]), height, opts);
              textFigLine = joinFigArray(figWords.concat([
                {
                  fig: textFigWord,
                  overlap: nextFigChars.overlap
                }
              ]), height, opts);
              maxWidth = figLinesWidth(textFigLine);
            } else {
              textFigLine = horizontalSmush(outputFigText, figChar, overlap, opts);
              maxWidth = figLinesWidth(textFigLine);
            }
            if (maxWidth >= opts.width && charIndex > 0) {
              if (opts.whitespaceBreak) {
                outputFigText = joinFigArray(figWords.slice(0, -1), height, opts);
                if (figWords.length > 1) {
                  outputFigLines.push(outputFigText);
                  outputFigText = newFigChar(height);
                }
                figWords = [];
              } else {
                outputFigLines.push(outputFigText);
                outputFigText = newFigChar(height);
              }
            }
          }
          if (opts.width > 0 && opts.whitespaceBreak) {
            if (!isSpace || charIndex === len - 1) {
              nextFigChars.chars.push({ fig: figChar, overlap });
            }
            if (isSpace || charIndex === len - 1) {
              tmpBreak = null;
              while (true) {
                textFigLine = joinFigArray(nextFigChars.chars, height, opts);
                maxWidth = figLinesWidth(textFigLine);
                if (maxWidth >= opts.width) {
                  tmpBreak = breakWord(nextFigChars.chars, height, opts);
                  nextFigChars = { chars: tmpBreak.chars };
                  outputFigLines.push(tmpBreak.outputFigText);
                } else {
                  break;
                }
              }
              if (maxWidth > 0) {
                if (tmpBreak) {
                  figWords.push({ fig: textFigLine, overlap: 1 });
                } else {
                  figWords.push({
                    fig: textFigLine,
                    overlap: nextFigChars.overlap
                  });
                }
              }
              if (isSpace) {
                figWords.push({ fig: figChar, overlap });
                outputFigText = newFigChar(height);
              }
              if (charIndex === len - 1) {
                outputFigText = joinFigArray(figWords, height, opts);
              }
              nextFigChars = {
                chars: [],
                overlap
              };
              continue;
            }
          }
          outputFigText = horizontalSmush(outputFigText, figChar, overlap, opts);
        }
      }
      if (figLinesWidth(outputFigText) > 0) {
        outputFigLines.push(outputFigText);
      }
      if (opts.showHardBlanks !== true) {
        outputFigLines.forEach(function(outputFigText2) {
          len = outputFigText2.length;
          for (row = 0;row < len; row++) {
            outputFigText2[row] = outputFigText2[row].replace(new RegExp("\\" + opts.hardBlank, "g"), " ");
          }
        });
      }
      return outputFigLines;
    }
    const getHorizontalFittingRules = function(layout, options) {
      let props = [
        "hLayout",
        "hRule1",
        "hRule2",
        "hRule3",
        "hRule4",
        "hRule5",
        "hRule6"
      ], params = {}, ii;
      if (layout === "default") {
        for (ii = 0;ii < props.length; ii++) {
          params[props[ii]] = options.fittingRules[props[ii]];
        }
      } else if (layout === "full") {
        params = {
          hLayout: FULL_WIDTH,
          hRule1: false,
          hRule2: false,
          hRule3: false,
          hRule4: false,
          hRule5: false,
          hRule6: false
        };
      } else if (layout === "fitted") {
        params = {
          hLayout: FITTING,
          hRule1: false,
          hRule2: false,
          hRule3: false,
          hRule4: false,
          hRule5: false,
          hRule6: false
        };
      } else if (layout === "controlled smushing") {
        params = {
          hLayout: CONTROLLED_SMUSHING,
          hRule1: true,
          hRule2: true,
          hRule3: true,
          hRule4: true,
          hRule5: true,
          hRule6: true
        };
      } else if (layout === "universal smushing") {
        params = {
          hLayout: SMUSHING,
          hRule1: false,
          hRule2: false,
          hRule3: false,
          hRule4: false,
          hRule5: false,
          hRule6: false
        };
      } else {
        return;
      }
      return params;
    };
    const getVerticalFittingRules = function(layout, options) {
      let props = ["vLayout", "vRule1", "vRule2", "vRule3", "vRule4", "vRule5"], params = {}, ii;
      if (layout === "default") {
        for (ii = 0;ii < props.length; ii++) {
          params[props[ii]] = options.fittingRules[props[ii]];
        }
      } else if (layout === "full") {
        params = {
          vLayout: FULL_WIDTH,
          vRule1: false,
          vRule2: false,
          vRule3: false,
          vRule4: false,
          vRule5: false
        };
      } else if (layout === "fitted") {
        params = {
          vLayout: FITTING,
          vRule1: false,
          vRule2: false,
          vRule3: false,
          vRule4: false,
          vRule5: false
        };
      } else if (layout === "controlled smushing") {
        params = {
          vLayout: CONTROLLED_SMUSHING,
          vRule1: true,
          vRule2: true,
          vRule3: true,
          vRule4: true,
          vRule5: true
        };
      } else if (layout === "universal smushing") {
        params = {
          vLayout: SMUSHING,
          vRule1: false,
          vRule2: false,
          vRule3: false,
          vRule4: false,
          vRule5: false
        };
      } else {
        return;
      }
      return params;
    };
    const generateText = function(fontName, options, txt) {
      txt = txt.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      let lines = txt.split(`
`);
      let figLines = [];
      let ii, len, output;
      len = lines.length;
      for (ii = 0;ii < len; ii++) {
        figLines = figLines.concat(generateFigTextLines(lines[ii], figFonts[fontName], options));
      }
      len = figLines.length;
      output = figLines[0];
      for (ii = 1;ii < len; ii++) {
        output = smushVerticalFigLines(output, figLines[ii], options);
      }
      return output ? output.join(`
`) : "";
    };
    function _reworkFontOpts(fontOpts, options) {
      let myOpts = JSON.parse(JSON.stringify(fontOpts)), params, prop;
      if (typeof options.horizontalLayout !== "undefined") {
        params = getHorizontalFittingRules(options.horizontalLayout, fontOpts);
        for (prop in params) {
          if (params.hasOwnProperty(prop)) {
            myOpts.fittingRules[prop] = params[prop];
          }
        }
      }
      if (typeof options.verticalLayout !== "undefined") {
        params = getVerticalFittingRules(options.verticalLayout, fontOpts);
        for (prop in params) {
          if (params.hasOwnProperty(prop)) {
            myOpts.fittingRules[prop] = params[prop];
          }
        }
      }
      myOpts.printDirection = typeof options.printDirection !== "undefined" ? options.printDirection : fontOpts.printDirection;
      myOpts.showHardBlanks = options.showHardBlanks || false;
      myOpts.width = options.width || -1;
      myOpts.whitespaceBreak = options.whitespaceBreak || false;
      return myOpts;
    }
    const me = function(txt, options, next5) {
      return me.text(txt, options, next5);
    };
    me.text = async function(txt, options, next5) {
      let fontName = "";
      txt = txt + "";
      if (typeof arguments[1] === "function") {
        next5 = options;
        options = {};
        options.font = figDefaults.font;
      }
      if (typeof options === "string") {
        fontName = options;
        options = {};
      } else {
        options = options || {};
        fontName = options.font || figDefaults.font;
      }
      return await new Promise((resolve2, reject2) => {
        me.loadFont(fontName, function(err, fontOpts) {
          if (err) {
            reject2(err);
            if (next5)
              next5(err);
            return;
          }
          const generatedTxt = generateText(fontName, _reworkFontOpts(fontOpts, options), txt);
          resolve2(generatedTxt);
          if (next5)
            next5(null, generatedTxt);
        });
      });
    };
    me.textSync = function(txt, options) {
      let fontName = "";
      txt = txt + "";
      if (typeof options === "string") {
        fontName = options;
        options = {};
      } else {
        options = options || {};
        fontName = options.font || figDefaults.font;
      }
      var fontOpts = _reworkFontOpts(me.loadFontSync(fontName), options);
      return generateText(fontName, fontOpts, txt);
    };
    me.metadata = function(fontName, next5) {
      fontName = fontName + "";
      return new Promise(function(resolve2, reject2) {
        me.loadFont(fontName, function(err, fontOpts) {
          if (err) {
            if (next5)
              next5(err);
            reject2(err);
            return;
          }
          if (next5) {
            next5(null, fontOpts, figFonts[fontName].comment);
          }
          resolve2([fontOpts, figFonts[fontName].comment]);
        });
      });
    };
    me.defaults = function(opts) {
      if (typeof opts === "object" && opts !== null) {
        for (var prop in opts) {
          if (opts.hasOwnProperty(prop)) {
            figDefaults[prop] = opts[prop];
          }
        }
      }
      return JSON.parse(JSON.stringify(figDefaults));
    };
    me.parseFont = function(fontName, data) {
      data = data.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      figFonts[fontName] = {};
      var lines = data.split(`
`);
      var headerData = lines.splice(0, 1)[0].split(" ");
      var figFont = figFonts[fontName];
      var opts = {};
      opts.hardBlank = headerData[0].substr(5, 1);
      opts.height = parseInt(headerData[1], 10);
      opts.baseline = parseInt(headerData[2], 10);
      opts.maxLength = parseInt(headerData[3], 10);
      opts.oldLayout = parseInt(headerData[4], 10);
      opts.numCommentLines = parseInt(headerData[5], 10);
      opts.printDirection = headerData.length >= 6 ? parseInt(headerData[6], 10) : 0;
      opts.fullLayout = headerData.length >= 7 ? parseInt(headerData[7], 10) : null;
      opts.codeTagCount = headerData.length >= 8 ? parseInt(headerData[8], 10) : null;
      opts.fittingRules = getSmushingRules(opts.oldLayout, opts.fullLayout);
      figFont.options = opts;
      if (opts.hardBlank.length !== 1 || isNaN(opts.height) || isNaN(opts.baseline) || isNaN(opts.maxLength) || isNaN(opts.oldLayout) || isNaN(opts.numCommentLines)) {
        throw new Error("FIGlet header contains invalid values.");
      }
      let charNums = [], ii;
      for (ii = 32;ii <= 126; ii++) {
        charNums.push(ii);
      }
      charNums = charNums.concat(196, 214, 220, 228, 246, 252, 223);
      if (lines.length < opts.numCommentLines + opts.height * charNums.length) {
        throw new Error("FIGlet file is missing data.");
      }
      let cNum, endCharRegEx, parseError2 = false;
      figFont.comment = lines.splice(0, opts.numCommentLines).join(`
`);
      figFont.numChars = 0;
      while (lines.length > 0 && figFont.numChars < charNums.length) {
        cNum = charNums[figFont.numChars];
        figFont[cNum] = lines.splice(0, opts.height);
        for (ii = 0;ii < opts.height; ii++) {
          if (typeof figFont[cNum][ii] === "undefined") {
            figFont[cNum][ii] = "";
          } else {
            endCharRegEx = new RegExp("\\" + figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) + "+$");
            figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, "");
          }
        }
        figFont.numChars++;
      }
      while (lines.length > 0) {
        cNum = lines.splice(0, 1)[0].split(" ")[0];
        if (/^0[xX][0-9a-fA-F]+$/.test(cNum)) {
          cNum = parseInt(cNum, 16);
        } else if (/^0[0-7]+$/.test(cNum)) {
          cNum = parseInt(cNum, 8);
        } else if (/^[0-9]+$/.test(cNum)) {
          cNum = parseInt(cNum, 10);
        } else if (/^-0[xX][0-9a-fA-F]+$/.test(cNum)) {
          cNum = parseInt(cNum, 16);
        } else {
          if (cNum === "") {
            break;
          }
          console.log("Invalid data:" + cNum);
          parseError2 = true;
          break;
        }
        figFont[cNum] = lines.splice(0, opts.height);
        for (ii = 0;ii < opts.height; ii++) {
          if (typeof figFont[cNum][ii] === "undefined") {
            figFont[cNum][ii] = "";
          } else {
            endCharRegEx = new RegExp("\\" + figFont[cNum][ii].substr(figFont[cNum][ii].length - 1, 1) + "+$");
            figFont[cNum][ii] = figFont[cNum][ii].replace(endCharRegEx, "");
          }
        }
        figFont.numChars++;
      }
      if (parseError2 === true) {
        throw new Error("Error parsing data.");
      }
      return opts;
    };
    me.loadFont = function(fontName, next5) {
      if (figFonts[fontName]) {
        if (next5) {
          next5(null, figFonts[fontName].options);
        }
        return Promise.resolve();
      }
      if (typeof fetch !== "function") {
        console.error("figlet.js requires the fetch API or a fetch polyfill such as https://cdnjs.com/libraries/fetch");
        throw new Error("fetch is required for figlet.js to work.");
      }
      return fetch(figDefaults.fontPath + "/" + fontName + ".flf").then(function(response) {
        if (response.ok) {
          return response.text();
        }
        console.log("Unexpected response", response);
        throw new Error("Network response was not ok.");
      }).then(function(text3) {
        if (next5) {
          next5(null, me.parseFont(fontName, text3));
        }
      }).catch(next5);
    };
    me.loadFontSync = function(name) {
      if (figFonts[name]) {
        return figFonts[name].options;
      }
      throw new Error("synchronous font loading is not implemented for the browser");
    };
    me.preloadFonts = function(fonts, next5) {
      let fontData = [];
      return fonts.reduce(function(promise3, name) {
        return promise3.then(function() {
          return fetch(figDefaults.fontPath + "/" + name + ".flf").then((response) => {
            return response.text();
          }).then(function(data) {
            fontData.push(data);
          });
        });
      }, Promise.resolve()).then(function(res) {
        for (var i in fonts) {
          if (fonts.hasOwnProperty(i)) {
            me.parseFont(fonts[i], fontData[i]);
          }
        }
        if (next5)
          next5();
      });
    };
    me.figFonts = figFonts;
    return me;
  })();
  if (typeof module !== "undefined") {
    if (typeof module.exports !== "undefined") {
      module.exports = figlet;
    }
  }
});

// ../../node_modules/figlet/lib/node-figlet.js
var require_node_figlet = __commonJS((exports, module) => {
  var __dirname = "/Users/aewing/Projects/cinderlink/cli-kit/node_modules/figlet/lib";
  var figlet = require_figlet();
  var fs2 = __require("fs");
  var path5 = __require("path");
  var fontDir = path5.join(__dirname, "/../fonts/");
  figlet.loadFont = function(name, next5) {
    return new Promise(function(resolve2, reject2) {
      if (figlet.figFonts[name]) {
        next5 && next5(null, figlet.figFonts[name].options);
        resolve2(figlet.figFonts[name].options);
        return;
      }
      fs2.readFile(path5.join(fontDir, name + ".flf"), { encoding: "utf-8" }, function(err, fontData) {
        if (err) {
          next5 && next5(err);
          reject2(err);
          return;
        }
        fontData = fontData + "";
        try {
          var font = figlet.parseFont(name, fontData);
          next5 && next5(null, font);
          resolve2(font);
        } catch (error2) {
          next5 && next5(error2);
          reject2(error2);
        }
      });
    });
  };
  figlet.loadFontSync = function(name) {
    if (figlet.figFonts[name]) {
      return figlet.figFonts[name].options;
    }
    var fontData = fs2.readFileSync(path5.join(fontDir, name + ".flf"), {
      encoding: "utf-8"
    });
    fontData = fontData + "";
    return figlet.parseFont(name, fontData);
  };
  figlet.fonts = function(next5) {
    return new Promise(function(resolve2, reject2) {
      var fontList = [];
      fs2.readdir(fontDir, function(err, files) {
        if (err) {
          next5 && next5(err);
          reject2(err);
          return;
        }
        files.forEach(function(file) {
          if (/\.flf$/.test(file)) {
            fontList.push(file.replace(/\.flf$/, ""));
          }
        });
        next5 && next5(null, fontList);
        resolve2(fontList);
      });
    });
  };
  figlet.fontsSync = function() {
    var fontList = [];
    fs2.readdirSync(fontDir).forEach(function(file) {
      if (/\.flf$/.test(file)) {
        fontList.push(file.replace(/\.flf$/, ""));
      }
    });
    return fontList;
  };
  module.exports = figlet;
});

// ../../src/tea/display/LargeText.ts
function generateFigletArt(text3, fontStyle = "standard") {
  try {
    const figletFont = FIGLET_FONTS[fontStyle];
    const asciiArt = import_figlet.default.textSync(text3, {
      font: figletFont,
      horizontalLayout: "default",
      verticalLayout: "default",
      width: 120,
      whitespaceBreak: true
    });
    const lines = asciiArt.split(`
`);
    while (lines.length > 0) {
      const lastLine = lines[lines.length - 1];
      if (lastLine && lastLine.trim() === "") {
        lines.pop();
      } else {
        break;
      }
    }
    return lines.map((line) => [line]);
  } catch (primaryError) {
    console.warn(`Failed to generate figlet art with font ${fontStyle}:`, primaryError);
    try {
      const asciiArt = import_figlet.default.textSync(text3, { font: "Standard" });
      const lines = asciiArt.split(`
`);
      while (lines.length > 0) {
        const lastLine = lines[lines.length - 1];
        if (lastLine && lastLine.trim() === "") {
          lines.pop();
        } else {
          break;
        }
      }
      return lines.map((line) => [line]);
    } catch (fallbackError) {
      console.error("Failed to generate figlet art even with standard font:", fallbackError);
      return [[`[ ${text3} ]`]];
    }
  }
}
function textToAsciiArt(text3, fontStyle = "standard") {
  return generateFigletArt(text3, fontStyle);
}
function scaleAsciiArt(lines, scale2) {
  if (scale2 <= 1)
    return lines;
  const scaledLines = [];
  const directionalChars = new Set(["/", "\\", "|", "<", ">", "^", "v", "\u2554", "\u2557", "\u255A", "\u255D"]);
  const horizontalRepeatChars = new Set(["_", "-", "=", "*", "#", "\u2588", "\u2580", "\u2584", "\u258C", "\u2590", "\u2551", "\u2550"]);
  for (const line of lines) {
    const fullLine = line.join("");
    const scaledLine = fullLine.split("").map((char) => {
      if (char === " ") {
        return char.repeat(scale2);
      } else if (horizontalRepeatChars.has(char)) {
        return char.repeat(scale2);
      } else if (directionalChars.has(char)) {
        if (scale2 === 2) {
          return char + " ";
        } else if (scale2 === 3) {
          return " " + char + " ";
        } else {
          const padding = Math.floor((scale2 - 1) / 2);
          return " ".repeat(padding) + char + " ".repeat(scale2 - 1 - padding);
        }
      } else {
        if (scale2 === 2) {
          return char + " ";
        } else {
          return char + " ".repeat(Math.min(scale2 - 1, 2));
        }
      }
    }).join("");
    for (let i = 0;i < scale2; i++) {
      scaledLines.push([scaledLine]);
    }
  }
  return scaledLines;
}
function createFilledBlocks(lines, char = "\u2588") {
  return lines.map((line) => {
    const fullLine = line.join("");
    const filledLine = fullLine.replace(/[^\s]/g, char);
    return [filledLine];
  });
}
function resolveGradient(paletteNameOrGradient) {
  if (typeof paletteNameOrGradient === "string") {
    const palette = colorPalettes[paletteNameOrGradient];
    if (palette) {
      return {
        colors: palette.colors,
        direction: "horizontal"
      };
    }
    const defaultPalette = colorPalettes.gradBlue;
    return {
      colors: defaultPalette ? defaultPalette.colors : [Colors.blue, Colors.cyan],
      direction: "horizontal"
    };
  }
  return paletteNameOrGradient;
}
function applyGradient(lines, gradient2, time2 = 0) {
  const colors2 = gradient2.colors;
  if (lines.length === 0 || lines[0] === undefined) {
    return text("");
  }
  const totalChars = lines[0].join("").length;
  return vstack(...lines.map((line, lineIndex) => {
    const fullLine = line.join("");
    const chars = fullLine.split("");
    return hstack(...chars.map((char, charIndex) => {
      if (char === " ")
        return text(" ");
      let gradientPos = 0;
      if (gradient2.direction === "horizontal") {
        gradientPos = (charIndex / totalChars + time2) % 1;
      } else if (gradient2.direction === "vertical") {
        gradientPos = (lineIndex / lines.length + time2) % 1;
      } else {
        gradientPos = ((charIndex + lineIndex) / (totalChars + lines.length) + time2) % 1;
      }
      const colorIndex = Math.floor(gradientPos * (colors2.length - 1));
      const color = colors2[colorIndex] || colors2[0] || Colors.white;
      return styledText(char, style().foreground(color));
    }));
  }));
}
function largeText(options) {
  let lines = textToAsciiArt(options.text, options.font || "block");
  if (options.mode === "filled") {
    lines = createFilledBlocks(lines);
  }
  if (options.scale && options.scale > 1) {
    lines = scaleAsciiArt(lines, options.scale);
  }
  const spacing = " ".repeat(options.spacing || 1);
  return vstack(...lines.map((line) => {
    const fullLine = line.join(spacing);
    return options.style ? styledText(fullLine, options.style) : text(fullLine);
  }));
}
function largeGradientText(options) {
  let lines = textToAsciiArt(options.text, options.font || "block");
  if (options.mode === "filled") {
    lines = createFilledBlocks(lines);
  }
  if (options.scale && options.scale > 1) {
    lines = scaleAsciiArt(lines, options.scale);
  }
  const spacedLines = lines.map((line) => {
    const spacing = " ".repeat(options.spacing || 1);
    return line.map((char, i) => i === line.length - 1 ? char : char + spacing);
  });
  const gradient2 = typeof options.gradient === "string" ? resolveGradient(options.gradient) : options.gradient;
  return applyGradient(spacedLines, gradient2);
}
function largeAnimatedGradientText(options) {
  let lines = textToAsciiArt(options.text, options.font || "block");
  if (options.mode === "filled") {
    lines = createFilledBlocks(lines);
  }
  if (options.scale && options.scale > 1) {
    lines = scaleAsciiArt(lines, options.scale);
  }
  const spacedLines = lines.map((line) => {
    const spacing = " ".repeat(options.spacing || 1);
    return line.map((char, i) => i === line.length - 1 ? char : char + spacing);
  });
  const gradient2 = typeof options.gradient === "string" ? resolveGradient(options.gradient) : options.gradient;
  const animationOffset = options.time * (options.animationSpeed || 0.1);
  return applyGradient(spacedLines, gradient2, animationOffset);
}
function largeTextWithPalette(text3, paletteName, options) {
  const palette = colorPalettes[paletteName];
  if (!palette) {
    return largeText({ text: text3, ...options });
  }
  const gradient2 = {
    colors: palette.colors,
    direction: "horizontal"
  };
  return largeGradientText({
    text: text3,
    gradient: gradient2,
    font: "block",
    mode: "outlined",
    ...options
  });
}
function largeAnimatedTextWithPalette(text3, paletteName, time2, options) {
  const palette = colorPalettes[paletteName];
  if (!palette) {
    return largeAnimatedGradientText({ text: text3, time: time2, ...options });
  }
  const gradient2 = {
    colors: palette.colors,
    direction: "horizontal"
  };
  return largeAnimatedGradientText({
    text: text3,
    gradient: gradient2,
    time: time2,
    font: "block",
    mode: "outlined",
    animationSpeed: 0.05,
    ...options
  });
}
var import_figlet, FIGLET_FONTS, colorPalettes, gradientPresets;
var init_LargeText = __esm(() => {
  import_figlet = __toESM(require_node_figlet(), 1);
  init_view();
  init_styling();
  FIGLET_FONTS = {
    standard: "Standard",
    big: "Big",
    ansiShadow: "ANSI Shadow",
    slant: "Slant",
    small: "Small",
    block: "Block",
    cyber: "Cyberlarge",
    neon: "Nancyj",
    graffiti: "Graffiti",
    chunky: "Chunky",
    "3d": "3D-ASCII",
    script: "Script",
    rounded: "Rounded",
    digital: "Digital"
  };
  colorPalettes = {
    gradBlue: {
      name: "Gradient Blue",
      colors: [Colors.blue, Colors.brightBlue]
    },
    sunset: {
      name: "Sunset",
      colors: [Colors.red, Colors.yellow, Colors.magenta]
    },
    matrix: {
      name: "Matrix",
      colors: [Colors.green, Colors.brightGreen, Colors.white]
    },
    fire: {
      name: "Fire",
      colors: [Colors.red, Colors.yellow, Colors.white]
    },
    ocean: {
      name: "Ocean",
      colors: [Colors.blue, Colors.cyan, Colors.brightCyan]
    },
    neon: {
      name: "Neon",
      colors: [Colors.magenta, Colors.cyan, Colors.yellow]
    },
    purple: {
      name: "Purple",
      colors: [Colors.magenta, Colors.brightMagenta]
    },
    forest: {
      name: "Forest",
      colors: [Colors.green, Colors.brightGreen, Colors.yellow]
    }
  };
  gradientPresets = {
    rainbow: {
      colors: [Colors.red, Colors.yellow, Colors.green, Colors.cyan, Colors.blue, Colors.magenta],
      direction: "horizontal"
    },
    sunset: {
      colors: colorPalettes.sunset.colors,
      direction: "horizontal"
    },
    ocean: {
      colors: colorPalettes.ocean.colors,
      direction: "horizontal"
    },
    matrix: {
      colors: colorPalettes.matrix.colors,
      direction: "vertical"
    },
    fire: {
      colors: colorPalettes.fire.colors,
      direction: "vertical"
    },
    neon: {
      colors: colorPalettes.neon.colors,
      direction: "diagonal"
    }
  };
});

// ../../src/components/display/large-text/index.ts
var init_large_text = __esm(() => {
  init_LargeText();
});

// ../../src/tea/display/MarkdownRenderer.ts
import * as fs2 from "fs/promises";
import * as path5 from "path";
function parseMarkdown(content) {
  const lines = content.split(`
`);
  const rendered = [];
  for (const line of lines) {
    let processedLine = line;
    if (line.startsWith("# ")) {
      processedLine = `\x1B[1;36m${line.slice(2)}\x1B[0m`;
    } else if (line.startsWith("## ")) {
      processedLine = `\x1B[1;35m${line.slice(3)}\x1B[0m`;
    } else if (line.startsWith("### ")) {
      processedLine = `\x1B[1;33m${line.slice(4)}\x1B[0m`;
    } else if (line.startsWith("#### ")) {
      processedLine = `\x1B[1;32m${line.slice(5)}\x1B[0m`;
    }
    if (line.startsWith("```")) {
      processedLine = `\x1B[2;37m${line}\x1B[0m`;
    } else if (line.startsWith("    ") || line.startsWith("\t")) {
      processedLine = `\x1B[2;37m${line}\x1B[0m`;
    }
    processedLine = processedLine.replace(/`([^`]+)`/g, "\x1B[2;36m$1\x1B[0m");
    processedLine = processedLine.replace(/\*\*([^*]+)\*\*/g, "\x1B[1m$1\x1B[0m");
    processedLine = processedLine.replace(/\*([^*]+)\*/g, "\x1B[3m$1\x1B[0m");
    processedLine = processedLine.replace(/\[([^\]]+)\]\([^)]+\)/g, "\x1B[4;34m$1\x1B[0m");
    if (line.match(/^[\s]*[-*+]\s/)) {
      processedLine = processedLine.replace(/^(\s*)([-*+])(\s)/, "$1\x1B[33m\u2022\x1B[0m$3");
    }
    if (line.match(/^[\s]*\d+\.\s/)) {
      processedLine = processedLine.replace(/^(\s*)(\d+\.)(\s)/, "$1\x1B[33m$2\x1B[0m$3");
    }
    rendered.push(processedLine);
  }
  return rendered;
}
function loadMarkdownFile(filePath, basePath = "docs") {
  return exports_Effect.gen(function* (_) {
    try {
      const fullPath = path5.isAbsolute(filePath) ? filePath : path5.join(basePath, filePath);
      const content = yield* _(exports_Effect.promise(() => fs2.readFile(fullPath, "utf-8")));
      return content;
    } catch (error2) {
      return yield* _(exports_Effect.fail(new Error(`Failed to load ${filePath}: ${error2}`)));
    }
  });
}
var MarkdownRenderer = (props) => {
  const basePath = props.basePath || "docs";
  const maxHeight = props.maxHeight || 20;
  return {
    init: exports_Effect.gen(function* (_) {
      const content = yield* _(loadMarkdownFile(props.initialFile, basePath));
      const rendered = parseMarkdown(content);
      return [{
        content: rendered,
        currentFile: props.initialFile,
        scrollPosition: 0,
        maxHeight
      }, []];
    }),
    update: (msg, model) => exports_Effect.gen(function* (_) {
      switch (msg.type) {
        case "scroll": {
          const maxScroll = Math.max(0, model.content.length - model.maxHeight);
          const newPosition = Math.max(0, Math.min(maxScroll, model.scrollPosition + msg.delta));
          return [{
            ...model,
            scrollPosition: newPosition
          }, []];
        }
        case "navigate": {
          return [model, []];
        }
        default:
          return [model, []];
      }
    }),
    view: (model) => {
      const visibleLines = model.content.slice(model.scrollPosition, model.scrollPosition + model.maxHeight);
      const totalLines = model.content.length;
      const startLine = model.scrollPosition + 1;
      const endLine = Math.min(model.scrollPosition + model.maxHeight, totalLines);
      const statusLine = `\uD83D\uDCC4 ${path5.basename(model.currentFile)} | Lines ${startLine}-${endLine} of ${totalLines} | Use \u2191\u2193 to scroll`;
      return vstack(...visibleLines.map((line) => text(line)), text(""), text(`\x1B[2m${statusLine}\x1B[0m`));
    },
    subscriptions: () => exports_Effect.succeed([])
  };
};
var init_MarkdownRenderer = __esm(() => {
  init_esm2();
  init_view();
});

// ../../src/components/display/markdown/index.ts
var init_markdown = __esm(() => {
  init_MarkdownRenderer();
});

// ../../src/components/display/index.ts
var init_display = __esm(() => {
  init_text();
  init_large_text();
  init_markdown();
  init_text();
  init_large_text();
  init_markdown();
});

// ../../src/components/feedback/spinner/index.ts
var init_spinner = __esm(() => {
  init_Spinner();
});

// ../../src/components/feedback/modal/jsx-dev-runtime.ts
var init_jsx_dev_runtime12 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/feedback/modal/Modal.tsx
var defaultProps2, Backdrop = ({ width, height, style: backdropStyle }) => {
  const backdropLine = "\u2593".repeat(width);
  const lines = [];
  for (let i = 0;i < height; i++) {
    lines.push(/* @__PURE__ */ jsx(Text, {
      style: backdropStyle,
      children: backdropLine
    }, undefined, false, undefined, this));
  }
  return vstack(...lines);
}, ModalContent = ({
  model,
  children: children3
}) => {
  const { props } = model;
  const actualWidth = props.width ?? defaultProps2.width ?? 60;
  const actualHeight = props.height ?? defaultProps2.height ?? 20;
  const titleStyle = props.titleStyle ?? defaultProps2.titleStyle ?? style();
  const modalStyle = props.modalStyle ?? defaultProps2.modalStyle ?? style();
  const header = [];
  if (props.title) {
    if (props.showCloseButton) {
      const spacerWidth = Math.max(0, actualWidth - stringWidth(props.title) - 3);
      header.push(/* @__PURE__ */ jsx(Flex, {
        direction: "horizontal",
        children: [
          /* @__PURE__ */ jsx(Text, {
            style: titleStyle,
            children: props.title
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            children: " ".repeat(spacerWidth)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            style: style().foreground(Colors.red).bold(),
            children: "[\xD7]"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this));
    } else {
      header.push(/* @__PURE__ */ jsx(Text, {
        style: titleStyle,
        children: props.title
      }, undefined, false, undefined, this));
    }
    header.push(/* @__PURE__ */ jsx(Text, {
      children: ""
    }, undefined, false, undefined, this));
  }
  const allContent = [...header, ...children3];
  const boxProps = {
    border: Borders.Rounded,
    padding: { top: 1, right: 2, bottom: 1, left: 2 },
    width: actualWidth,
    height: actualHeight,
    style: modalStyle
  };
  return /* @__PURE__ */ jsx(Box, {
    ...boxProps,
    children: vstack(...allContent)
  }, undefined, false, undefined, this);
}, Modal = (props = {}) => ({
  init: exports_Effect.succeed([
    {
      props: { ...defaultProps2, ...props },
      terminalWidth: 80,
      terminalHeight: 24,
      focusedButton: 0
    },
    []
  ]),
  update(msg, model) {
    switch (msg._tag) {
      case "Close":
        if (model.props.onClose) {
          model.props.onClose();
        }
        return exports_Effect.succeed([model, []]);
      case "SetTerminalSize":
        return exports_Effect.succeed([
          {
            ...model,
            terminalWidth: msg.width,
            terminalHeight: msg.height
          },
          []
        ]);
      case "FocusNext":
        return exports_Effect.succeed([
          {
            ...model,
            focusedButton: (model.focusedButton + 1) % 2
          },
          []
        ]);
      case "FocusPrevious":
        return exports_Effect.succeed([
          {
            ...model,
            focusedButton: model.focusedButton === 0 ? 1 : 0
          },
          []
        ]);
      case "Activate":
        if (model.props.onConfirm && model.focusedButton === 0) {
          model.props.onConfirm();
        } else if (model.props.onCancel && model.focusedButton === 1) {
          model.props.onCancel();
        }
        return exports_Effect.succeed([model, []]);
      case "BackdropClick":
        if (model.props.closeOnBackdrop && model.props.onClose) {
          model.props.onClose();
        }
        return exports_Effect.succeed([model, []]);
    }
  },
  view(model) {
    if (!model.props.isOpen) {
      return /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this);
    }
    const backdropStyle = model.props.backdropStyle ?? defaultProps2.backdropStyle ?? style();
    const modalWidth = model.props.width ?? defaultProps2.width ?? 60;
    const modalHeight = model.props.height ?? defaultProps2.height ?? 20;
    const x = Math.max(0, Math.floor((model.terminalWidth - modalWidth) / 2));
    const y = Math.max(0, Math.floor((model.terminalHeight - modalHeight) / 2));
    const backdrop = /* @__PURE__ */ jsx(Backdrop, {
      width: model.terminalWidth,
      height: model.terminalHeight,
      style: backdropStyle
    }, undefined, false, undefined, this);
    const modalContent = /* @__PURE__ */ jsx(ModalContent, {
      model,
      children: model.props.children || []
    }, undefined, false, undefined, this);
    return vstack(backdrop, modalContent);
  },
  handleKey(key, model) {
    if (!model.props.isOpen) {
      return null;
    }
    switch (key.key) {
      case "escape":
        if (model.props.closeOnEscape) {
          return { _tag: "Close" };
        }
        break;
      case "tab":
        if (key.shift) {
          return { _tag: "FocusPrevious" };
        } else {
          return { _tag: "FocusNext" };
        }
      case "enter":
      case " ":
        return { _tag: "Activate" };
    }
    return null;
  }
}), InfoModal = ({
  title,
  message,
  ...props
}) => {
  const width = Math.max(40, stringWidth(message) + 8);
  return Modal({
    title,
    width,
    height: 12,
    showCloseButton: true,
    ...props,
    children: [
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.black),
        children: message
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.gray),
        children: "Press Escape or click [\xD7] to close"
      }, undefined, false, undefined, this)
    ]
  });
}, ConfirmModal = ({
  title,
  message,
  onConfirm,
  onCancel,
  ...props
}) => {
  const width = Math.max(50, stringWidth(message) + 8);
  const buttonRow = /* @__PURE__ */ jsx(Flex, {
    direction: "horizontal",
    gap: 3,
    justify: "center",
    children: [
      /* @__PURE__ */ jsx(Button, {
        label: "Yes",
        style: style().background(Colors.green).foreground(Colors.white).bold(),
        onPress: onConfirm
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Button, {
        label: "No",
        style: style().background(Colors.red).foreground(Colors.white).bold(),
        onPress: onCancel || (() => {})
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
  return Modal({
    title,
    width,
    height: 15,
    showCloseButton: false,
    closeOnBackdrop: false,
    ...props,
    children: [
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.black),
        children: message
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      buttonRow,
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.gray),
        children: "Use Tab to navigate, Enter to select"
      }, undefined, false, undefined, this)
    ]
  });
}, LoadingModal = ({
  title,
  message,
  ...props
}) => {
  const width = Math.max(40, stringWidth(message) + 8);
  return Modal({
    title,
    width,
    height: 10,
    showCloseButton: false,
    closeOnEscape: false,
    closeOnBackdrop: false,
    ...props,
    children: [
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Flex, {
        direction: "horizontal",
        gap: 1,
        children: [
          /* @__PURE__ */ jsx(Text, {
            children: "  "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Spinner, {
            size: "small",
            style: style().foreground(Colors.blue).bold()
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            children: " "
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx(Text, {
            style: style().foreground(Colors.black),
            children: message
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this)
    ]
  });
}, ErrorModal = ({
  title,
  error: error2,
  ...props
}) => {
  const width = Math.max(50, stringWidth(error2) + 8);
  return Modal({
    title,
    width,
    height: 12,
    showCloseButton: true,
    titleStyle: style().foreground(Colors.red).bold(),
    ...props,
    children: [
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.red),
        children: [
          "\u26A0 ",
          error2
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        children: ""
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: style().foreground(Colors.gray),
        children: "Press Escape to close"
      }, undefined, false, undefined, this)
    ]
  });
};
var init_Modal = __esm(() => {
  init_esm2();
  init_styling();
  init_string_width();
  init_Box();
  init_Text();
  init_Button();
  init_Flex();
  init_Spinner();
  init_view();
  init_jsx_dev_runtime12();
  defaultProps2 = {
    width: 60,
    height: 20,
    showCloseButton: true,
    closeOnEscape: true,
    closeOnBackdrop: true,
    backdropStyle: style().background(Colors.black).foreground(Colors.gray),
    modalStyle: style().background(Colors.white).foreground(Colors.black),
    titleStyle: style().foreground(Colors.blue).bold()
  };
});

// ../../src/components/feedback/modal/index.ts
var init_modal = __esm(() => {
  init_Modal();
});

// ../../src/tea/feedback/ProgressBar.ts
var defaultProgressBarStyle, fancyProgressBarStyle, asciiProgressBarStyle, progressBar = (options = {}) => {
  const id3 = generateComponentId("progressbar");
  const width = options.width ?? 20;
  const showPercentage = options.showPercentage ?? true;
  const indeterminate = options.indeterminate ?? false;
  const progressStyle = options.style ?? defaultProgressBarStyle;
  const initialProgress = options.initialProgress ?? 0;
  return {
    init() {
      const model = {
        id: id3,
        progress: initialProgress,
        width,
        showPercentage,
        indeterminate,
        indeterminateFrame: 0,
        style: progressStyle
      };
      const cmds = indeterminate ? [
        exports_Effect.succeed({
          _tag: "animateIndeterminate"
        }).pipe(exports_Effect.delay(100))
      ] : [];
      return exports_Effect.succeed([model, cmds]);
    },
    update(msg, model) {
      switch (msg._tag) {
        case "setProgress": {
          const newProgress = Math.max(0, Math.min(1, msg.progress));
          return exports_Effect.succeed([{ ...model, progress: newProgress }, []]);
        }
        case "animateIndeterminate": {
          const newFrame = (model.indeterminateFrame + 1) % (model.width * 2);
          const newModel = { ...model, indeterminateFrame: newFrame };
          const nextCmd = exports_Effect.succeed({
            _tag: "animateIndeterminate"
          }).pipe(exports_Effect.delay(100));
          return exports_Effect.succeed([newModel, [nextCmd]]);
        }
      }
    },
    view(model) {
      const { width: width2, progress, showPercentage: showPercentage2, indeterminate: indeterminate2, indeterminateFrame, style: style2 } = model;
      let bar;
      if (indeterminate2) {
        const position = indeterminateFrame % (width2 * 2);
        const slidePosition = position < width2 ? position : width2 * 2 - position;
        bar = Array.from({ length: width2 }, (_, i) => {
          const distance2 = Math.abs(i - slidePosition);
          if (distance2 <= 2) {
            return style2.indeterminateChar;
          }
          return style2.emptyChar;
        }).join("");
      } else {
        const filled = Math.floor(progress * width2);
        const empty47 = width2 - filled;
        bar = style2.fillChar.repeat(filled) + style2.emptyChar.repeat(empty47);
      }
      const progressBar2 = [
        style2.leftBracket,
        bar,
        style2.rightBracket
      ].join("");
      let display = progressBar2;
      if (showPercentage2 && !indeterminate2) {
        const percentage = Math.floor(progress * 100);
        display = `${progressBar2} ${percentage}%`;
      }
      let fillColor = style2.colors.fill;
      if (!indeterminate2 && progress >= 1) {
        fillColor = style().foreground(Colors.green);
      } else if (!indeterminate2 && progress >= 0.8) {
        fillColor = style().foreground(Colors.yellow);
      }
      return styledText(display, fillColor);
    },
    focus() {
      return exports_Effect.succeed({ _tag: "none" });
    },
    blur() {
      return exports_Effect.succeed({ _tag: "none" });
    },
    focused() {
      return false;
    },
    setSize(width2) {
      return exports_Effect.succeed(undefined);
    },
    getSize(model) {
      const width2 = model.width + 2;
      const extraWidth = model.showPercentage ? 5 : 0;
      return { width: width2 + extraWidth, height: 1 };
    }
  };
}, simpleProgressBar = (width) => progressBar({ width, style: defaultProgressBarStyle }), fancyProgressBar = (width) => progressBar({ width, style: fancyProgressBarStyle }), asciiProgressBar = (width) => progressBar({ width, style: asciiProgressBarStyle }), loadingBar = (width) => progressBar({
  width,
  indeterminate: true,
  showPercentage: false,
  style: {
    ...defaultProgressBarStyle,
    indeterminateChar: "\u2593",
    colors: {
      ...defaultProgressBarStyle.colors,
      fill: style().foreground(Colors.cyan)
    }
  }
}), setProgress = (progress) => ({
  _tag: "setProgress",
  progress
});
var init_ProgressBar = __esm(() => {
  init_esm2();
  init_styling();
  init_view();
  init_base();
  defaultProgressBarStyle = {
    emptyChar: "\u2591",
    fillChar: "\u2588",
    leftBracket: "[",
    rightBracket: "]",
    indeterminateChar: "\u2593",
    colors: {
      empty: style().foreground(Colors.gray),
      fill: style().foreground(Colors.blue),
      brackets: style().foreground(Colors.white),
      percentage: style().foreground(Colors.white)
    }
  };
  fancyProgressBarStyle = {
    emptyChar: "\u2500",
    fillChar: "\u2501",
    leftBracket: "\u2524",
    rightBracket: "\u251C",
    indeterminateChar: "\u25FC",
    colors: {
      empty: style().foreground(Colors.gray),
      fill: style().foreground(Colors.cyan),
      brackets: style().foreground(Colors.brightWhite),
      percentage: style().foreground(Colors.brightCyan)
    }
  };
  asciiProgressBarStyle = {
    emptyChar: "-",
    fillChar: "#",
    leftBracket: "[",
    rightBracket: "]",
    indeterminateChar: "=",
    colors: {
      empty: style().foreground(Colors.gray),
      fill: style().foreground(Colors.green),
      brackets: style().foreground(Colors.white),
      percentage: style().foreground(Colors.green)
    }
  };
});

// ../../src/components/feedback/progress-bar/index.ts
var init_progress_bar = __esm(() => {
  init_ProgressBar();
});

// ../../src/components/feedback/index.ts
var init_feedback = __esm(() => {
  init_spinner();
  init_modal();
  init_progress_bar();
});

// ../../src/components/data/table/jsx-dev-runtime.ts
var init_jsx_dev_runtime13 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/data/table/Table.tsx
var TableSelectionMode, updateNavigation = (model, newIndex, newScrollOffset) => {
  const maxIndex = model.filteredRows.length - 1;
  const clampedIndex = Math.max(0, Math.min(maxIndex, newIndex));
  const pageSize = model.props.pageSize ?? 10;
  const calculatedScrollOffset = newScrollOffset ?? model.scrollOffset;
  const clampedScrollOffset = Math.max(0, Math.min(maxIndex - pageSize + 1, calculatedScrollOffset));
  return [{
    ...model,
    currentRowIndex: clampedIndex,
    scrollOffset: clampedScrollOffset
  }, []];
}, applyFilters = (rows, filters) => {
  if (filters.length === 0)
    return rows;
  return rows.filter((row) => {
    return filters.every((filter18) => {
      const value6 = String(row.data[filter18.column] || "").toLowerCase();
      const filterValue = filter18.value.toLowerCase();
      switch (filter18.type) {
        case "contains":
          return value6.includes(filterValue);
        case "equals":
          return value6 === filterValue;
        case "startsWith":
          return value6.startsWith(filterValue);
        case "endsWith":
          return value6.endsWith(filterValue);
        default:
          return true;
      }
    });
  });
}, applySorting = (rows, sort3) => {
  if (!sort3)
    return rows;
  return [...rows].sort((a, b) => {
    const aValue = a.data[sort3.column];
    const bValue = b.data[sort3.column];
    let comparison = 0;
    if (aValue < bValue)
      comparison = -1;
    else if (aValue > bValue)
      comparison = 1;
    return sort3.direction === "desc" ? -comparison : comparison;
  });
}, getCellContent = (column, row, rowIndex) => {
  const value6 = row.data[column.key];
  if (column.render) {
    return column.render(value6, row.data, rowIndex);
  }
  return String(value6 || "");
}, formatCell = (content, width, align = "left") => {
  const contentWidth = stringWidth(content);
  if (contentWidth >= width) {
    let truncated = "";
    let currentWidth = 0;
    const segmenter = new Intl.Segmenter;
    const segments = [...segmenter.segment(content)];
    for (const { segment } of segments) {
      const segmentWidth = stringWidth(segment);
      if (currentWidth + segmentWidth > width - 1) {
        break;
      }
      truncated += segment;
      currentWidth += segmentWidth;
    }
    return truncated + "\u2026";
  }
  const padding = width - contentWidth;
  switch (align) {
    case "center":
      const leftPad = Math.floor(padding / 2);
      const rightPad = padding - leftPad;
      return " ".repeat(leftPad) + content + " ".repeat(rightPad);
    case "right":
      return " ".repeat(padding) + content;
    case "left":
    default:
      return content + " ".repeat(padding);
  }
}, TableHeader = ({ model, columnWidths }) => {
  const headerStyle = model.props.headerStyle ?? style().foreground(Colors.brightWhite);
  const borderStyle = model.props.borderStyle ?? style().foreground(Colors.gray);
  const headerCells = model.props.columns.map((col, index) => {
    const width = columnWidths[index];
    let title = col.title;
    if (model.sort && model.sort.column === col.key) {
      title += model.sort.direction === "asc" ? " \u2191" : " \u2193";
    }
    return formatCell(title, width, col.align);
  });
  if (model.props.showRowNumbers) {
    headerCells.unshift(formatCell("#", 4, "right"));
  }
  const separator = columnWidths.map((width) => "\u2500".repeat(width));
  if (model.props.showRowNumbers) {
    separator.unshift("\u2500".repeat(4));
  }
  return vstack(/* @__PURE__ */ jsx(Text, {
    style: headerStyle,
    children: headerCells.join("\u2502")
  }, undefined, false, undefined, this), /* @__PURE__ */ jsx(Text, {
    style: borderStyle,
    children: separator.join("\u253C")
  }, undefined, false, undefined, this));
}, TableStatusLine = ({ model }) => {
  const statusStyle = model.props.statusLineStyle ?? style().foreground(Colors.gray);
  const statusParts = [];
  if (model.filteredRows.length !== model.rows.length) {
    statusParts.push(`${model.filteredRows.length}/${model.rows.length} rows`);
  } else {
    statusParts.push(`${model.rows.length} rows`);
  }
  if (model.selectedRowIds.length > 0) {
    statusParts.push(`${model.selectedRowIds.length} selected`);
  }
  if (model.sort) {
    statusParts.push(`sorted by ${model.sort.column} ${model.sort.direction}`);
  }
  if (model.filters.length > 0) {
    statusParts.push(`${model.filters.length} filters`);
  }
  return /* @__PURE__ */ jsx(Text, {
    style: statusStyle,
    children: statusParts.join(" \u2022 ")
  }, undefined, false, undefined, this);
}, Table = (props) => {
  const id3 = generateComponentId("table");
  const rows = props.rows || [];
  const initialSort = props.initialSort ?? null;
  const initialFilters = props.initialFilters ?? [];
  return {
    id: id3,
    init() {
      const filteredRows = applySorting(applyFilters(rows, initialFilters), initialSort);
      const model = {
        id: id3,
        props,
        rows,
        filteredRows,
        selectedRowIds: [],
        currentRowIndex: 0,
        sort: initialSort,
        filters: initialFilters,
        scrollOffset: 0,
        focused: false,
        disabled: false,
        width: props.width ?? 80
      };
      return exports_Effect.succeed([model, []]);
    },
    update(msg, model) {
      switch (msg._tag) {
        case "selectRow": {
          if (model.props.selectionMode === "none" /* None */) {
            return exports_Effect.succeed([model, []]);
          }
          const newSelectedIds = model.props.selectionMode === "multiple" /* Multiple */ ? [...model.selectedRowIds, msg.rowId] : [msg.rowId];
          if (model.props.onRowSelect) {
            model.props.onRowSelect(msg.rowId);
          }
          return exports_Effect.succeed([{ ...model, selectedRowIds: newSelectedIds }, []]);
        }
        case "toggleRowSelection": {
          if (model.props.selectionMode === "none" /* None */) {
            return exports_Effect.succeed([model, []]);
          }
          const isSelected = model.selectedRowIds.includes(msg.rowId);
          const newSelectedIds = isSelected ? model.selectedRowIds.filter((id4) => id4 !== msg.rowId) : model.props.selectionMode === "multiple" /* Multiple */ ? [...model.selectedRowIds, msg.rowId] : [msg.rowId];
          if (!isSelected && model.props.onRowSelect) {
            model.props.onRowSelect(msg.rowId);
          }
          return exports_Effect.succeed([{ ...model, selectedRowIds: newSelectedIds }, []]);
        }
        case "selectAll": {
          if (model.props.selectionMode !== "multiple" /* Multiple */) {
            return exports_Effect.succeed([model, []]);
          }
          const allRowIds = model.filteredRows.map((row) => row.id);
          return exports_Effect.succeed([{ ...model, selectedRowIds: allRowIds }, []]);
        }
        case "clearSelection": {
          return exports_Effect.succeed([{ ...model, selectedRowIds: [] }, []]);
        }
        case "sortColumn": {
          const currentSort = model.sort;
          let newSort = null;
          if (!currentSort || currentSort.column !== msg.column) {
            newSort = { column: msg.column, direction: "asc" };
          } else if (currentSort.direction === "asc") {
            newSort = { column: msg.column, direction: "desc" };
          } else {
            newSort = null;
          }
          const newFilteredRows = applySorting(applyFilters(model.rows, model.filters), newSort);
          if (model.props.onSort) {
            model.props.onSort(newSort);
          }
          return exports_Effect.succeed([{
            ...model,
            sort: newSort,
            filteredRows: newFilteredRows,
            currentRowIndex: 0,
            scrollOffset: 0
          }, []]);
        }
        case "addFilter": {
          const newFilters = [...model.filters.filter((f) => f.column !== msg.filter.column), msg.filter];
          const newFilteredRows = applySorting(applyFilters(model.rows, newFilters), model.sort);
          if (model.props.onFilter) {
            model.props.onFilter(newFilters);
          }
          return exports_Effect.succeed([{
            ...model,
            filters: newFilters,
            filteredRows: newFilteredRows,
            currentRowIndex: 0,
            scrollOffset: 0
          }, []]);
        }
        case "removeFilter": {
          const newFilters = model.filters.filter((f) => f.column !== msg.column);
          const newFilteredRows = applySorting(applyFilters(model.rows, newFilters), model.sort);
          if (model.props.onFilter) {
            model.props.onFilter(newFilters);
          }
          return exports_Effect.succeed([{
            ...model,
            filters: newFilters,
            filteredRows: newFilteredRows,
            currentRowIndex: 0,
            scrollOffset: 0
          }, []]);
        }
        case "clearFilters": {
          const newFilteredRows = applySorting(model.rows, model.sort);
          if (model.props.onFilter) {
            model.props.onFilter([]);
          }
          return exports_Effect.succeed([{
            ...model,
            filters: [],
            filteredRows: newFilteredRows,
            currentRowIndex: 0,
            scrollOffset: 0
          }, []]);
        }
        case "navigateUp": {
          const newIndex = model.currentRowIndex - 1;
          const pageSize = model.props.pageSize ?? 10;
          const newScrollOffset = newIndex < model.scrollOffset ? newIndex : model.scrollOffset;
          return exports_Effect.succeed(updateNavigation(model, newIndex, newScrollOffset));
        }
        case "navigateDown": {
          const newIndex = model.currentRowIndex + 1;
          const pageSize = model.props.pageSize ?? 10;
          const newScrollOffset = newIndex >= model.scrollOffset + pageSize ? newIndex - pageSize + 1 : model.scrollOffset;
          return exports_Effect.succeed(updateNavigation(model, newIndex, newScrollOffset));
        }
        case "navigatePageUp": {
          const pageSize = model.props.pageSize ?? 10;
          const newIndex = model.currentRowIndex - pageSize;
          const newScrollOffset = model.scrollOffset - pageSize;
          return exports_Effect.succeed(updateNavigation(model, newIndex, newScrollOffset));
        }
        case "navigatePageDown": {
          const pageSize = model.props.pageSize ?? 10;
          const newIndex = model.currentRowIndex + pageSize;
          const newScrollOffset = model.scrollOffset + pageSize;
          return exports_Effect.succeed(updateNavigation(model, newIndex, newScrollOffset));
        }
        case "navigateHome": {
          return exports_Effect.succeed(updateNavigation(model, 0, 0));
        }
        case "navigateEnd": {
          const pageSize = model.props.pageSize ?? 10;
          const maxIndex = model.filteredRows.length - 1;
          const newScrollOffset = maxIndex - pageSize + 1;
          return exports_Effect.succeed(updateNavigation(model, maxIndex, newScrollOffset));
        }
        case "focus": {
          return exports_Effect.succeed([{ ...model, focused: true }, []]);
        }
        case "blur": {
          return exports_Effect.succeed([{ ...model, focused: false }, []]);
        }
      }
    },
    view(model) {
      const columnWidths = model.props.columns.map((col) => col.width ?? Math.min(col.maxWidth ?? 20, Math.max(col.minWidth ?? 8, stringWidth(col.title) + 2)));
      const rows2 = [];
      if (model.props.showHeader ?? true) {
        rows2.push(/* @__PURE__ */ jsx(TableHeader, {
          model,
          columnWidths
        }, undefined, false, undefined, this));
      }
      const pageSize = model.props.pageSize ?? 10;
      const visibleRows = model.filteredRows.slice(model.scrollOffset, model.scrollOffset + pageSize);
      visibleRows.forEach((row, index) => {
        const absoluteIndex = model.scrollOffset + index;
        const isSelected = model.selectedRowIds.includes(row.id);
        const isCurrent = absoluteIndex === model.currentRowIndex;
        const isDisabled3 = row.disabled || model.disabled;
        const cells = model.props.columns.map((col, colIndex) => {
          const content = getCellContent(col, row, absoluteIndex);
          const width = columnWidths[colIndex];
          return formatCell(content, width, col.align);
        });
        if (model.props.showRowNumbers) {
          cells.unshift(formatCell(String(absoluteIndex + 1), 4, "right"));
        }
        let cellStyle = model.props.rowStyle ?? style();
        if (isDisabled3) {
          cellStyle = model.props.disabledRowStyle ?? style().foreground(Colors.gray);
        } else if (isCurrent && model.focused) {
          cellStyle = model.props.currentRowStyle ?? style().background(Colors.blue).foreground(Colors.white);
        } else if (isSelected) {
          cellStyle = model.props.selectedRowStyle ?? style().background(Colors.cyan).foreground(Colors.black);
        }
        rows2.push(/* @__PURE__ */ jsx(Text, {
          style: cellStyle,
          children: cells.join("\u2502")
        }, undefined, false, undefined, this));
      });
      if (model.props.showStatusLine ?? true) {
        rows2.push(/* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this));
        rows2.push(/* @__PURE__ */ jsx(TableStatusLine, {
          model
        }, undefined, false, undefined, this));
      }
      return vstack(...rows2);
    },
    focus() {
      return exports_Effect.succeed({ _tag: "focus" });
    },
    blur() {
      return exports_Effect.succeed({ _tag: "blur" });
    },
    focused(model) {
      return model.focused;
    },
    setSize(width, height) {
      return exports_Effect.succeed(undefined);
    },
    getSize(model) {
      const pageSize = model.props.pageSize ?? 10;
      const headerHeight = model.props.showHeader ?? true ? 2 : 0;
      const dataHeight = Math.min(pageSize, model.filteredRows.length);
      const statusHeight = model.props.showStatusLine ?? true ? 2 : 0;
      const totalHeight = headerHeight + dataHeight + statusHeight;
      return { width: model.width, height: totalHeight };
    },
    handleKey(key, model) {
      if (model.disabled || !model.focused)
        return null;
      switch (key.key) {
        case "up":
        case "k":
          return { _tag: "navigateUp" };
        case "down":
        case "j":
          return { _tag: "navigateDown" };
        case "pageup":
          return { _tag: "navigatePageUp" };
        case "pagedown":
          return { _tag: "navigatePageDown" };
        case "home":
          return { _tag: "navigateHome" };
        case "end":
          return { _tag: "navigateEnd" };
        case "enter":
        case " ":
          if (model.filteredRows[model.currentRowIndex]) {
            const currentRow = model.filteredRows[model.currentRowIndex];
            if (currentRow) {
              return { _tag: "toggleRowSelection", rowId: currentRow.id };
            }
          }
          return null;
        case "ctrl+a":
          return { _tag: "selectAll" };
        case "escape":
          return { _tag: "clearSelection" };
        default:
          return null;
      }
    },
    handleMouse(mouse, model) {
      if (model.disabled || mouse.type !== "press" || mouse.button !== "left")
        return null;
      return { _tag: "focus" };
    }
  };
}, createColumn = (key, title, options = {}) => ({
  key,
  title,
  sortable: true,
  filterable: true,
  align: "left",
  ...options
}), createRow = (id3, data, options = {}) => ({
  id: id3,
  data,
  selectable: true,
  disabled: false,
  ...options
}), SimpleTable = ({
  data,
  columnKeys,
  ...props
}) => {
  const keys9 = columnKeys && columnKeys.length > 0 ? columnKeys : Object.keys(data[0] || {});
  const columns = keys9.map((key) => createColumn(String(key), String(key).toUpperCase()));
  const rows = data.map((item, index) => createRow(`row-${index}`, item));
  return Table({ columns, rows, ...props });
};
var init_Table = __esm(() => {
  init_esm2();
  init_string_width();
  init_styling();
  init_view();
  init_Text();
  init_base();
  init_jsx_dev_runtime13();
  ((TableSelectionMode2) => {
    TableSelectionMode2["None"] = "none";
    TableSelectionMode2["Single"] = "single";
    TableSelectionMode2["Multiple"] = "multiple";
  })(TableSelectionMode ||= {});
});

// ../../src/components/data/table/index.ts
var init_table = __esm(() => {
  init_Table();
  init_Table();
});

// ../../src/components/data/list/index.ts
var init_list = __esm(() => {
  init_List2();
});

// ../../src/components/data/FilterBox.tsx
var vstack2, hstack7, text5, styledText2, FilterBox = (props) => {
  const {
    title = "Filters",
    presets = [],
    activePreset,
    searchTerm = "",
    showSearch = true,
    searchPlaceholder = "Search...",
    compact: compact5 = false
  } = props;
  const content = compact5 ? hstack7(presets.length > 0 && hstack7(styledText2("Filter: ", style().foreground(Colors.gray)), ...presets.map((preset) => styledText2(`${preset.icon || "\u2022"} ${preset.label}`, style().foreground(activePreset === preset.name ? Colors.cyan : Colors.gray).bold(activePreset === preset.name))).reduce((acc, item, i) => i === 0 ? [item] : [...acc, text5(" | "), item], [])), showSearch && hstack7(text5("  "), text5("\uD83D\uDD0D "), searchTerm ? styledText2(searchTerm, style().foreground(Colors.yellow)) : styledText2(searchPlaceholder, style().foreground(Colors.gray).italic()))) : vstack2(presets.length > 0 && vstack2(styledText2("Quick Filters:", style().foreground(Colors.cyan).bold()), text5(""), ...presets.map((preset) => hstack7(styledText2(activePreset === preset.name ? "\u25B6" : " ", style().foreground(activePreset === preset.name ? Colors.green : Colors.gray)), text5(preset.icon || "\u2022"), styledText2(preset.label, style().foreground(activePreset === preset.name ? Colors.cyan : Colors.white).bold(activePreset === preset.name))))), showSearch && hstack7(text5("\uD83D\uDD0D"), searchTerm ? styledText2(searchTerm, style().foreground(Colors.yellow)) : styledText2(searchPlaceholder, style().foreground(Colors.gray).italic())));
  return content;
}, LOG_FILTER_PRESETS, PROCESS_FILTER_PRESETS, FilterableContent = (props) => {
  const {
    items,
    renderItem,
    filters = [],
    searchFields = [],
    title = "Filterable Content",
    emptyMessage = "No items match the current filters"
  } = props;
  const filteredItems = items;
  return vstack2(FilterBox({
    presets: filters,
    compact: true,
    showSearch: searchFields.length > 0
  }), text5(""), styledText2("\u2500".repeat(80), style().foreground(Colors.gray)), text5(""), filteredItems.length === 0 ? styledText2(emptyMessage, style().foreground(Colors.yellow)) : vstack2(...filteredItems.map(renderItem)), text5(""), hstack7(styledText2(`Showing ${filteredItems.length} of ${items.length} items`, style().foreground(Colors.gray))));
};
var init_FilterBox = __esm(() => {
  init_core3();
  init_styling();
  ({ vstack: vstack2, hstack: hstack7, text: text5, styledText: styledText2 } = exports_view);
  LOG_FILTER_PRESETS = [
    {
      name: "errors",
      label: "Errors Only",
      icon: "\u274C",
      filter: (log4) => log4.level === "error" || log4.level === "fatal"
    },
    {
      name: "warnings",
      label: "Warnings & Errors",
      icon: "\u26A0\uFE0F",
      filter: (log4) => ["warn", "error", "fatal"].includes(log4.level)
    },
    {
      name: "debug",
      label: "Debug & Above",
      icon: "\uD83D\uDD0D",
      filter: (log4) => log4.level !== "trace"
    },
    {
      name: "recent",
      label: "Last 5 minutes",
      icon: "\uD83D\uDD50",
      filter: (log4) => Date.now() - log4.timestamp.getTime() < 5 * 60 * 1000
    }
  ];
  PROCESS_FILTER_PRESETS = [
    {
      name: "running",
      label: "Running Only",
      icon: "\uD83D\uDFE2",
      filter: (proc) => proc.status === "running"
    },
    {
      name: "stopped",
      label: "Stopped Only",
      icon: "\u26AA",
      filter: (proc) => proc.status === "stopped"
    },
    {
      name: "errors",
      label: "Errors Only",
      icon: "\uD83D\uDD34",
      filter: (proc) => proc.status === "error"
    },
    {
      name: "active",
      label: "Active (Running/Starting)",
      icon: "\u26A1",
      filter: (proc) => ["running", "starting"].includes(proc.status)
    }
  ];
});

// ../../src/components/data/index.ts
var init_data2 = __esm(() => {
  init_table();
  init_list();
  init_FilterBox();
});

// ../../src/components/navigation/tabs/jsx-dev-runtime.ts
var init_jsx_dev_runtime14 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/navigation/tabs/Tabs.tsx
var defaultTabStyles, findTab = (tabs, tabId) => {
  return tabs.find((tab) => tab.id === tabId) || null;
}, getNextTabId = (tabs, currentId) => {
  const currentIndex = tabs.findIndex((tab) => tab.id === currentId);
  if (currentIndex === -1)
    return null;
  for (let i = 1;i < tabs.length; i++) {
    const nextIndex = (currentIndex + i) % tabs.length;
    const nextTab = tabs[nextIndex];
    if (nextTab && !nextTab.disabled) {
      return nextTab.id;
    }
  }
  return null;
}, getPrevTabId = (tabs, currentId) => {
  const currentIndex = tabs.findIndex((tab) => tab.id === currentId);
  if (currentIndex === -1)
    return null;
  for (let i = 1;i < tabs.length; i++) {
    const prevIndex = (currentIndex - i + tabs.length) % tabs.length;
    const prevTab = tabs[prevIndex];
    if (prevTab && !prevTab.disabled) {
      return prevTab.id;
    }
  }
  return null;
}, TabTitle = ({
  tab,
  isActive: isActive2,
  isFocused,
  styles
}) => {
  let tabStyle = styles.inactiveTab;
  if (tab.disabled) {
    tabStyle = styles.disabledTab;
  } else if (isActive2) {
    tabStyle = styles.activeTab;
  }
  if (isFocused && !tab.disabled) {
    tabStyle = tabStyle.merge(styles.focused);
  }
  const parts2 = [];
  if (tab.icon) {
    parts2.push(/* @__PURE__ */ jsx(Text, {
      children: [
        tab.icon,
        " "
      ]
    }, undefined, true, undefined, this));
  }
  parts2.push(/* @__PURE__ */ jsx(Text, {
    children: tab.title
  }, undefined, false, undefined, this));
  if (tab.badge) {
    parts2.push(/* @__PURE__ */ jsx(Text, {
      style: styles.badge,
      children: [
        " (",
        tab.badge,
        ")"
      ]
    }, undefined, true, undefined, this));
  }
  return /* @__PURE__ */ jsx(Text, {
    style: tabStyle,
    children: h(...parts2)
  }, undefined, false, undefined, this);
}, TabBar = ({
  model,
  styles,
  orientation
}) => {
  const tabs = model.props.tabs.map((tab, index) => {
    const isActive2 = tab.id === model.activeTabId;
    const isFocused = model.focused;
    const tabView = /* @__PURE__ */ jsx(TabTitle, {
      tab,
      isActive: isActive2,
      isFocused: isFocused && isActive2,
      styles
    }, undefined, false, undefined, this);
    if (orientation === "horizontal" && index < model.props.tabs.length - 1) {
      return h(tabView, /* @__PURE__ */ jsx(Text, {
        style: styles.tabSeparator,
        children: " | "
      }, undefined, false, undefined, this));
    }
    return tabView;
  });
  const TabContainer = orientation === "horizontal" ? Flex : Box;
  const containerProps = orientation === "horizontal" ? { direction: "horizontal", gap: 0 } : {};
  return /* @__PURE__ */ jsx(Box, {
    style: styles.tabBar,
    children: /* @__PURE__ */ jsx(TabContainer, {
      ...containerProps,
      children: orientation === "horizontal" ? hstack(...tabs) : vstack(...tabs)
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
}, TabContent = ({
  content,
  renderContent,
  style: contentStyle
}) => {
  if (renderContent) {
    return renderContent(content);
  }
  if (typeof content === "string") {
    return /* @__PURE__ */ jsx(Text, {
      style: contentStyle,
      children: content
    }, undefined, false, undefined, this);
  }
  return content;
}, Tabs = (props = { tabs: [] }) => {
  const styles = { ...defaultTabStyles, ...props.styles };
  return {
    id: generateComponentId("tabs"),
    init() {
      const activeTabId = props.activeTabId || (props.tabs.length > 0 ? props.tabs[0].id : "");
      const model = {
        id: generateComponentId("tabs"),
        props,
        activeTabId,
        focused: false,
        disabled: false,
        width: 80,
        height: 24
      };
      return exports_Effect.succeed([model, []]);
    },
    update(msg, model) {
      switch (msg._tag) {
        case "selectTab": {
          const tab = findTab(model.props.tabs, msg.tabId);
          if (!tab || tab.disabled) {
            return exports_Effect.succeed([model, []]);
          }
          if (model.props.onTabChange) {
            model.props.onTabChange(msg.tabId);
          }
          return exports_Effect.succeed([
            { ...model, activeTabId: msg.tabId },
            []
          ]);
        }
        case "nextTab": {
          const nextId = getNextTabId(model.props.tabs, model.activeTabId);
          if (!nextId) {
            return exports_Effect.succeed([model, []]);
          }
          if (model.props.onTabChange) {
            model.props.onTabChange(nextId);
          }
          return exports_Effect.succeed([
            { ...model, activeTabId: nextId },
            []
          ]);
        }
        case "prevTab": {
          const prevId = getPrevTabId(model.props.tabs, model.activeTabId);
          if (!prevId) {
            return exports_Effect.succeed([model, []]);
          }
          if (model.props.onTabChange) {
            model.props.onTabChange(prevId);
          }
          return exports_Effect.succeed([
            { ...model, activeTabId: prevId },
            []
          ]);
        }
        case "focus": {
          return exports_Effect.succeed([
            { ...model, focused: true },
            []
          ]);
        }
        case "blur": {
          return exports_Effect.succeed([
            { ...model, focused: false },
            []
          ]);
        }
        default:
          return exports_Effect.succeed([model, []]);
      }
    },
    view(model) {
      const activeTab = findTab(model.props.tabs, model.activeTabId);
      const orientation = model.props.orientation ?? "horizontal";
      const showTabBar = model.props.tabBarVisible ?? true;
      const views = [];
      if (showTabBar) {
        views.push(/* @__PURE__ */ jsx(TabBar, {
          model,
          styles,
          orientation
        }, undefined, false, undefined, this));
        if (orientation === "horizontal") {
          views.push(/* @__PURE__ */ jsx(Text, {
            style: styles.tabSeparator,
            children: "\u2500".repeat(model.width)
          }, undefined, false, undefined, this));
        }
      }
      if (activeTab) {
        views.push(/* @__PURE__ */ jsx(TabContent, {
          content: activeTab.content,
          renderContent: model.props.renderContent,
          style: styles.content
        }, undefined, false, undefined, this));
      }
      return orientation === "horizontal" ? vstack(...views) : /* @__PURE__ */ jsx(Flex, {
        direction: "horizontal",
        gap: 2,
        children: hstack(...views)
      }, undefined, false, undefined, this);
    },
    focus() {
      return exports_Effect.succeed({ _tag: "focus" });
    },
    blur() {
      return exports_Effect.succeed({ _tag: "blur" });
    },
    focused(model) {
      return model.focused;
    },
    setSize(width, height) {
      return exports_Effect.succeed(undefined);
    },
    getSize(model) {
      return { width: model.width, height: model.height };
    },
    handleKey(key, model) {
      if (model.disabled || !model.focused)
        return null;
      switch (key.key) {
        case "tab":
          if (key.shift) {
            return { _tag: "prevTab" };
          } else {
            return { _tag: "nextTab" };
          }
        case "left":
        case "h":
          if (model.props.orientation !== "vertical") {
            return { _tag: "prevTab" };
          }
          break;
        case "right":
        case "l":
          if (model.props.orientation !== "vertical") {
            return { _tag: "nextTab" };
          }
          break;
        case "up":
        case "k":
          if (model.props.orientation === "vertical") {
            return { _tag: "prevTab" };
          }
          break;
        case "down":
        case "j":
          if (model.props.orientation === "vertical") {
            return { _tag: "nextTab" };
          }
          break;
      }
      if (key.runes && key.runes.length === 1) {
        const num = parseInt(key.runes, 10);
        if (!isNaN(num) && num >= 1 && num <= 9 && num <= model.props.tabs.length) {
          const tab = model.props.tabs[num - 1];
          if (tab && !tab.disabled) {
            return { _tag: "selectTab", tabId: tab.id };
          }
        }
      }
      return null;
    },
    handleMouse(mouse, model) {
      if (model.disabled || mouse.type !== "press" || mouse.button !== "left")
        return null;
      return null;
    }
  };
}, SimpleTabs = (props) => {
  return Tabs({
    ...props,
    tabs: props.tabs
  });
}, ViewTabs = (props) => {
  return Tabs({
    ...props,
    tabs: props.tabs
  });
};
var init_Tabs = __esm(() => {
  init_esm2();
  init_styling();
  init_view();
  init_Text();
  init_Box();
  init_Flex();
  init_base();
  init_jsx_dev_runtime14();
  defaultTabStyles = {
    focused: style().bold(),
    blurred: style(),
    disabled: style().faint(),
    activeTab: style().foreground(Colors.brightWhite).background(Colors.blue),
    inactiveTab: style().foreground(Colors.gray),
    disabledTab: style().foreground(Colors.darkGray),
    tabSeparator: style().foreground(Colors.gray),
    content: style().foreground(Colors.white),
    badge: style().foreground(Colors.yellow),
    tabBar: style()
  };
});

// ../../src/components/navigation/tabs/index.ts
var init_tabs = __esm(() => {
  init_Tabs();
});

// ../../src/layout/join.ts
var Top = 0, Left2 = 0, Center2 = 0.5, Bottom = 1, Right2 = 1, joinHorizontal = (position, ...views) => {
  const spacing = 0;
  if (views.length === 0) {
    return { render: () => exports_Effect.succeed(""), width: 0, height: 0 };
  }
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(exports_Effect.forEach(views, (v) => v.render()));
      const viewLines = rendered.map((content) => content.split(`
`));
      const maxHeight = Math.max(...viewLines.map((lines) => lines.length));
      const aligned = viewLines.map((lines) => {
        const height = lines.length;
        if (height >= maxHeight)
          return lines;
        const diff11 = maxHeight - height;
        const top = Math.floor(diff11 * position);
        const bottom = diff11 - top;
        return [
          ...Array(top).fill(""),
          ...lines,
          ...Array(bottom).fill("")
        ];
      });
      const result = [];
      for (let i = 0;i < maxHeight; i++) {
        const lineParts = aligned.map((lines, viewIndex) => {
          const line = lines[i] || "";
          const viewWidth = views[viewIndex]?.width || 0;
          return line.padEnd(viewWidth);
        });
        const spacer = " ".repeat(spacing);
        result.push(lineParts.join(spacer));
      }
      return result.join(`
`);
    }),
    width: views.reduce((sum3, v) => sum3 + (v.width || 0), 0) + spacing * (views.length - 1),
    height: Math.max(...views.map((v) => v.height || 0))
  };
}, joinVertical = (position, ...views) => {
  const spacing = 0;
  if (views.length === 0) {
    return { render: () => exports_Effect.succeed(""), width: 0, height: 0 };
  }
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(exports_Effect.forEach(views, (v) => v.render()));
      const maxWidth = Math.max(...views.map((v) => v.width || 0));
      const aligned = rendered.map((content, index) => {
        const lines = content.split(`
`);
        const viewWidth = views[index]?.width || 0;
        if (viewWidth >= maxWidth)
          return lines;
        const diff11 = maxWidth - viewWidth;
        const left3 = Math.floor(diff11 * position);
        const right3 = diff11 - left3;
        return lines.map((line) => " ".repeat(left3) + line + " ".repeat(right3));
      });
      if (spacing > 0) {
        const spacerLines = Array(spacing).fill(" ".repeat(maxWidth));
        const result = [];
        aligned.forEach((lines, i) => {
          result.push(...lines);
          if (i < aligned.length - 1) {
            result.push(...spacerLines);
          }
        });
        return result.join(`
`);
      }
      return aligned.flat().join(`
`);
    }),
    width: Math.max(...views.map((v) => v.width || 0)),
    height: views.reduce((sum3, v) => sum3 + (v.height || 0), 0) + spacing * (views.length - 1)
  };
}, place = (width, height, hPos, vPos, view) => {
  return {
    render: () => exports_Effect.gen(function* (_) {
      const content = yield* _(view.render());
      const lines = content.split(`
`);
      const alignedLines = lines.map((line) => {
        const lineWidth = stringWidth(line);
        if (lineWidth >= width)
          return line.slice(0, width);
        const space = width - lineWidth;
        const left3 = Math.floor(space * hPos);
        const right3 = space - left3;
        return " ".repeat(left3) + line + " ".repeat(right3);
      });
      const currentHeight = alignedLines.length;
      if (currentHeight >= height) {
        return alignedLines.slice(0, height).join(`
`);
      }
      const vSpace = height - currentHeight;
      const top = Math.floor(vSpace * vPos);
      const bottom = vSpace - top;
      const emptyLine = " ".repeat(width);
      const result = [
        ...Array(top).fill(emptyLine),
        ...alignedLines,
        ...Array(bottom).fill(emptyLine)
      ];
      return result.join(`
`);
    }),
    width,
    height
  };
};
var init_join = __esm(() => {
  init_esm2();
  init_string_width();
});

// ../../src/layout/box.ts
var normalizePadding = (padding) => {
  if (typeof padding === "number") {
    return { top: padding, right: padding, bottom: padding, left: padding };
  }
  return {
    top: padding?.top || 0,
    right: padding?.right || 0,
    bottom: padding?.bottom || 0,
    left: padding?.left || 0
  };
}, getContentDimensions = (lines) => ({
  width: Math.max(...lines.map((line) => stringWidth(line)), 0),
  height: lines.length
}), createPaddedLines = (contentLines, contentWidth, padding) => {
  const paddedWidth = contentWidth + padding.left + padding.right;
  const paddedLines = [];
  paddedLines.push(...Array(padding.top).fill(" ".repeat(paddedWidth)));
  for (const line of contentLines) {
    const padded = " ".repeat(padding.left) + line.padEnd(contentWidth) + " ".repeat(padding.right);
    paddedLines.push(padded);
  }
  paddedLines.push(...Array(padding.bottom).fill(" ".repeat(paddedWidth)));
  return paddedLines;
}, adjustToFinalWidth = (lines, currentWidth, finalWidth) => {
  if (finalWidth <= currentWidth)
    return lines;
  const extraPadding = finalWidth - currentWidth;
  return lines.map((line) => line + " ".repeat(extraPadding));
}, styledBox = (content, props = {}) => {
  const contents = Array.isArray(content) ? content : [content];
  const innerView = contents.length === 1 ? contents[0] : joinVertical(Center2, ...contents);
  const padding = normalizePadding(props.padding);
  return {
    render: () => exports_Effect.gen(function* (_) {
      const innerContent = yield* _(innerView.render());
      const innerLines = innerContent.split(`
`);
      const { width: innerWidth } = getContentDimensions(innerLines);
      const paddedLines = createPaddedLines(innerLines, innerWidth, padding);
      const paddedWidth = innerWidth + padding.left + padding.right;
      const finalWidth = Math.max(paddedWidth, props.minWidth || 0);
      const adjustedLines = adjustToFinalWidth(paddedLines, paddedWidth, finalWidth);
      if (props.border) {
        const bordered = renderBox(adjustedLines, props.border, props.borderSides || 15 /* All */, finalWidth);
        return bordered.join(`
`);
      }
      return adjustedLines.join(`
`);
    }),
    width: Math.max((innerView.width || 0) + padding.left + padding.right + (props.border ? 2 : 0), (props.minWidth || 0) + (props.border ? 2 : 0)),
    height: Math.max((innerView.height || 0) + padding.top + padding.bottom + (props.border ? 2 : 0), (props.minHeight || 0) + (props.border ? 2 : 0))
  };
};
var init_box2 = __esm(() => {
  init_esm2();
  init_string_width();
  init_view();
  init_styling();
  init_join();
});

// ../../src/tea/navigation/Help.ts
var defaultConfig2, getTotalBindings = (sections) => {
  return sections.reduce((sum3, section) => sum3 + section.bindings.length, 0);
}, getPageSize = (height) => {
  return Math.floor((height ?? defaultConfig2.height ?? 25) / 4);
}, clampIndex = (index, max6) => {
  return Math.max(0, Math.min(index, max6 - 1));
}, filterSections = (sections, query) => {
  if (!query.trim()) {
    return sections;
  }
  const lowerQuery = query.toLowerCase();
  return sections.map((section) => ({
    ...section,
    bindings: section.bindings.filter((binding) => binding.key.toLowerCase().includes(lowerQuery) || binding.description.toLowerCase().includes(lowerQuery) || binding.category && binding.category.toLowerCase().includes(lowerQuery))
  })).filter((section) => section.bindings.length > 0);
}, formatKeyBinding = (binding, maxKeyWidth, keyStyle, descriptionStyle) => {
  const keyPart = binding.key.padEnd(maxKeyWidth);
  const separator = " \u2022 ";
  return hstack(styledText(keyPart, keyStyle), styledText(separator, style().foreground(Colors.gray)), styledText(binding.description, descriptionStyle));
}, createSectionHeader = (title, description, categoryStyle) => {
  const views = [
    text(""),
    styledText(`\u25B6 ${title}`, categoryStyle)
  ];
  if (description) {
    views.push(styledText(`  ${description}`, style().foreground(Colors.gray)));
  }
  views.push(text(""));
  return views;
}, createSearchInput = (query, width, active2) => {
  const prefix = "Search: ";
  const maxQueryWidth = width - stringWidth(prefix) - 4;
  let displayQuery = query;
  if (stringWidth(query) > maxQueryWidth) {
    displayQuery = query.substring(query.length - maxQueryWidth);
  }
  const cursor = active2 ? "\u2502" : "";
  const searchStyle = active2 ? style().background(Colors.blue).foreground(Colors.white) : style().foreground(Colors.gray);
  return styledBox(hstack(styledText(prefix, style().foreground(Colors.yellow)), styledText(displayQuery + cursor, searchStyle)), {
    border: Borders.Rounded,
    padding: { top: 0, right: 1, bottom: 0, left: 1 },
    style: style().foreground(Colors.gray)
  });
}, getDefaultKeybindings = () => [
  {
    title: "General",
    description: "Basic application controls",
    bindings: [
      { key: "q", description: "Quit application", category: "general" },
      { key: "Ctrl+C", description: "Force quit", category: "general" },
      { key: "Escape", description: "Close dialog/cancel", category: "general" },
      { key: "?", description: "Show/hide help", category: "general" },
      { key: "F1", description: "Show help", category: "general" }
    ]
  },
  {
    title: "Navigation",
    description: "Moving around the interface",
    bindings: [
      { key: "\u2191/k", description: "Move up", category: "navigation" },
      { key: "\u2193/j", description: "Move down", category: "navigation" },
      { key: "\u2190/h", description: "Move left", category: "navigation" },
      { key: "\u2192/l", description: "Move right", category: "navigation" },
      { key: "Home", description: "Go to first item", category: "navigation" },
      { key: "End", description: "Go to last item", category: "navigation" },
      { key: "Page Up", description: "Page up", category: "navigation" },
      { key: "Page Down", description: "Page down", category: "navigation" }
    ]
  },
  {
    title: "Selection",
    description: "Selecting and activating items",
    bindings: [
      { key: "Enter", description: "Select/activate item", category: "selection" },
      { key: "Space", description: "Toggle selection", category: "selection" },
      { key: "Tab", description: "Next selectable item", category: "selection" },
      { key: "Shift+Tab", description: "Previous selectable item", category: "selection" },
      { key: "Ctrl+A", description: "Select all", category: "selection" }
    ]
  },
  {
    title: "Editing",
    description: "Text editing and manipulation",
    bindings: [
      { key: "Ctrl+C", description: "Copy", category: "editing" },
      { key: "Ctrl+V", description: "Paste", category: "editing" },
      { key: "Ctrl+X", description: "Cut", category: "editing" },
      { key: "Ctrl+Z", description: "Undo", category: "editing" },
      { key: "Ctrl+Y", description: "Redo", category: "editing" },
      { key: "Delete", description: "Delete character", category: "editing" },
      { key: "Backspace", description: "Delete previous character", category: "editing" }
    ]
  }
], help = (config4 = {}, sections) => {
  const finalConfig = { ...defaultConfig2, ...config4 };
  const defaultSections = sections ?? getDefaultKeybindings();
  return {
    init: exports_Effect.succeed([
      {
        config: finalConfig,
        sections: defaultSections,
        isOpen: false,
        searchQuery: "",
        filteredSections: defaultSections,
        selectedIndex: 0,
        showSearch: false,
        terminalWidth: 80,
        terminalHeight: 24
      },
      []
    ]),
    update(msg, model) {
      switch (msg._tag) {
        case "Open":
          return exports_Effect.succeed([
            {
              ...model,
              isOpen: true,
              filteredSections: filterSections(model.sections, model.searchQuery)
            },
            []
          ]);
        case "Close":
          return exports_Effect.succeed([
            {
              ...model,
              isOpen: false,
              showSearch: false,
              searchQuery: "",
              filteredSections: model.sections
            },
            []
          ]);
        case "ToggleSearch":
          const newShowSearch = !model.showSearch;
          return exports_Effect.succeed([
            {
              ...model,
              showSearch: newShowSearch,
              searchQuery: newShowSearch ? model.searchQuery : "",
              filteredSections: newShowSearch ? filterSections(model.sections, model.searchQuery) : model.sections
            },
            []
          ]);
        case "SetSearchQuery":
          const filtered = filterSections(model.sections, msg.query);
          return exports_Effect.succeed([
            {
              ...model,
              searchQuery: msg.query,
              filteredSections: filtered,
              selectedIndex: 0
            },
            []
          ]);
        case "ClearSearch":
          return exports_Effect.succeed([
            {
              ...model,
              searchQuery: "",
              filteredSections: model.sections,
              selectedIndex: 0
            },
            []
          ]);
        case "NavigateUp":
          return exports_Effect.succeed([
            {
              ...model,
              selectedIndex: Math.max(0, model.selectedIndex - 1)
            },
            []
          ]);
        case "NavigateDown":
          const totalBindings = getTotalBindings(model.filteredSections);
          return exports_Effect.succeed([
            {
              ...model,
              selectedIndex: clampIndex(model.selectedIndex + 1, totalBindings)
            },
            []
          ]);
        case "NavigatePageUp":
          const pageSize = getPageSize(model.config.height);
          return exports_Effect.succeed([
            {
              ...model,
              selectedIndex: Math.max(0, model.selectedIndex - pageSize)
            },
            []
          ]);
        case "NavigatePageDown":
          const totalBindingsDown = getTotalBindings(model.filteredSections);
          const pageSizeDown = getPageSize(model.config.height);
          return exports_Effect.succeed([
            {
              ...model,
              selectedIndex: clampIndex(model.selectedIndex + pageSizeDown, totalBindingsDown)
            },
            []
          ]);
        case "SetSections":
          const newFiltered = filterSections(msg.sections, model.searchQuery);
          const newTotal = getTotalBindings(newFiltered);
          return exports_Effect.succeed([
            {
              ...model,
              sections: msg.sections,
              filteredSections: newFiltered,
              selectedIndex: clampIndex(model.selectedIndex, newTotal)
            },
            []
          ]);
        case "SetTerminalSize":
          return exports_Effect.succeed([
            {
              ...model,
              terminalWidth: msg.width,
              terminalHeight: msg.height
            },
            []
          ]);
      }
    },
    view(model) {
      if (!model.isOpen) {
        return text("");
      }
      const { config: config5 } = model;
      const width = config5.width ?? defaultConfig2.width ?? 70;
      const height = config5.height ?? defaultConfig2.height ?? 25;
      const maxKeyWidth = config5.maxKeyWidth ?? defaultConfig2.maxKeyWidth ?? 15;
      const headerStyle = config5.headerStyle ?? defaultConfig2.headerStyle ?? style();
      const keyStyle = config5.keyStyle ?? defaultConfig2.keyStyle ?? style();
      const descriptionStyle = config5.descriptionStyle ?? defaultConfig2.descriptionStyle ?? style();
      const categoryStyle = config5.categoryStyle ?? defaultConfig2.categoryStyle ?? style();
      const mainStyle = config5.style ?? defaultConfig2.style ?? style();
      const content = [];
      if (config5.title) {
        content.push(styledText(config5.title, headerStyle));
        content.push(text(""));
      }
      if (config5.showSearch && model.showSearch) {
        content.push(createSearchInput(model.searchQuery, width - 4, true));
        content.push(text(""));
      }
      for (const section of model.filteredSections) {
        if (config5.showCategories) {
          content.push(...createSectionHeader(section.title, section.description, categoryStyle));
        }
        for (const binding of section.bindings) {
          content.push(hstack(text("  "), formatKeyBinding(binding, maxKeyWidth, keyStyle, descriptionStyle)));
        }
      }
      content.push(text(""));
      content.push(text(""));
      content.push(styledText("Controls:", style().foreground(Colors.yellow).bold()));
      content.push(styledText("  \u2191\u2193: Navigate \u2022 /: Search \u2022 Escape: Close", style().foreground(Colors.gray)));
      if (config5.showAsModal) {
        return styledBox(vstack(...content), {
          border: Borders.Rounded,
          padding: { top: 1, right: 2, bottom: 1, left: 2 },
          minWidth: width,
          minHeight: height,
          style: mainStyle
        });
      } else {
        return vstack(...content);
      }
    },
    handleKey(key, model) {
      if (!model.isOpen) {
        return null;
      }
      if (model.showSearch) {
        switch (key.key) {
          case "escape":
            return { _tag: "ToggleSearch" };
          case "enter":
            return { _tag: "ToggleSearch" };
          case "backspace":
            if (model.searchQuery.length > 0) {
              return { _tag: "SetSearchQuery", query: model.searchQuery.slice(0, -1) };
            }
            break;
          default:
            if (key.key.length === 1 && !key.ctrl && !key.alt) {
              return { _tag: "SetSearchQuery", query: model.searchQuery + key.key };
            }
        }
      } else {
        switch (key.key) {
          case "escape":
            return { _tag: "Close" };
          case "up":
          case "k":
            return { _tag: "NavigateUp" };
          case "down":
          case "j":
            return { _tag: "NavigateDown" };
          case "pageup":
            return { _tag: "NavigatePageUp" };
          case "pagedown":
            return { _tag: "NavigatePageDown" };
          case "/":
            if (model.config.showSearch) {
              return { _tag: "ToggleSearch" };
            }
            break;
          case "c":
            if (key.ctrl) {
              return { _tag: "ClearSearch" };
            }
            break;
        }
      }
      return null;
    }
  };
}, createHelpModal = (title, customSections) => {
  const component = help({
    title: title ?? "Help & Keyboard Shortcuts",
    showAsModal: true,
    showSearch: true,
    width: 75,
    height: 30
  }, customSections);
  const openEffect = exports_Effect.succeed({ _tag: "Open" });
  return { component, openEffect };
}, createHelpPanel = (sections, config4) => {
  return help({
    showAsModal: false,
    showCategories: true,
    showSearch: false,
    ...config4
  }, sections);
}, createContextHelp = (context10, bindings) => {
  return {
    title: `${context10} Controls`,
    description: `Keyboard shortcuts for ${context10.toLowerCase()}`,
    bindings: bindings.map((binding) => ({ ...binding, context: context10 }))
  };
};
var init_Help = __esm(() => {
  init_esm2();
  init_view();
  init_styling();
  init_box2();
  init_string_width();
  defaultConfig2 = {
    title: "Help & Keyboard Shortcuts",
    width: 70,
    height: 25,
    showAsModal: true,
    showCategories: true,
    showSearch: true,
    maxKeyWidth: 15,
    style: style().background(Colors.black).foreground(Colors.white),
    headerStyle: style().foreground(Colors.brightBlue).bold(),
    keyStyle: style().foreground(Colors.yellow).bold(),
    descriptionStyle: style().foreground(Colors.white),
    categoryStyle: style().foreground(Colors.brightCyan).bold()
  };
});

// ../../src/components/navigation/help/index.ts
var init_help = __esm(() => {
  init_Help();
});

// ../../src/components/navigation/index.ts
var init_navigation = __esm(() => {
  init_tabs();
  init_help();
});

// ../../src/components/containers/viewport/jsx-dev-runtime.ts
var init_jsx_dev_runtime15 = __esm(() => {
  init_dev_runtime();
});

// ../../src/components/containers/viewport/Viewport.tsx
var Viewport = (props) => {
  const {
    children: children3,
    width,
    height,
    showScrollbars = true,
    smoothScroll = true,
    scrollStep = 1,
    pageSize = Math.max(1, height - 2),
    style: customStyle,
    borderStyle = "single",
    scrollbarStyle,
    onScroll,
    onScrollUp,
    onScrollDown,
    onScrollLeft,
    onScrollRight,
    ...restProps
  } = props;
  const state = $state({
    scrollX: 0,
    scrollY: 0,
    contentWidth: 0,
    contentHeight: 0,
    content: [],
    isFocused: false
  });
  const processChildren = (children4) => {
    if (!children4)
      return [];
    const childArray = Array.isArray(children4) ? children4 : [children4];
    const lines2 = [];
    childArray.forEach((child) => {
      if (typeof child === "string") {
        lines2.push(child);
      } else if (child && typeof child === "object" && "render" in child) {
        const rendered = child.render();
        if (typeof rendered === "string") {
          lines2.push(...rendered.split(`
`));
        }
      } else {
        lines2.push(String(child));
      }
    });
    return lines2;
  };
  const contentLines = processChildren(children3);
  state.content = contentLines;
  state.contentHeight = contentLines.length;
  state.contentWidth = Math.max(...contentLines.map((line) => stringWidth(line)), 0);
  const viewportWidth = showScrollbars ? width - 1 : width;
  const viewportHeight = showScrollbars ? height - 1 : height;
  const maxScrollX = Math.max(0, state.contentWidth - viewportWidth);
  const maxScrollY = Math.max(0, state.contentHeight - viewportHeight);
  state.scrollX = Math.max(0, Math.min(state.scrollX, maxScrollX));
  state.scrollY = Math.max(0, Math.min(state.scrollY, maxScrollY));
  const scrollUp = (amount = scrollStep) => {
    state.scrollY = Math.max(0, state.scrollY - amount);
    onScroll?.(state.scrollX, state.scrollY);
    onScrollUp?.();
  };
  const scrollDown = (amount = scrollStep) => {
    state.scrollY = Math.min(maxScrollY, state.scrollY + amount);
    onScroll?.(state.scrollX, state.scrollY);
    onScrollDown?.();
  };
  const scrollLeft = (amount = scrollStep) => {
    state.scrollX = Math.max(0, state.scrollX - amount);
    onScroll?.(state.scrollX, state.scrollY);
    onScrollLeft?.();
  };
  const scrollRight = (amount = scrollStep) => {
    state.scrollX = Math.min(maxScrollX, state.scrollX + amount);
    onScroll?.(state.scrollX, state.scrollY);
    onScrollRight?.();
  };
  const scrollToTop = () => {
    state.scrollY = 0;
    onScroll?.(state.scrollX, state.scrollY);
  };
  const scrollToBottom = () => {
    state.scrollY = maxScrollY;
    onScroll?.(state.scrollX, state.scrollY);
  };
  const pageUp = () => {
    scrollUp(pageSize);
  };
  const pageDown = () => {
    scrollDown(pageSize);
  };
  const renderContent = () => {
    const visibleLines = state.content.slice(state.scrollY, state.scrollY + viewportHeight).map((line) => {
      const visiblePart = line.slice(state.scrollX, state.scrollX + viewportWidth);
      return visiblePart.padEnd(viewportWidth);
    });
    while (visibleLines.length < viewportHeight) {
      visibleLines.push(" ".repeat(viewportWidth));
    }
    return visibleLines;
  };
  const renderVerticalScrollbar = () => {
    if (!showScrollbars || maxScrollY === 0)
      return null;
    const scrollbarHeight = viewportHeight;
    const thumbSize = Math.max(1, Math.floor(viewportHeight / state.contentHeight * scrollbarHeight));
    const thumbPosition = Math.floor(state.scrollY / maxScrollY * (scrollbarHeight - thumbSize));
    const scrollbarLines = Array.from({ length: scrollbarHeight }, (_, i) => {
      if (i >= thumbPosition && i < thumbPosition + thumbSize) {
        return "\u2588";
      }
      return "\u2502";
    });
    return scrollbarLines;
  };
  const renderHorizontalScrollbar = () => {
    if (!showScrollbars || maxScrollX === 0)
      return null;
    const scrollbarWidth = viewportWidth;
    const thumbSize = Math.max(1, Math.floor(viewportWidth / state.contentWidth * scrollbarWidth));
    const thumbPosition = Math.floor(state.scrollX / maxScrollX * (scrollbarWidth - thumbSize));
    let scrollbar = "";
    for (let i = 0;i < scrollbarWidth; i++) {
      if (i >= thumbPosition && i < thumbPosition + thumbSize) {
        scrollbar += "\u2588";
      } else {
        scrollbar += "\u2500";
      }
    }
    return scrollbar;
  };
  const renderedContent = renderContent();
  const verticalScrollbar = renderVerticalScrollbar();
  const horizontalScrollbar = renderHorizontalScrollbar();
  const lines = [];
  renderedContent.forEach((line, index) => {
    const contentLine = /* @__PURE__ */ jsx("text", {
      children: line
    }, undefined, false, undefined, this);
    if (showScrollbars && verticalScrollbar && index < verticalScrollbar.length) {
      lines.push(/* @__PURE__ */ jsx("hstack", {
        children: [
          contentLine,
          /* @__PURE__ */ jsx("text", {
            children: verticalScrollbar[index]
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this));
    } else {
      lines.push(contentLine);
    }
  });
  if (showScrollbars && horizontalScrollbar) {
    const hScrollLine = /* @__PURE__ */ jsx("text", {
      children: horizontalScrollbar
    }, undefined, false, undefined, this);
    if (verticalScrollbar) {
      lines.push(/* @__PURE__ */ jsx("hstack", {
        children: [
          hScrollLine,
          /* @__PURE__ */ jsx("text", {
            children: "\u2518"
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this));
    } else {
      lines.push(hScrollLine);
    }
  }
  const viewportStyle = customStyle || style();
  const styledViewport = /* @__PURE__ */ jsx("vstack", {
    style: viewportStyle,
    children: lines
  }, undefined, false, undefined, this);
  const handleKeyPress = (key) => {
    switch (key) {
      case "ArrowUp":
      case "k":
        scrollUp();
        break;
      case "ArrowDown":
      case "j":
        scrollDown();
        break;
      case "ArrowLeft":
      case "h":
        scrollLeft();
        break;
      case "ArrowRight":
      case "l":
        scrollRight();
        break;
      case "PageUp":
        pageUp();
        break;
      case "PageDown":
        pageDown();
        break;
      case "Home":
        scrollToTop();
        break;
      case "End":
        scrollToBottom();
        break;
    }
  };
  return styledViewport;
};
var init_Viewport = __esm(() => {
  init_runes();
  init_styling();
  init_string_width();
  init_jsx_dev_runtime15();
});

// ../../src/tea/containers/Viewport.ts
var updateScroll = (model, newScrollX, newScrollY, actualViewportWidth, actualViewportHeight) => {
  const { scrollX, scrollY } = clampScroll(newScrollX, newScrollY, model.contentWidth, model.contentHeight, actualViewportWidth, actualViewportHeight);
  return [{ ...model, scrollX, scrollY }, []];
}, calculateContentDimensions = (content) => {
  const height = content.length;
  const width = content.reduce((max6, line) => Math.max(max6, stringWidth(line)), 0);
  return { width, height };
}, clampScroll = (scrollX, scrollY, contentWidth, contentHeight, viewportWidth, viewportHeight) => {
  const maxScrollX = Math.max(0, contentWidth - viewportWidth);
  const maxScrollY = Math.max(0, contentHeight - viewportHeight);
  return {
    scrollX: Math.max(0, Math.min(scrollX, maxScrollX)),
    scrollY: Math.max(0, Math.min(scrollY, maxScrollY))
  };
}, getVisibleContent = (content, scrollX, scrollY, viewportWidth, viewportHeight) => {
  const visibleLines = content.slice(scrollY, scrollY + viewportHeight);
  return visibleLines.map((line) => {
    if (scrollX >= stringWidth(line)) {
      return "";
    }
    let charCount = 0;
    let bytePos = 0;
    while (bytePos < line.length && charCount < scrollX) {
      const char = line[bytePos];
      charCount += stringWidth(char);
      bytePos++;
    }
    const startPos = bytePos;
    let visibleWidth = 0;
    let endPos = startPos;
    while (endPos < line.length && visibleWidth < viewportWidth) {
      const char = line[endPos];
      const charWidth = stringWidth(char);
      if (visibleWidth + charWidth > viewportWidth) {
        break;
      }
      visibleWidth += charWidth;
      endPos++;
    }
    const visiblePart = line.substring(startPos, endPos);
    const paddingNeeded = viewportWidth - stringWidth(visiblePart);
    return visiblePart + " ".repeat(Math.max(0, paddingNeeded));
  });
}, createVerticalScrollbar = (scrollY, contentHeight, viewportHeight) => {
  if (contentHeight <= viewportHeight) {
    return Array(viewportHeight).fill("\u2502");
  }
  const scrollbarHeight = viewportHeight;
  const thumbHeight = Math.max(1, Math.floor(viewportHeight / contentHeight * scrollbarHeight));
  const thumbPosition = Math.floor(scrollY / (contentHeight - viewportHeight) * (scrollbarHeight - thumbHeight));
  const scrollbar = [];
  for (let i = 0;i < scrollbarHeight; i++) {
    if (i >= thumbPosition && i < thumbPosition + thumbHeight) {
      scrollbar.push("\u2588");
    } else {
      scrollbar.push("\u2502");
    }
  }
  return scrollbar;
}, createHorizontalScrollbar = (scrollX, contentWidth, viewportWidth) => {
  if (contentWidth <= viewportWidth) {
    return "\u2500".repeat(viewportWidth);
  }
  const scrollbarWidth = viewportWidth;
  const thumbWidth = Math.max(1, Math.floor(viewportWidth / contentWidth * scrollbarWidth));
  const thumbPosition = Math.floor(scrollX / (contentWidth - viewportWidth) * (scrollbarWidth - thumbWidth));
  let scrollbar = "";
  for (let i = 0;i < scrollbarWidth; i++) {
    if (i >= thumbPosition && i < thumbPosition + thumbWidth) {
      scrollbar += "\u2588";
    } else {
      scrollbar += "\u2500";
    }
  }
  return scrollbar;
}, viewport = (config4) => ({
  init: exports_Effect.succeed([
    {
      config: {
        showScrollbars: true,
        smoothScroll: false,
        scrollStep: 1,
        pageSize: Math.floor(config4.height * 0.8),
        ...config4
      },
      scrollX: 0,
      scrollY: 0,
      contentWidth: 0,
      contentHeight: 0,
      content: [],
      isFocused: false
    },
    []
  ]),
  update(msg, model) {
    const { config: config5 } = model;
    const actualViewportWidth = config5.showScrollbars ? config5.width - 1 : config5.width;
    const actualViewportHeight = config5.showScrollbars ? config5.height - 1 : config5.height;
    switch (msg._tag) {
      case "ScrollUp": {
        const amount = msg.amount ?? config5.scrollStep ?? 1;
        return exports_Effect.succeed(updateScroll(model, model.scrollX, model.scrollY - amount, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollDown": {
        const amount = msg.amount ?? config5.scrollStep ?? 1;
        return exports_Effect.succeed(updateScroll(model, model.scrollX, model.scrollY + amount, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollLeft": {
        const amount = msg.amount ?? config5.scrollStep ?? 1;
        return exports_Effect.succeed(updateScroll(model, model.scrollX - amount, model.scrollY, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollRight": {
        const amount = msg.amount ?? config5.scrollStep ?? 1;
        return exports_Effect.succeed(updateScroll(model, model.scrollX + amount, model.scrollY, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollToTop": {
        return exports_Effect.succeed(updateScroll(model, model.scrollX, 0, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollToBottom": {
        return exports_Effect.succeed(updateScroll(model, model.scrollX, model.contentHeight, actualViewportWidth, actualViewportHeight));
      }
      case "ScrollToPosition": {
        return exports_Effect.succeed(updateScroll(model, msg.x, msg.y, actualViewportWidth, actualViewportHeight));
      }
      case "PageUp": {
        const amount = config5.pageSize ?? Math.floor(actualViewportHeight * 0.8);
        return exports_Effect.succeed(updateScroll(model, model.scrollX, model.scrollY - amount, actualViewportWidth, actualViewportHeight));
      }
      case "PageDown": {
        const amount = config5.pageSize ?? Math.floor(actualViewportHeight * 0.8);
        return exports_Effect.succeed(updateScroll(model, model.scrollX, model.scrollY + amount, actualViewportWidth, actualViewportHeight));
      }
      case "SetContent": {
        const { width: contentWidth, height: contentHeight } = calculateContentDimensions(msg.content);
        const { scrollX, scrollY } = clampScroll(model.scrollX, model.scrollY, contentWidth, contentHeight, actualViewportWidth, actualViewportHeight);
        return exports_Effect.succeed([
          {
            ...model,
            content: msg.content,
            contentWidth,
            contentHeight,
            scrollX,
            scrollY
          },
          []
        ]);
      }
      case "Focus": {
        return exports_Effect.succeed([{ ...model, isFocused: true }, []]);
      }
      case "Blur": {
        return exports_Effect.succeed([{ ...model, isFocused: false }, []]);
      }
      case "MouseWheel": {
        const scrollAmount = config5.scrollStep ?? 1;
        const newScrollX = model.scrollX + msg.deltaX * scrollAmount;
        const newScrollY = model.scrollY + msg.deltaY * scrollAmount;
        return exports_Effect.succeed(updateScroll(model, newScrollX, newScrollY, actualViewportWidth, actualViewportHeight));
      }
    }
  },
  view(model) {
    const { config: config5 } = model;
    const actualViewportWidth = config5.showScrollbars ? config5.width - 1 : config5.width;
    const actualViewportHeight = config5.showScrollbars ? config5.height - 1 : config5.height;
    const visibleContent = getVisibleContent(model.content, model.scrollX, model.scrollY, actualViewportWidth, actualViewportHeight);
    while (visibleContent.length < actualViewportHeight) {
      visibleContent.push(" ".repeat(actualViewportWidth));
    }
    const contentViews = visibleContent.map((line) => styledText(line, style()));
    if (!config5.showScrollbars) {
      return vstack(...contentViews);
    }
    const verticalScrollbar = createVerticalScrollbar(model.scrollY, model.contentHeight, actualViewportHeight);
    const horizontalScrollbar = createHorizontalScrollbar(model.scrollX, model.contentWidth, actualViewportWidth);
    const scrollbarViews = verticalScrollbar.map((char) => styledText(char, style(Colors.gray)));
    const contentWithVerticalScrollbar = contentViews.map((contentView, index) => hstack(contentView, scrollbarViews[index] || styledText("\u2502", style(Colors.gray))));
    const horizontalScrollbarView = hstack(styledText(horizontalScrollbar, style(Colors.gray)), styledText("\u2518", style(Colors.gray)));
    const borderStyle = model.isFocused ? style(Colors.brightBlue) : style(Colors.gray);
    const viewport2 = vstack(...contentWithVerticalScrollbar, horizontalScrollbarView);
    return styledBox(viewport2, { border: Borders.Rounded, style: borderStyle });
  }
}), createTextContent = (text7, maxWidth) => {
  const lines = text7.split(`
`);
  if (!maxWidth) {
    return lines;
  }
  const wrappedLines = [];
  for (const line of lines) {
    if (stringWidth(line) <= maxWidth) {
      wrappedLines.push(line);
    } else {
      let currentLine = "";
      const words = line.split(" ");
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        if (stringWidth(testLine) <= maxWidth) {
          currentLine = testLine;
        } else {
          if (currentLine) {
            wrappedLines.push(currentLine);
            currentLine = word;
          } else {
            wrappedLines.push(word.substring(0, maxWidth));
            currentLine = word.substring(maxWidth);
          }
        }
      }
      if (currentLine) {
        wrappedLines.push(currentLine);
      }
    }
  }
  return wrappedLines;
}, createGridContent = (data, columnWidths, separator = " | ") => {
  return data.map((row) => {
    const paddedCells = row.map((cell, index) => {
      const width = columnWidths[index] || 10;
      const cellWidth = stringWidth(cell);
      if (cellWidth >= width) {
        return cell.substring(0, width);
      } else {
        return cell + " ".repeat(width - cellWidth);
      }
    });
    return paddedCells.join(separator);
  });
}, createNumberedContent = (lines, startNumber = 1, numberWidth = 4) => {
  return lines.map((line, index) => {
    const lineNumber = startNumber + index;
    const paddedNumber = lineNumber.toString().padStart(numberWidth, " ");
    return `${paddedNumber}: ${line}`;
  });
};
var init_Viewport2 = __esm(() => {
  init_esm2();
  init_view();
  init_styling();
  init_box2();
  init_string_width();
});

// ../../src/components/containers/viewport/index.ts
var init_viewport = __esm(() => {
  init_Viewport();
  init_Viewport2();
});

// ../../src/components/containers/ScrollableBox.tsx
var vstack3, hstack8, text7, styledText3, ScrollableBox = (props) => {
  const {
    title,
    items,
    renderItem,
    height = 20,
    showScrollbar = true,
    showFilter = false,
    filterPlaceholder = "Filter...",
    emptyMessage = "No items to display",
    border = "rounded",
    showCount = true,
    footer
  } = props;
  const visibleItems = items.slice(0, height);
  const hasMore = items.length > height;
  const content = vstack3(showCount && hstack8(styledText3(`Items: ${items.length}`, style().foreground(Colors.gray)), hasMore && styledText3(` (showing ${visibleItems.length})`, style().foreground(Colors.yellow))), showFilter && vstack3(text7("\uD83D\uDD0D " + filterPlaceholder)), items.length === 0 ? styledText3(emptyMessage, style().foreground(Colors.yellow)) : vstack3(...visibleItems.map((item, index) => renderItem(item, index)), hasMore && styledText3(`... and ${items.length - height} more`, style().foreground(Colors.gray).italic())), footer && (typeof footer === "string" ? styledText3(footer, style().foreground(Colors.gray)) : footer));
  return content;
}, ScrollableLogBox = (props) => {
  const { logs, colorize = true, ...rest } = props;
  const levelColors = {
    debug: Colors.gray,
    info: Colors.blue,
    warn: Colors.yellow,
    error: Colors.red
  };
  const levelIcons = {
    debug: "\uD83D\uDD0D",
    info: "\u2139\uFE0F",
    warn: "\u26A0\uFE0F",
    error: "\u274C"
  };
  return ScrollableBox({
    ...rest,
    items: logs,
    renderItem: (log4) => hstack8(styledText3(log4.timestamp.toLocaleTimeString(), style().foreground(Colors.gray)), styledText3(`${levelIcons[log4.level]} ${log4.level.toUpperCase().padEnd(5)}`, colorize ? style().foreground(levelColors[log4.level]).bold() : style()), styledText3(`[${log4.source.padEnd(12)}]`, style().foreground(Colors.cyan)), text7(log4.message))
  });
}, ScrollableProcessList = (props) => {
  const { processes, detailed = false, ...rest } = props;
  const statusColors = {
    running: Colors.green,
    stopped: Colors.gray,
    error: Colors.red,
    starting: Colors.yellow
  };
  const statusIcons = {
    running: "\uD83D\uDFE2",
    stopped: "\u26AA",
    error: "\uD83D\uDD34",
    starting: "\uD83D\uDFE1"
  };
  return ScrollableBox({
    ...rest,
    items: processes,
    renderItem: (proc) => vstack3(hstack8(text7(statusIcons[proc.status] || "\u26AB"), styledText3(proc.name.padEnd(20), style().foreground(Colors.cyan).bold()), styledText3(`[${proc.status.toUpperCase().padEnd(8)}]`, style().foreground(statusColors[proc.status])), proc.pid && styledText3(`PID: ${proc.pid.toString().padEnd(8)}`, style().foreground(Colors.gray)), proc.uptime && styledText3(`\u23F1\uFE0F  ${proc.uptime}s`, style().foreground(Colors.blue)), proc.restarts !== undefined && styledText3(`\uD83D\uDD04 ${proc.restarts}`, style().foreground(Colors.yellow))), detailed && styledText3("\u2514\u2500 Additional details here...", style().foreground(Colors.gray)))
  });
};
var init_ScrollableBox = __esm(() => {
  init_core3();
  init_styling();
  ({ vstack: vstack3, hstack: hstack8, text: text7, styledText: styledText3 } = exports_view);
});

// ../../src/components/containers/index.ts
var init_containers = __esm(() => {
  init_viewport();
  init_ScrollableBox();
});

// ../../src/components/system/Exit.tsx
var init_Exit2 = __esm(() => {
  init_esm2();
  init_view();
  init_interactive();
});

// ../../src/tea/system/Exit.ts
function setExitHandler(handler) {
  exitHandler = handler;
}
function containsExit(view) {
  return false;
}
var exitHandler = null;
var init_Exit3 = __esm(() => {
  init_esm2();
  init_view();
});

// ../../src/components/system/index.ts
var init_system = __esm(() => {
  init_Exit2();
  init_Exit3();
});

// ../../src/plugins/jsx/jsx-dev-runtime.ts
var init_jsx_dev_runtime16 = __esm(() => {
  init_dev_runtime();
});

// ../../src/plugins/jsx/components.tsx
var init_components2 = __esm(() => {
  init_components();
  init_stores3();
  init_jsx_dev_runtime16();
});

// ../../src/cli/jsx/app.ts
var exports_app = {};
__export(exports_app, {
  runJSXCLI: () => runJSXCLI,
  runCLIApp: () => runCLIApp,
  jsxCommand: () => jsxCommand,
  defineJSXCommand: () => defineJSXCommand
});
async function runCLIApp(AppComponent, options = {}) {
  debug2("runCLIApp called with options:", options);
  setCliConfig(options);
  const argv = process.argv.slice(2);
  debug2("Command line args:", argv);
  const commandPath = [];
  const args2 = {};
  const flags = {};
  let i = 0;
  let showHelpFlag = false;
  while (i < argv.length && !argv[i].startsWith("-")) {
    if (argv[i] === "help" || argv[i] === "--help") {
      showHelpFlag = true;
      break;
    }
    commandPath.push(argv[i]);
    i++;
  }
  if (argv.includes("--help") || argv.includes("-h")) {
    showHelpFlag = true;
  }
  debug2("Command path:", commandPath);
  setCommandContext(commandPath, args2, flags);
  try {
    debug2("Rendering app to collect scopes...");
    const element = typeof AppComponent === "function" ? AppComponent() : AppComponent;
    if (element && typeof element === "object" && "render" in element) {
      await exports_Effect.runPromise(element.render().pipe(exports_Effect.provide(LiveServices), exports_Effect.map(() => {})));
    }
    debug2("Scope collection complete");
    const hasCommands = hasCliCommands();
    debug2("Has CLI commands:", hasCommands);
    if (!hasCommands) {
      debug2("No CLI commands found, running as CLI app without commands");
      clearCommandContext();
      return runAppWithContext(AppComponent);
    }
    await activateScopesForCommand(commandPath);
    debug2("CLI commands found, executing command");
    return executeCommand(commandPath, args2, flags, showHelpFlag, AppComponent);
  } finally {
    clearCommandContext();
  }
}
async function activateScopesForCommand(commandPath) {
  debug2("Activating scopes for command path:", commandPath);
  const allScopes = scopeManager.getAllScopes();
  const cliScope = allScopes.find((s) => s.type === "cli");
  if (!cliScope) {
    debug2("No CLI scope found");
    return;
  }
  await exports_Effect.runPromise(scopeManager.activateScope(cliScope.id).pipe(exports_Effect.catchAll(() => exports_Effect.void)));
  let currentScope = cliScope;
  for (const segment of commandPath) {
    const children3 = scopeManager.getChildScopes(currentScope.id);
    const childScope = children3.find((child) => child.name === segment);
    if (childScope) {
      await exports_Effect.runPromise(scopeManager.activateScope(childScope.id).pipe(exports_Effect.catchAll(() => exports_Effect.void)));
      currentScope = childScope;
    } else {
      break;
    }
  }
  debug2("Scope activation complete");
}
async function runAppWithContext(AppComponent) {
  debug2("Running CLI app with command context");
  const component = {
    init: exports_Effect.succeed([{}, []]),
    update: () => exports_Effect.succeed([{}, []]),
    view: () => typeof AppComponent === "function" ? AppComponent() : AppComponent,
    subscription: () => exports_Effect.succeed([])
  };
  return exports_Effect.runPromise(runApp(component).pipe(exports_Effect.provide(LiveServices), exports_Effect.catchAll(() => exports_Effect.void)));
}
async function executeCommand(path6, args2, flags, helpRequested = false, AppComponent) {
  debug2("Executing command:", path6, "helpRequested:", helpRequested);
  if (helpRequested) {
    return runAppWithContext(AppComponent);
  }
  const command = getCommandByPath(path6);
  if (!command) {
    if (path6.length === 0) {
      return runAppWithContext(AppComponent);
    } else {
      console.error(`Command not found: ${path6.join(" ")}`);
      process.exit(1);
    }
  }
  if (command.type === "plugin" && !command.handler) {
    return runAppWithContext(AppComponent);
  }
  if (!command.handler) {
    return runAppWithContext(AppComponent);
  }
  debug2("Executing handler for command:", command.name);
  const context10 = {
    args: args2,
    flags,
    command: command.name,
    commandPath: path6
  };
  try {
    const result = await command.handler(context10);
    if (result && typeof result === "object" && "render" in result) {
      const output = await exports_Effect.runPromise(result.render().pipe(exports_Effect.provide(LiveServices)));
      process.stdout.write(output);
      process.stdout.write(`
`);
    }
    process.exit(0);
  } catch (error2) {
    console.error("Command failed:", error2);
    process.exit(1);
  }
}
function defineJSXCommand(config4) {
  return config4;
}
function jsxCommand(name, handler) {
  return {
    name,
    handler
  };
}
async function runJSXCLI(config4) {
  debug2("runJSXCLI called with config:", config4.name);
  return runCLIApp(() => {
    const jsx2 = (type2, props) => ({ type: type2, props });
    return jsx2("vstack", {
      children: [
        jsx2("text", { children: config4.name }),
        jsx2("text", { children: config4.description || "" })
      ]
    });
  }, config4);
}
var DEBUG, debug2 = (msg, ...args2) => {
  if (DEBUG)
    console.log(`[CLI JSX APP] ${msg}`, ...args2);
};
var init_app = __esm(() => {
  init_esm2();
  init_manager();
  init_stores2();
  init_runtime2();
  init_impl();
  DEBUG = process.env.TUIX_DEBUG === "true";
});

// ../../src/plugins/jsx/app.ts
function createJSXPlugin(config4) {
  return config4;
}

// ../../src/jsx/config-validator.ts
import * as fs3 from "fs";
import * as path6 from "path";
function validateJSXConfig(projectRoot = process.cwd()) {
  const issues = [];
  const tsconfigPath = path6.join(projectRoot, "tsconfig.json");
  if (fs3.existsSync(tsconfigPath)) {
    try {
      const tsconfig = JSON.parse(fs3.readFileSync(tsconfigPath, "utf-8"));
      const compilerOptions = tsconfig.compilerOptions || {};
      if (!compilerOptions.jsx) {
        issues.push({
          level: "error",
          message: 'Missing "jsx" in tsconfig.json compilerOptions',
          file: "tsconfig.json",
          suggestion: 'Add "jsx": "react-jsx" to compilerOptions'
        });
      } else if (compilerOptions.jsx !== "react-jsx" && compilerOptions.jsx !== "react-jsxdev") {
        issues.push({
          level: "warning",
          message: `Unexpected jsx setting: "${compilerOptions.jsx}"`,
          file: "tsconfig.json",
          suggestion: 'Use "jsx": "react-jsx" for production or "react-jsxdev" for development'
        });
      }
      if (!compilerOptions.jsxImportSource) {
        issues.push({
          level: "error",
          message: 'Missing "jsxImportSource" in tsconfig.json',
          file: "tsconfig.json",
          suggestion: 'Add "jsxImportSource": "tuix" or "jsxImportSource": "."'
        });
      } else if (compilerOptions.jsxImportSource === "@cinderlink/cli-kit") {
        issues.push({
          level: "error",
          message: 'Outdated jsxImportSource: "@cinderlink/cli-kit"',
          file: "tsconfig.json",
          suggestion: 'Change to "jsxImportSource": "tuix"'
        });
      }
    } catch (_e) {
      issues.push({
        level: "error",
        message: "Failed to parse tsconfig.json",
        file: "tsconfig.json",
        suggestion: "Ensure tsconfig.json is valid JSON"
      });
    }
  }
  const bunfigPath = path6.join(projectRoot, "bunfig.toml");
  if (fs3.existsSync(bunfigPath)) {
    const bunfig = fs3.readFileSync(bunfigPath, "utf-8");
    if (bunfig.includes("[jsx]")) {
      const jsxSection = bunfig.split("[jsx]")[1]?.split("[")[0] || "";
      if (jsxSection.includes("@cinderlink/cli-kit")) {
        issues.push({
          level: "error",
          message: "Outdated importSource in bunfig.toml",
          file: "bunfig.toml",
          suggestion: 'Change importSource to "tuix" or "."'
        });
      }
      if (!jsxSection.includes("factory")) {
        issues.push({
          level: "warning",
          message: "Missing factory setting in bunfig.toml [jsx] section",
          file: "bunfig.toml",
          suggestion: 'Add: factory = "jsx"'
        });
      }
    }
  }
  const jsxRuntimePath = path6.join(projectRoot, "jsx-runtime.ts");
  const jsxRuntimeJsPath = path6.join(projectRoot, "jsx-runtime.js");
  if (!fs3.existsSync(jsxRuntimePath) && !fs3.existsSync(jsxRuntimeJsPath)) {
    issues.push({
      level: "error",
      message: "Missing jsx-runtime.ts in project root",
      file: "jsx-runtime.ts",
      suggestion: "Ensure jsx-runtime.ts exists and exports jsx, jsxs, jsxDEV, and Fragment"
    });
  }
  const packageJsonPath = path6.join(projectRoot, "package.json");
  if (fs3.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs3.readFileSync(packageJsonPath, "utf-8"));
      if (!packageJson.exports?.["./jsx-runtime"]) {
        issues.push({
          level: "error",
          message: 'Missing "./jsx-runtime" export in package.json',
          file: "package.json",
          suggestion: 'Add exports["./jsx-runtime"] pointing to jsx-runtime.ts'
        });
      }
    } catch (_e) {}
  }
  return issues;
}
function formatConfigIssues(issues) {
  if (issues.length === 0) {
    return "\u2705 JSX configuration looks good!";
  }
  const errors2 = issues.filter((i) => i.level === "error");
  const warnings = issues.filter((i) => i.level === "warning");
  const infos = issues.filter((i) => i.level === "info");
  let output = `\uD83D\uDD27 JSX Configuration Issues Found:

`;
  if (errors2.length > 0) {
    output += `\u274C Errors:
`;
    errors2.forEach((issue) => {
      output += `  \u2022 ${issue.message}
`;
      if (issue.file)
        output += `    File: ${issue.file}
`;
      if (issue.suggestion)
        output += `    Fix: ${issue.suggestion}
`;
      output += `
`;
    });
  }
  if (warnings.length > 0) {
    output += `\u26A0\uFE0F  Warnings:
`;
    warnings.forEach((issue) => {
      output += `  \u2022 ${issue.message}
`;
      if (issue.file)
        output += `    File: ${issue.file}
`;
      if (issue.suggestion)
        output += `    Fix: ${issue.suggestion}
`;
      output += `
`;
    });
  }
  if (infos.length > 0) {
    output += `\u2139\uFE0F  Info:
`;
    infos.forEach((issue) => {
      output += `  \u2022 ${issue.message}
`;
      if (issue.suggestion)
        output += `    ${issue.suggestion}
`;
      output += `
`;
    });
  }
  return output;
}
function validateJSXElement(element, context10 = "unknown") {
  if (!element) {
    throw new Error(`JSX element is null or undefined in ${context10}`);
  }
  if (typeof element !== "object") {
    throw new Error(`JSX element is not an object (got ${typeof element}) in ${context10}`);
  }
  if (typeof element.render !== "function") {
    console.error("Invalid JSX element:", {
      context: context10,
      type: typeof element,
      keys: Object.keys(element),
      element
    });
    const suggestions = [];
    if (element.type && element.props) {
      suggestions.push("Element looks like unprocessed JSX. Check jsxImportSource configuration.");
    }
    if (element._tag || element.tag) {
      suggestions.push("Element might be an Effect or other non-View object.");
    }
    if (Array.isArray(element)) {
      suggestions.push("Element is an array. Wrap multiple elements in a container like <vstack> or <hstack>.");
    }
    const configIssues = validateJSXConfig();
    if (configIssues.length > 0) {
      suggestions.push(`
JSX Configuration Issues:`);
      suggestions.push(formatConfigIssues(configIssues));
    }
    throw new Error(`JSX element is not a valid View (missing render() method) in ${context10}
` + (suggestions.length > 0 ? `
Possible issues:
` + suggestions.join(`
`) : ""));
  }
}
var init_config_validator = () => {};

// ../../src/jsx/render.ts
var exports_render = {};
__export(exports_render, {
  renderToTerminal: () => renderToTerminal,
  renderToString: () => renderToString
});
async function renderToTerminal(element) {
  const DEBUG2 = process.env.TUIX_DEBUG === "true";
  const debug3 = (msg) => {
    if (DEBUG2)
      console.log(`[TUIX RENDER] ${msg}`);
  };
  debug3("renderToTerminal called");
  debug3("Element:", element);
  debug3("Element type:", typeof element);
  debug3("Element is null?", element === null);
  debug3("Element is undefined?", element === undefined);
  validateJSXElement(element, "renderToTerminal");
  debug3("Element validation passed");
  const program = exports_Effect.gen(function* (_) {
    const isInteractive2 = yield* _(exports_FiberRef.get(InteractiveFiberRef));
    const view = element;
    debug3(`\uD83D\uDD0D Interactive context check: isInteractive=${isInteractive2}`);
    if (isInteractive2) {
      debug3("\uD83D\uDCFA Using interactive renderer with full terminal control");
      const terminal2 = yield* _(TerminalService);
      const renderer2 = yield* _(RendererService);
      yield* _(terminal2.clear);
      yield* _(terminal2.hideCursor);
      yield* _(renderer2.render(view));
      debug3("\uD83D\uDCFA Interactive render completed");
    } else {
      debug3("\uD83D\uDCDD Using non-interactive renderer (stdout only)");
      const content = yield* _(view.render());
      debug3(`\uD83D\uDCDD Rendered content length: ${content.length} chars`);
      process.stdout.write(content);
      process.stdout.write(`
`);
      debug3("\uD83D\uDCDD Non-interactive render completed");
    }
  });
  await exports_Effect.runPromise(program.pipe(exports_Effect.provide(LiveServices), exports_Effect.catchAll((error2) => exports_Effect.sync(() => {
    console.error("Render error:", error2);
  }))));
}
async function renderToString(element) {
  let output = "";
  const program = exports_Effect.gen(function* (_) {
    const renderer2 = yield* _(RendererService);
    const result = yield* _(renderer2.render(element, { x: 0, y: 0 }));
    output = result;
  });
  await exports_Effect.runPromise(program.pipe(exports_Effect.provide(LiveServices), exports_Effect.catchAll(() => exports_Effect.void)));
  return output;
}
var init_render2 = __esm(() => {
  init_esm2();
  init_services();
  init_impl();
  init_interactive();
  init_config_validator();
});

// ../../src/jsx/app.ts
function createJSXApp(AppComponent, config4) {
  debug3("createJSXApp called");
  const getAppElement = () => {
    try {
      if (typeof AppComponent === "function") {
        const result = AppComponent();
        if (!result) {
          console.error("[render] ERROR: App component function returned null/undefined");
          return jsx("vstack", { children: [] });
        }
        return result;
      } else {
        if (!AppComponent) {
          console.error("[render] ERROR: App component is null/undefined");
          return jsx("vstack", { children: [] });
        }
        return AppComponent;
      }
    } catch (error2) {
      console.error("[render] ERROR: Exception in getAppElement:", error2);
      return jsx("vstack", { children: [] });
    }
  };
  if (config4?.onInit) {
    const initResult = config4.onInit();
    if (initResult instanceof Promise) {
      initResult.catch(console.error);
    }
  }
  const component = {
    init: exports_Effect.succeed([{}, []]),
    update: () => exports_Effect.succeed([{}, []]),
    view: getAppElement,
    subscription: () => exports_Effect.succeed([])
  };
  const cleanup2 = () => {
    if (config4?.onExit) {
      const exitResult = config4.onExit();
      if (exitResult instanceof Promise) {
        exitResult.catch(console.error);
      }
    }
  };
  process.on("SIGINT", cleanup2);
  process.on("SIGTERM", cleanup2);
  debug3("Running app...");
  return exports_Effect.runPromise(exports_Effect.gen(function* () {
    const isAlreadyInteractive = yield* exports_FiberRef.get(InteractiveFiberRef);
    debug3(`Is already interactive: ${isAlreadyInteractive}`);
    if (isAlreadyInteractive) {
      debug3("Already in interactive context, running app with event loop");
      yield* runApp(component).pipe(exports_Effect.catchAll(() => exports_Effect.void));
    } else {
      debug3("Not in interactive context, rendering once and exiting");
      const view = getAppElement();
      debug3("Got app element:", view);
      debug3("App element type:", typeof view);
      debug3("App element keys:", view ? Object.keys(view) : "null/undefined");
      if (!view) {
        console.error("ERROR: getAppElement() returned null/undefined");
        console.error("This usually means the JSX component returned nothing");
      }
      const { renderToTerminal: renderToTerminal2 } = yield* exports_Effect.promise(() => Promise.resolve().then(() => (init_render2(), exports_render)));
      yield* exports_Effect.promise(() => renderToTerminal2(view));
      debug3("Finished rendering");
      process.exit(0);
    }
  }).pipe(exports_Effect.provide(InteractiveContextLive), exports_Effect.provide(LiveServices), exports_Effect.orDie)).finally(cleanup2);
}
function render3(AppComponent) {
  debug3("render() called");
  if (renderInProgress) {
    console.error("[render] ERROR: render() called while already rendering!");
    console.error("[render] This usually indicates a problem with the app structure");
    return Promise.resolve();
  }
  renderInProgress = true;
  const { hasCliCommands: hasCliCommands2 } = (init_stores2(), __toCommonJS(exports_stores));
  const { runCLIApp: runCLIApp2 } = (init_app(), __toCommonJS(exports_app));
  const element = typeof AppComponent === "function" ? AppComponent() : AppComponent;
  if (hasCliCommands2()) {
    debug3("CLI commands detected, delegating to runCLIApp");
    return runCLIApp2(AppComponent).finally(() => {
      renderInProgress = false;
    });
  }
  debug3("No CLI commands detected, running as regular app");
  return createJSXApp(AppComponent).finally(() => {
    renderInProgress = false;
  });
}
var DEBUG2, debug3 = (msg, ...args2) => {
  if (DEBUG2)
    console.log(`[TUIX JSX] ${msg}`, ...args2);
}, renderInProgress = false;
var init_app2 = __esm(() => {
  init_esm2();
  init_runtime2();
  init_impl();
  init_interactive();
  init_runtime3();
  init_runes();
  init_jsx_lifecycle();
  init_components5();
  init_components();
  init_components2();
  init_app();
  init_app();
  DEBUG2 = process.env.TUIX_DEBUG === "true";
});

// ../../src/tea/component.ts
function createComponent(componentFn) {
  const stateId = generateComponentId2();
  const state = {
    stateRefs: new Map,
    derivedRefs: new Map,
    effects: [],
    mountCallbacks: [],
    destroyCallbacks: [],
    subscriptions: new Map
  };
  const $state2 = (initial) => {
    const key = `state_${stateId}_${state.stateRefs.size}`;
    let currentValue = initial;
    const subscribers = state.subscriptions.get(key) || [];
    return {
      get value() {
        return currentValue;
      },
      subscribe(callback) {
        subscribers.push(callback);
        state.subscriptions.set(key, subscribers);
        return () => {
          const index = subscribers.indexOf(callback);
          if (index >= 0) {
            subscribers.splice(index, 1);
          }
        };
      },
      set(value6) {
        if (currentValue !== value6) {
          currentValue = value6;
          subscribers.forEach((callback) => callback(value6));
        }
      },
      update(updater) {
        const newValue = updater(currentValue);
        this.set(newValue);
      }
    };
  };
  const $derived4 = (computation) => {
    const key = `derived_${stateId}_${state.derivedRefs.size}`;
    let currentValue = computation();
    const subscribers = state.subscriptions.get(key) || [];
    const update10 = () => {
      const newValue = computation();
      if (currentValue !== newValue) {
        currentValue = newValue;
        subscribers.forEach((callback) => callback(newValue));
      }
    };
    setTimeout(update10, 0);
    return {
      get value() {
        return currentValue;
      },
      subscribe(callback) {
        subscribers.push(callback);
        state.subscriptions.set(key, subscribers);
        return () => {
          const index = subscribers.indexOf(callback);
          if (index >= 0) {
            subscribers.splice(index, 1);
          }
        };
      }
    };
  };
  const $effect3 = (fn2) => {
    const cleanup2 = fn2();
    if (typeof cleanup2 === "function") {
      state.effects.push(cleanup2);
    }
  };
  const onMount2 = (fn2) => {
    state.mountCallbacks.push(fn2);
  };
  const onDestroy3 = (fn2) => {
    state.destroyCallbacks.push(fn2);
  };
  const context10 = {
    $state: $state2,
    $derived: $derived4,
    $effect: $effect3,
    onMount: onMount2,
    onDestroy: onDestroy3
  };
  const componentDef = componentFn(context10);
  return {
    init: exports_Effect.succeed([
      componentDef.init ? componentDef.init() : {},
      []
    ]),
    update: (msg, model) => {
      const newModel = componentDef.update ? componentDef.update(msg, model) : model;
      return exports_Effect.succeed([newModel, []]);
    },
    view: (model) => {
      try {
        return componentDef.view();
      } catch (error2) {
        console.error("Component view error:", error2);
        return text("Error rendering component");
      }
    },
    subscriptions: componentDef.subscriptions ? (model) => componentDef.subscriptions(model) : () => exports_Effect.succeed([])
  };
}
function wrapComponent(teaComponent) {
  return (context10) => ({
    view: () => {
      return text("Wrapped component (TODO: implement proper wrapping)");
    }
  });
}
function functional(viewFn) {
  return (context10) => ({
    view: viewFn
  });
}
function reactive(initialState2, render4) {
  return (context10) => {
    const state = context10.$state(initialState2);
    return {
      view: () => render4(state, context10)
    };
  };
}
var generateComponentId2 = () => {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `component-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
};
var init_component = __esm(() => {
  init_esm2();
  init_view();
});

// ../../src/tea/reactivity.ts
function $state2(initial) {
  let currentValue = initial;
  const subscribers = new Set;
  const signal = () => {
    return currentValue;
  };
  signal.set = (value6) => {
    if (currentValue !== value6) {
      currentValue = value6;
      subscribers.forEach((callback) => {
        try {
          callback(value6);
        } catch (error2) {
          console.error("Error in signal subscription:", error2);
        }
      });
    }
  };
  signal.update = (updater) => {
    signal.set(updater(currentValue));
  };
  signal.subscribe = (callback) => {
    subscribers.add(callback);
    callback(currentValue);
    return () => {
      subscribers.delete(callback);
    };
  };
  return signal;
}
function $derived4(computation) {
  const signal = $state2(computation());
  const dependencies = new Set;
  const trackDependencies = () => {
    const value6 = computation();
    return value6;
  };
  const subscriptions = [];
  const updateDerived = () => {
    subscriptions.forEach((unsub) => unsub());
    subscriptions.length = 0;
    const newValue = trackDependencies();
    signal.set(newValue);
    dependencies.forEach((dep) => {
      const unsubscribe = dep.subscribe(() => {
        const updatedValue = trackDependencies();
        signal.set(updatedValue);
      });
      subscriptions.push(unsubscribe);
    });
  };
  updateDerived();
  const derivedSignal = () => signal();
  derivedSignal.subscribe = signal.subscribe;
  return derivedSignal;
}
function createStore(initial) {
  const signal = $state2(initial);
  return {
    ...signal,
    setProperty(key, value6) {
      signal.update((state) => ({
        ...state,
        [key]: value6
      }));
    },
    patch(partial2) {
      signal.update((state) => ({
        ...state,
        ...partial2
      }));
    },
    reset() {
      signal.set(initial);
    }
  };
}
function $memo(computation, dependencies) {
  if (dependencies) {
    const signal = $state2(computation());
    const updateMemo = () => {
      signal.set(computation());
    };
    dependencies.forEach((dep) => {
      dep.subscribe(updateMemo);
    });
    const memoSignal = () => signal();
    memoSignal.subscribe = signal.subscribe;
    return memoSignal;
  } else {
    return $derived4(computation);
  }
}
function batch(fn2) {
  fn2();
}
function $debounced(signal, delay3) {
  const debouncedSignal = $state2(signal());
  let timeoutId = null;
  signal.subscribe((value6) => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      debouncedSignal.set(value6);
      timeoutId = null;
    }, delay3);
  });
  const readonlySignal = () => debouncedSignal();
  readonlySignal.subscribe = debouncedSignal.subscribe;
  return readonlySignal;
}
function $throttled(signal, delay3) {
  const throttledSignal = $state2(signal());
  let lastUpdate = 0;
  signal.subscribe((value6) => {
    const now2 = Date.now();
    if (now2 - lastUpdate >= delay3) {
      throttledSignal.set(value6);
      lastUpdate = now2;
    }
  });
  const readonlySignal = () => throttledSignal();
  readonlySignal.subscribe = throttledSignal.subscribe;
  return readonlySignal;
}

// ../../src/tea/mouse-aware.ts
var makeMouseAware = (component, config4) => ({
  init: exports_Effect.gen(function* (_) {
    const [innerModel, innerCmds] = yield* _(component.init);
    const model = {
      inner: innerModel,
      mouseState: {
        isHovered: false,
        isPressed: false,
        lastX: 0,
        lastY: 0
      }
    };
    const mouseRouter = yield* _(MouseRouterService);
    const bounds = config4.getBounds(innerModel);
    yield* _(mouseRouter.registerComponent(config4.componentId, createBounds(config4.componentId, bounds.x, bounds.y, bounds.width, bounds.height, config4.zIndex || 0), (event, localX, localY) => {
      switch (event.type) {
        case "press":
          return { _tag: "MousePress", x: localX, y: localY };
        case "release":
          return { _tag: "MouseRelease", x: localX, y: localY };
        case "motion":
          const wasHovered = model.mouseState.isHovered;
          const isNowHovered = localX >= 0 && localY >= 0 && localX < bounds.width && localY < bounds.height;
          if (!wasHovered && isNowHovered) {
            return { _tag: "MouseEnter" };
          } else if (wasHovered && !isNowHovered) {
            return { _tag: "MouseLeave" };
          } else {
            return { _tag: "MouseMove", x: localX, y: localY };
          }
        default:
          return null;
      }
    }));
    const wrappedCmds = innerCmds.map((cmd) => cmd.pipe(exports_Effect.map((msg) => ({ _tag: "InnerMsg", msg }))));
    return [model, wrappedCmds];
  }),
  update(msg, model) {
    const wrapInnerCmds = (cmds) => cmds.map((cmd) => cmd.pipe(exports_Effect.map((msg2) => ({ _tag: "InnerMsg", msg: msg2 }))));
    const handleMouseEvent = (event, x, y) => {
      const innerMsg = config4.handleMouse(event, x, y, model.inner);
      if (!innerMsg)
        return exports_Effect.succeed([model, []]);
      return exports_Effect.map(component.update(innerMsg, model.inner), ([newInner, cmds]) => [
        { ...model, inner: newInner, mouseState: { ...model.mouseState, lastX: x, lastY: y } },
        wrapInnerCmds(cmds)
      ]);
    };
    switch (msg._tag) {
      case "InnerMsg": {
        return exports_Effect.gen(function* (_) {
          const [newInner, innerCmds] = yield* _(component.update(msg.msg, model.inner));
          const mouseRouter = yield* _(MouseRouterService);
          const newBounds = config4.getBounds(newInner);
          yield* _(mouseRouter.updateComponentBounds(config4.componentId, createBounds(config4.componentId, newBounds.x, newBounds.y, newBounds.width, newBounds.height, config4.zIndex || 0)));
          const wrappedCmds = wrapInnerCmds(innerCmds);
          return [{ ...model, inner: newInner }, wrappedCmds];
        });
      }
      case "MouseEnter": {
        const newModel = {
          ...model,
          mouseState: { ...model.mouseState, isHovered: true }
        };
        const innerMsg = config4.handleMouse({ type: "motion", button: "none", x: 0, y: 0, ctrl: false, alt: false, shift: false }, model.mouseState.lastX, model.mouseState.lastY, model.inner);
        if (!innerMsg)
          return exports_Effect.succeed([newModel, []]);
        return exports_Effect.map(component.update(innerMsg, model.inner), ([newInner, cmds]) => [
          { ...newModel, inner: newInner },
          wrapInnerCmds(cmds)
        ]);
      }
      case "MouseLeave": {
        return exports_Effect.succeed([
          {
            ...model,
            mouseState: { ...model.mouseState, isHovered: false, isPressed: false }
          },
          []
        ]);
      }
      case "MousePress": {
        const newModel = {
          ...model,
          mouseState: { ...model.mouseState, isPressed: true, lastX: msg.x, lastY: msg.y }
        };
        const event = {
          type: "press",
          button: "left",
          x: msg.x,
          y: msg.y,
          ctrl: false,
          alt: false,
          shift: false
        };
        return handleMouseEvent(event, msg.x, msg.y).pipe(exports_Effect.map(([m, cmds]) => [
          { ...m, mouseState: { ...m.mouseState, isPressed: true } },
          cmds
        ]));
      }
      case "MouseRelease": {
        const event = {
          type: "release",
          button: "left",
          x: msg.x,
          y: msg.y,
          ctrl: false,
          alt: false,
          shift: false
        };
        return handleMouseEvent(event, msg.x, msg.y).pipe(exports_Effect.map(([m, cmds]) => [
          { ...m, mouseState: { ...m.mouseState, isPressed: false } },
          cmds
        ]));
      }
      case "MouseMove": {
        const event = {
          type: "motion",
          button: "none",
          x: msg.x,
          y: msg.y,
          ctrl: false,
          alt: false,
          shift: false
        };
        return handleMouseEvent(event, msg.x, msg.y);
      }
    }
  },
  view(model) {
    const innerView = component.view(model.inner);
    if (process.env.DEBUG_MOUSE) {
      const debugInfo = vstack(styledText(`Hover: ${model.mouseState.isHovered}`, style()), styledText(`Press: ${model.mouseState.isPressed}`, style()), styledText(`Pos: ${model.mouseState.lastX},${model.mouseState.lastY}`, style()));
      return vstack(innerView, debugInfo);
    }
    return innerView;
  },
  subscriptions: component.subscriptions ? (model) => exports_Effect.map(component.subscriptions(model.inner), (stream) => stream.pipe(stream.map((msg) => ({ _tag: "InnerMsg", msg })))) : undefined
}), clickableHandler = (onClick) => (event, localX, localY) => {
  if (event.type === "release" && event.button === "left") {
    return onClick();
  }
  return null;
}, hoverHandler = (onEnter, onLeave) => (event, localX, localY, wasHovered) => {
  if (event.type === "motion") {
    const isNowHovered = localX >= 0 && localY >= 0;
    if (!wasHovered && isNowHovered)
      return onEnter();
    if (wasHovered && !isNowHovered)
      return onLeave();
  }
  return null;
}, dragHandler = (onDragStart, onDragMove, onDragEnd) => {
  let isDragging = false;
  return (event, localX, localY) => {
    switch (event.type) {
      case "press":
        if (event.button === "left") {
          isDragging = true;
          return onDragStart(localX, localY);
        }
        break;
      case "motion":
        if (isDragging) {
          return onDragMove(localX, localY);
        }
        break;
      case "release":
        if (isDragging && event.button === "left") {
          isDragging = false;
          return onDragEnd(localX, localY);
        }
        break;
    }
    return null;
  };
};
var init_mouse_aware = __esm(() => {
  init_esm2();
  init_mouse_router();
  init_hit_test();
  init_view();
  init_styling();
});

// ../../src/components/streams/index.ts
function StreamComponent(props) {
  const items = $state([]);
  const error2 = $state(null);
  const isComplete = $state(false);
  $effect2(() => {
    let fiber = null;
    const runStream = pipe(props.stream, props.buffer === "sliding" && props.bufferSize ? Stream2.bufferSliding(props.bufferSize) : props.buffer === "dropping" && props.bufferSize ? Stream2.bufferDropping(props.bufferSize) : props.buffer === "unbounded" ? Stream2.buffer({ capacity: "unbounded" }) : (s) => s, Stream2.runForEach((item) => exports_Effect.sync(() => {
      const newItems = [...items.value, item];
      if (props.maxItems && newItems.length > props.maxItems) {
        items.value = newItems.slice(-props.maxItems);
      } else {
        items.value = newItems;
      }
    })), exports_Effect.catchAll((e) => exports_Effect.sync(() => {
      error2.value = e;
      return;
    })), exports_Effect.ensuring(exports_Effect.sync(() => {
      isComplete.value = true;
      props.onComplete?.();
    })));
    exports_Effect.runPromise(exports_Effect.forkDaemon(runStream).pipe(exports_Effect.map((f) => {
      fiber = f;
    })));
    return () => {
      if (fiber) {
        exports_Effect.runPromise(exports_Fiber.interrupt(fiber));
      }
    };
  });
  if (error2.value && props.onError) {
    const errorView = props.onError(error2.value);
    return typeof errorView === "string" ? jsx("error", { children: errorView }) : errorView;
  }
  if (items.value.length === 0 && !isComplete.value && props.placeholder) {
    return typeof props.placeholder === "string" ? jsx("text", { children: props.placeholder }) : props.placeholder;
  }
  const renderedItems = items.value.map((item, index) => {
    const rendered = props.children ? props.children(item) : props.transform ? props.transform(item) : String(item);
    const element = typeof rendered === "string" ? jsx("text", { children: rendered, style: props.itemStyle }) : rendered;
    if (props.separator && index < items.value.length - 1) {
      return jsx("vstack", {
        children: [
          element,
          typeof props.separator === "string" ? jsx("text", { children: props.separator }) : props.separator
        ]
      });
    }
    return element;
  });
  return jsx("vstack", { children: renderedItems });
}
function PipeComponent(props) {
  const transformedStream = pipe(props.from, props.concurrency ? Stream2.mapEffect((a) => {
    const result = props.through(a);
    return exports_Effect.isEffect(result) ? result : exports_Effect.succeed(result);
  }, { concurrency: props.concurrency }) : Stream2.map((a) => {
    const result = props.through(a);
    return exports_Effect.isEffect(result) ? exports_Effect.runSync(result) : result;
  }));
  return props.children(transformedStream);
}
function TransformComponent(props) {
  const finalStream = props.transforms.reduce((stream, transform5) => transform5.fn(stream), props.stream);
  if (props.showPipeline) {
    const pipeline = props.transforms.filter((t) => t.name).map((t) => t.name).join(" \u2192 ");
    return jsx("vstack", {
      children: [
        jsx("text", {
          children: `Pipeline: ${pipeline}`,
          color: "gray",
          italic: true
        }),
        props.children(finalStream)
      ]
    });
  }
  return props.children(finalStream);
}
function StreamBoxComponent(props) {
  const { title, border, padding, width, height, boxStyle, ...streamProps } = props;
  return jsx("panel", {
    title,
    border: border || "single",
    padding,
    width,
    height,
    style: boxStyle,
    children: jsx(StreamComponent, streamProps)
  });
}
function fromArray(items, delay3) {
  return delay3 ? pipe(Stream2.fromIterable(items), Stream2.schedule(exports_Schedule.spaced(delay3))) : Stream2.fromIterable(items);
}
function poll10(fn2, interval) {
  return Stream2.repeatEffect(exports_Effect.promise(() => Promise.resolve(fn2()))).pipe(Stream2.schedule(exports_Schedule.spaced(interval)));
}
function fromEventEmitter(emitter, eventName) {
  return Stream2.async((emit2) => {
    const handler = (data) => {
      emit2.single(data);
    };
    emitter.on(eventName, handler);
    return exports_Effect.sync(() => {
      emitter.off(eventName, handler);
    });
  });
}
function timer2(interval, maxTicks) {
  const baseStream = Stream2.iterate(0, (n) => n + 1).pipe(Stream2.schedule(exports_Schedule.spaced(interval)));
  return maxTicks ? Stream2.take(baseStream, maxTicks) : baseStream;
}
function random4(min4 = 0, max6 = 100, interval) {
  const stream = Stream2.repeatEffect(exports_Effect.sync(() => Math.random() * (max6 - min4) + min4));
  return interval ? stream.pipe(Stream2.schedule(exports_Schedule.spaced(interval))) : stream;
}
var Stream2, Pipe, Transform, StreamBox;
var init_streams = __esm(() => {
  init_esm2();
  init_runtime3();
  init_runes();
  Stream2 = StreamComponent;
  Pipe = PipeComponent;
  Transform = TransformComponent;
  StreamBox = StreamBoxComponent;
});

// ../../src/cli/components/jsx-dev-runtime.ts
var init_jsx_dev_runtime17 = __esm(() => {
  init_dev_runtime();
});

// ../../src/cli/components/Command.tsx
var init_Command2 = __esm(() => {
  init_cli();
  init_jsx_dev_runtime17();
});

// ../../src/cli/components/Plugin.tsx
var init_Plugin2 = __esm(() => {
  init_cli();
  init_jsx_dev_runtime17();
});

// ../../src/cli/components/Help.tsx
var defaultStyles, formatUsage = (command) => {
  const parts2 = [command.name];
  command.args.filter((arg) => arg.required).forEach((arg) => parts2.push(`<${arg.name}>`));
  command.args.filter((arg) => !arg.required).forEach((arg) => parts2.push(`[${arg.name}]`));
  if (command.options.length > 0) {
    parts2.push("[options]");
  }
  return parts2.join(" ");
}, formatOption = (option6) => {
  const parts2 = [];
  if (option6.short) {
    parts2.push(`-${option6.short},`);
  }
  parts2.push(`--${option6.name}`);
  if (option6.type !== "boolean") {
    parts2.push(`<${option6.type}>`);
  }
  return parts2.join(" ");
}, CommandHelp = ({ command, styles }) => {
  const sections = [];
  sections.push(/* @__PURE__ */ jsx(Box, {
    children: [
      /* @__PURE__ */ jsx(Text, {
        style: styles.section,
        children: "Usage:"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Text, {
        style: styles.usage,
        children: [
          "  ",
          formatUsage(command)
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this));
  if (command.description) {
    sections.push(/* @__PURE__ */ jsx(Box, {
      children: [
        /* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.description,
          children: command.description
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this));
  }
  if (command.args.length > 0) {
    sections.push(/* @__PURE__ */ jsx(Box, {
      children: [
        /* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.section,
          children: "Arguments:"
        }, undefined, false, undefined, this),
        vstack(...command.args.map((arg) => /* @__PURE__ */ jsx(Flex, {
          direction: "horizontal",
          gap: 2,
          children: [
            /* @__PURE__ */ jsx(Text, {
              style: styles.argument,
              children: [
                "  ",
                arg.name
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx(Text, {
              style: styles.description,
              children: arg.description
            }, undefined, false, undefined, this),
            arg.required && /* @__PURE__ */ jsx(Text, {
              style: style().foreground(Colors.red),
              children: "(required)"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)))
      ]
    }, undefined, true, undefined, this));
  }
  if (command.options.length > 0) {
    sections.push(/* @__PURE__ */ jsx(Box, {
      children: [
        /* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.section,
          children: "Options:"
        }, undefined, false, undefined, this),
        vstack(...command.options.map((option6) => /* @__PURE__ */ jsx(Flex, {
          direction: "horizontal",
          gap: 2,
          children: [
            /* @__PURE__ */ jsx(Text, {
              style: styles.option,
              children: [
                "  ",
                formatOption(option6).padEnd(20)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx(Text, {
              style: styles.description,
              children: option6.description
            }, undefined, false, undefined, this),
            option6.required && /* @__PURE__ */ jsx(Text, {
              style: style().foreground(Colors.red),
              children: "(required)"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this)))
      ]
    }, undefined, true, undefined, this));
  }
  if (command.aliases.length > 0) {
    sections.push(/* @__PURE__ */ jsx(Box, {
      children: [
        /* @__PURE__ */ jsx(Text, {
          children: ""
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.section,
          children: "Aliases:"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.command,
          children: [
            "  ",
            command.aliases.join(", ")
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this));
  }
  return vstack(...sections);
}, GlobalHelp = ({ props, styles }) => {
  const commands = props.config.commands || {};
  const commandList = Object.entries(commands).map(([name, config4]) => ({
    name,
    ...config4
  }));
  const visibleCommands = commandList.filter((cmd) => !cmd.hidden || props.showHidden);
  const grouped3 = new Map;
  const ungrouped = [];
  visibleCommands.forEach((cmd) => {
    const colonIndex = cmd.name.indexOf(":");
    if (colonIndex > 0) {
      const category = cmd.name.substring(0, colonIndex);
      const existing = grouped3.get(category) || [];
      grouped3.set(category, [...existing, cmd]);
    } else {
      ungrouped.push(cmd);
    }
  });
  const sections = [];
  sections.push(/* @__PURE__ */ jsx(Text, {
    style: styles.title,
    children: "Available Commands"
  }, undefined, false, undefined, this), /* @__PURE__ */ jsx(Text, {
    children: ""
  }, undefined, false, undefined, this));
  if (ungrouped.length > 0) {
    const maxNameLength = Math.max(...ungrouped.map((cmd) => cmd.name.length));
    sections.push(...ungrouped.map((cmd) => /* @__PURE__ */ jsx(Flex, {
      direction: "horizontal",
      gap: 2,
      children: [
        /* @__PURE__ */ jsx(Text, {
          style: styles.command,
          children: [
            "  ",
            cmd.name.padEnd(maxNameLength + 2)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.description,
          children: cmd.description
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)));
  }
  grouped3.forEach((cmds, category) => {
    const maxNameLength = Math.max(...cmds.map((cmd) => cmd.name.length));
    sections.push(/* @__PURE__ */ jsx(Text, {
      children: ""
    }, undefined, false, undefined, this), /* @__PURE__ */ jsx(Text, {
      style: styles.section,
      children: [
        category,
        ":"
      ]
    }, undefined, true, undefined, this), ...cmds.map((cmd) => /* @__PURE__ */ jsx(Flex, {
      direction: "horizontal",
      gap: 2,
      children: [
        /* @__PURE__ */ jsx(Text, {
          style: styles.command,
          children: [
            "  ",
            cmd.name.padEnd(maxNameLength + 2)
          ]
        }, undefined, true, undefined, this),
        /* @__PURE__ */ jsx(Text, {
          style: styles.description,
          children: cmd.description
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)));
  });
  sections.push(/* @__PURE__ */ jsx(Text, {
    children: ""
  }, undefined, false, undefined, this), /* @__PURE__ */ jsx(Text, {
    style: styles.description,
    children: "Run 'help [command]' for more information on a specific command."
  }, undefined, false, undefined, this));
  return vstack(...sections);
}, Help2 = (props) => {
  const styles = { ...defaultStyles, ...props.styles };
  if (props.command && props.command.length > 0) {
    let currentCommands = props.config.commands || {};
    let command = null;
    let commandName = "";
    for (const part of props.command) {
      if (currentCommands[part]) {
        command = currentCommands[part];
        commandName = part;
        currentCommands = command.commands || {};
      } else {
        command = null;
        break;
      }
    }
    if (!command) {
      return {
        render: () => exports_Effect.succeed(renderSync(/* @__PURE__ */ jsx(Text, {
          style: style().foreground(Colors.red),
          children: [
            "Unknown command: ",
            props.command.join(" ")
          ]
        }, undefined, true, undefined, this)))
      };
    }
    return {
      render: () => exports_Effect.succeed(renderSync(/* @__PURE__ */ jsx(CommandHelp, {
        command: { name: commandName, ...command },
        styles
      }, undefined, false, undefined, this)))
    };
  } else {
    return {
      render: () => exports_Effect.succeed(renderSync(GlobalHelp({ props, styles })))
    };
  }
}, generateHelpText = (config4, command) => {
  const helpView = Help2({ config: config4, command });
  return exports_Effect.runSync(helpView.render());
};
var init_Help2 = __esm(() => {
  init_esm2();
  init_styling();
  init_view();
  init_Text();
  init_Box();
  init_Flex();
  init_jsx_dev_runtime17();
  defaultStyles = {
    title: style().bold().foreground(Colors.brightWhite),
    section: style().bold().foreground(Colors.cyan),
    command: style().foreground(Colors.green),
    description: style().foreground(Colors.gray),
    usage: style().foreground(Colors.yellow),
    argument: style().foreground(Colors.blue),
    option: style().foreground(Colors.magenta),
    example: style().foreground(Colors.gray)
  };
});

// ../../src/cli/config.ts
function defineConfig(config4) {
  return {
    ...config4,
    options: config4.options ?? {},
    commands: config4.commands ?? {},
    plugins: config4.plugins ?? []
  };
}
function lazyLoad(importFn, metadata) {
  const lazyHandler = async () => {
    const module = await importFn();
    return module.default;
  };
  Object.assign(lazyHandler, { _lazy: true, _loader: importFn });
  if (metadata) {
    Object.assign(lazyHandler, metadata);
  }
  return lazyHandler;
}
function defineCommand(config4) {
  const { handler, ...rest } = config4;
  if (typeof handler === "function" && handler.constructor.name === "AsyncFunction" && !handler.length) {
    return {
      ...rest,
      handler: lazyLoad(handler)
    };
  }
  return {
    ...rest,
    handler
  };
}
function validateConfig2(config4) {
  if (!config4.name || config4.name.trim() === "") {
    throw new Error("CLI config must have a name");
  }
  if (!config4.version || config4.version.trim() === "") {
    throw new Error("CLI config must have a version");
  }
  const semverRegex = /^\d+\.\d+\.\d+/;
  if (!semverRegex.test(config4.version)) {
    throw new Error("CLI config version must be a valid semver format");
  }
  if (config4.description !== undefined && config4.description.trim() === "") {
    throw new Error("CLI config description cannot be empty string");
  }
  if (config4.commands !== undefined && (typeof config4.commands !== "object" || Array.isArray(config4.commands))) {
    throw new Error("CLI config commands must be an object");
  }
  if (config4.plugins !== undefined && !Array.isArray(config4.plugins)) {
    throw new Error("CLI config plugins must be an array");
  }
  const reservedNames = ["help", "version", "h", "v"];
  Object.keys(config4.commands || {}).forEach((name) => {
    if (reservedNames.includes(name)) {
      throw new Error(`Command name "${name}" is reserved`);
    }
  });
}
var commonOptions, commonArgs;
var init_config5 = __esm(() => {
  init_esm();
  commonOptions = {
    verbose: exports_external.boolean().default(false).describe("Enable verbose output"),
    quiet: exports_external.boolean().default(false).describe("Suppress output"),
    debug: exports_external.boolean().default(false).describe("Enable debug output"),
    help: exports_external.boolean().default(false).describe("Show help information"),
    version: exports_external.boolean().default(false).describe("Show version information"),
    config: exports_external.string().optional().describe("Path to config file"),
    output: exports_external.string().optional().describe("Output file path"),
    force: exports_external.boolean().default(false).describe("Force operation without confirmation"),
    yes: exports_external.boolean().default(false).describe("Answer yes to all prompts"),
    no: exports_external.boolean().default(false).describe("Answer no to all prompts"),
    port: exports_external.number().min(1).max(65535).default(3000).describe("Port number"),
    host: exports_external.string().default("localhost").describe("Host to bind to"),
    input: exports_external.string().describe("Input file path"),
    watch: exports_external.boolean().default(false).describe("Watch for file changes"),
    logLevel: exports_external.enum(["debug", "info", "warn", "error"]).default("info").describe("Log level"),
    logFile: exports_external.string().optional().describe("Log file path"),
    format: exports_external.enum(["json", "yaml", "table", "csv"]).default("table").describe("Output format"),
    pretty: exports_external.boolean().default(false).describe("Pretty print output")
  };
  commonArgs = {
    path: exports_external.string().describe("File or directory path"),
    paths: exports_external.array(exports_external.string()).describe("Multiple file or directory paths"),
    file: exports_external.string().describe("File path"),
    files: exports_external.array(exports_external.string()).describe("Multiple file paths"),
    directory: exports_external.string().describe("Directory path"),
    name: exports_external.string().describe("Name"),
    names: exports_external.array(exports_external.string()).describe("Multiple names"),
    value: exports_external.string().describe("Value"),
    values: exports_external.array(exports_external.string()).describe("Multiple values"),
    id: exports_external.string().describe("Identifier"),
    url: exports_external.string().url().describe("URL"),
    email: exports_external.string().email().describe("Email address")
  };
});

// ../../src/cli/parser.ts
class CLIParser {
  config;
  constructor(config4) {
    this.config = config4;
  }
  parse(argv) {
    const result = {
      command: [],
      args: {},
      options: {},
      rawArgs: [...argv]
    };
    let i = 0;
    let currentConfig = this.config;
    let currentCommands = this.config.commands || {};
    while (i < argv.length) {
      const arg = argv[i];
      if (!arg)
        break;
      if (arg.startsWith("-"))
        break;
      const resolvedCommand = this.resolveCommand(arg, currentCommands);
      if (resolvedCommand) {
        result.command.push(resolvedCommand);
        currentConfig = currentCommands[resolvedCommand];
        currentCommands = currentConfig.commands || {};
        i++;
      } else {
        break;
      }
    }
    while (i < argv.length) {
      const arg = argv[i];
      if (arg === "--") {
        i++;
        while (i < argv.length) {
          const rawArg = argv[i];
          if (rawArg !== undefined) {
            result.rawArgs.push(rawArg);
          }
          i++;
        }
        break;
      }
      if (arg && arg.startsWith("--")) {
        const [name, value6] = this.parseLongOption(arg);
        const nextArg = argv[i + 1];
        if (value6 !== undefined) {
          this.addOptionValue(result.options, name, this.parseValue(value6));
        } else if (nextArg && !nextArg.startsWith("-")) {
          this.addOptionValue(result.options, name, this.parseValue(nextArg));
          i++;
        } else {
          this.addOptionValue(result.options, name, true);
        }
      } else if (arg && arg.startsWith("-") && arg.length > 1) {
        this.parseShortOptions(arg.slice(1), result.options, argv, i);
      } else if (arg) {
        const argIndex = Object.keys(result.args).length;
        result.args[argIndex] = this.parseValue(arg);
      }
      i++;
    }
    if (result.options.help || result.options.version) {
      return result;
    }
    const optionSchemas = {
      ...this.config.options,
      ...this.getCommandOptionSchemas(result.command),
      help: exports_external.boolean().default(false),
      version: exports_external.boolean().default(false)
    };
    const argSchemas = this.getCommandArgSchemas(result.command);
    this.validateAndTransform(result, optionSchemas, argSchemas);
    return result;
  }
  addOptionValue(options, name, value6) {
    if (name in options) {
      if (Array.isArray(options[name])) {
        options[name].push(value6);
      } else {
        options[name] = [options[name], value6];
      }
    } else {
      options[name] = value6;
    }
  }
  parseValue(value6) {
    if (/^-?\d+$/.test(value6)) {
      return parseInt(value6, 10);
    }
    if (/^-?\d*\.\d+$/.test(value6)) {
      return parseFloat(value6);
    }
    if (value6 === "true")
      return true;
    if (value6 === "false")
      return false;
    return value6;
  }
  parseLongOption(arg) {
    const equalIndex = arg.indexOf("=");
    if (equalIndex !== -1) {
      return [arg.slice(2, equalIndex), arg.slice(equalIndex + 1)];
    }
    return [arg.slice(2), undefined];
  }
  parseShortOptions(flags, options, argv, currentIndex) {
    for (let i = 0;i < flags.length; i++) {
      const flag = flags[i];
      if (!flag)
        continue;
      if (i === flags.length - 1) {
        const nextArg = argv[currentIndex + 1];
        if (nextArg && !nextArg.startsWith("-")) {
          this.addOptionValue(options, flag, this.parseValue(nextArg));
        } else {
          this.addOptionValue(options, flag, true);
        }
      } else {
        this.addOptionValue(options, flag, true);
      }
    }
  }
  getCommandOptionSchemas(commandPath) {
    let schemas = { ...this.config.options };
    let currentCommands = this.config.commands || {};
    for (const command of commandPath) {
      const commandConfig = currentCommands[command];
      if (commandConfig?.options) {
        schemas = { ...schemas, ...commandConfig.options };
      }
      currentCommands = commandConfig?.commands || {};
    }
    return schemas;
  }
  getCommandArgSchemas(commandPath) {
    let currentCommands = this.config.commands || {};
    for (const command of commandPath) {
      const commandConfig = currentCommands[command];
      if (commandPath.indexOf(command) === commandPath.length - 1) {
        return commandConfig?.args || {};
      }
      currentCommands = commandConfig?.commands || {};
    }
    return {};
  }
  resolveCommand(name, commands) {
    if (commands[name]) {
      return name;
    }
    for (const [commandName, config4] of Object.entries(commands)) {
      if (config4.aliases?.includes(name)) {
        return commandName;
      }
    }
    return null;
  }
  validateAndTransform(result, optionSchemas, argSchemas) {
    for (const [name, schema] of Object.entries(optionSchemas)) {
      try {
        if (name in result.options) {
          result.options[name] = schema.parse(result.options[name]);
        } else {
          const defaultResult = schema.safeParse(undefined);
          if (defaultResult.success) {
            result.options[name] = defaultResult.data;
          }
        }
      } catch (error2) {
        if (error2 instanceof exports_external.ZodError) {
          throw new Error(`Invalid option --${name}: ${error2.errors[0]?.message || "validation failed"}`);
        }
        throw error2;
      }
    }
    const argNames = Object.keys(argSchemas);
    const positionalArgs = Object.values(result.args);
    const newArgs = {};
    argNames.forEach((name, index) => {
      const schema = argSchemas[name];
      if (schema && schema instanceof exports_external.ZodArray) {
        if (index < positionalArgs.length) {
          newArgs[name] = positionalArgs.slice(index);
        }
      } else {
        if (index < positionalArgs.length) {
          newArgs[name] = positionalArgs[index];
        }
      }
    });
    for (const [name, schema] of Object.entries(argSchemas)) {
      try {
        if (name in newArgs) {
          newArgs[name] = schema.parse(newArgs[name]);
        } else {
          const defaultResult = schema.safeParse(undefined);
          if (defaultResult.success) {
            newArgs[name] = defaultResult.data;
          } else {
            throw new Error(`Missing required argument: ${name}`);
          }
        }
      } catch (error2) {
        if (error2 instanceof exports_external.ZodError) {
          throw new Error(`Invalid argument ${name}: ${error2.errors[0]?.message || "validation failed"}`);
        }
        throw error2;
      }
    }
    result.args = newArgs;
  }
  generateHelp(commandPath) {
    const lines = [];
    if (!commandPath || commandPath.length === 0) {
      lines.push(`${this.config.name} v${this.config.version}`);
      if (this.config.description) {
        lines.push(`${this.config.description}`);
      }
      lines.push("");
      lines.push("USAGE:");
      lines.push(`  ${this.config.name} [OPTIONS] <COMMAND>`);
      lines.push("");
      if (Object.keys(this.config.options || {}).length > 0) {
        lines.push("OPTIONS:");
        this.addOptionsHelp(lines, this.config.options || {});
        lines.push("");
      }
      if (Object.keys(this.config.commands || {}).length > 0) {
        lines.push("COMMANDS:");
        this.addCommandsHelp(lines, this.config.commands || {});
      }
    } else {
      const commandConfig = this.getCommandConfig(commandPath);
      if (!commandConfig) {
        return `Unknown command: ${commandPath.join(" ")}`;
      }
      lines.push(`${this.config.name} ${commandPath.join(" ")}`);
      if (commandConfig.description) {
        lines.push(`${commandConfig.description}`);
      }
      lines.push("");
      lines.push("USAGE:");
      const usage = [`${this.config.name}`, ...commandPath];
      if (commandConfig.options && Object.keys(commandConfig.options).length > 0) {
        usage.push("[OPTIONS]");
      }
      if (commandConfig.args) {
        Object.keys(commandConfig.args).forEach((arg) => {
          usage.push(`<${arg}>`);
        });
      }
      if (commandConfig.commands && Object.keys(commandConfig.commands).length > 0) {
        usage.push("<COMMAND>");
      }
      lines.push(`  ${usage.join(" ")}`);
      lines.push("");
      if (commandConfig.options && Object.keys(commandConfig.options).length > 0) {
        lines.push("OPTIONS:");
        this.addOptionsHelp(lines, commandConfig.options);
        lines.push("");
      }
      if (commandConfig.commands && Object.keys(commandConfig.commands).length > 0) {
        lines.push("COMMANDS:");
        this.addCommandsHelp(lines, commandConfig.commands);
      }
    }
    return lines.join(`
`);
  }
  getSchemaDescription(schema) {
    if ("_def" in schema && typeof schema._def === "object" && schema._def && "description" in schema._def) {
      return String(schema._def.description || "");
    }
    return "";
  }
  addOptionsHelp(lines, options) {
    Object.entries(options).forEach(([name, schema]) => {
      const description = this.getSchemaDescription(schema);
      lines.push(`  --${name.padEnd(20)} ${description}`);
    });
  }
  addCommandsHelp(lines, commands) {
    Object.entries(commands).forEach(([name, config4]) => {
      if (!config4.hidden) {
        lines.push(`  ${name.padEnd(20)} ${config4.description || ""}`);
      }
    });
  }
  getCommandConfig(commandPath) {
    let currentCommands = this.config.commands || {};
    let currentConfig = null;
    for (const command of commandPath) {
      currentConfig = currentCommands[command] || null;
      if (!currentConfig)
        return null;
      currentCommands = currentConfig.commands || {};
    }
    return currentConfig;
  }
}
var init_parser = __esm(() => {
  init_esm();
});

// ../../src/cli/events.ts
var CLIEventChannels, ParseError3;
var init_events3 = __esm(() => {
  CLIEventChannels = {
    COMMAND: "cli-command",
    PARSE: "cli-parse",
    ROUTE: "cli-route",
    PLUGIN: "cli-plugin",
    HELP: "cli-help"
  };
  ParseError3 = class ParseError3 extends Error {
    input;
    position;
    constructor(message, input2, position) {
      super(message);
      this.input = input2;
      this.position = position;
      this.name = "ParseError";
    }
  };
});

// ../../src/cli/module.ts
var CLIModule;
var init_module2 = __esm(() => {
  init_esm2();
  init_module_base();
  init_events3();
  init_events3();
  init_events2();
  CLIModule = class CLIModule extends ModuleBase {
    commandTree = {};
    constructor(eventBus) {
      super(eventBus, "cli");
    }
    initialize() {
      return exports_Effect.gen(function* () {
        this.state = "initializing";
        yield* this.subscribeToEvents();
        yield* this.setReady();
      }.bind(this));
    }
    subscribeToEvents() {
      return this.subscribeMany([
        {
          channel: "scope-events",
          handler: (event) => this.handleScopeEvent(event)
        },
        {
          channel: JSXEventChannels.SCOPE,
          handler: (event) => this.handleJSXScopeEvent(event)
        }
      ]);
    }
    handleScopeEvent(event) {
      return exports_Effect.gen(function* () {
        if (event.type === "scope-registered" && "scope" in event) {
          const scope5 = event.scope;
          if (scope5.executable) {
            yield* this.registerScopeAsCommand(scope5);
          }
        }
      }.bind(this));
    }
    handleJSXScopeEvent(event) {
      return exports_Effect.gen(function* () {
        if (event.type === "jsx-scope-created" && "scope" in event) {
          const scope5 = event.scope;
          if (scope5.executable && scope5.handler) {
            yield* this.registerCommand({
              path: scope5.path,
              handler: scope5.handler,
              description: scope5.description,
              args: scope5.args,
              flags: scope5.flags,
              options: scope5.options,
              aliases: scope5.aliases
            });
          }
        }
      }.bind(this));
    }
    registerScopeAsCommand(scope5) {
      if (!scope5.handler) {
        return exports_Effect.void;
      }
      return this.registerCommand({
        path: scope5.path,
        handler: scope5.handler,
        description: scope5.description,
        args: scope5.args,
        flags: scope5.flags,
        options: scope5.options,
        aliases: scope5.aliases
      });
    }
    registerCommand(config4) {
      return exports_Effect.gen(function* () {
        let current2 = this.commandTree;
        for (let i = 0;i < config4.path.length - 1; i++) {
          const segment = config4.path[i];
          if (!current2[segment]) {
            current2[segment] = { subcommands: {} };
          }
          current2 = current2[segment].subcommands;
        }
        const commandName = config4.path[config4.path.length - 1];
        current2[commandName] = {
          handler: config4.handler,
          description: config4.description,
          args: config4.args,
          flags: config4.flags,
          options: config4.options,
          aliases: config4.aliases,
          subcommands: current2[commandName]?.subcommands || {}
        };
        yield* this.emitCommandRegistered(config4.path);
      }.bind(this));
    }
    unregisterCommand(path7) {
      return exports_Effect.gen(function* () {
        let current2 = this.commandTree;
        const segments = [...path7];
        const commandName = segments.pop();
        for (const segment of segments) {
          if (!current2[segment]) {
            return;
          }
          current2 = current2[segment].subcommands;
        }
        delete current2[commandName];
        yield* this.emitCommandUnregistered(path7);
      }.bind(this));
    }
    updateCommandTree(tree) {
      return exports_Effect.sync(() => {
        this.commandTree = tree;
      });
    }
    parseInput(input2) {
      return exports_Effect.gen(function* () {
        yield* this.emitParseStart(input2);
        try {
          const command = [];
          const args2 = {};
          const flags = new Set;
          const options = {};
          const positional = [];
          let i = 0;
          while (i < input2.length && !input2[i].startsWith("-")) {
            command.push(input2[i]);
            i++;
          }
          while (i < input2.length) {
            const arg = input2[i];
            if (arg.startsWith("--")) {
              const [key, value6] = arg.slice(2).split("=");
              if (value6 !== undefined) {
                options[key] = value6;
              } else {
                flags.add(key);
              }
            } else if (arg.startsWith("-")) {
              arg.slice(1).split("").forEach((flag) => flags.add(flag));
            } else {
              positional.push(arg);
            }
            i++;
          }
          const result = {
            command,
            args: args2,
            flags,
            options,
            _: positional
          };
          yield* this.emitParseSuccess(input2, result);
          return result;
        } catch (error2) {
          yield* this.emitParseError(input2, error2);
          return yield* exports_Effect.fail(new ParseError3("Failed to parse input", input2));
        }
      }.bind(this));
    }
    executeCommand(path7, args2) {
      return exports_Effect.gen(function* () {
        const startTime = Date.now();
        try {
          const command = this.findCommand(path7);
          if (!command || !command.handler) {
            yield* this.emitRouteNotFound(path7);
            return yield* exports_Effect.fail(new ExecutionError(`Command not found: ${path7.join(" ")}`));
          }
          yield* this.emitRouteFound(path7, command.handler);
          const result = yield* command.handler(args2, {});
          const executionTime = Date.now() - startTime;
          yield* this.emitCommandExecuted(path7, args2, result, executionTime);
          return result;
        } catch (error2) {
          yield* this.emitCommandFailed(path7, args2, error2);
          return yield* exports_Effect.fail(error2);
        }
      }.bind(this));
    }
    findCommand(path7) {
      let current2 = this.commandTree;
      for (const segment of path7) {
        const command = current2[segment];
        if (!command)
          return null;
        current2 = command.subcommands || {};
      }
      return current2[path7[path7.length - 1]] || null;
    }
    showHelp(path7) {
      return exports_Effect.gen(function* () {
        yield* this.emitEvent(CLIEventChannels.HELP, {
          type: "cli-help-requested",
          path: path7
        });
        console.log(`Help for: ${path7.join(" ")}`);
        yield* this.emitEvent(CLIEventChannels.HELP, {
          type: "cli-help-displayed",
          path: path7
        });
        return 0;
      }.bind(this));
    }
    emitCommandRegistered(path7) {
      return this.emitEvent(CLIEventChannels.COMMAND, {
        type: "cli-command-registered",
        path: path7
      });
    }
    emitCommandUnregistered(path7) {
      return this.emitEvent(CLIEventChannels.COMMAND, {
        type: "cli-command-registered",
        path: path7
      });
    }
    emitCommandExecuted(path7, args2, result, executionTime) {
      return this.emitEvent(CLIEventChannels.COMMAND, {
        type: "cli-command-executed",
        path: path7,
        args: args2,
        result,
        executionTime
      });
    }
    emitCommandFailed(path7, args2, error2) {
      return this.emitEvent(CLIEventChannels.COMMAND, {
        type: "cli-command-failed",
        path: path7,
        args: args2,
        error: error2
      });
    }
    emitParseStart(input2) {
      return this.emitEvent(CLIEventChannels.PARSE, {
        type: "cli-parse-start",
        input: input2
      });
    }
    emitParseSuccess(input2, result) {
      return this.emitEvent(CLIEventChannels.PARSE, {
        type: "cli-parse-success",
        input: input2,
        result
      });
    }
    emitParseError(input2, error2) {
      return this.emitEvent(CLIEventChannels.PARSE, {
        type: "cli-parse-error",
        input: input2,
        error: new ParseError3(error2.message, input2)
      });
    }
    emitRouteFound(path7, handler) {
      return this.emitEvent(CLIEventChannels.ROUTE, {
        type: "cli-route-found",
        path: path7,
        handler
      });
    }
    emitRouteNotFound(path7) {
      return this.emitEvent(CLIEventChannels.ROUTE, {
        type: "cli-route-not-found",
        path: path7
      });
    }
  };
});

// ../../src/cli/router.ts
class CLIRouter {
  config;
  _commands = {};
  _middleware = [];
  cliModule = null;
  constructor(config4) {
    this.config = config4;
    this._commands = { ...config4.commands || {} };
    this.initializeCLIModule();
  }
  initializeCLIModule() {
    try {
      const registry = getGlobalRegistry();
      this.cliModule = registry.getModule("cli");
      if (!this.cliModule) {
        const eventBus = getGlobalEventBus();
        this.cliModule = new CLIModule(eventBus);
        exports_Effect.runSync(registry.register(this.cliModule));
        exports_Effect.runSync(this.cliModule.initialize());
      }
    } catch (error2) {}
  }
  route(parsedArgs) {
    if (parsedArgs.command.length === 0) {
      return {
        handler: null,
        config: null,
        isLazy: false
      };
    }
    const commandConfig = this.findCommandConfig(parsedArgs.command);
    if (!commandConfig) {
      if (this.cliModule) {
        exports_Effect.runSync(this.cliModule.emitRouteNotFound(parsedArgs.command));
      }
      return {
        handler: null,
        config: null,
        isLazy: false
      };
    }
    const handler = commandConfig.handler;
    if (!handler) {
      return {
        handler: null,
        config: commandConfig,
        isLazy: false
      };
    }
    const isLazy = this.isLazyHandler(handler);
    if (this.cliModule) {
      exports_Effect.runSync(this.cliModule.emitRouteFound(parsedArgs.command, handler));
    }
    return {
      handler,
      config: commandConfig,
      isLazy
    };
  }
  findCommandConfig(commandPath) {
    let currentCommands = this.config.commands || {};
    let currentConfig = null;
    for (const command of commandPath) {
      currentConfig = currentCommands[command] || null;
      if (!currentConfig) {
        return null;
      }
      if (commandPath.indexOf(command) < commandPath.length - 1) {
        currentCommands = currentConfig.commands || {};
      }
    }
    return currentConfig;
  }
  getAvailableCommands(commandPath = []) {
    let currentCommands = this.config.commands || {};
    for (const command of commandPath) {
      const commandConfig = currentCommands[command];
      if (!commandConfig) {
        return [];
      }
      currentCommands = commandConfig.commands || {};
    }
    return Object.keys(currentCommands).filter((name) => {
      const config4 = currentCommands[name];
      return config4 && !config4.hidden;
    });
  }
  getCommandAliases(commandName) {
    const commands = this.config.commands || {};
    const config4 = commands[commandName];
    return config4?.aliases || [];
  }
  resolveCommandName(name, currentCommands) {
    const commands = currentCommands || this.config.commands || {};
    if (commands[name]) {
      return name;
    }
    for (const [commandName, config4] of Object.entries(commands)) {
      if (config4.aliases?.includes(name)) {
        return commandName;
      }
    }
    return null;
  }
  isLazyHandler(handler) {
    return typeof handler === "function" && handler.length === 0;
  }
  async executeHandler(handler, args2, isLazy = false) {
    try {
      if (isLazy) {
        const actualHandler = await handler();
        return await this.callHandler(actualHandler, args2);
      } else {
        return await this.callHandler(handler, args2);
      }
    } catch (error2) {
      if (error2 instanceof Error) {
        error2.message = `Command execution failed: ${error2.message}`;
      }
      throw error2;
    }
  }
  async callHandler(handler, args2) {
    const result = handler(args2);
    if (result instanceof Promise) {
      return await result;
    }
    return result;
  }
  validateCommandPath(commandPath) {
    return this.findCommandConfig(commandPath) !== null;
  }
  getCommandHierarchy() {
    return this.buildHierarchy(this.config.commands || {}, []);
  }
  buildHierarchy(commands, path7) {
    const hierarchy = {};
    for (const [name, config4] of Object.entries(commands)) {
      const currentPath = [...path7, name];
      hierarchy[name] = {
        path: currentPath,
        description: config4.description,
        hasHandler: !!config4.handler,
        aliases: config4.aliases || [],
        hidden: config4.hidden || false,
        subcommands: config4.commands ? this.buildHierarchy(config4.commands, currentPath) : {}
      };
    }
    return hierarchy;
  }
  getCommands() {
    return Object.keys(this._commands || {});
  }
  addCommand(name, config4) {
    if (!this._commands) {
      this._commands = {};
    }
    this._commands[name] = config4;
  }
  getCommand(name) {
    return this._commands?.[name] || null;
  }
  async execute(commandName, args2 = {}, options = {}) {
    const command = this.getCommand(commandName);
    if (!command) {
      throw new Error(`Unknown command: ${commandName}`);
    }
    if (!command.handler) {
      throw new Error(`Command ${commandName} has no handler`);
    }
    let handler = command.handler;
    for (let i = this._middleware.length - 1;i >= 0; i--) {
      handler = this._middleware[i](handler);
    }
    if (typeof handler === "function") {
      const combinedArgs = { ...args2, ...options };
      if (handler.length === 0) {
        const result = await handler();
        if (typeof result === "function") {
          return result(combinedArgs);
        } else {
          return result;
        }
      } else {
        return handler(combinedArgs);
      }
    }
    throw new Error(`Invalid handler for command: ${commandName}`);
  }
  addMiddleware(middleware) {
    this._middleware.push(middleware);
  }
}

class CommandSuggestions {
  router;
  constructor(router) {
    this.router = router;
  }
  getSuggestions(unknownCommand, commandPath = []) {
    const availableCommands2 = this.router.getAvailableCommands(commandPath);
    const suggestions = availableCommands2.map((cmd) => ({
      command: cmd,
      distance: this.levenshteinDistance(unknownCommand, cmd)
    })).filter((item) => item.distance <= 3).sort((a, b) => a.distance - b.distance).slice(0, 3).map((item) => item.command);
    return suggestions;
  }
  levenshteinDistance(str1, str2) {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    for (let i = 0;i <= str1.length; i++) {
      matrix[0][i] = i;
    }
    for (let j = 0;j <= str2.length; j++) {
      matrix[j][0] = j;
    }
    for (let j = 1;j <= str2.length; j++) {
      for (let i = 1;i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + indicator);
      }
    }
    return matrix[str2.length][str1.length];
  }
}
var init_router = __esm(() => {
  init_esm2();
  init_event_bus();
  init_module_registry();
  init_module2();
});

// ../../src/cli/hooks.ts
function createHook(eventBus, channel, source) {
  const hook = {
    subscribe: (handler) => {
      return exports_Effect.gen(function* () {
        const effectHandler = (event) => {
          const result = handler(event);
          if (exports_Effect.isEffect(result)) {
            return result;
          } else if (result instanceof Promise) {
            return exports_Effect.tryPromise({
              try: () => result,
              catch: () => new Error("Hook handler failed")
            }).pipe(exports_Effect.asVoid);
          } else {
            return exports_Effect.void;
          }
        };
        const unsubscribe = yield* eventBus.subscribe(channel, effectHandler);
        return { unsubscribe };
      });
    },
    once: (handler) => {
      return exports_Effect.gen(function* () {
        let unsubscribe = null;
        const effectHandler = (event) => {
          return exports_Effect.gen(function* () {
            const result = handler(event);
            if (exports_Effect.isEffect(result)) {
              yield* result;
            } else if (result instanceof Promise) {
              yield* exports_Effect.tryPromise({
                try: () => result,
                catch: () => new Error("Hook handler failed")
              });
            }
            if (unsubscribe) {
              yield* unsubscribe();
            }
          });
        };
        unsubscribe = yield* eventBus.subscribe(channel, effectHandler);
        return { unsubscribe };
      });
    },
    filter: (predicate) => {
      return {
        subscribe: (handler) => {
          return hook.subscribe((event) => {
            if (predicate(event)) {
              return handler(event);
            }
            return exports_Effect.void;
          });
        },
        once: (handler) => {
          return hook.once((event) => {
            if (predicate(event)) {
              return handler(event);
            }
            return exports_Effect.void;
          });
        },
        filter: (nextPredicate) => {
          return hook.filter((event) => predicate(event) && nextPredicate(event));
        }
      };
    }
  };
  return hook;
}
function createHooks(eventBus, source = "cli") {
  return {
    onBeforeInit: createHook(eventBus, "hook:beforeInit", source),
    onAfterInit: createHook(eventBus, "hook:afterInit", source),
    onBeforeCommand: createHook(eventBus, "hook:beforeCommand", source),
    onAfterCommand: createHook(eventBus, "hook:afterCommand", source),
    onError: createHook(eventBus, "hook:onError", source),
    onPluginLoad: createHook(eventBus, "hook:pluginLoad", source),
    onPluginUnload: createHook(eventBus, "hook:pluginUnload", source),
    onBeforeParse: createHook(eventBus, "hook:beforeParse", source),
    onAfterParse: createHook(eventBus, "hook:afterParse", source),
    onBeforeValidate: createHook(eventBus, "hook:beforeValidate", source),
    onAfterValidate: createHook(eventBus, "hook:afterValidate", source),
    onBeforeExecute: createHook(eventBus, "hook:beforeExecute", source),
    onAfterExecute: createHook(eventBus, "hook:afterExecute", source),
    onBeforeRender: createHook(eventBus, "hook:beforeRender", source),
    onAfterRender: createHook(eventBus, "hook:afterRender", source),
    on: (channel) => createHook(eventBus, channel, source),
    emit: (event) => {
      return eventBus.emit(event.type, event);
    }
  };
}
function createHookEvent(type2, data, source = "cli") {
  return {
    ...data,
    type: type2,
    timestamp: new Date,
    source,
    id: generateId()
  };
}
function getGlobalHooks(eventBus) {
  if (!globalHooks) {
    if (!eventBus) {
      throw new Error("Global hooks not initialized. Please provide an EventBus on first call.");
    }
    globalHooks = createHooks(eventBus);
  }
  return globalHooks;
}
var globalHooks = null;
var init_hooks2 = __esm(() => {
  init_esm2();
  init_event_bus();
});

// ../../src/cli/runner.ts
class CLIRunner {
  config;
  parser;
  router;
  suggestions;
  tuixConfig;
  eventBus;
  hooks;
  constructor(config4, tuixConfig) {
    this.config = config4;
    validateConfig2(config4);
    this.tuixConfig = tuixConfig;
    this.parser = new CLIParser(config4);
    this.router = new CLIRouter(config4);
    this.suggestions = new CommandSuggestions(this.router);
    this.eventBus = new EventBus;
    this.hooks = createHooks(this.eventBus, config4.name || "cli");
  }
  async run(argv = process.argv.slice(2)) {
    try {
      const parsedArgs = this.parser.parse(argv);
      if (parsedArgs.options.help) {
        this.showHelp(parsedArgs.command.length > 0 ? parsedArgs.command : undefined);
        return;
      }
      if (parsedArgs.options.version) {
        this.showVersion();
        return;
      }
      if (parsedArgs.command.length === 0) {
        this.showHelp();
        process.exit(0);
        return;
      }
      const route = this.router.route(parsedArgs);
      if (!route.handler) {
        this.handleUnknownCommand(parsedArgs.command);
        process.exit(1);
        return;
      }
      const plugins = await this.loadPlugins();
      const context10 = {
        config: this.config,
        parsedArgs,
        plugins,
        tuixConfig: this.tuixConfig
      };
      await exports_Effect.runPromise(this.hooks.emit(createHookEvent("hook:beforeCommand", {
        command: parsedArgs.command,
        args: parsedArgs.options
      })));
      try {
        const positionalArgs = parsedArgs.rawArgs.slice(parsedArgs.command.length);
        const parsedPositionalArgs = {};
        if (route.config?.args) {
          const argNames = Object.keys(route.config.args);
          argNames.forEach((argName, index) => {
            if (index < positionalArgs.length) {
              const argConfig = route.config.args[argName];
              let value6 = positionalArgs[index];
              if (argConfig && typeof argConfig.parse === "function") {
                try {
                  value6 = argConfig.parse(value6);
                } catch (error2) {
                  console.warn(`Failed to parse argument "${argName}":`, error2);
                }
              }
              parsedPositionalArgs[argName] = value6;
            }
          });
        }
        const handlerArgs = {
          ...parsedPositionalArgs,
          ...parsedArgs.options,
          _raw: {
            command: parsedArgs.command,
            args: positionalArgs,
            options: parsedArgs.options
          },
          _context: context10
        };
        const result = await this.router.executeHandler(route.handler, handlerArgs, route.isLazy);
        if (result) {
          if (this.isComponent(result)) {
            await exports_Effect.runPromise(runApp(result).pipe(exports_Effect.provide(LiveServices), exports_Effect.catchAll(() => exports_Effect.void), exports_Effect.orDie));
          } else if (this.isView(result)) {
            const rendered = await exports_Effect.runPromise(result.render());
            console.log(rendered);
          } else if (typeof result === "object") {
            console.log("Command returned non-component result:", result);
          }
        }
        await exports_Effect.runPromise(this.hooks.emit(createHookEvent("hook:afterCommand", {
          command: parsedArgs.command,
          args: parsedArgs.options,
          result
        })));
      } catch (error2) {
        await exports_Effect.runPromise(this.hooks.emit(createHookEvent("hook:onError", {
          error: error2 instanceof Error ? error2 : new Error(String(error2)),
          command: parsedArgs.command,
          args: parsedArgs.options
        })));
        throw error2;
      }
    } catch (error2) {
      this.handleError(error2);
      process.exit(1);
    }
  }
  showHelp(commandPath) {
    const helpText = this.parser.generateHelp(commandPath);
    console.log(helpText);
  }
  showVersion() {
    console.log(`${this.config.name} ${this.config.version}`);
  }
  handleUnknownCommand(commandPath) {
    const unknownCommand = commandPath[commandPath.length - 1] || "<unknown>";
    const parentPath = commandPath.slice(0, -1);
    console.error(`Error: Unknown command '${unknownCommand}'`);
    const suggestions = this.suggestions.getSuggestions(unknownCommand, parentPath);
    if (suggestions.length > 0) {
      console.error(`
Did you mean:`);
      suggestions.forEach((suggestion) => {
        console.error(`  ${[...parentPath, suggestion].join(" ")}`);
      });
    }
    console.error(`
Run '${this.config.name} --help' for usage information`);
  }
  handleError(error2) {
    if (error2 instanceof Error) {
      console.error(`Error: ${error2.message}`);
      if (process.env.CLI_VERBOSE === "true") {
        console.error(error2.stack);
      }
    } else {
      console.error(`Error: ${String(error2)}`);
    }
  }
  async loadPlugins() {
    const plugins = [];
    if (!this.config.plugins || this.config.plugins.length === 0) {
      return plugins;
    }
    for (const pluginConfig of this.config.plugins) {
      try {
        if (typeof pluginConfig === "string") {
          const plugin = await import(pluginConfig);
          if (plugin.default) {
            plugins.push(plugin.default);
          } else {
            console.warn(`Plugin ${pluginConfig} has no default export`);
          }
        } else if (typeof pluginConfig === "object" && pluginConfig !== null && "metadata" in pluginConfig) {
          plugins.push(pluginConfig);
        }
      } catch (error2) {
        console.warn(`Failed to load plugin:`, error2);
      }
    }
    for (const plugin of plugins) {
      if (plugin.install) {
        try {
          const context10 = {
            command: [],
            config: {},
            plugins: [],
            metadata: plugin.metadata
          };
          await plugin.install(context10);
        } catch (error2) {
          console.warn(`Failed to initialize plugin ${plugin.metadata.name}:`, error2);
        }
      }
    }
    return plugins;
  }
  getHooks() {
    return this.hooks;
  }
  isComponent(value6) {
    return value6 !== null && typeof value6 === "object" && "init" in value6 && typeof value6.init === "function";
  }
  isView(value6) {
    return value6 !== null && typeof value6 === "object" && "render" in value6 && typeof value6.render === "function";
  }
  viewToComponent(view) {
    return {
      init: exports_Effect.succeed([{ done: false }, []]),
      update: (model, msg) => {
        const modelObj = model;
        const msgObj = msg;
        if (msg && (msgObj._tag === "KeyPress" || modelObj.done)) {
          return exports_Effect.succeed([{ ...modelObj, done: true }, [exports_Effect.succeed({ _tag: "Quit" })]]);
        }
        return exports_Effect.succeed([{ ...modelObj, done: true }, []]);
      },
      view: () => view
    };
  }
}
async function runCLI(config4, argv) {
  let tuixConfig;
  try {
    tuixConfig = await loadConfig();
  } catch (error2) {
    if (process.env.CLI_VERBOSE === "true") {
      console.warn("No tuix config found, running without config:", error2);
    }
  }
  const runner = new CLIRunner(config4, tuixConfig);
  await runner.run(argv);
}
async function cli(config4) {
  await runCLI(config4);
}
async function ensureConfig(appName) {
  try {
    return await loadConfig();
  } catch (error2) {
    const configName = appName || "tuix";
    const defaultConfig3 = createConfig();
    const configPath = `${configName}.config.ts`;
    const configContent = `import { createConfig } from 'tuix'

export default createConfig({
  // Process manager services
  processManager: {
    services: {
      // Add your services here
      // Example:
      // 'my-service': {
      //   command: 'npm run dev',
      //   cwd: '.',
      //   env: {},
      //   autoRestart: true
      // }
    }
  },
  
  // Logger configuration
  logger: {
    level: 'info',
    format: 'json',
    outputs: ['console']
  }
})
`;
    await Bun.write(configPath, configContent);
    console.log(`\u2705 Created default config at ${configPath}`);
    return defaultConfig3;
  }
}
var init_runner = __esm(() => {
  init_esm2();
  init_runtime2();
  init_impl();
  init_parser();
  init_router();
  init_config5();
  init_config4();
  init_event_bus();
  init_hooks2();
});

// ../../src/cli/components/App.tsx
var App = (props) => {
  const commands = {};
  if (props.children) {
    const children3 = Array.isArray(props.children) ? props.children : [props.children];
    children3.forEach((child) => {
      if (child && typeof child === "object" && "_tag" in child && child._tag === "Command") {
        const commandData = child;
        const name = commandData.name;
        const config4 = commandData.config;
        commands[name] = config4;
      }
    });
  }
  const cliConfig3 = defineConfig({
    name: props.name,
    version: props.version || "1.0.0",
    description: props.description,
    commands,
    ui: {
      header: props.header,
      footer: props.footer,
      boxStyle: props.boxStyle || "rounded",
      padding: props.padding || 1
    }
  });
  return {
    _tag: "App",
    config: cliConfig3,
    render: () => exports_Effect.succeed("")
  };
};
var init_App = __esm(() => {
  init_esm2();
  init_config5();
  init_runner();
});

// ../../src/cli/components/index.ts
var init_components3 = __esm(() => {
  init_Command2();
  init_Plugin2();
  init_Help2();
  init_App();
});

// ../../src/components/index.ts
var init_components4 = __esm(() => {
  init_forms();
  init_layout();
  init_display();
  init_feedback();
  init_data2();
  init_navigation();
  init_containers();
  init_system();
  init_app2();
  init_base();
  init_component();
  init_mouse_aware();
  init_streams();
  init_components3();
  init_forms();
  init_layout();
  init_display();
  init_feedback();
  init_data2();
  init_navigation();
  init_containers();
  init_system();
});

// ../../src/cli/jsx/components/Help.tsx
function Help(props) {
  return text2(props.content);
}
var init_Help3 = __esm(() => {
  init_components4();
});

// ../../src/cli/jsx/components/Example.tsx
function Example(props) {
  return box2({
    flexDirection: "column",
    gap: 1,
    marginY: 1
  }, props.description ? text2(props.description) : null, box2({
    paddingX: 2,
    borderStyle: "single",
    borderColor: "gray"
  }, text2(props.code)));
}
var init_Example = __esm(() => {
  init_components4();
});

// ../../src/cli/jsx/components/Exit.tsx
function Exit3(props) {
  onMount(() => {
    process.exit(props.code ?? 0);
  });
  return props.message ? text2(props.message) : null;
}
var init_Exit4 = __esm(() => {
  init_jsx_lifecycle();
  init_components4();
});

// ../../src/cli/jsx/components/LoadPlugin.tsx
function LoadPlugin(props) {
  let loaded = false;
  let error2 = null;
  onMount(async () => {
    try {
      const plugin = await import(props.path);
      if (typeof plugin.default === "function") {
        await plugin.default();
      }
      loaded = true;
    } catch (e) {
      error2 = e;
      console.error(`Failed to load plugin from ${props.path}:`, e);
    }
  });
  if (error2) {
    return text2(`Failed to load plugin: ${error2.message}`);
  }
  return text2(`Loading plugin from ${props.path}...`);
}
var init_LoadPlugin = __esm(() => {
  init_jsx_lifecycle();
  init_components4();
});

// ../../src/cli/jsx/components/index.ts
var init_components5 = __esm(() => {
  init_CLI();
  init_Plugin();
  init_Command();
  init_Arg();
  init_Flag();
  init_Option2();
  init_Help3();
  init_Example();
  init_Exit4();
  init_LoadPlugin();
  init_cli();
  init_components();
});

// ../../src/logger/types.ts
var LogLevels, defaultSerializers, Logger, LoggerConfig, InteractiveLogRenderer;
var init_types5 = __esm(() => {
  init_esm2();
  LogLevels = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  defaultSerializers = {
    error: (err) => ({
      message: err.message,
      name: err.name,
      stack: err.stack,
      ...err
    }),
    req: (req) => ({
      method: req.method,
      url: req.url,
      headers: req.headers,
      remoteAddress: req.connection?.remoteAddress,
      remotePort: req.connection?.remotePort
    }),
    res: (res) => ({
      statusCode: res.statusCode,
      headers: res.getHeaders?.()
    })
  };
  Logger = exports_Context.GenericTag("tuix/Logger");
  LoggerConfig = exports_Context.GenericTag("tuix/LoggerConfig");
  InteractiveLogRenderer = exports_Context.GenericTag("tuix/InteractiveLogRenderer");
});

// ../../src/logger/logger.ts
import * as os2 from "os";

class TuixLogger {
  config;
  levelValue;
  serializers;
  contextPath;
  metadata;
  spans = new Map;
  constructor(config4, contextPath = [], metadata = {}, serializers = {}) {
    this.config = config4;
    this.levelValue = LogLevels[config4.level];
    this.serializers = { ...defaultSerializers, ...serializers };
    this.contextPath = contextPath;
    this.metadata = metadata;
  }
  trace(message, metadata) {
    return this.log({ level: "trace", message, metadata });
  }
  debug(message, metadata) {
    return this.log({ level: "debug", message, metadata });
  }
  info(message, metadata) {
    return this.log({ level: "info", message, metadata });
  }
  warn(message, metadata) {
    return this.log({ level: "warn", message, metadata });
  }
  error(message, error2, metadata) {
    return this.log({ level: "error", message, error: error2, metadata });
  }
  fatal(message, error2, metadata) {
    return this.log({ level: "fatal", message, error: error2, metadata });
  }
  log(entry) {
    if (!entry.level || !this.isLevelEnabled(entry.level)) {
      return exports_Effect.void;
    }
    const fullEntry = {
      level: entry.level,
      message: entry.message || "",
      timestamp: entry.timestamp || new Date,
      context: [...this.contextPath, ...entry.context || []],
      metadata: this.serializeMetadata({ ...this.metadata, ...entry.metadata }),
      error: entry.error,
      span: entry.span,
      pid: process.pid,
      hostname: os2.hostname(),
      name: this.config.name,
      v: 1,
      src: this.getSourceInfo()
    };
    return exports_Effect.forEach(this.config.transports, (transport) => transport.write(fullEntry)).pipe(exports_Effect.asVoid, exports_Effect.catchAll(() => exports_Effect.void));
  }
  child(context10) {
    if (typeof context10 === "string") {
      return new TuixLogger(this.config, [...this.contextPath, context10], this.metadata, this.serializers);
    } else {
      return new TuixLogger(this.config, this.contextPath, { ...this.metadata, ...context10 }, this.serializers);
    }
  }
  span(name, effect4) {
    const self = this;
    return exports_Effect.gen(function* (_) {
      const startTime = Date.now();
      const spanId = `${name}-${startTime}-${Math.random()}`;
      yield* _(exports_Effect.sync(() => {
        self.spans.set(spanId, { startTime, attributes: {} });
      }));
      const result = yield* _(effect4.pipe(exports_Effect.tap(() => {
        const span4 = self.spans.get(spanId);
        if (span4) {
          const duration4 = Date.now() - span4.startTime;
          self.spans.delete(spanId);
          return self.log({
            level: "trace",
            message: `Span completed: ${name}`,
            span: {
              name,
              duration: duration4,
              attributes: span4.attributes
            }
          });
        }
        return exports_Effect.void;
      }), exports_Effect.tapError(() => {
        const span4 = self.spans.get(spanId);
        if (span4) {
          const duration4 = Date.now() - span4.startTime;
          self.spans.delete(spanId);
          return self.log({
            level: "error",
            message: `Span failed: ${name}`,
            span: {
              name,
              duration: duration4,
              attributes: { ...span4.attributes, error: true }
            }
          });
        }
        return exports_Effect.void;
      })));
      return result;
    });
  }
  startSpan(name, attributes) {
    const startTime = Date.now();
    const spanId = `${name}-${startTime}-${Math.random()}`;
    this.spans.set(spanId, { startTime, attributes: attributes || {} });
    return {
      name,
      startTime,
      attributes: attributes || {},
      end: (endAttributes) => {
        const span4 = this.spans.get(spanId);
        if (span4) {
          const duration4 = Date.now() - span4.startTime;
          this.spans.delete(spanId);
          return this.log({
            level: "trace",
            message: `Span: ${name}`,
            span: {
              name,
              duration: duration4,
              attributes: { ...span4.attributes, ...endAttributes }
            }
          });
        }
        return exports_Effect.void;
      }
    };
  }
  pretty() {
    return this;
  }
  addSerializer(field, serializer) {
    return new TuixLogger(this.config, this.contextPath, this.metadata, { ...this.serializers, [field]: serializer });
  }
  level() {
    return this.config.level;
  }
  level(level) {
    this.config.level = level;
    this.levelValue = LogLevels[level];
  }
  isLevelEnabled(level) {
    return LogLevels[level] >= this.levelValue;
  }
  serializeMetadata(metadata) {
    if (!metadata)
      return;
    const serialized = {};
    for (const [key, value6] of Object.entries(metadata)) {
      if (key in this.serializers) {
        serialized[key] = this.serializers[key](value6);
      } else {
        serialized[key] = value6;
      }
    }
    return serialized;
  }
  getSourceInfo() {
    return;
  }
}
var makeLoggerLayer = (config4) => exports_Layer.succeed(Logger, new TuixLogger(config4)), LoggerQueue, makeQueuedLoggerLayer = (config4, queueSize = 1000) => exports_Layer.effectDiscard(exports_Effect.gen(function* (_) {
  const queue = yield* _(exports_Queue.bounded(queueSize));
  const queuedLogger = new TuixLogger({
    ...config4,
    transports: [{
      write: (entry) => exports_Queue.offer(queue, entry)
    }]
  });
  const processor = yield* _(exports_Stream.fromQueue(queue).pipe(exports_Stream.tap((entry) => exports_Effect.forEach(config4.transports, (transport) => transport.write(entry)).pipe(exports_Effect.asVoid)), exports_Stream.runDrain, exports_Effect.fork));
  yield* _(exports_Layer.succeed(Logger, queuedLogger));
  yield* _(exports_Layer.succeed(LoggerQueue, { queue, processor }));
})), globalLogger = null, setGlobalLogger = (logger) => {
  globalLogger = logger;
}, getGlobalLogger = () => {
  if (!globalLogger) {
    throw new Error("Global logger not initialized. Call setGlobalLogger first.");
  }
  return globalLogger;
}, log4, withLoggerContext = (context10) => (effect4) => exports_Effect.flatMap(Logger, (logger) => exports_Effect.provide(effect4, exports_Layer.succeed(Logger, logger.child(context10))));
var init_logger2 = __esm(() => {
  init_esm2();
  init_types5();
  LoggerQueue = exports_Context.GenericTag("tuix/LoggerQueue");
  log4 = {
    trace: (message, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.trace(message, metadata)),
    debug: (message, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.debug(message, metadata)),
    info: (message, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.info(message, metadata)),
    warn: (message, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.warn(message, metadata)),
    error: (message, error2, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.error(message, error2, metadata)),
    fatal: (message, error2, metadata) => exports_Effect.flatMap(Logger, (logger) => logger.fatal(message, error2, metadata))
  };
});

// ../../src/utils/ansi.ts
function stripAnsi(text9) {
  return text9.replace(ANSI_REGEX, "");
}
var ANSI_REGEX;
var init_ansi = __esm(() => {
  init_string_width();
  ANSI_REGEX = /\u001b\[[0-9;]*m/g;
});

// ../../src/logger/formatters.ts
class PrettyFormatter {
  options;
  constructor(options = {}) {
    this.options = options;
    this.options = {
      colorize: true,
      showTimestamp: true,
      showLevel: true,
      showEmoji: false,
      showContext: true,
      showMetadata: true,
      showSource: false,
      timestampFormat: "iso",
      indentSize: 2,
      ...options
    };
  }
  format(entry) {
    const parts2 = [];
    const { colorize } = this.options;
    if (this.options.showTimestamp) {
      const timestamp = this.formatTimestamp(entry.timestamp);
      parts2.push(colorize ? `${DIM}${timestamp}${RESET2}` : timestamp);
    }
    if (this.options.showLevel) {
      const level = entry.level.toUpperCase().padEnd(5);
      const levelColor = colorize ? LEVEL_COLORS[entry.level] : "";
      const emoji = this.options.showEmoji ? LEVEL_EMOJIS[entry.level] + " " : "";
      parts2.push(`${levelColor}${emoji}${level}${colorize ? RESET2 : ""}`);
    }
    if (this.options.showContext && entry.context?.length) {
      const context10 = entry.context.join(".");
      parts2.push(colorize ? `${DIM}[${context10}]${RESET2}` : `[${context10}]`);
    }
    parts2.push(entry.message);
    if (entry.error) {
      parts2.push(`
` + this.formatError(entry.error, colorize));
    }
    if (this.options.showMetadata && entry.metadata && Object.keys(entry.metadata).length > 0) {
      parts2.push(`
` + this.formatMetadata(entry.metadata, colorize));
    }
    if (this.options.showSource && entry.src) {
      const src = `${entry.src.file}:${entry.src.line}${entry.src.func ? ` (${entry.src.func})` : ""}`;
      parts2.push(colorize ? `${DIM}${src}${RESET2}` : src);
    }
    return parts2.join(" ");
  }
  formatTimestamp(date2) {
    const { timestampFormat } = this.options;
    if (typeof timestampFormat === "function") {
      return timestampFormat(date2);
    }
    switch (timestampFormat) {
      case "unix":
        return String(Math.floor(date2.getTime() / 1000));
      case "relative":
        return this.getRelativeTime(date2);
      case "iso":
      default:
        return date2.toISOString();
    }
  }
  getRelativeTime(date2) {
    const now2 = new Date;
    const diff11 = now2.getTime() - date2.getTime();
    if (diff11 < 1000)
      return "now";
    if (diff11 < 60000)
      return `${Math.floor(diff11 / 1000)}s ago`;
    if (diff11 < 3600000)
      return `${Math.floor(diff11 / 60000)}m ago`;
    if (diff11 < 86400000)
      return `${Math.floor(diff11 / 3600000)}h ago`;
    return `${Math.floor(diff11 / 86400000)}d ago`;
  }
  formatError(error2, colorize) {
    const indent = " ".repeat(this.options.indentSize || 2);
    const lines = [];
    lines.push(`${indent}${colorize ? BOLD2 : ""}Error: ${error2.message}${colorize ? RESET2 : ""}`);
    if (error2.stack) {
      const stackLines = error2.stack.split(`
`).slice(1);
      stackLines.forEach((line) => {
        if (colorize) {
          line = line.replace(/\(([^)]+)\)/, `(${DIM}$1${RESET2})`);
          line = line.replace(/at (\S+)/, `at ${ITALIC2}$1${RESET2}`);
        }
        lines.push(indent + line.trim());
      });
    }
    return lines.join(`
`);
  }
  formatMetadata(metadata, colorize) {
    return this.formatJSON(metadata, colorize, 1);
  }
  formatJSON(obj, colorize, depth = 0) {
    const indent = " ".repeat((this.options.indentSize || 2) * depth);
    const nextIndent = " ".repeat((this.options.indentSize || 2) * (depth + 1));
    if (obj === null)
      return colorize ? `${DIM}null${RESET2}` : "null";
    if (obj === undefined)
      return colorize ? `${DIM}undefined${RESET2}` : "undefined";
    const type2 = typeof obj;
    if (type2 === "string") {
      return colorize ? `${LEVEL_COLORS.info}"${obj}"${RESET2}` : `"${obj}"`;
    }
    if (type2 === "number") {
      return colorize ? `${LEVEL_COLORS.warn}${obj}${RESET2}` : String(obj);
    }
    if (type2 === "boolean") {
      return colorize ? `${LEVEL_COLORS.debug}${obj}${RESET2}` : String(obj);
    }
    if (obj instanceof Date) {
      return colorize ? `${LEVEL_COLORS.trace}${obj.toISOString()}${RESET2}` : obj.toISOString();
    }
    if (Array.isArray(obj)) {
      if (obj.length === 0)
        return "[]";
      const items = obj.map((item) => nextIndent + this.formatJSON(item, colorize, depth + 1)).join(`,
`);
      return `[
${items}
${indent}]`;
    }
    if (type2 === "object") {
      const keys9 = Object.keys(obj);
      if (keys9.length === 0)
        return "{}";
      const items = keys9.map((key) => {
        const formattedKey = colorize ? `${BOLD2}${key}${RESET2}` : key;
        const value6 = this.formatJSON(obj[key], colorize, depth + 1);
        return `${nextIndent}${formattedKey}: ${value6}`;
      }).join(`,
`);
      return `{
${items}
${indent}}`;
    }
    return String(obj);
  }
}

class JSONFormatter {
  options;
  constructor(options = {}) {
    this.options = options;
  }
  format(entry) {
    const obj = {
      timestamp: entry.timestamp.toISOString(),
      level: entry.level,
      message: entry.message,
      ...entry.name && { name: entry.name },
      ...entry.hostname && { hostname: entry.hostname },
      ...entry.pid && { pid: entry.pid },
      ...entry.v !== undefined && { v: entry.v },
      ...entry.context?.length && { context: entry.context },
      ...entry.error && {
        error: {
          message: entry.error.message,
          name: entry.error.name,
          stack: entry.error.stack
        }
      },
      ...entry.span && { span: entry.span },
      ...entry.src && { src: entry.src },
      ...entry.metadata && { ...entry.metadata }
    };
    if (this.options.pretty) {
      return JSON.stringify(obj, null, this.options.indent || 2);
    }
    return JSON.stringify(obj);
  }
}

class CompactFormatter {
  format(entry) {
    const parts2 = [];
    parts2.push(entry.timestamp.toISOString().replace("T", " ").slice(0, -5));
    parts2.push(entry.level.toUpperCase());
    if (entry.context?.length) {
      parts2.push(`[${entry.context.join(".")}]`);
    }
    parts2.push(entry.message);
    if (entry.error) {
      parts2.push(`ERROR: ${entry.error.message}`);
    }
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      const metaStr = Object.entries(entry.metadata).map(([k, v]) => `${k}=${JSON.stringify(v)}`).join(" ");
      parts2.push(metaStr);
    }
    return parts2.join(" | ");
  }
}

class CLIFormatter {
  options;
  constructor(options = {}) {
    this.options = options;
    this.options = {
      colorize: true,
      maxWidth: process.stdout.columns || 80,
      ...options
    };
  }
  format(entry) {
    const { colorize, maxWidth = 80 } = this.options;
    const levelColor = colorize ? LEVEL_COLORS[entry.level] : "";
    const emoji = LEVEL_EMOJIS[entry.level];
    const prefix = `${emoji} ${levelColor}${entry.level.toUpperCase()}${colorize ? RESET2 : ""}`;
    const prefixLength = stripAnsi(prefix).length + 1;
    const messageWidth = maxWidth - prefixLength;
    const wrappedMessage = this.wrapText(entry.message, messageWidth);
    const firstLine = wrappedMessage[0] || "";
    const restLines = wrappedMessage.slice(1).map((line) => " ".repeat(prefixLength) + line).join(`
`);
    let output = `${prefix} ${firstLine}`;
    if (restLines) {
      output += `
` + restLines;
    }
    if (entry.metadata && Object.keys(entry.metadata).length > 0) {
      const metaLine = this.formatMetadataLine(entry.metadata, colorize);
      output += `
` + " ".repeat(prefixLength) + metaLine;
    }
    return output;
  }
  wrapText(text9, width) {
    if (text9.length <= width)
      return [text9];
    const lines = [];
    const words = text9.split(" ");
    let currentLine = "";
    for (const word of words) {
      if (currentLine.length + word.length + 1 <= width) {
        currentLine += (currentLine ? " " : "") + word;
      } else {
        if (currentLine)
          lines.push(currentLine);
        currentLine = word;
      }
    }
    if (currentLine)
      lines.push(currentLine);
    return lines;
  }
  formatMetadataLine(metadata, colorize) {
    const items = Object.entries(metadata).map(([key, value6]) => {
      const formattedValue = typeof value6 === "string" ? value6 : JSON.stringify(value6);
      return colorize ? `${DIM}${key}=${RESET2}${formattedValue}` : `${key}=${formattedValue}`;
    });
    return items.join(" ");
  }
}
var LEVEL_COLORS, LEVEL_EMOJIS, RESET2 = "\x1B[0m", BOLD2 = "\x1B[1m", DIM = "\x1B[2m", ITALIC2 = "\x1B[3m";
var init_formatters = __esm(() => {
  init_ansi();
  LEVEL_COLORS = {
    trace: "\x1B[90m",
    debug: "\x1B[36m",
    info: "\x1B[32m",
    warn: "\x1B[33m",
    error: "\x1B[31m",
    fatal: "\x1B[35m"
  };
  LEVEL_EMOJIS = {
    trace: "\uD83D\uDD0D",
    debug: "\uD83D\uDC1B",
    info: "\u2139\uFE0F ",
    warn: "\u26A0\uFE0F ",
    error: "\u274C",
    fatal: "\uD83D\uDC80"
  };
});

// ../../src/logger/transports.ts
import * as fs4 from "fs";
import * as path7 from "path";
import * as zlib from "zlib";
import { promisify } from "util";

class ConsoleTransport {
  options;
  formatter;
  level;
  constructor(options = {}) {
    this.options = options;
    this.formatter = options.format || new PrettyFormatter({
      colorize: options.colorize !== false,
      showTimestamp: options.timestamp !== false,
      showLevel: options.showLevel !== false,
      showMetadata: options.showMetadata !== false,
      showEmoji: true
    });
    this.level = options.level ? LogLevels[options.level] : LogLevels.trace;
  }
  write(entry) {
    return exports_Effect.sync(() => {
      if (LogLevels[entry.level] < this.level)
        return;
      const formatted = this.formatter.format(entry);
      if (entry.level === "error" || entry.level === "fatal") {
        console.error(formatted);
      } else {
        console.log(formatted);
      }
    });
  }
}

class FileTransport {
  options;
  formatter;
  level;
  stream;
  currentSize = 0;
  fileIndex = 0;
  constructor(options) {
    this.options = options;
    this.formatter = options.format || new JSONFormatter;
    this.level = options.level ? LogLevels[options.level] : LogLevels.trace;
    this.initStream();
  }
  initStream() {
    const filename = this.getFilename();
    this.stream = fs4.createWriteStream(filename, {
      flags: this.options.options?.flags || "a",
      encoding: this.options.options?.encoding || "utf8",
      mode: this.options.options?.mode
    });
    try {
      const stats = fs4.statSync(filename);
      this.currentSize = stats.size;
    } catch {
      this.currentSize = 0;
    }
  }
  getFilename() {
    if (this.fileIndex === 0) {
      return this.options.filename;
    }
    const parsed = path7.parse(this.options.filename);
    return path7.join(parsed.dir, `${parsed.name}.${this.fileIndex}${parsed.ext}`);
  }
  async rotateLog() {
    if (!this.stream)
      return;
    this.stream.end();
    if (this.options.zippedArchive) {
      const oldFilename = this.getFilename();
      const compressed = await gzip2(fs4.readFileSync(oldFilename));
      fs4.writeFileSync(`${oldFilename}.gz`, compressed);
      fs4.unlinkSync(oldFilename);
    }
    this.fileIndex++;
    if (this.options.maxFiles && this.fileIndex > this.options.maxFiles) {
      const oldestFile = path7.join(path7.dirname(this.options.filename), `${path7.basename(this.options.filename)}.${this.fileIndex - this.options.maxFiles}`);
      try {
        fs4.unlinkSync(oldestFile);
        fs4.unlinkSync(`${oldestFile}.gz`);
      } catch {}
    }
    this.currentSize = 0;
    this.initStream();
  }
  write(entry) {
    return exports_Effect.async((callback) => {
      if (LogLevels[entry.level] < this.level) {
        callback(exports_Effect.succeed(undefined));
        return;
      }
      const formatted = this.formatter.format(entry) + `
`;
      const size23 = Buffer.byteLength(formatted);
      if (this.options.maxSize) {
        const maxSize = typeof this.options.maxSize === "string" ? this.parseSize(this.options.maxSize) : this.options.maxSize;
        if (this.currentSize + size23 > maxSize) {
          this.rotateLog().then(() => {
            this.writeToStream(formatted, size23, callback);
          });
          return;
        }
      }
      this.writeToStream(formatted, size23, callback);
    });
  }
  writeToStream(formatted, size23, callback) {
    if (!this.stream) {
      callback(exports_Effect.fail(new Error("Stream not initialized")));
      return;
    }
    this.stream.write(formatted, (err) => {
      if (err) {
        callback(exports_Effect.fail(err));
      } else {
        this.currentSize += size23;
        callback(exports_Effect.succeed(undefined));
      }
    });
  }
  parseSize(size23) {
    const units = {
      b: 1,
      k: 1024,
      kb: 1024,
      m: 1024 * 1024,
      mb: 1024 * 1024,
      g: 1024 * 1024 * 1024,
      gb: 1024 * 1024 * 1024
    };
    const match26 = size23.toLowerCase().match(/^(\d+)([a-z]+)?$/);
    if (!match26)
      throw new Error(`Invalid size format: ${size23}`);
    const value6 = parseInt(match26[1]);
    const unit = match26[2] || "b";
    return value6 * (units[unit] || 1);
  }
  close() {
    return exports_Effect.sync(() => {
      if (this.stream) {
        this.stream.end();
        this.stream = undefined;
      }
    });
  }
}

class StreamTransport {
  options;
  formatter;
  level;
  constructor(options) {
    this.options = options;
    this.formatter = options.format || new JSONFormatter;
    this.level = options.level ? LogLevels[options.level] : LogLevels.trace;
  }
  write(entry) {
    return exports_Effect.async((callback) => {
      if (LogLevels[entry.level] < this.level) {
        callback(exports_Effect.succeed(undefined));
        return;
      }
      const formatted = this.formatter.format(entry) + `
`;
      this.options.stream.write(formatted, (err) => {
        if (err) {
          callback(exports_Effect.fail(err));
        } else {
          callback(exports_Effect.succeed(undefined));
        }
      });
    });
  }
}

class HttpTransport {
  options;
  formatter;
  level;
  queue = null;
  batchProcessor = null;
  constructor(options) {
    this.options = options;
    this.formatter = options.format || new JSONFormatter;
    this.level = options.level ? LogLevels[options.level] : LogLevels.trace;
    if (options.batch) {
      this.initBatchProcessor();
    }
  }
  initBatchProcessor() {
    const self = this;
    exports_Effect.gen(function* (_) {
      const queue = yield* _(exports_Queue.unbounded());
      self.queue = queue;
      const batchSize = self.options.batchSize || 100;
      const batchInterval = self.options.batchInterval || 5000;
      self.batchProcessor = yield* _(exports_Stream.fromQueue(queue).pipe(exports_Stream.groupedWithin(batchSize, exports_Schedule.fixed(batchInterval)), exports_Stream.tap((chunk4) => self.sendBatch(exports_Chunk.toArray(chunk4))), exports_Stream.runDrain, exports_Effect.fork));
    }).pipe(exports_Effect.runPromise);
  }
  write(entry) {
    if (LogLevels[entry.level] < this.level) {
      return exports_Effect.void;
    }
    if (this.options.batch && this.queue) {
      return exports_Queue.offer(this.queue, entry);
    } else {
      return this.send([entry]);
    }
  }
  send(entries4) {
    return exports_Effect.tryPromise({
      try: async () => {
        const body = entries4.map((e) => this.formatter.format(e)).join(`
`);
        const response = await fetch(this.options.url, {
          method: this.options.method || "POST",
          headers: {
            "Content-Type": "application/json",
            ...this.options.headers
          },
          body
        });
        if (!response.ok) {
          throw new Error(`HTTP transport failed: ${response.status} ${response.statusText}`);
        }
      },
      catch: (error2) => new Error(`HTTP transport error: ${error2}`)
    }).pipe(exports_Effect.asVoid);
  }
  sendBatch(entries4) {
    if (entries4.length === 0)
      return exports_Effect.void;
    return this.send(entries4);
  }
  close() {
    if (this.batchProcessor) {
      return exports_Fiber.interrupt(this.batchProcessor);
    }
    return exports_Effect.void;
  }
}

class TUITransport {
  entries = [];
  updateCallback;
  onUpdate(callback) {
    this.updateCallback = callback;
  }
  write(entry) {
    return exports_Effect.sync(() => {
      const interactiveEntry = {
        ...entry,
        id: `${Date.now()}-${Math.random()}`,
        expanded: false
      };
      this.entries.push(interactiveEntry);
      if (this.entries.length > 1e4) {
        this.entries = this.entries.slice(-1e4);
      }
      if (this.updateCallback) {
        this.updateCallback([...this.entries]);
      }
    });
  }
  getEntries() {
    return [...this.entries];
  }
  clear() {
    this.entries = [];
    if (this.updateCallback) {
      this.updateCallback([]);
    }
  }
}
var gzip2, gunzip2;
var init_transports = __esm(() => {
  init_esm2();
  init_types5();
  init_formatters();
  gzip2 = promisify(zlib.gzip);
  gunzip2 = promisify(zlib.gunzip);
});

// ../../src/logger/components/LogExplorer.ts
function formatTimestamp(date2) {
  return date2.toLocaleTimeString() + "." + date2.getMilliseconds().toString().padStart(3, "0");
}
function LogExplorer({
  entries: entries4,
  maxEntries = 1000,
  showSearch = true,
  showFilters = true,
  theme = "dark"
}) {
  const expandedIds = new Set;
  const searchTerm = "";
  const levelFilter = "all";
  const filteredEntries = entries4.filter((entry) => {
    if (levelFilter !== "all" && entry.level !== levelFilter) {
      return false;
    }
    if (searchTerm && !entry.message.toLowerCase().includes(searchTerm.toLowerCase())) {
      return false;
    }
    return true;
  }).slice(-maxEntries).map((entry) => ({
    ...entry,
    expanded: expandedIds.has(entry.id)
  }));
  const header = hstack(styledText("\uD83D\uDD0D Log Explorer", style().bold().foreground(Colors.blue)), text("  "), styledText(`(${filteredEntries.length} entries)`, style().foreground(Colors.gray)));
  const logRows = filteredEntries.map((entry) => {
    const levelColor = LEVEL_COLORS2[entry.level];
    const levelIcon = LEVEL_ICONS[entry.level];
    const timestamp = formatTimestamp(entry.timestamp);
    return hstack(styledText(timestamp, style().foreground(Colors.gray)), text("  "), styledText(`${levelIcon} ${entry.level.toUpperCase()}`, style().foreground(Colors[levelColor] || Colors.white)), text("  "), entry.context?.length > 0 ? styledText(`[${entry.context.join(".")}]`, style().foreground(Colors.blue)) : text(""), text("  "), text(entry.message));
  });
  const controls = hstack(styledText("\u2191\u2193 Navigate", style().foreground(Colors.gray)), styledText("  Enter Expand/Collapse", style().foreground(Colors.gray)), styledText("  / Search", style().foreground(Colors.gray)), styledText("  q Quit", style().foreground(Colors.gray)));
  return vstack(header, text(""), styledText("\u2500".repeat(80), style().foreground(Colors.gray)), ...logRows, text(""), controls);
}
var LEVEL_COLORS2, LEVEL_ICONS;
var init_LogExplorer = __esm(() => {
  init_view();
  init_styling();
  LEVEL_COLORS2 = {
    trace: "gray",
    debug: "cyan",
    info: "green",
    warn: "yellow",
    error: "red",
    fatal: "magenta"
  };
  LEVEL_ICONS = {
    trace: "\uD83D\uDD0D",
    debug: "\uD83D\uDC1B",
    info: "\u2139\uFE0F ",
    warn: "\u26A0\uFE0F ",
    error: "\u274C",
    fatal: "\uD83D\uDC80"
  };
});

// ../../src/logger/components/LogComponents.ts
function LogLevelText({
  level,
  showEmoji = false,
  uppercase = true
}) {
  const color = LEVEL_COLORS3[level];
  const emoji = showEmoji ? LEVEL_EMOJIS2[level] + " " : "";
  const levelText = uppercase ? level.toUpperCase() : level;
  return styledText(`${emoji}${levelText}`, style().foreground(Colors[color]));
}
function LogMessage({
  level,
  message,
  timestamp,
  context: context10,
  showTimestamp = true,
  showContext = true,
  showEmoji = false
}) {
  const parts2 = [];
  if (showTimestamp && timestamp) {
    parts2.push(styledText(timestamp.toISOString(), style().foreground(Colors.gray)));
  }
  parts2.push(LogLevelText({ level, showEmoji }));
  if (showContext && context10 && context10.length > 0) {
    parts2.push(styledText(`[${context10.join(".")}]`, style().foreground(Colors.blue)));
  }
  parts2.push(text(message));
  return hstack(...parts2.map((part, i) => i === 0 ? part : hstack(text(" "), part)));
}
function LogError({
  error: error2,
  showStack = true,
  indent = 2
}) {
  const indentStr = " ".repeat(indent);
  const parts2 = [
    styledText(`${indentStr}Error: ${error2.message}`, style().foreground(Colors.red).bold())
  ];
  if (showStack && error2.stack) {
    const stackLines = error2.stack.split(`
`).slice(1);
    stackLines.forEach((line) => {
      parts2.push(styledText(indentStr + line.trim(), style().foreground(Colors.gray)));
    });
  }
  return vstack(...parts2);
}
function LogMetadata({
  metadata,
  indent = 2,
  compact: compact5 = false
}) {
  if (compact5) {
    const items = Object.entries(metadata).map(([key, value6]) => `${key}=${JSON.stringify(value6)}`).join(" ");
    return styledText(items, style().foreground(Colors.gray));
  }
  return vstack(...Object.entries(metadata).map(([key, value6]) => hstack(styledText(" ".repeat(indent) + key + ":", style().foreground(Colors.blue).bold()), text(" "), text(formatValue(value6)))));
}
function PrettyLogEntry({
  level,
  message,
  timestamp = new Date,
  context: context10,
  error: error2,
  metadata,
  showEmoji = true,
  showTimestamp = true,
  showContext = true,
  showMetadata = true
}) {
  const parts2 = [
    LogMessage({
      level,
      message,
      timestamp,
      context: context10,
      showTimestamp,
      showContext,
      showEmoji
    })
  ];
  if (error2) {
    parts2.push(LogError({ error: error2 }));
  }
  if (showMetadata && metadata && Object.keys(metadata).length > 0) {
    parts2.push(LogMetadata({ metadata }));
  }
  return vstack(...parts2);
}
function formatValue(value6) {
  if (value6 === null)
    return "null";
  if (value6 === undefined)
    return "undefined";
  if (typeof value6 === "string")
    return value6;
  if (typeof value6 === "number")
    return String(value6);
  if (typeof value6 === "boolean")
    return String(value6);
  if (value6 instanceof Date)
    return value6.toISOString();
  return JSON.stringify(value6, null, 2);
}
var LEVEL_COLORS3, LEVEL_EMOJIS2, LEVEL_ANSI, ANSI2, logUtils;
var init_LogComponents = __esm(() => {
  init_view();
  init_styling();
  LEVEL_COLORS3 = {
    trace: "gray",
    debug: "cyan",
    info: "green",
    warn: "yellow",
    error: "red",
    fatal: "magenta"
  };
  LEVEL_EMOJIS2 = {
    trace: "\uD83D\uDD0D",
    debug: "\uD83D\uDC1B",
    info: "\u2139\uFE0F ",
    warn: "\u26A0\uFE0F ",
    error: "\u274C",
    fatal: "\uD83D\uDC80"
  };
  LEVEL_ANSI = {
    trace: "\x1B[90m",
    debug: "\x1B[36m",
    info: "\x1B[32m",
    warn: "\x1B[33m",
    error: "\x1B[31m",
    fatal: "\x1B[35m"
  };
  ANSI2 = {
    reset: "\x1B[0m",
    bold: "\x1B[1m",
    dim: "\x1B[2m",
    italic: "\x1B[3m",
    underline: "\x1B[4m"
  };
  logUtils = {
    colorize(text9, level) {
      return `${LEVEL_ANSI[level]}${text9}${ANSI2.reset}`;
    },
    withEmoji(text9, level) {
      return `${LEVEL_EMOJIS2[level]} ${text9}`;
    },
    formatLogLine(level, message, options) {
      const parts2 = [];
      if (options?.timestamp) {
        parts2.push(`${ANSI2.dim}${options.timestamp.toISOString()}${ANSI2.reset}`);
      }
      if (options?.showLevel !== false) {
        const levelText = level.toUpperCase().padEnd(5);
        const emoji = options?.showEmoji ? LEVEL_EMOJIS2[level] + " " : "";
        parts2.push(`${LEVEL_ANSI[level]}${emoji}${levelText}${ANSI2.reset}`);
      }
      if (options?.context && options.context.length > 0) {
        parts2.push(`${ANSI2.dim}[${options.context.join(".")}]${ANSI2.reset}`);
      }
      parts2.push(message);
      return parts2.join(" ");
    },
    trace: (message) => console.log(logUtils.formatLogLine("trace", message, { showEmoji: true })),
    debug: (message) => console.log(logUtils.formatLogLine("debug", message, { showEmoji: true })),
    info: (message) => console.log(logUtils.formatLogLine("info", message, { showEmoji: true })),
    warn: (message) => console.log(logUtils.formatLogLine("warn", message, { showEmoji: true })),
    error: (message) => console.log(logUtils.formatLogLine("error", message, { showEmoji: true })),
    fatal: (message) => console.log(logUtils.formatLogLine("fatal", message, { showEmoji: true }))
  };
});

// ../../src/logger/presets.ts
function applyPreset(logs, presetName) {
  const preset = LOG_PRESETS[presetName];
  if (!preset) {
    throw new Error(`Unknown preset: ${presetName}`);
  }
  return logs.filter((log5) => matchesFilter(log5, preset));
}
function matchesFilter(log5, filter18) {
  if (filter18.level) {
    const levels = Array.isArray(filter18.level) ? filter18.level : [filter18.level];
    if (!levels.includes(log5.level)) {
      return false;
    }
  }
  if (filter18.source && log5.source !== filter18.source) {
    return false;
  }
  if (filter18.pattern) {
    const pattern2 = filter18.pattern instanceof RegExp ? filter18.pattern : new RegExp(filter18.pattern, "i");
    if (!pattern2.test(log5.message)) {
      return false;
    }
  }
  if (filter18.processPattern && log5.processName) {
    const pattern2 = filter18.processPattern instanceof RegExp ? filter18.processPattern : new RegExp(filter18.processPattern, "i");
    if (!pattern2.test(log5.processName)) {
      return false;
    }
  }
  if (filter18.timeRange) {
    const logTime = log5.timestamp.getTime();
    if (filter18.timeRange.since) {
      const since = filter18.timeRange.since instanceof Date ? filter18.timeRange.since : new Date(filter18.timeRange.since);
      if (logTime < since.getTime()) {
        return false;
      }
    }
    if (filter18.timeRange.until) {
      const until = filter18.timeRange.until instanceof Date ? filter18.timeRange.until : new Date(filter18.timeRange.until);
      if (logTime > until.getTime()) {
        return false;
      }
    }
  }
  if (filter18.custom && !filter18.custom(log5)) {
    return false;
  }
  return true;
}
function getAvailablePresets() {
  return Object.entries(LOG_PRESETS).map(([key, preset]) => ({
    name: key,
    description: preset.description
  }));
}
function createFilter(options) {
  return {
    name: "Custom Filter",
    description: "User-defined filter",
    level: options.level,
    pattern: options.search ? new RegExp(options.search, "i") : undefined,
    processPattern: options.process ? new RegExp(options.process, "i") : undefined,
    timeRange: {
      since: options.since,
      until: options.until
    }
  };
}
var LOG_PRESETS, quickFilters;
var init_presets = __esm(() => {
  LOG_PRESETS = {
    errors: {
      name: "Errors Only",
      description: "Show only error and fatal log entries",
      level: ["error", "fatal"]
    },
    warnings: {
      name: "Warnings & Errors",
      description: "Show warnings, errors, and fatal entries",
      level: ["warn", "error", "fatal"]
    },
    debug: {
      name: "Debug Mode",
      description: "Show debug and above (no trace)",
      level: ["debug", "info", "warn", "error", "fatal"]
    },
    verbose: {
      name: "Verbose",
      description: "Show all log levels including trace",
      level: ["trace", "debug", "info", "warn", "error", "fatal"]
    },
    vite: {
      name: "Vite Development",
      description: "Filter Vite dev server logs",
      pattern: /\[(vite|hmr|dev|build)\]/i,
      custom: (log5) => {
        if (log5.message.includes("Local:") && log5.message.includes("http://"))
          return false;
        if (log5.message.includes("ready in"))
          return true;
        if (log5.message.includes("hmr update"))
          return true;
        if (log5.message.includes("error") || log5.level === "error")
          return true;
        return log5.level !== "debug";
      }
    },
    vitest: {
      name: "Vitest Testing",
      description: "Filter test execution logs",
      pattern: /\[(test|vitest|spec)\]/i,
      custom: (log5) => {
        if (log5.message.includes("PASS") || log5.message.includes("FAIL"))
          return true;
        if (log5.message.includes("\u2713") || log5.message.includes("\xD7"))
          return true;
        if (log5.level === "error" || log5.level === "warn")
          return true;
        return !log5.message.includes("stdout |");
      }
    },
    typescript: {
      name: "TypeScript Compiler",
      description: "TypeScript compilation logs",
      pattern: /\[(tsc|typescript|ts)\]/i,
      custom: (log5) => {
        if (log5.message.includes("error TS"))
          return true;
        if (log5.message.includes("Found 0 errors"))
          return true;
        if (log5.message.includes("Watching for file changes"))
          return false;
        return log5.level !== "debug";
      }
    },
    eslint: {
      name: "ESLint",
      description: "Linting and code quality logs",
      pattern: /\[(eslint|lint)\]/i,
      custom: (log5) => {
        if (log5.message.includes("\u2716") || log5.message.includes("error"))
          return true;
        if (log5.message.includes("warning"))
          return true;
        if (log5.message.includes("\u2714") && log5.message.includes("problems"))
          return true;
        return false;
      }
    },
    production: {
      name: "Production",
      description: "Production-safe log levels",
      level: ["info", "warn", "error", "fatal"],
      custom: (log5) => {
        if (log5.message.includes("[DEV]") || log5.message.includes("[DEBUG]"))
          return false;
        if (log5.message.includes("Hot reload") || log5.message.includes("hmr"))
          return false;
        return true;
      }
    },
    recent: {
      name: "Recent (Last 5min)",
      description: "Logs from the last 5 minutes",
      timeRange: {
        since: new Date(Date.now() - 5 * 60 * 1000)
      }
    },
    today: {
      name: "Today",
      description: "Logs from today",
      timeRange: {
        since: new Date(new Date().setHours(0, 0, 0, 0))
      }
    },
    performance: {
      name: "Performance",
      description: "Performance-related logs",
      pattern: /\b(slow|performance|time|duration|ms|seconds?|latency|memory|cpu)\b/i
    },
    database: {
      name: "Database",
      description: "Database-related logs",
      pattern: /\b(sql|query|database|db|postgres|mysql|mongodb|redis)\b/i
    },
    network: {
      name: "Network",
      description: "Network and HTTP-related logs",
      pattern: /\b(http|request|response|api|fetch|curl|network|tcp|udp|websocket)\b/i
    },
    security: {
      name: "Security",
      description: "Security-related logs",
      pattern: /\b(auth|login|logout|token|jwt|oauth|security|attack|blocked|unauthorized|forbidden)\b/i,
      level: ["warn", "error", "fatal"]
    },
    startup: {
      name: "Startup",
      description: "Application startup logs",
      pattern: /\b(start|startup|init|launch|boot|ready|listening|server)\b/i,
      timeRange: {
        since: new Date(Date.now() - 2 * 60 * 1000)
      }
    },
    crashes: {
      name: "Crashes",
      description: "Application crashes and fatal errors",
      level: ["fatal"],
      pattern: /\b(crash|fatal|exit|killed|segfault|panic|abort)\b/i
    }
  };
  quickFilters = {
    errors: (logs) => applyPreset(logs, "errors"),
    warnings: (logs) => applyPreset(logs, "warnings"),
    debug: (logs) => applyPreset(logs, "debug"),
    recent: (logs) => applyPreset(logs, "recent"),
    production: (logs) => applyPreset(logs, "production"),
    vite: (logs) => applyPreset(logs, "vite"),
    vitest: (logs) => applyPreset(logs, "vitest")
  };
});

// ../../src/logger/components/LiveLogDashboard.ts
function LiveLogDashboard({
  processes,
  maxLines = 100,
  refreshInterval = 1000,
  showProcessStats = true,
  filter: filter18,
  searchTerm = "",
  selectedPreset = "",
  theme = "dark"
}) {
  const allLogs = [];
  processes.forEach((process2) => {
    process2.logs.forEach((log5) => {
      allLogs.push({ ...log5, processName: process2.name });
    });
  });
  allLogs.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
  let filteredLogs = allLogs;
  if (selectedPreset && LOG_PRESETS[selectedPreset]) {
    filteredLogs = filteredLogs.filter((log5) => matchesFilter(log5, LOG_PRESETS[selectedPreset]));
  }
  if (filter18) {
    filteredLogs = filteredLogs.filter((log5) => matchesFilter(log5, filter18));
  }
  if (searchTerm) {
    const searchRegex = new RegExp(searchTerm, "i");
    filteredLogs = filteredLogs.filter((log5) => searchRegex.test(log5.message) || searchRegex.test(log5.processName) || searchRegex.test(log5.level));
  }
  const displayLogs = filteredLogs.slice(-maxLines);
  const header = createHeader(allLogs.length, displayLogs.length, selectedPreset, searchTerm);
  const filterControls = createFilterControls(selectedPreset, searchTerm);
  const processStats = showProcessStats ? createProcessStats(processes) : [];
  const logEntries = displayLogs.map((log5, i) => createLogEntry(log5, i, theme));
  const footerControls = createFooterControls();
  return vstack(header, text(""), filterControls, text(""), ...processStats, styledText("\u2500".repeat(120), style().foreground(Colors.gray)), ...logEntries, text(""), footerControls);
}
function createHeader(totalLogs, filteredLogs, preset, search) {
  const filterInfo = [];
  if (preset)
    filterInfo.push(`preset: ${preset}`);
  if (search)
    filterInfo.push(`search: "${search}"`);
  const filterText = filterInfo.length > 0 ? ` (${filterInfo.join(", ")})` : "";
  return hstack(styledText("\uD83D\uDCCA Live Log Dashboard", style().bold().foreground(Colors.blue)), text("  "), styledText(`${filteredLogs}/${totalLogs} logs${filterText}`, style().foreground(Colors.gray)), text("  "), styledText(`Updated: ${new Date().toLocaleTimeString()}`, style().foreground(Colors.cyan)));
}
function createFilterControls(preset, search) {
  const presetList = Object.keys(LOG_PRESETS).slice(0, 8).join(", ");
  return vstack(hstack(styledText("\uD83D\uDD0D Filters: ", style().foreground(Colors.yellow)), text(`Preset: ${preset || "none"} | Search: ${search || "none"}`)), hstack(styledText("Presets: ", style().foreground(Colors.gray)), text(presetList + "...")));
}
function createProcessStats(processes) {
  const stats = processes.map((process2) => {
    const recentLogs = process2.logs.filter((log5) => Date.now() - log5.timestamp.getTime() < 60000);
    const errorCount = recentLogs.filter((log5) => log5.level === "error").length;
    const warnCount = recentLogs.filter((log5) => log5.level === "warn").length;
    const statusColor = process2.status === "running" ? Colors.green : process2.status === "error" ? Colors.red : Colors.gray;
    return hstack(styledText("\u25CF", style().foreground(statusColor)), text(" "), styledText(process2.name.padEnd(15), style().bold()), text(`\uD83D\uDCC4 ${process2.logs.length.toString().padStart(4)} logs`), text("  "), errorCount > 0 ? styledText(`\u274C ${errorCount}`, style().foreground(Colors.red)) : text(""), text("  "), warnCount > 0 ? styledText(`\u26A0\uFE0F ${warnCount}`, style().foreground(Colors.yellow)) : text(""));
  });
  return [
    styledText("Process Status:", style().foreground(Colors.cyan).bold()),
    ...stats,
    text("")
  ];
}
function createLogEntry(log5, index, theme) {
  const timestamp = log5.timestamp.toLocaleTimeString() + "." + log5.timestamp.getMilliseconds().toString().padStart(3, "0");
  const levelColor = LEVEL_COLORS3[log5.level];
  const levelEmoji = LEVEL_EMOJIS2[log5.level];
  const levelText = log5.level.toUpperCase().padEnd(5);
  const maxMessageLength = 80;
  const message = log5.message.length > maxMessageLength ? log5.message.substring(0, maxMessageLength) + "..." : log5.message;
  const processName = log5.processName.padEnd(12).substring(0, 12);
  return hstack(styledText(timestamp, style().foreground(Colors.gray)), text(" "), styledText(`[${processName}]`, style().foreground(Colors.blue)), text(" "), styledText(`${levelEmoji} ${levelText}`, style().foreground(Colors[levelColor] || Colors.white)), text(" "), text(message));
}
function createFooterControls() {
  return vstack(styledText("\u2500".repeat(120), style().foreground(Colors.gray)), hstack(styledText("Controls: ", style().foreground(Colors.yellow).bold()), styledText("/search", style().foreground(Colors.green)), text(" | "), styledText("p presets", style().foreground(Colors.green)), text(" | "), styledText("c clear", style().foreground(Colors.green)), text(" | "), styledText("f filter", style().foreground(Colors.green)), text(" | "), styledText("\u2191\u2193 scroll", style().foreground(Colors.green)), text(" | "), styledText("q quit", style().foreground(Colors.red))), hstack(styledText("Quick presets: ", style().foreground(Colors.gray)), styledText("1", style().foreground(Colors.cyan)), text(":errors "), styledText("2", style().foreground(Colors.cyan)), text(":warnings "), styledText("3", style().foreground(Colors.cyan)), text(":debug "), styledText("4", style().foreground(Colors.cyan)), text(":vite "), styledText("5", style().foreground(Colors.cyan)), text(":vitest "), styledText("6", style().foreground(Colors.cyan)), text(":production ")));
}
function ProcessLogView({
  processName,
  logs,
  maxLines = 50,
  filter: filter18,
  searchTerm = "",
  showTimestamp = true,
  followMode = false
}) {
  let filteredLogs = logs.map((log5) => ({ ...log5, processName }));
  if (filter18) {
    filteredLogs = filteredLogs.filter((log5) => matchesFilter(log5, filter18));
  }
  if (searchTerm) {
    const searchRegex = new RegExp(searchTerm, "i");
    filteredLogs = filteredLogs.filter((log5) => searchRegex.test(log5.message));
  }
  const displayLogs = followMode ? filteredLogs.slice(-maxLines) : filteredLogs.slice(0, maxLines);
  const header = hstack(styledText(`\uD83D\uDCDD Logs: ${processName}`, style().bold().foreground(Colors.blue)), text("  "), styledText(`(${displayLogs.length}/${logs.length})`, style().foreground(Colors.gray)), searchTerm ? hstack(text("  "), styledText(`search: "${searchTerm}"`, style().foreground(Colors.yellow))) : text(""));
  const logEntries = displayLogs.map((log5, i) => {
    const timestamp = showTimestamp ? `${log5.timestamp.toLocaleTimeString()} ` : "";
    const levelColor = LEVEL_COLORS3[log5.level];
    const levelEmoji = LEVEL_EMOJIS2[log5.level];
    return hstack(showTimestamp ? styledText(timestamp, style().foreground(Colors.gray)) : text(""), styledText(`${levelEmoji} ${log5.level.toUpperCase().padEnd(5)}`, style().foreground(Colors[levelColor] || Colors.white)), text(" "), text(log5.message));
  });
  return vstack(header, text(""), ...logEntries, text(""), styledText(followMode ? "Following logs... (q to quit)" : "End of logs", style().foreground(Colors.gray)));
}
var init_LiveLogDashboard = __esm(() => {
  init_view();
  init_styling();
  init_LogComponents();
  init_presets();
});

// ../../src/logger/index.ts
var createConsoleLogger = (level = "info", options) => {
  const config4 = {
    level,
    transports: [
      new ConsoleTransport({
        colorize: options?.colorize !== false,
        prettyPrint: options?.prettyPrint !== false,
        showLevel: true,
        showMetadata: true,
        format: new PrettyFormatter({
          colorize: options?.colorize !== false,
          showEmoji: options?.showEmoji ?? true
        })
      })
    ]
  };
  return new TuixLogger(config4);
}, createProductionLogger = (name, options) => {
  const level = options?.level || "info";
  const logDir = options?.logDir || "./logs";
  const transports2 = [];
  transports2.push(new FileTransport({
    filename: `${logDir}/${name}.log`,
    level,
    maxSize: options?.maxFileSize || "100mb",
    maxFiles: options?.maxFiles || 10,
    zippedArchive: true,
    format: new JSONFormatter
  }));
  transports2.push(new FileTransport({
    filename: `${logDir}/${name}-error.log`,
    level: "error",
    maxSize: options?.maxFileSize || "100mb",
    maxFiles: options?.maxFiles || 10,
    zippedArchive: true,
    format: new JSONFormatter
  }));
  if (options?.console !== false) {
    transports2.push(new ConsoleTransport({
      level,
      colorize: true,
      format: new CompactFormatter
    }));
  }
  const config4 = {
    level,
    transports: transports2,
    context: name ? [name] : undefined
  };
  return makeLoggerLayer(config4);
}, createDevelopmentLogger = (name, level = "debug") => {
  const config4 = {
    level,
    transports: [
      new ConsoleTransport({
        colorize: true,
        prettyPrint: true,
        showTimestamp: true,
        showLevel: true,
        showMetadata: true,
        format: new PrettyFormatter({
          colorize: true,
          showEmoji: true,
          showSource: true,
          timestampFormat: "relative"
        })
      })
    ],
    context: name ? [name] : undefined
  };
  return makeLoggerLayer(config4);
}, createCLILogger = (level = "info", options) => {
  const transports2 = [];
  let effectiveLevel = level;
  if (options?.quiet)
    effectiveLevel = "error";
  if (options?.verbose)
    effectiveLevel = "debug";
  transports2.push(new ConsoleTransport({
    level: effectiveLevel,
    format: new CLIFormatter({
      colorize: true,
      maxWidth: process.stdout.columns || 80
    })
  }));
  if (options?.logFile) {
    transports2.push(new FileTransport({
      filename: options.logFile,
      level: "debug",
      format: new JSONFormatter
    }));
  }
  const config4 = {
    level: effectiveLevel,
    transports: transports2
  };
  return makeLoggerLayer(config4);
}, createRemoteLogger = (url2, options) => {
  const transports2 = [];
  transports2.push(new HttpTransport({
    url: url2,
    level: options?.level || "info",
    headers: options?.headers,
    batch: options?.batch !== false,
    batchSize: options?.batchSize || 100,
    batchInterval: options?.batchInterval || 5000,
    format: new JSONFormatter
  }));
  if (options?.localFallback !== false) {
    transports2.push(new ConsoleTransport({
      level: "error",
      format: new CompactFormatter
    }));
  }
  const config4 = {
    level: options?.level || "info",
    transports: transports2
  };
  return makeQueuedLoggerLayer(config4, 1e4);
}, LoggerUtils;
var init_logger3 = __esm(() => {
  init_types5();
  init_logger2();
  init_formatters();
  init_transports();
  init_LogExplorer();
  init_LogComponents();
  init_LiveLogDashboard();
  init_presets();
  init_logger2();
  init_transports();
  init_formatters();
  init_logger2();
  LoggerUtils = {
    parseLevel(level) {
      const normalized = level.toLowerCase();
      if (["trace", "debug", "info", "warn", "error", "fatal"].includes(normalized)) {
        return normalized;
      }
      throw new Error(`Invalid log level: ${level}`);
    },
    getLevelFromEnv(envVar = "LOG_LEVEL", defaultLevel = "info") {
      const level = process.env[envVar];
      if (!level)
        return defaultLevel;
      try {
        return this.parseLevel(level);
      } catch {
        console.warn(`Invalid log level in ${envVar}: ${level}, using ${defaultLevel}`);
        return defaultLevel;
      }
    },
    fromEnv(name = "app") {
      const level = this.getLevelFromEnv();
      const format6 = process.env.LOG_FORMAT || "pretty";
      const output = process.env.LOG_OUTPUT || "console";
      if (output === "file") {
        const logDir = process.env.LOG_DIR || "./logs";
        return createProductionLogger(name, { level, logDir });
      } else if (false) {} else {
        return createDevelopmentLogger(name, level);
      }
    }
  };
});

// ../../src/plugins/jsx-dev-runtime.ts
var init_jsx_dev_runtime18 = __esm(() => {
  init_dev_runtime();
});

// ../../src/plugins/logging.tsx
import * as fs5 from "fs/promises";
import * as path8 from "path";
var loggingState, ShowLogsCommand, ListLogsCommand, ConfigCommand, InteractiveLogsView = ({ source, filter: filter18, level, timeout: timeout5 }) => {
  return /* @__PURE__ */ jsx("vstack", {
    children: /* @__PURE__ */ jsx("panel", {
      border: "double",
      title: "\uD83D\uDCFA Interactive Log Viewer",
      style: { padding: "1" },
      children: /* @__PURE__ */ jsx("vstack", {
        children: [
          /* @__PURE__ */ jsx("panel", {
            border: "rounded",
            title: "Configuration",
            style: { padding: "1" },
            children: /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("hstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Source:"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "cyan",
                      bold: true,
                      children: source
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                filter18 && /* @__PURE__ */ jsx("hstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Filter:"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "yellow",
                      children: filter18
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                level && /* @__PURE__ */ jsx("hstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Min Level:"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "blue",
                      children: level
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                timeout5 && /* @__PURE__ */ jsx("hstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Timeout:"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "green",
                      children: [
                        timeout5,
                        "s"
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this),
          /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
          /* @__PURE__ */ jsx("panel", {
            border: "single",
            style: { padding: "1" },
            children: /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: "\uD83D\uDD04 Interactive log viewer loading..."
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "gray",
                  children: "Controls:"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  \u2022 Press 'q' to quit"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  \u2022 Use arrow keys to navigate"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  \u2022 Press 'f' to filter"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  \u2022 Press '/' to search"
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this)
        ]
      }, undefined, true, undefined, this)
    }, undefined, false, undefined, this)
  }, undefined, false, undefined, this);
}, LogEntryView = ({ entry }) => {
  const levelColors = {
    debug: "gray",
    info: "blue",
    warn: "yellow",
    error: "red"
  };
  const levelIcons = {
    debug: "\uD83D\uDD0D",
    info: "\u2139\uFE0F",
    warn: "\u26A0\uFE0F",
    error: "\u274C"
  };
  return /* @__PURE__ */ jsx("hstack", {
    children: [
      /* @__PURE__ */ jsx("text", {
        color: "gray",
        children: entry.timestamp.toLocaleTimeString()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("text", {
        color: levelColors[entry.level] || "white",
        bold: true,
        children: [
          levelIcons[entry.level] || "\u2022",
          " ",
          entry.level.toUpperCase().padEnd(5)
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx("text", {
        color: "cyan",
        children: [
          "[",
          entry.source.padEnd(12),
          "]"
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx("text", {
        children: entry.message
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}, LoggingPlugin = ({
  name = "logs",
  description = "Comprehensive logging functionality",
  version = "1.0.0",
  dir: dir2,
  as: as13
} = {}) => {
  const pluginName = as13 || name;
  if (dir2 && loggingState.logDir !== dir2) {
    loggingState.logDir = dir2;
  }
  return /* @__PURE__ */ jsx(Plugin, {
    name: pluginName,
    description,
    version,
    children: [
      /* @__PURE__ */ jsx(Command, {
        ...ShowLogsCommand
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        ...ListLogsCommand
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        ...ConfigCommand
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        ...ShowLogsCommand,
        name: "view"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        ...ShowLogsCommand,
        name: "cat"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        ...ListLogsCommand,
        name: "ls"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx(Command, {
        name: "tail",
        description: "Follow log output (alias for show --follow)",
        args: {
          source: {
            description: "Log file or logger name",
            required: true
          }
        },
        flags: {
          lines: {
            description: "Number of lines to show initially",
            alias: "n",
            type: "number",
            default: 10
          },
          dir: {
            description: "Override log directory",
            alias: "d",
            type: "string"
          }
        },
        interactive: true,
        handler: (ctx) => {
          if (ctx.flags.dir) {
            loggingState.logDir = ctx.flags.dir;
          }
          return ShowLogsCommand.handler({
            ...ctx,
            flags: { ...ctx.flags, follow: true }
          });
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var init_logging = __esm(() => {
  init_app2();
  init_jsx();
  init_logger3();
  init_jsx_dev_runtime18();
  loggingState = {
    loggers: new Map,
    currentLogFile: null,
    logLevel: "info",
    logDir: "./logs"
  };
  ShowLogsCommand = defineJSXCommand({
    name: "show",
    description: "Show logs from a file or logger",
    aliases: ["view", "cat"],
    args: {
      source: {
        description: "Log file or logger name",
        required: true
      }
    },
    flags: {
      lines: {
        description: "Number of lines to show",
        alias: "n",
        type: "number",
        default: 50
      },
      follow: {
        description: "Follow log output (tail -f)",
        alias: "f",
        type: "boolean"
      },
      filter: {
        description: "Filter logs by pattern/regex",
        type: "string"
      },
      level: {
        description: "Minimum log level to show",
        type: "string",
        choices: ["debug", "info", "warn", "error"]
      },
      interactive: {
        description: "Use interactive log explorer",
        alias: "i",
        type: "boolean"
      },
      timeout: {
        description: "Auto-stop watchers after specified seconds",
        type: "number"
      },
      dir: {
        description: "Override log directory",
        alias: "d",
        type: "string"
      }
    },
    examples: [
      "logs show app.log --lines 100",
      "logs show app.log --follow --filter 'error'",
      "logs show app.log --interactive",
      "logs show system --level warn"
    ],
    interactive: (ctx) => ctx.flags.follow === true || ctx.flags.interactive === true,
    handler: async (ctx) => {
      const { source } = ctx.args;
      const { lines, follow, filter: filter18, level, interactive, timeout: timeout5 } = ctx.flags;
      if (!ctx.flags.dir && ctx.tuixConfig) {
        if (ctx.tuixConfig.logsDirectory) {
          loggingState.logDir = ctx.tuixConfig.logsDirectory;
        } else if (ctx.tuixConfig.tuixDir) {
          loggingState.logDir = path8.join(ctx.tuixConfig.tuixDir, "logs");
        }
      }
      if (interactive) {
        return /* @__PURE__ */ jsx(InteractiveLogsView, {
          source,
          filter: filter18,
          level,
          timeout: timeout5
        }, undefined, false, undefined, this);
      }
      try {
        const isFile = source.includes(".") || source.includes("/");
        let logEntries = [];
        if (isFile) {
          const logDir = ctx.flags.dir || loggingState.logDir;
          const logPath = path8.isAbsolute(source) ? source : path8.join(logDir, source);
          const content = await fs5.readFile(logPath, "utf-8");
          const lines2 = content.split(`
`).filter((line) => line.trim());
          logEntries = lines2.map((line, i) => {
            try {
              const parsed = JSON.parse(line);
              return {
                timestamp: new Date(parsed.timestamp || parsed.time || Date.now()),
                level: parsed.level || "info",
                message: parsed.message || parsed.msg || line,
                source: path8.basename(logPath)
              };
            } catch {
              return {
                timestamp: new Date,
                level: "info",
                message: line,
                source: path8.basename(logPath)
              };
            }
          });
        } else {
          const logger2 = loggingState.loggers.get(source);
          if (!logger2) {
            return /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "red",
                  children: `Logger not found: ${source}`
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  children: `Available loggers: ${Array.from(loggingState.loggers.keys()).join(", ")}`
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this);
          }
          logEntries = [];
        }
        if (level) {
          const levelPriority = { debug: 0, info: 1, warn: 2, error: 3 };
          const minPriority = levelPriority[level];
          logEntries = logEntries.filter((entry) => levelPriority[entry.level] >= minPriority);
        }
        if (filter18) {
          const regex = new RegExp(filter18, "i");
          logEntries = logEntries.filter((entry) => regex.test(entry.message));
        }
        if (lines) {
          logEntries = logEntries.slice(-lines);
        }
        return /* @__PURE__ */ jsx("vstack", {
          children: /* @__PURE__ */ jsx("panel", {
            border: "double",
            title: `\uD83D\uDCDD Logs from ${source}`,
            style: { padding: "1" },
            children: /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("hstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: [
                        "Entries: ",
                        logEntries.length
                      ]
                    }, undefined, true, undefined, this),
                    filter18 && /* @__PURE__ */ jsx("text", {
                      color: "cyan",
                      children: [
                        "Filter: ",
                        filter18
                      ]
                    }, undefined, true, undefined, this),
                    level && /* @__PURE__ */ jsx("text", {
                      color: "yellow",
                      children: [
                        "Level \u2265 ",
                        level
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  children: "\u2500".repeat(80)
                }, undefined, false, undefined, this),
                logEntries.length === 0 ? /* @__PURE__ */ jsx("panel", {
                  border: "single",
                  style: { padding: "1" },
                  children: /* @__PURE__ */ jsx("text", {
                    color: "yellow",
                    children: "\u26A0\uFE0F  No log entries found"
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this) : /* @__PURE__ */ jsx("panel", {
                  border: "rounded",
                  title: "Log Entries",
                  style: { padding: "1", maxHeight: "30" },
                  children: /* @__PURE__ */ jsx("vstack", {
                    children: logEntries.map((entry, i) => /* @__PURE__ */ jsx(LogEntryView, {
                      entry
                    }, i, false, undefined, this))
                  }, undefined, false, undefined, this)
                }, undefined, false, undefined, this),
                follow && /* @__PURE__ */ jsx("panel", {
                  border: "single",
                  style: { padding: "0.5" },
                  children: /* @__PURE__ */ jsx("hstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "cyan",
                        children: "\uD83D\uDD04 Following logs..."
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: "Ctrl+C to stop"
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this)
          }, undefined, false, undefined, this)
        }, undefined, false, undefined, this);
      } catch (error2) {
        return /* @__PURE__ */ jsx("vstack", {
          children: [
            /* @__PURE__ */ jsx("text", {
              color: "red",
              children: `Failed to read logs: ${error2 instanceof Error ? error2.message : String(error2)}`
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx("text", {
              color: "blue",
              children: "Usage: logs show <file|logger> [options]"
            }, undefined, false, undefined, this)
          ]
        }, undefined, true, undefined, this);
      }
    }
  });
  ListLogsCommand = defineJSXCommand({
    name: "list",
    description: "List available log files and loggers",
    aliases: ["ls"],
    flags: {
      verbose: {
        description: "Show detailed information",
        alias: "v",
        type: "boolean"
      },
      dir: {
        description: "Override log directory",
        alias: "d",
        type: "string"
      }
    },
    handler: async (ctx) => {
      const logFiles = [];
      const loggers = Array.from(loggingState.loggers.keys());
      if (!ctx.flags.dir && ctx.tuixConfig) {
        if (ctx.tuixConfig.logsDirectory) {
          loggingState.logDir = ctx.tuixConfig.logsDirectory;
        } else if (ctx.tuixConfig.tuixDir) {
          loggingState.logDir = path8.join(ctx.tuixConfig.tuixDir, "logs");
        }
      }
      try {
        const logDir = ctx.flags.dir || loggingState.logDir;
        const files = await fs5.readdir(logDir);
        logFiles.push(...files.filter((file) => file.endsWith(".log") || file.endsWith(".json")));
      } catch {}
      return /* @__PURE__ */ jsx("vstack", {
        children: /* @__PURE__ */ jsx("panel", {
          border: "double",
          title: "\uD83D\uDCCB Available Logs",
          style: { padding: "1" },
          children: /* @__PURE__ */ jsx("vstack", {
            children: [
              /* @__PURE__ */ jsx("panel", {
                title: "\uD83D\uDCC1 Log Files",
                border: "rounded",
                style: { padding: "1" },
                children: /* @__PURE__ */ jsx("vstack", {
                  children: logFiles.length === 0 ? /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "No log files found in ",
                      ctx.flags.dir || loggingState.logDir
                    ]
                  }, undefined, true, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: [
                          "Directory: ",
                          ctx.flags.dir || loggingState.logDir
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                      logFiles.map((file) => /* @__PURE__ */ jsx("hstack", {
                        children: [
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: "\uD83D\uDCC4"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "cyan",
                            children: file
                          }, undefined, false, undefined, this),
                          ctx.flags.verbose && /* @__PURE__ */ jsx("text", {
                            color: "gray",
                            children: [
                              "  (",
                              path8.join(ctx.flags.dir || loggingState.logDir, file),
                              ")"
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, file, true, undefined, this))
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx("panel", {
                title: "\uD83D\uDD27 Active Loggers",
                border: "rounded",
                style: { padding: "1" },
                children: /* @__PURE__ */ jsx("vstack", {
                  children: loggers.length === 0 ? /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: "No active loggers"
                  }, undefined, false, undefined, this) : loggers.map((name) => /* @__PURE__ */ jsx("hstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "blue",
                        children: "\u2022"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "cyan",
                        children: name
                      }, undefined, false, undefined, this)
                    ]
                  }, name, true, undefined, this))
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
              /* @__PURE__ */ jsx("panel", {
                border: "single",
                style: { padding: "0.5" },
                children: /* @__PURE__ */ jsx("text", {
                  color: "gray",
                  children: [
                    "Use '",
                    ctx.cliName,
                    " logs show <name>' to view logs"
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this)
        }, undefined, false, undefined, this)
      }, undefined, false, undefined, this);
    }
  });
  ConfigCommand = defineJSXCommand({
    name: "config",
    description: "Configure logging settings",
    subcommands: {
      set: defineJSXCommand({
        name: "set",
        description: "Set logging configuration",
        args: {
          key: {
            description: "Configuration key",
            required: true,
            choices: ["level", "dir", "format"]
          },
          value: {
            description: "Configuration value",
            required: true
          }
        },
        handler: (ctx) => {
          const { key, value: value6 } = ctx.args;
          switch (key) {
            case "level":
              if (!["debug", "info", "warn", "error"].includes(value6)) {
                return /* @__PURE__ */ jsx("error", {
                  children: "Invalid log level. Use: debug, info, warn, error"
                }, undefined, false, undefined, this);
              }
              loggingState.logLevel = value6;
              break;
            case "dir":
              loggingState.logDir = value6;
              break;
            default:
              return /* @__PURE__ */ jsx("error", {
                children: [
                  "Unknown configuration key: ",
                  key
                ]
              }, undefined, true, undefined, this);
          }
          return /* @__PURE__ */ jsx("vstack", {
            children: [
              /* @__PURE__ */ jsx("text", {
                color: "green",
                children: "Configuration updated"
              }, undefined, false, undefined, this),
              /* @__PURE__ */ jsx("text", {
                children: `${key}: ${value6}`
              }, undefined, false, undefined, this)
            ]
          }, undefined, true, undefined, this);
        }
      }),
      get: defineJSXCommand({
        name: "get",
        description: "Get logging configuration",
        args: {
          key: {
            description: "Configuration key",
            required: false
          }
        },
        handler: (ctx) => {
          if (!ctx.args.key) {
            return /* @__PURE__ */ jsx("panel", {
              border: "double",
              title: "\u2699\uFE0F  Logging Configuration",
              style: { padding: "1" },
              children: /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("hstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: "Log Level:"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "cyan",
                        bold: true,
                        children: loggingState.logLevel
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("hstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: "Directory:"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "blue",
                        children: loggingState.logDir
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("hstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: "Active Loggers:"
                      }, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "green",
                        children: loggingState.loggers.size
                      }, undefined, false, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this)
            }, undefined, false, undefined, this);
          }
          const config4 = {
            level: loggingState.logLevel,
            dir: loggingState.logDir,
            loggers: loggingState.loggers.size
          };
          const value6 = config4[ctx.args.key];
          if (value6 === undefined) {
            return /* @__PURE__ */ jsx("error", {
              children: [
                "Unknown configuration key: ",
                ctx.args.key
              ]
            }, undefined, true, undefined, this);
          }
          return /* @__PURE__ */ jsx("text", {
            children: `${ctx.args.key}: ${value6}`
          }, undefined, false, undefined, this);
        }
      })
    },
    handler: () => /* @__PURE__ */ jsx("vstack", {
      children: [
        /* @__PURE__ */ jsx("text", {
          color: "blue",
          bold: true,
          children: "Logging Configuration"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx("text", {
          children: "Use subcommands:"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx("text", {
          color: "green",
          children: "\u2022 config get [key]"
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx("text", {
          color: "green",
          children: "\u2022 config set <key> <value>"
        }, undefined, false, undefined, this)
      ]
    }, undefined, true, undefined, this)
  });
});

// ../../src/process-manager/manager.ts
import { join as join12 } from "path";
import { existsSync as existsSync2, mkdirSync } from "fs";

class ProcessManager {
  config;
  cwd;
  processes = new Map;
  logDir;
  isInitialized = false;
  isShuttingDown = false;
  debugTuix;
  logger;
  constructor(config4 = {}, cwd = process.cwd()) {
    this.config = config4;
    this.cwd = cwd;
    this.logDir = join12(config4.tuixDir || ".tuix", "logs");
    this.debugTuix = config4.debugTuix ?? process.env.TUIX_DEBUG === "true";
    this.logger = config4.logger;
  }
  log(level, message, metadata) {
    if (this.logger) {
      if (level === "debug" && !this.debugTuix)
        return;
      const effect4 = this.logger[level](message, metadata);
      exports_Effect.runPromise(effect4).catch(() => {
        console[level === "debug" ? "log" : level](`[ProcessManager] ${message}`, metadata);
      });
    } else if (this.debugTuix || level !== "debug") {
      console[level === "debug" ? "log" : level](`[ProcessManager] ${message}`, metadata);
    }
  }
  async init() {
    if (this.isInitialized)
      return;
    const dirs = [
      this.config.tuixDir || ".tuix",
      this.logDir,
      join12(this.config.tuixDir || ".tuix", "pids")
    ];
    for (const dir2 of dirs) {
      if (!existsSync2(dir2)) {
        mkdirSync(dir2, { recursive: true });
      }
    }
    this.isInitialized = true;
    this.log("debug", "\uD83D\uDE80 Native Bun Process Manager initialized");
  }
  async add(config4) {
    await this.init();
    if (this.processes.has(config4.name)) {
      throw new Error(`Process ${config4.name} already exists`);
    }
    const managedProcess = {
      name: config4.name,
      config: config4,
      restarts: 0,
      status: "stopped",
      logs: []
    };
    this.processes.set(config4.name, managedProcess);
    if (config4.autostart !== false) {
      await this.start(config4.name);
    }
  }
  async start(name) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess) {
      throw new Error(`Process ${name} not found`);
    }
    if (managedProcess.status === "running") {
      this.log("debug", `Process ${name} is already running`);
      return;
    }
    try {
      managedProcess.status = "starting";
      const logFile = Bun.file(join12(this.logDir, `${name}.log`));
      const errorFile = Bun.file(join12(this.logDir, `${name}.error.log`));
      let resolvedCommand = managedProcess.config.command;
      const commandPath = await Bun.which(managedProcess.config.command);
      if (commandPath) {
        resolvedCommand = commandPath;
      } else {
        try {
          const result = await Bun.$`which ${managedProcess.config.command}`.text();
          if (result.trim()) {
            resolvedCommand = result.trim();
          }
        } catch {
          this.log("warn", `Could not resolve path for ${managedProcess.config.command}, using as-is`);
        }
      }
      const subprocess = Bun.spawn({
        cmd: [resolvedCommand, ...managedProcess.config.args],
        cwd: managedProcess.config.cwd || this.cwd,
        env: {
          ...process.env,
          ...managedProcess.config.env,
          TUIX_PROCESS_NAME: name,
          TUIX_MANAGED: "true"
        },
        stdout: "pipe",
        stderr: "pipe",
        stdin: "ignore",
        ipc: (message, subprocess2) => {
          this.handleIPCMessage(name, message, subprocess2);
        }
      });
      this.setupLogCapture(name, subprocess, logFile, errorFile);
      managedProcess.subprocess = subprocess;
      managedProcess.status = "running";
      managedProcess.startTime = new Date;
      subprocess.exited.then((exitCode) => {
        this.handleProcessExit(name, exitCode);
      });
      this.log("info", `\u2705 Started ${name} (PID: ${subprocess.pid})`);
      if (managedProcess.config.command === "bun" || resolvedCommand.includes("bun")) {
        try {
          subprocess.send({ type: "ping", from: "manager" });
        } catch {}
      }
    } catch (error2) {
      managedProcess.status = "errored";
      managedProcess.lastError = error2 instanceof Error ? error2.message : String(error2);
      throw error2;
    }
  }
  async stop(name) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess || managedProcess.status !== "running") {
      this.log("debug", `Process ${name} is not running`);
      return;
    }
    if (!managedProcess.subprocess) {
      this.log("warn", `Process ${name} has no subprocess`);
      return;
    }
    if (managedProcess.subprocess.send) {
      try {
        managedProcess.subprocess.send({ type: "shutdown", from: "manager" });
        await Promise.race([
          managedProcess.subprocess.exited,
          new Promise((resolve3) => setTimeout(resolve3, 5000))
        ]);
      } catch {}
    }
    if (managedProcess.subprocess.exitCode === null) {
      managedProcess.subprocess.kill();
    }
    managedProcess.status = "stopped";
    this.log("info", `\u2705 Stopped ${name}`);
  }
  async restart(name) {
    await this.stop(name);
    await new Promise((resolve3) => setTimeout(resolve3, 1000));
    await this.start(name);
  }
  async updateProcessEnv(name, envUpdates, restart = false) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess) {
      throw new Error(`Process ${name} not found`);
    }
    managedProcess.config.env = {
      ...managedProcess.config.env,
      ...envUpdates
    };
    this.log("info", `Updated environment variables for ${name}:`, envUpdates);
    if (restart) {
      this.log("info", `Restarting ${name} to apply environment changes`);
      await this.restart(name);
    } else {
      this.log("info", `Environment variables updated for ${name}. Restart process to apply changes.`);
    }
  }
  async startAll() {
    await this.init();
    const processes = Array.from(this.processes.values()).filter((p) => p.config.autostart !== false);
    if (processes.length === 0) {
      this.log("info", "No processes configured for startup");
      return;
    }
    this.log("info", `\uD83D\uDE80 Starting ${processes.length} processes in parallel...`);
    const results = await Promise.allSettled(processes.map((p) => this.start(p.name)));
    const succeeded = results.filter((r) => r.status === "fulfilled").length;
    const failed = results.filter((r) => r.status === "rejected").length;
    this.log("info", `\u2705 Started ${succeeded} processes successfully`);
    if (failed > 0) {
      this.log("error", `\u274C Failed to start ${failed} processes`);
    }
  }
  status(name) {
    if (name) {
      const managedProcess = this.processes.get(name);
      if (!managedProcess) {
        throw new Error(`Process ${name} not found`);
      }
      return this.getProcessStatus(managedProcess);
    }
    return Array.from(this.processes.values()).map((p) => this.getProcessStatus(p));
  }
  getProcessStatus(managedProcess) {
    return {
      name: managedProcess.name,
      status: managedProcess.status,
      pid: managedProcess.subprocess?.pid,
      uptime: managedProcess.status === "running" && managedProcess.startTime ? Date.now() - managedProcess.startTime.getTime() : 0,
      restarts: managedProcess.restarts,
      command: managedProcess.config.command,
      args: managedProcess.config.args,
      lastError: managedProcess.lastError
    };
  }
  handleIPCMessage(name, message, subprocess) {
    this.log("debug", `[IPC] ${name}: ${JSON.stringify(message)}`);
    switch (message.type) {
      case "pong":
        this.log("debug", `\u2705 ${name} responded to ping`);
        break;
      case "status":
        const managedProcess = this.processes.get(name);
        if (managedProcess && managedProcess.metrics) {
          managedProcess.metrics = {
            memory: message.memory?.rss,
            cpu: message.cpu,
            uptime: message.uptime
          };
        }
        break;
      case "metric":
        break;
      default:
        this.log("debug", `Unknown IPC message from ${name}: ${JSON.stringify(message)}`);
    }
  }
  handleProcessExit(name, exitCode) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess)
      return;
    managedProcess.status = exitCode === 0 ? "stopped" : "errored";
    const runtime6 = managedProcess.startTime ? Date.now() - managedProcess.startTime.getTime() : 0;
    const exitedQuickly = runtime6 < 2000;
    if (exitedQuickly && exitCode !== 0) {
      this.log("warn", `\u26A0\uFE0F  Process ${name} exited immediately with code ${exitCode} - check command and logs`);
      managedProcess.lastError = `Process exited immediately with code ${exitCode}`;
    } else {
      this.log("info", `Process ${name} exited with code ${exitCode}`);
    }
    const shouldRestart = managedProcess.config.autorestart !== false && exitCode !== 0 && exitCode !== 143 && managedProcess.restarts < 5 && !this.isShuttingDown && !exitedQuickly;
    if (shouldRestart) {
      managedProcess.restarts++;
      this.log("info", `Restarting ${name} (attempt ${managedProcess.restarts}/5)...`);
      setTimeout(() => {
        if (!this.isShuttingDown) {
          this.start(name).catch((error2) => {
            this.log("error", `Failed to restart ${name}: ${error2 instanceof Error ? error2.message : String(error2)}`);
          });
        }
      }, 1000 * managedProcess.restarts);
    }
  }
  async shutdown() {
    this.log("info", "Shutting down all processes...");
    this.isShuttingDown = true;
    await Promise.all(Array.from(this.processes.keys()).map((name) => this.stop(name)));
  }
  async getCwd() {
    return this.cwd;
  }
  async createConfig() {
    return this.config;
  }
  async recover() {
    this.log("info", "\uD83D\uDD04 Attempting to recover existing processes...");
    await this.startAll();
  }
  async connectToWrapper(name) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess) {
      throw new Error(`Process ${name} not found`);
    }
    return {
      connected: managedProcess.status === "running",
      pid: managedProcess.subprocess?.pid,
      status: managedProcess.status
    };
  }
  list() {
    return Array.from(this.processes.values()).map((managedProcess) => ({
      name: managedProcess.name,
      config: managedProcess.config,
      status: managedProcess.status,
      pid: managedProcess.subprocess?.pid,
      startTime: managedProcess.startTime,
      restarts: managedProcess.restarts,
      lastError: managedProcess.lastError,
      memory: managedProcess.metrics?.memory,
      cpu: managedProcess.metrics?.cpu,
      logs: managedProcess.logs || []
    }));
  }
  getLogs(name, limit) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess) {
      return [];
    }
    const logs = managedProcess.logs || [];
    return limit ? logs.slice(-limit) : logs;
  }
  stats() {
    const processes = Array.from(this.processes.values());
    const running4 = processes.filter((p) => p.status === "running").length;
    const stopped = processes.filter((p) => p.status === "stopped").length;
    const errored = processes.filter((p) => p.status === "errored" || p.status === "crashed").length;
    let totalMemory = 0;
    let totalCpu = 0;
    processes.forEach((p) => {
      if (p.metrics?.memory) {
        totalMemory += p.metrics.memory;
      }
      if (p.metrics?.cpu) {
        totalCpu += p.metrics.cpu;
      }
    });
    return {
      processes: {
        total: processes.length,
        running: running4,
        stopped,
        errored
      },
      system: {
        memory: {
          total: process.memoryUsage().heapTotal,
          used: totalMemory || process.memoryUsage().heapUsed,
          free: process.memoryUsage().heapTotal - (totalMemory || process.memoryUsage().heapUsed)
        },
        cpu: {
          usage: totalCpu,
          loadAverage: [0, 0, 0]
        },
        uptime: process.uptime()
      }
    };
  }
  startTime = new Date;
  async setupLogCapture(name, subprocess, logFile, errorFile) {
    const managedProcess = this.processes.get(name);
    if (!managedProcess)
      return;
    const stdoutWriter = logFile.writer();
    const stderrWriter = errorFile.writer();
    const addLogEntry = (message, level = "info", source = "stdout") => {
      const logEntry = {
        timestamp: new Date,
        level,
        message: message.trim(),
        source
      };
      managedProcess.logs.push(logEntry);
      if (managedProcess.logs.length > 1000) {
        managedProcess.logs = managedProcess.logs.slice(-1000);
      }
      if (this.logger) {
        const effect4 = level === "error" ? this.logger.error(`[${name}] ${message}`, { process: name, source }) : this.logger.info(`[${name}] ${message}`, { process: name, source });
        exports_Effect.runPromise(effect4).catch(() => {});
      }
    };
    if (subprocess.stdout) {
      (async () => {
        try {
          const reader = subprocess.stdout.getReader();
          const decoder2 = new TextDecoder;
          while (true) {
            const { done: done15, value: value6 } = await reader.read();
            if (done15)
              break;
            const text9 = decoder2.decode(value6, { stream: true });
            if (text9) {
              await stdoutWriter.write(text9);
              await stdoutWriter.flush();
              const lines = text9.split(`
`).filter((line) => line.trim());
              lines.forEach((line) => addLogEntry(line, "info", "stdout"));
            }
          }
        } catch (error2) {
          this.log("error", `Error reading stdout for ${name}: ${error2}`);
        }
      })();
    }
    if (subprocess.stderr) {
      (async () => {
        try {
          const reader = subprocess.stderr.getReader();
          const decoder2 = new TextDecoder;
          while (true) {
            const { done: done15, value: value6 } = await reader.read();
            if (done15)
              break;
            const text9 = decoder2.decode(value6, { stream: true });
            if (text9) {
              await stderrWriter.write(text9);
              await stderrWriter.flush();
              const lines = text9.split(`
`).filter((line) => line.trim());
              lines.forEach((line) => addLogEntry(line, "error", "stderr"));
            }
          }
        } catch (error2) {
          this.log("error", `Error reading stderr for ${name}: ${error2}`);
        }
      })();
    }
  }
}
function setupManagedProcess() {
  if (process.env.TUIX_MANAGED === "true") {
    const processName = process.env.TUIX_PROCESS_NAME || "unknown";
    process.on("message", (message) => {
      switch (message.type) {
        case "ping":
          process.send?.({ type: "pong", from: processName });
          break;
        case "shutdown":
          console.log("Received shutdown signal, cleaning up...");
          process.exit(0);
          break;
      }
    });
    setInterval(() => {
      process.send?.({
        type: "status",
        from: processName,
        memory: process.memoryUsage(),
        uptime: process.uptime()
      });
    }, 30000);
  }
}
var init_manager2 = __esm(() => {
  init_esm2();
});

// ../../src/process-manager/components/ProcessMonitor.ts
function formatUptime(ms) {
  if (ms < 1000)
    return "0s";
  const seconds2 = Math.floor(ms / 1000);
  const minutes2 = Math.floor(seconds2 / 60);
  const hours2 = Math.floor(minutes2 / 60);
  const days2 = Math.floor(hours2 / 24);
  if (days2 > 0)
    return `${days2}d ${hours2 % 24}h`;
  if (hours2 > 0)
    return `${hours2}h ${minutes2 % 60}m`;
  if (minutes2 > 0)
    return `${minutes2}m ${seconds2 % 60}s`;
  return `${seconds2}s`;
}
function formatBytes(bytes) {
  if (bytes < 1024)
    return `${bytes}B`;
  if (bytes < 1024 * 1024)
    return `${(bytes / 1024).toFixed(1)}KB`;
  if (bytes < 1024 * 1024 * 1024)
    return `${(bytes / (1024 * 1024)).toFixed(1)}MB`;
  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)}GB`;
}
function ProcessMonitor({
  manager,
  refreshInterval = 1000,
  showLogs = true,
  showStats = true
}) {
  const processes = manager.list();
  const selectedIndex = 0;
  const selectedProcess = processes[selectedIndex];
  const selectedLogs = selectedProcess ? manager.getLogs(selectedProcess.name) : [];
  const systemStats = showStats ? manager.stats() : null;
  const lastUpdate = new Date;
  const header = hstack(styledText("\uD83D\uDD0D Process Monitor", style().bold().foreground(Colors.blue)), text("  "), styledText(`Last update: ${lastUpdate.toLocaleTimeString()}`, style().foreground(Colors.gray)));
  const processHeader = hstack(styledText("ST  ", style().bold()), styledText("NAME            ", style().bold()), styledText("STATUS    ", style().bold()), styledText("PID     ", style().bold()), styledText("UPTIME    ", style().bold()), styledText("MEMORY    ", style().bold()), styledText("CPU     ", style().bold()), styledText("RST", style().bold()));
  const processRows = processes.map((process2, i) => {
    const statusColor = STATUS_COLORS[process2.status];
    const statusIcon = STATUS_ICONS[process2.status];
    const uptime = process2.startTime ? Date.now() - process2.startTime.getTime() : 0;
    const selected = i === selectedIndex;
    return hstack(styledText(statusIcon + "  ", style().foreground(Colors[statusColor] || Colors.white)), text(process2.name.padEnd(16)), styledText(process2.status.padEnd(10), style().foreground(Colors[statusColor] || Colors.white)), text((process2.pid || "-").toString().padEnd(8)), text((uptime > 0 ? formatUptime(uptime) : "-").padEnd(10)), text((process2.memory ? formatBytes(process2.memory) : "-").padEnd(10)), text((process2.cpu ? `${process2.cpu.toFixed(1)}%` : "-").padEnd(8)), text(process2.restarts.toString()));
  });
  const controls = hstack(styledText("\u2191\u2193/jk Navigate", style().foreground(Colors.gray)), styledText("  s Start/Stop", style().foreground(Colors.gray)), styledText("  r Restart", style().foreground(Colors.gray)), styledText("  c Clear logs", style().foreground(Colors.gray)), styledText("  q Quit", style().foreground(Colors.gray)));
  return vstack(header, text(""), processHeader, styledText("\u2500".repeat(80), style().foreground(Colors.gray)), ...processRows, text(""), controls);
}
var STATUS_COLORS, STATUS_ICONS;
var init_ProcessMonitor = __esm(() => {
  init_view();
  init_styling();
  STATUS_COLORS = {
    running: "green",
    stopped: "gray",
    starting: "yellow",
    stopping: "yellow",
    error: "red",
    crashed: "red"
  };
  STATUS_ICONS = {
    running: "\u25CF",
    stopped: "\u25CB",
    starting: "\u25D0",
    stopping: "\u25D0",
    error: "\u2717",
    crashed: "\u2717"
  };
});

// ../../src/process-manager/jsx-dev-runtime.ts
var init_jsx_dev_runtime19 = __esm(() => {
  init_dev_runtime();
});

// ../../src/process-manager/plugin.tsx
function parseCommand(commandString) {
  const parts2 = [];
  let current2 = "";
  let inQuotes = false;
  let quoteChar = "";
  for (let i = 0;i < commandString.length; i++) {
    const char = commandString[i];
    if ((char === '"' || char === "'") && !inQuotes) {
      inQuotes = true;
      quoteChar = char;
    } else if (char === quoteChar && inQuotes) {
      inQuotes = false;
      quoteChar = "";
    } else if (char === " " && !inQuotes) {
      if (current2.trim()) {
        parts2.push(current2.trim());
        current2 = "";
      }
    } else {
      current2 += char;
    }
  }
  if (current2.trim()) {
    parts2.push(current2.trim());
  }
  return {
    command: parts2[0] || "",
    args: parts2.slice(1)
  };
}
async function getProcessManager(tuixConfig) {
  if (!processManager) {
    const configData = tuixConfig?.toObject ? tuixConfig.toObject() : tuixConfig || {};
    const debugEnabled = configData.enableTuixDebug ?? process.env.TUIX_DEBUG === "true";
    const loggerConfig = configData.logger || {
      level: "info",
      colorize: true,
      prettyPrint: true,
      showEmoji: true
    };
    const logger2 = createConsoleLogger(debugEnabled ? "debug" : loggerConfig.level, {
      colorize: loggerConfig.colorize !== false,
      prettyPrint: loggerConfig.prettyPrint !== false,
      showEmoji: loggerConfig.showEmoji !== false
    });
    const log5 = async (level, message, metadata) => {
      if (level === "debug" && !debugEnabled)
        return;
      await exports_Effect.runPromise(logger2[level](message, metadata)).catch(() => {
        console[level === "debug" ? "log" : level](`[ProcessManager] ${message}`, metadata);
      });
    };
    const processManagerConfig = configData.processManager || {};
    processManager = new ProcessManager({
      logger: logger2.child("process-manager"),
      logDir: processManagerConfig.logDir || "./logs",
      autoSave: processManagerConfig.autoSave !== false,
      cwd: process.cwd(),
      debugTuix: debugEnabled
    });
    await processManager.init();
    if (processManagerConfig.services) {
      await log5("debug", `\uD83D\uDD27 Loading ${Object.keys(processManagerConfig.services).length} services from config`);
      for (const [name, config4] of Object.entries(processManagerConfig.services)) {
        try {
          const existing = processManager.list().find((p) => p.name === name);
          if (existing) {
            await log5("debug", `  \u2022 Service ${name} already exists`);
            continue;
          }
          await log5("debug", `  \u2022 Adding service: ${name}`);
          let processConfig = { name, ...config4 };
          if (typeof config4.command === "string" && config4.command.includes(" ")) {
            const { command, args: args2 } = parseCommand(config4.command);
            processConfig = {
              ...processConfig,
              command,
              args: [...args2, ...config4.args || []]
            };
            await log5("debug", `    \u2022 Parsed command: ${processConfig.command} with args: [${processConfig.args.join(", ")}]`);
          }
          await processManager.add(processConfig);
        } catch (error2) {
          await log5("error", `  \u274C Failed to add ${name}: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
      await log5("debug", `\u2705 Loaded ${processManager.list().length} services into ProcessManager`);
    } else {
      await log5("warn", "\u26A0\uFE0F No services found in config");
      await log5("debug", `Config data: ${JSON.stringify(configData, null, 2)}`);
    }
  }
  return processManager;
}
async function getServiceConfig(serviceName, preset) {
  const presets2 = {
    vitest: {
      name: serviceName,
      command: "bun test --watch",
      autorestart: true,
      group: "testing",
      logPreset: "vitest",
      healthCheck: {
        pattern: "Test Files|PASS|FAIL",
        timeout: 1e4
      }
    },
    vite: {
      name: serviceName,
      command: "bun run dev",
      autorestart: true,
      group: "build",
      logPreset: "vite",
      healthCheck: {
        pattern: "Local:|ready in|build started",
        timeout: 15000
      }
    },
    tsc: {
      name: serviceName,
      command: "bun run typecheck --watch",
      autorestart: false,
      group: "quality",
      logPreset: "tsc",
      healthCheck: {
        pattern: "Found \\d+ errors|No errors found",
        timeout: 1e4
      }
    },
    eslint: {
      name: serviceName,
      command: "bun run lint --watch",
      autorestart: false,
      group: "quality",
      logPreset: "eslint",
      healthCheck: {
        pattern: "\u2713|\u2717|problems?",
        timeout: 8000
      }
    },
    bun: {
      name: serviceName,
      command: "bun test --watch",
      autorestart: true,
      group: "testing",
      logPreset: "bun",
      healthCheck: {
        pattern: "pass|fail|\\d+ test",
        timeout: 8000
      }
    }
  };
  if (preset && presets2[preset]) {
    return presets2[preset];
  }
  return {
    name: serviceName,
    command: serviceName,
    autorestart: false,
    logPreset: "default"
  };
}
var processManager = null, ProcessStatusView = ({ process: process2, detailed }) => {
  const statusColors = {
    running: "green",
    stopped: "gray",
    error: "red",
    starting: "yellow"
  };
  const statusIcons = {
    running: "\uD83D\uDFE2",
    stopped: "\u26AA",
    error: "\uD83D\uDD34",
    starting: "\uD83D\uDFE1"
  };
  const uptime = process2.startTime ? `${Math.floor((Date.now() - process2.startTime.getTime()) / 1000)}s` : "-";
  return /* @__PURE__ */ jsx("panel", {
    border: "single",
    style: { padding: "0.5" },
    children: /* @__PURE__ */ jsx("vstack", {
      children: [
        /* @__PURE__ */ jsx("hstack", {
          children: [
            /* @__PURE__ */ jsx("text", {
              children: statusIcons[process2.status] || "\u26AB"
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx("text", {
              bold: true,
              color: "cyan",
              children: process2.name.padEnd(20)
            }, undefined, false, undefined, this),
            /* @__PURE__ */ jsx("text", {
              color: statusColors[process2.status] || "white",
              children: [
                "[",
                process2.status.toUpperCase().padEnd(8),
                "]"
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx("text", {
              color: "gray",
              children: [
                "PID: ",
                (process2.pid || "-").toString().padEnd(8)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx("text", {
              color: "blue",
              children: [
                "\u23F1\uFE0F  ",
                uptime.padEnd(10)
              ]
            }, undefined, true, undefined, this),
            /* @__PURE__ */ jsx("text", {
              color: "yellow",
              children: [
                "\uD83D\uDD04 ",
                process2.restarts || 0
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this),
        detailed && /* @__PURE__ */ jsx("vstack", {
          children: [
            /* @__PURE__ */ jsx("text", {
              color: "gray",
              children: [
                "\u251C\u2500 Command: ",
                process2.command || "Unknown"
              ]
            }, undefined, true, undefined, this),
            process2.group && /* @__PURE__ */ jsx("text", {
              color: "purple",
              children: [
                "\u251C\u2500 Group: ",
                process2.group
              ]
            }, undefined, true, undefined, this),
            process2.args?.length > 0 && /* @__PURE__ */ jsx("text", {
              color: "gray",
              children: [
                "\u2514\u2500 Args: ",
                process2.args.join(" ")
              ]
            }, undefined, true, undefined, this)
          ]
        }, undefined, true, undefined, this)
      ]
    }, undefined, true, undefined, this)
  }, undefined, false, undefined, this);
}, LogEntryView2 = ({ log: log5, service: service3 }) => {
  const levelColors = {
    debug: "gray",
    info: "blue",
    warn: "yellow",
    error: "red"
  };
  return /* @__PURE__ */ jsx("hstack", {
    children: [
      /* @__PURE__ */ jsx("text", {
        color: "gray",
        children: log5.timestamp.toLocaleTimeString()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("text", {
        color: levelColors[log5.level] || "white",
        children: log5.level.toUpperCase()
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("text", {
        color: "cyan",
        children: [
          "[",
          service3,
          "]"
        ]
      }, undefined, true, undefined, this),
      /* @__PURE__ */ jsx("text", {
        children: log5.message
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
}, ProcessManagerPlugin = ({
  name = "pm",
  description = "Process management and monitoring",
  version = "1.0.0",
  as: as13
} = {}) => {
  console.log(`[ProcessManagerPlugin] Called with name='${name}', as='${as13}'`);
  const pluginName = as13 || name;
  console.log(`[ProcessManagerPlugin] Returning plugin JSX with name='${pluginName}'`);
  const getProcessManagerForHandlers = async (tuixConfig) => {
    return await getProcessManager(tuixConfig);
  };
  return /* @__PURE__ */ jsx("plugin", {
    name: pluginName,
    description,
    version,
    children: [
      /* @__PURE__ */ jsx("command", {
        name: "start",
        description: "Start a service or all services",
        args: {
          service: {
            description: "Service name (optional, starts all if not specified)",
            required: false
          }
        },
        flags: {
          preset: {
            description: "Service preset (vitest, vite, tsc, eslint, bun)",
            alias: "p",
            type: "string",
            choices: ["vitest", "vite", "tsc", "eslint", "bun"]
          },
          command: {
            description: "Custom command to run",
            alias: "c",
            type: "string"
          },
          group: {
            description: "Service group",
            alias: "g",
            type: "string"
          },
          autorestart: {
            description: "Auto-restart on failure",
            alias: "r",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            const serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0) {
                return /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "yellow",
                      children: "No services configured yet."
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "cyan",
                      bold: true,
                      children: "\uD83D\uDCA1 Recommended: Add services to your config file"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: [
                        "Add this to your tuix.config.ts or ",
                        ctx.cliName,
                        ".config.ts:"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("panel", {
                      border: "single",
                      title: "Example Config",
                      children: /* @__PURE__ */ jsx("vstack", {
                        children: [
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "export default defineConfig(",
                              `{`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "  processManager: ",
                              `{`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "    services: ",
                              `{`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "      'dev-server': ",
                              `{`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: "        command: 'npm run dev',"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: "        autorestart: true,"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: "        group: 'development'"
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "      ",
                              `}`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "    ",
                              `}`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              "  ",
                              `}`
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              `}`,
                              ")"
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: [
                        "Or add manually: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --command <cmd>"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: [
                        "Or use a preset: ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <service> --preset vite"
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this);
              }
              const stoppedServices = processes.filter((p) => p.status === "stopped");
              if (stoppedServices.length === 0) {
                return /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "green",
                      children: "\u2705 All services are already running!"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx(ProcessStatusView, {
                      process: processes[0]
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this);
              }
              for (const service3 of stoppedServices) {
                await pm.start(service3.name);
              }
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "green",
                    children: [
                      "\u2705 Started ",
                      stoppedServices.length,
                      " service(s)"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  stoppedServices.map((service3) => /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service3.name
                    ]
                  }, service3.name, true, undefined, this))
                ]
              }, undefined, true, undefined, this);
            }
            const existing = pm.list().find((p) => p.name === serviceName);
            if (!existing) {
              let config4;
              if (ctx.flags.command) {
                config4 = {
                  name: serviceName,
                  command: ctx.flags.command,
                  autorestart: ctx.flags.autorestart || false,
                  group: ctx.flags.group || "default"
                };
              } else {
                config4 = await getServiceConfig(serviceName, ctx.flags.preset);
                if (ctx.flags.group)
                  config4.group = ctx.flags.group;
                if (ctx.flags.autorestart !== undefined)
                  config4.autorestart = ctx.flags.autorestart;
              }
              await pm.add(config4);
            }
            await pm.start(serviceName);
            return /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "\u2705 Service started successfully!"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("panel", {
                  title: "Service Details",
                  border: "rounded",
                  children: /* @__PURE__ */ jsx("vstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        children: [
                          "Name: ",
                          serviceName
                        ]
                      }, undefined, true, undefined, this),
                      ctx.flags.preset && /* @__PURE__ */ jsx("text", {
                        children: [
                          "Preset: ",
                          ctx.flags.preset
                        ]
                      }, undefined, true, undefined, this),
                      ctx.flags.command && /* @__PURE__ */ jsx("text", {
                        children: [
                          "Command: ",
                          ctx.flags.command
                        ]
                      }, undefined, true, undefined, this),
                      ctx.flags.group && /* @__PURE__ */ jsx("text", {
                        children: [
                          "Group: ",
                          ctx.flags.group
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        children: [
                          "Auto-restart: ",
                          ctx.flags.autorestart ? "Yes" : "No"
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              ]
            }, undefined, true, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "red",
                  children: [
                    "\u274C Failed to start service: ",
                    error2.message
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "blue",
                  children: [
                    "Try: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start <service> --preset <preset>"
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "stop",
        description: "Stop a service or all services",
        args: {
          service: {
            description: "Service name (optional, stops all if not specified)",
            required: false
          }
        },
        flags: {
          force: {
            description: "Force stop",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            const serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              const runningServices = processes.filter((p) => p.status === "running");
              if (runningServices.length === 0) {
                return /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: "No services are currently running."
                }, undefined, false, undefined, this);
              }
              for (const service3 of runningServices) {
                await pm.stop(service3.name);
              }
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "green",
                    children: [
                      "\u2705 Stopped ",
                      runningServices.length,
                      " service(s)"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  runningServices.map((service3) => /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service3.name
                    ]
                  }, service3.name, true, undefined, this))
                ]
              }, undefined, true, undefined, this);
            }
            await pm.stop(serviceName);
            return /* @__PURE__ */ jsx("text", {
              color: "green",
              children: [
                "\u2705 Service stopped: ",
                serviceName
              ]
            }, undefined, true, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to stop: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "restart",
        description: "Restart a service or all services",
        args: {
          service: {
            description: "Service name (optional, restarts all if not specified)",
            required: false
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            const serviceName = ctx.args.service;
            if (!serviceName) {
              const processes = pm.list();
              if (processes.length === 0) {
                return /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: "No services configured."
                }, undefined, false, undefined, this);
              }
              await Promise.all(processes.map((service3) => pm.restart(service3.name)));
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "green",
                    children: [
                      "\u2705 Restarted ",
                      processes.length,
                      " service(s)"
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  processes.map((service3) => /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "  \u2022 ",
                      service3.name
                    ]
                  }, service3.name, true, undefined, this))
                ]
              }, undefined, true, undefined, this);
            }
            await pm.restart(serviceName);
            return /* @__PURE__ */ jsx("text", {
              color: "green",
              children: [
                "\u2705 Service restarted: ",
                serviceName
              ]
            }, undefined, true, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to restart: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "status",
        description: "Show process status",
        args: {
          service: {
            description: "Specific service name",
            required: false
          }
        },
        flags: {
          watch: {
            description: "Watch status in real-time",
            alias: "w",
            type: "boolean"
          },
          detailed: {
            description: "Show detailed information",
            alias: "d",
            type: "boolean"
          }
        },
        interactive: (ctx) => ctx.flags.watch === true,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            let processes;
            if (ctx.args.service) {
              const allProcesses = pm.list();
              const serviceProcess = allProcesses.find((p) => p.name === ctx.args.service);
              if (!serviceProcess) {
                return /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "red",
                      children: [
                        "\u274C Service '",
                        ctx.args.service,
                        "' not found"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Available services:"
                    }, undefined, false, undefined, this),
                    allProcesses.length === 0 ? /* @__PURE__ */ jsx("text", {
                      color: "yellow",
                      children: "  No services configured"
                    }, undefined, false, undefined, this) : allProcesses.map((proc) => /* @__PURE__ */ jsx("text", {
                      color: "cyan",
                      children: [
                        "  \u2022 ",
                        proc.name
                      ]
                    }, proc.name, true, undefined, this))
                  ]
                }, undefined, true, undefined, this);
              }
              processes = [serviceProcess];
            } else {
              processes = pm.list();
            }
            return /* @__PURE__ */ jsx("vstack", {
              children: /* @__PURE__ */ jsx("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status Dashboard",
                style: { padding: "1" },
                children: processes.length === 0 ? /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "yellow",
                      children: "\u26A0\uFE0F  No processes configured or running"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: "Quick start options:"
                    }, undefined, false, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " start <name> --preset vite"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        ' start <name> --command "npm run dev"'
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      color: "green",
                      children: [
                        "  \u2022 ",
                        ctx.cliName,
                        " ",
                        pluginName,
                        " config --init"
                      ]
                    }, undefined, true, undefined, this)
                  ]
                }, undefined, true, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("hstack", {
                      children: [
                        /* @__PURE__ */ jsx("text", {
                          color: "gray",
                          children: [
                            "Total: ",
                            processes.length
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsx("text", {
                          color: "green",
                          children: [
                            "Running: ",
                            processes.filter((p) => p.status === "running").length
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsx("text", {
                          color: "red",
                          children: [
                            "Stopped: ",
                            processes.filter((p) => p.status === "stopped").length
                          ]
                        }, undefined, true, undefined, this),
                        /* @__PURE__ */ jsx("text", {
                          color: "yellow",
                          children: [
                            "Other: ",
                            processes.filter((p) => !["running", "stopped"].includes(p.status)).length
                          ]
                        }, undefined, true, undefined, this)
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {
                      children: "\u2500".repeat(80)
                    }, undefined, false, undefined, this),
                    processes.map((proc) => /* @__PURE__ */ jsx(ProcessStatusView, {
                      process: proc,
                      detailed: ctx.flags.detailed
                    }, proc.name, false, undefined, this))
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "logs",
        description: "Show process logs",
        args: {
          service: {
            description: "Service name",
            required: false
          }
        },
        flags: {
          lines: {
            description: "Number of lines to show",
            alias: "n",
            type: "number",
            default: 50
          },
          follow: {
            description: "Follow log output",
            alias: "f",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (!ctx.args.service) {
              const processes = pm.list();
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "cyan",
                    bold: true,
                    children: "Process Logs"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  processes.length === 0 ? /* @__PURE__ */ jsx("text", {
                    color: "yellow",
                    children: "No processes running."
                  }, undefined, false, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                    children: [
                      /* @__PURE__ */ jsx("text", {
                        children: "Available services:"
                      }, undefined, false, undefined, this),
                      processes.map((proc) => /* @__PURE__ */ jsx("text", {
                        color: "green",
                        children: [
                          "  \u2022 ",
                          proc.name
                        ]
                      }, proc.name, true, undefined, this)),
                      /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        color: "gray",
                        children: [
                          "Usage: ",
                          ctx.cliName,
                          " ",
                          pluginName,
                          " logs <service>"
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this);
            }
            const logs = pm.getLogs(ctx.args.service, ctx.flags.lines);
            return /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "blue",
                  bold: true,
                  children: [
                    "\uD83D\uDCDD Logs: ",
                    ctx.args.service
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "gray",
                  children: [
                    "Showing ",
                    logs.length,
                    " entries"
                  ]
                }, undefined, true, undefined, this),
                /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                logs.length === 0 ? /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: "No logs available for this service"
                }, undefined, false, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                  children: [
                    logs.map((log5, i) => /* @__PURE__ */ jsx(LogEntryView2, {
                      log: log5,
                      service: ctx.args.service
                    }, i, false, undefined, this)),
                    ctx.flags.follow && /* @__PURE__ */ jsx("text", {
                      color: "cyan",
                      children: "\uD83D\uDD04 Following logs... Press Ctrl+C to stop"
                    }, undefined, false, undefined, this)
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to get logs: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "dashboard",
        description: "Interactive process and log dashboard",
        flags: {
          logs: {
            description: "Show log dashboard instead of process dashboard",
            alias: "l",
            type: "boolean"
          },
          preset: {
            description: "Apply log filter preset",
            alias: "p",
            type: "string",
            choices: ["errors", "warnings", "debug", "vite", "vitest", "typescript", "production", "recent"]
          },
          refresh: {
            description: "Refresh interval in milliseconds",
            alias: "r",
            type: "number",
            default: 1000
          }
        },
        interactive: true,
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            if (ctx.flags.logs) {
              const processes = pm.list().map((proc) => ({
                name: proc.name,
                logs: pm.getLogs(proc.name, 100),
                status: proc.status
              }));
              return /* @__PURE__ */ jsx("vstack", {
                children: /* @__PURE__ */ jsx("panel", {
                  border: "double",
                  title: "\uD83D\uDCCA Live Log Dashboard",
                  style: { padding: "1" },
                  children: /* @__PURE__ */ jsx("vstack", {
                    children: [
                      /* @__PURE__ */ jsx("hstack", {
                        children: [
                          /* @__PURE__ */ jsx("text", {
                            color: "gray",
                            children: [
                              "Monitoring: ",
                              processes.length,
                              " processes"
                            ]
                          }, undefined, true, undefined, this),
                          ctx.flags.preset && /* @__PURE__ */ jsx("text", {
                            color: "cyan",
                            children: [
                              "Preset: ",
                              ctx.flags.preset
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "blue",
                            children: [
                              "Refresh: ",
                              ctx.flags.refresh,
                              "ms"
                            ]
                          }, undefined, true, undefined, this)
                        ]
                      }, undefined, true, undefined, this),
                      /* @__PURE__ */ jsx("text", {
                        children: "\u2500".repeat(80)
                      }, undefined, false, undefined, this),
                      processes.length === 0 ? /* @__PURE__ */ jsx("panel", {
                        border: "single",
                        style: { padding: "1" },
                        children: /* @__PURE__ */ jsx("vstack", {
                          children: [
                            /* @__PURE__ */ jsx("text", {
                              color: "yellow",
                              children: "\u26A0\uFE0F  No processes running"
                            }, undefined, false, undefined, this),
                            /* @__PURE__ */ jsx("text", {
                              color: "gray",
                              children: [
                                "Start some services first: ",
                                ctx.cliName,
                                " ",
                                pluginName,
                                " start <service>"
                              ]
                            }, undefined, true, undefined, this)
                          ]
                        }, undefined, true, undefined, this)
                      }, undefined, false, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                        children: [
                          /* @__PURE__ */ jsx("panel", {
                            border: "rounded",
                            title: "Process Overview",
                            style: { padding: "1" },
                            children: /* @__PURE__ */ jsx("vstack", {
                              children: processes.map((proc) => {
                                const recentLogs = proc.logs.filter((log5) => Date.now() - log5.timestamp.getTime() < 60000);
                                const errorCount = recentLogs.filter((log5) => log5.level === "error").length;
                                const warnCount = recentLogs.filter((log5) => log5.level === "warn").length;
                                return /* @__PURE__ */ jsx("hstack", {
                                  children: [
                                    /* @__PURE__ */ jsx("text", {
                                      color: proc.status === "running" ? "green" : proc.status === "error" ? "red" : "gray",
                                      children: "\u25CF"
                                    }, undefined, false, undefined, this),
                                    /* @__PURE__ */ jsx("text", {
                                      bold: true,
                                      color: "cyan",
                                      children: proc.name.padEnd(20)
                                    }, undefined, false, undefined, this),
                                    /* @__PURE__ */ jsx("text", {
                                      color: "blue",
                                      children: [
                                        proc.logs.length.toString().padStart(5),
                                        " logs"
                                      ]
                                    }, undefined, true, undefined, this),
                                    errorCount > 0 && /* @__PURE__ */ jsx("text", {
                                      color: "red",
                                      children: [
                                        "  \u274C ",
                                        errorCount,
                                        " errors"
                                      ]
                                    }, undefined, true, undefined, this),
                                    warnCount > 0 && /* @__PURE__ */ jsx("text", {
                                      color: "yellow",
                                      children: [
                                        "  \u26A0\uFE0F  ",
                                        warnCount,
                                        " warnings"
                                      ]
                                    }, undefined, true, undefined, this)
                                  ]
                                }, proc.name, true, undefined, this);
                              })
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("panel", {
                            border: "rounded",
                            title: "Recent Logs",
                            style: { padding: "1", maxHeight: "20" },
                            children: /* @__PURE__ */ jsx("vstack", {
                              children: (() => {
                                const allLogs = [];
                                processes.forEach((proc) => {
                                  proc.logs.forEach((log5) => {
                                    allLogs.push({ ...log5, processName: proc.name });
                                  });
                                });
                                allLogs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                                let filteredLogs = allLogs;
                                if (ctx.flags.preset) {
                                  const presetMap = {
                                    errors: (log5) => log5.level === "error" || log5.level === "fatal",
                                    warnings: (log5) => ["warn", "error", "fatal"].includes(log5.level),
                                    debug: (log5) => log5.level !== "trace",
                                    vite: (log5) => /\b(vite|hmr|dev|build)\b/i.test(log5.message),
                                    vitest: (log5) => /\b(test|vitest|spec|pass|fail)\b/i.test(log5.message),
                                    typescript: (log5) => /\b(typescript|tsc|error ts)\b/i.test(log5.message),
                                    production: (log5) => !log5.message.includes("[DEV]") && !log5.message.includes("hmr"),
                                    recent: (log5) => Date.now() - log5.timestamp.getTime() < 5 * 60 * 1000
                                  };
                                  const presetFilter = presetMap[ctx.flags.preset];
                                  if (presetFilter) {
                                    filteredLogs = filteredLogs.filter(presetFilter);
                                  }
                                }
                                return filteredLogs.slice(0, 20).map((log5, i) => {
                                  const timestamp = log5.timestamp.toLocaleTimeString();
                                  const levelColors = {
                                    error: "red",
                                    warn: "yellow",
                                    info: "blue",
                                    debug: "gray"
                                  };
                                  const color = levelColors[log5.level] || "white";
                                  return /* @__PURE__ */ jsx("hstack", {
                                    children: [
                                      /* @__PURE__ */ jsx("text", {
                                        color: "gray",
                                        children: timestamp
                                      }, undefined, false, undefined, this),
                                      /* @__PURE__ */ jsx("text", {
                                        color: "cyan",
                                        children: [
                                          "[",
                                          log5.processName.padEnd(12),
                                          "]"
                                        ]
                                      }, undefined, true, undefined, this),
                                      /* @__PURE__ */ jsx("text", {
                                        color,
                                        bold: true,
                                        children: log5.level.toUpperCase().padEnd(5)
                                      }, undefined, false, undefined, this),
                                      /* @__PURE__ */ jsx("text", {
                                        children: [
                                          log5.message.substring(0, 80),
                                          log5.message.length > 80 ? "..." : ""
                                        ]
                                      }, undefined, true, undefined, this)
                                    ]
                                  }, i, true, undefined, this);
                                });
                              })()
                            }, undefined, false, undefined, this)
                          }, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                          /* @__PURE__ */ jsx("panel", {
                            border: "single",
                            style: { padding: "0.5" },
                            children: /* @__PURE__ */ jsx("hstack", {
                              children: [
                                /* @__PURE__ */ jsx("text", {
                                  color: "yellow",
                                  children: "\uD83D\uDD04 Live updating..."
                                }, undefined, false, undefined, this),
                                /* @__PURE__ */ jsx("text", {
                                  color: "gray",
                                  children: "Press Ctrl+C to exit"
                                }, undefined, false, undefined, this),
                                /* @__PURE__ */ jsx("text", {
                                  color: "cyan",
                                  children: "Tip: Use --preset for filtering"
                                }, undefined, false, undefined, this)
                              ]
                            }, undefined, true, undefined, this)
                          }, undefined, false, undefined, this)
                        ]
                      }, undefined, true, undefined, this)
                    ]
                  }, undefined, true, undefined, this)
                }, undefined, false, undefined, this)
              }, undefined, false, undefined, this);
            } else {
              await exports_Effect.runPromise(ProcessMonitor({ manager: pm }).pipe(exports_Effect.provide(LiveServices)));
              return /* @__PURE__ */ jsx("text", {
                color: "green",
                children: "Process dashboard exited"
              }, undefined, false, undefined, this);
            }
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to start dashboard: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "config",
        description: "Manage process manager configuration",
        flags: {
          init: {
            description: "Initialize config file with example services",
            type: "boolean"
          },
          show: {
            description: "Show current config",
            type: "boolean"
          },
          path: {
            description: "Show config file path",
            type: "boolean"
          }
        },
        handler: async (ctx) => {
          try {
            if (ctx.flags.init) {
              const configName = ctx.cliName === "tuix" ? "tuix" : ctx.cliName;
              const configPath = `${configName}.config.ts`;
              const configContent = `import { defineConfig } from 'tuix'

export default defineConfig({
  // Process manager services
  processManager: {
    services: {
      // Example development server
      'dev-server': {
        command: 'npm run dev',
        autorestart: true,
        group: 'development',
        env: {
          NODE_ENV: 'development'
        }
      },
      
      // Example test watcher
      'test-watch': {
        command: 'npm run test:watch',
        autorestart: true,
        group: 'testing'
      },
      
      // Example type checker
      'typecheck': {
        command: 'npm run typecheck --watch',
        autorestart: false,
        group: 'quality'
      }
    },
    
    // Process manager settings
    logDir: './logs',
    autoSave: true
  },
  
  // Logger configuration
  logger: {
    level: 'info',
    format: 'json',
    outputs: ['console']
  }
})
`;
              await Bun.write(configPath, configContent);
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "green",
                    children: [
                      "\u2705 Created config file: ",
                      configPath
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "cyan",
                    children: "\uD83D\uDCDD Example services added:"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: "  \u2022 dev-server (npm run dev)"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: "  \u2022 test-watch (npm run test:watch)"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: "  \u2022 typecheck (npm run typecheck --watch)"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "yellow",
                    children: "Edit the config file to customize your services!"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "Then run: ",
                      ctx.cliName,
                      " ",
                      pluginName,
                      " start"
                    ]
                  }, undefined, true, undefined, this)
                ]
              }, undefined, true, undefined, this);
            }
            if (ctx.flags.show) {
              const config4 = ctx.tuixConfig;
              if (!config4) {
                return /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: "No config loaded. Run with --init to create one."
                }, undefined, false, undefined, this);
              }
              const services = config4.processManager?.services || {};
              const serviceCount = Object.keys(services).length;
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "cyan",
                    bold: true,
                    children: "\uD83D\uDCCB Current Configuration"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    children: [
                      "Services configured: ",
                      serviceCount
                    ]
                  }, undefined, true, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  serviceCount > 0 && /* @__PURE__ */ jsx("panel", {
                    title: "Configured Services",
                    border: "rounded",
                    children: /* @__PURE__ */ jsx("vstack", {
                      children: Object.entries(services).map(([name2, service3]) => /* @__PURE__ */ jsx("hstack", {
                        children: [
                          /* @__PURE__ */ jsx("text", {
                            color: "green",
                            children: [
                              name2,
                              ":"
                            ]
                          }, undefined, true, undefined, this),
                          /* @__PURE__ */ jsx("text", {
                            color: "gray",
                            children: service3.command
                          }, undefined, false, undefined, this),
                          service3.group && /* @__PURE__ */ jsx("text", {
                            color: "purple",
                            children: [
                              "[",
                              service3.group,
                              "]"
                            ]
                          }, undefined, true, undefined, this),
                          service3.autorestart && /* @__PURE__ */ jsx("text", {
                            color: "yellow",
                            children: "[auto-restart]"
                          }, undefined, false, undefined, this)
                        ]
                      }, name2, true, undefined, this))
                    }, undefined, false, undefined, this)
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this);
            }
            if (ctx.flags.path) {
              const configName = ctx.cliName === "tuix" ? "tuix" : ctx.cliName;
              const possiblePaths = [
                `${configName}.config.ts`,
                `${configName}.config.js`,
                `tuix.config.ts`,
                `tuix.config.js`,
                `.${configName}/config.ts`,
                `.${configName}/config.js`,
                `.tuix/config.ts`,
                `.tuix/config.js`
              ];
              return /* @__PURE__ */ jsx("vstack", {
                children: [
                  /* @__PURE__ */ jsx("text", {
                    color: "cyan",
                    bold: true,
                    children: "\uD83D\uDCC1 Config File Locations"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: "Config is loaded from first found file:"
                  }, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  possiblePaths.map((path9, i) => /* @__PURE__ */ jsx("text", {
                    color: "gray",
                    children: [
                      "  ",
                      i + 1,
                      ". ",
                      path9
                    ]
                  }, i, true, undefined, this)),
                  /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                  /* @__PURE__ */ jsx("text", {
                    color: "yellow",
                    children: "Use --init to create a config file"
                  }, undefined, false, undefined, this)
                ]
              }, undefined, true, undefined, this);
            }
            return /* @__PURE__ */ jsx("vstack", {
              children: [
                /* @__PURE__ */ jsx("text", {
                  color: "cyan",
                  bold: true,
                  children: "\u2699\uFE0F Process Manager Config"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "gray",
                  children: "Available commands:"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  --init    Create example config file"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  --show    Show current configuration"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "green",
                  children: "  --path    Show config file search paths"
                }, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: [
                    "Example: ",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " config --init"
                  ]
                }, undefined, true, undefined, this)
              ]
            }, undefined, true, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Config command failed: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx("command", {
        name: "ps",
        description: "Show process status (alias)",
        handler: async (ctx) => {
          try {
            const pm = await getProcessManagerForHandlers(ctx.tuixConfig);
            const processes = pm.list();
            return /* @__PURE__ */ jsx("vstack", {
              children: /* @__PURE__ */ jsx("panel", {
                border: "double",
                title: "\uD83D\uDCCA Process Status",
                style: { padding: "1" },
                children: processes.length === 0 ? /* @__PURE__ */ jsx("text", {
                  color: "yellow",
                  children: [
                    "No processes running. Use '",
                    ctx.cliName,
                    " ",
                    pluginName,
                    " start' to begin."
                  ]
                }, undefined, true, undefined, this) : /* @__PURE__ */ jsx("vstack", {
                  children: [
                    /* @__PURE__ */ jsx("text", {
                      color: "gray",
                      children: [
                        processes.length,
                        " process",
                        processes.length > 1 ? "es" : "",
                        " monitored"
                      ]
                    }, undefined, true, undefined, this),
                    /* @__PURE__ */ jsx("text", {}, undefined, false, undefined, this),
                    processes.map((proc) => /* @__PURE__ */ jsx(ProcessStatusView, {
                      process: proc
                    }, proc.name, false, undefined, this))
                  ]
                }, undefined, true, undefined, this)
              }, undefined, false, undefined, this)
            }, undefined, false, undefined, this);
          } catch (error2) {
            return /* @__PURE__ */ jsx("text", {
              color: "red",
              children: [
                "\u274C Failed to get process status: ",
                error2.message
              ]
            }, undefined, true, undefined, this);
          }
        }
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var init_plugin = __esm(() => {
  init_manager2();
  init_process_manager();
  init_logger3();
  init_impl();
  init_esm2();
  init_jsx_dev_runtime19();
});

// ../../src/process-manager/index.ts
async function createProcessManager(config4, cwd) {
  const manager = new ProcessManager(config4, cwd);
  await manager.init();
  return manager;
}
var init_process_manager = __esm(() => {
  init_manager2();
  init_manager2();
  init_manager2();
  init_ProcessMonitor();
  init_plugin();
});

// ../../src/plugins/index.ts
var exports_plugins = {};
__export(exports_plugins, {
  ProcessManagerPlugin: () => ProcessManagerPlugin,
  LoggingPlugin: () => LoggingPlugin
});
var init_plugins = __esm(() => {
  init_logging();
  init_process_manager();
});

// ../../src/jsx/runtime.ts
class JSXPluginRegistry {
  declarativePlugins = new Map;
  scopeManager = scopeManager;
  currentScopeId = null;
  scopeIdStack = [];
  jsxModule = null;
  commandStack = [];
  renderableContent = [];
  activeCommand = null;
  configManager = null;
  constructor() {
    this.initializeJSXModule();
  }
  initializeJSXModule() {
    try {
      const registry = getGlobalRegistry();
      this.jsxModule = registry.getModule("jsx");
      if (this.jsxModule) {
        debug4("JSX Module found and initialized");
      }
    } catch (error2) {
      debug4("JSX Module not available yet:", error2);
    }
  }
  getCurrentScope() {
    if (!this.currentScopeId)
      return null;
    return this.scopeManager.getScopeDef(this.currentScopeId);
  }
  pushScope(scope5) {
    if (this.currentScopeId) {
      this.scopeIdStack.push(this.currentScopeId);
    }
    this.currentScopeId = scope5.id;
    exports_Effect.runSync(this.scopeManager.registerScope(scope5));
  }
  popScope() {
    const current2 = this.getCurrentScope();
    if (this.scopeIdStack.length > 0) {
      this.currentScopeId = this.scopeIdStack.pop();
    } else {
      this.currentScopeId = null;
    }
    return current2;
  }
  registerDeclarativePlugin(name, component2, metadata) {
    debug4("Registering declarative plugin:", name);
    this.declarativePlugins.set(name, {
      component: component2,
      metadata: metadata || {},
      registeredAt: new Date
    });
    const pluginScope = {
      id: `plugin_${name}_${Date.now()}`,
      type: "plugin",
      name,
      path: [name],
      description: metadata?.description,
      executable: true,
      metadata,
      children: []
    };
    this.pushScope(pluginScope);
    if (this.jsxModule) {
      exports_Effect.runSync(this.jsxModule.emitPluginStart(name, pluginScope));
    }
    return name;
  }
  unregisterDeclarativePlugin(name) {
    debug4("Unregistering declarative plugin:", name);
    const allScopes = this.scopeManager.getAllScopes();
    const pluginScope = allScopes.find((s) => s.type === "plugin" && s.name === name);
    if (pluginScope) {
      exports_Effect.runSync(this.scopeManager.removeScope(pluginScope.id));
    }
    this.declarativePlugins.delete(name);
    if (this.currentScopeId === pluginScope?.id) {
      this.popScope();
    }
    if (this.jsxModule && pluginScope) {
      exports_Effect.runSync(this.jsxModule.emitPluginEnd(name));
    }
  }
  getDeclarativePlugin(name) {
    return this.declarativePlugins.get(name);
  }
  listDeclarativePlugins() {
    return Array.from(this.declarativePlugins.keys());
  }
  hasDeclarativePlugin(name) {
    return this.declarativePlugins.has(name);
  }
  registerPlugin(name, plugin, description, version) {
    debug4("Registering loaded plugin:", name);
    const { pluginStore: pluginStore2 } = (init_plugins(), __toCommonJS(exports_plugins));
    pluginStore2.register(plugin);
    pluginStore2.enable(name);
    const pluginScope = {
      id: `plugin_${name}_${Date.now()}`,
      type: "plugin",
      name,
      path: [name],
      description,
      metadata: { version, plugin },
      executable: true,
      children: []
    };
    this.pushScope(pluginScope);
    if (this.jsxModule) {
      exports_Effect.runSync(this.jsxModule.emitPluginStart(name, pluginScope));
    }
    return name;
  }
  unregisterPlugin(name) {
    debug4("Unregistering loaded plugin:", name);
    const { pluginStore: pluginStore2 } = (init_plugins(), __toCommonJS(exports_plugins));
    const allScopes = this.scopeManager.getAllScopes();
    const pluginScope = allScopes.find((s) => s.type === "plugin" && s.name === name);
    if (pluginScope) {
      if (this.currentScopeId === pluginScope.id) {
        this.popScope();
      }
      exports_Effect.runSync(this.scopeManager.removeScope(pluginScope.id));
    }
    if (this.jsxModule) {
      exports_Effect.runSync(this.jsxModule.emitPluginEnd(name));
    }
    pluginStore2.disable(name);
  }
  getPlugin(name) {
    const { pluginStore: pluginStore2 } = (init_plugins(), __toCommonJS(exports_plugins));
    return pluginStore2.isEnabled(name) ? pluginStore2.getPlugin(name) : null;
  }
  listPlugins() {
    const { pluginStore: pluginStore2 } = (init_plugins(), __toCommonJS(exports_plugins));
    return pluginStore2.listEnabled();
  }
  registerCommand(path9, handler, metadata) {
    debug4("Registering command:", path9.join(" "));
    const currentScope = this.getCurrentScope();
    const parentPath = currentScope?.path || [];
    const fullPath = [...parentPath, ...path9];
    const commandScope = {
      id: `command_${fullPath.join("_")}_${Date.now()}`,
      type: "command",
      name: path9[path9.length - 1],
      path: fullPath,
      handler,
      executable: true,
      metadata,
      children: []
    };
    exports_Effect.runSync(this.scopeManager.registerScope(commandScope));
    if (currentScope) {
      currentScope.children.push(commandScope);
    }
    if (this.jsxModule) {
      exports_Effect.runSync(this.jsxModule.emitCommandRegistered(fullPath, commandScope));
    }
    return fullPath.join(" ");
  }
  unregisterCommand(path9) {
    debug4("Unregistering command:", path9.join(" "));
    const allScopes = this.scopeManager.getAllScopes();
    const commandScope = allScopes.find((s) => s.type === "command" && s.path.length === path9.length && s.path.every((p, i) => p === path9[i]));
    if (commandScope) {
      exports_Effect.runSync(this.scopeManager.removeScope(commandScope.id));
    }
  }
  executeCommand(path9, args2 = {}, flags = {}) {
    debug4("Executing command:", path9.join(" "));
    const allScopes = this.scopeManager.getAllScopes();
    const commandScope = allScopes.find((s) => s.type === "command" && s.path.length === path9.length && s.path.every((p, i) => p === path9[i]));
    if (!commandScope || !commandScope.handler) {
      throw new Error(`Command not found: ${path9.join(" ")}`);
    }
    return commandScope.handler({ args: args2, flags });
  }
  setActiveCommand(command) {
    this.activeCommand = command;
  }
  getActiveCommand() {
    return this.activeCommand;
  }
  pushContext(type2, id3, data2) {
    const scope5 = {
      id: `${type2}_${id3}_${Date.now()}`,
      type: type2,
      name: id3,
      path: this.getCurrentScope()?.path ? [...this.getCurrentScope().path, id3] : [id3],
      metadata: data2,
      executable: type2 !== "component",
      children: []
    };
    this.pushScope(scope5);
    this.commandStack.push({ type: type2, id: id3, data: data2 });
  }
  popContext() {
    const context10 = this.commandStack.pop();
    const poppedScope = this.popScope();
    if (context10 && poppedScope) {
      debug4(`Popped ${context10.type} context:`, context10.id);
    }
    return context10;
  }
  getCurrentContext() {
    return this.commandStack[this.commandStack.length - 1] || null;
  }
  getContextStack() {
    return [...this.commandStack];
  }
  pushRenderableContent(content) {
    this.renderableContent.push(content);
  }
  popRenderableContent() {
    return this.renderableContent.pop();
  }
  hasRenderableContent() {
    return this.renderableContent.length > 0;
  }
  getScopedState(key, defaultValue) {
    let currentId = this.currentScopeId;
    while (currentId) {
      const scope5 = this.scopeManager.getScopeDef(currentId);
      if (scope5?.metadata?.[key] !== undefined) {
        return scope5.metadata[key];
      }
      const state = this.scopeManager.getScope(currentId);
      currentId = state?.parentId || null;
    }
    return defaultValue;
  }
  setScopedState(key, value6) {
    const currentScope = this.getCurrentScope();
    if (currentScope) {
      currentScope.metadata = currentScope.metadata || {};
      currentScope.metadata[key] = value6;
    }
  }
  getScopedPlugins() {
    const allScopes = this.scopeManager.getAllScopes();
    return allScopes.filter((s) => s.type === "plugin").map((s) => s.metadata?.plugin).filter(Boolean);
  }
  setConfigManager(configManager) {
    this.configManager = configManager;
  }
  getConfigManager() {
    return this.configManager;
  }
  getScopeManager() {
    return this.scopeManager;
  }
  getCurrentPlugin() {
    const currentScope = this.getCurrentScope();
    if (currentScope?.type === "plugin") {
      return currentScope.metadata?.plugin || null;
    }
    let currentId = this.currentScopeId;
    while (currentId) {
      const scope5 = this.scopeManager.getScopeDef(currentId);
      if (scope5?.type === "plugin") {
        return scope5.metadata?.plugin || null;
      }
      const state = this.scopeManager.getScope(currentId);
      currentId = state?.parentId || null;
    }
    return null;
  }
  getCurrentCommand() {
    const currentScope = this.getCurrentScope();
    if (currentScope?.type === "command") {
      return currentScope;
    }
    let currentId = this.currentScopeId;
    while (currentId) {
      const scope5 = this.scopeManager.getScopeDef(currentId);
      if (scope5?.type === "command") {
        return scope5;
      }
      const state = this.scopeManager.getScope(currentId);
      currentId = state?.parentId || null;
    }
    return null;
  }
  getDebugInfo() {
    return {
      currentScopeId: this.currentScopeId,
      scopeStackDepth: this.scopeIdStack.length,
      commandStackDepth: this.commandStack.length,
      renderableContentDepth: this.renderableContent.length,
      declarativePluginsCount: this.declarativePlugins.size,
      totalScopes: this.scopeManager.getAllScopes().length
    };
  }
}
var DEBUG3, debug4 = (msg, ...args2) => {
  if (DEBUG3) {
    console.log(`[TUIX JSX] ${msg}`, ...args2);
  }
}, registry, jsx = (type2, props, ...children3) => {
  debug4("[RUNTIME] Processing element type:", type2, {
    props: props ? Object.keys(props) : null,
    key: props?.key
  });
  const safeProps = props || {};
  const allChildren = safeProps.children ? Array.isArray(safeProps.children) ? safeProps.children : [safeProps.children] : children3;
  const validChildren = allChildren.flat(Infinity).filter((child) => child != null);
  if (typeof type2 === "function") {
    debug4("[RUNTIME] Calling function component:", type2.name || "Anonymous");
    const componentProps = { ...safeProps, children: validChildren };
    const result = type2(componentProps);
    debug4("[RUNTIME] Function component returned:", typeof result);
    if (result && typeof result === "object") {
      debug4("[RUNTIME] Result details:", {
        render: typeof result.render,
        width: result.width,
        height: result.height
      });
    }
    return result;
  }
  switch (type2) {
    case "text":
      return text(validChildren.join(""));
    case "vstack":
      return vstack(validChildren, safeProps);
    case "hstack":
      return hstack(validChildren, safeProps);
    case "styled-text":
    case "styledText":
      const textContent = validChildren.join("");
      return styledText(textContent, safeProps.style || {});
    case "cli":
      return CLI({ ...safeProps, children: validChildren });
    case "plugin":
      return Plugin({ ...safeProps, children: validChildren });
    case "command":
      return Command({ ...safeProps, children: validChildren });
    case "arg":
      return Arg({ ...safeProps, children: validChildren });
    case "flag":
      return Flag({ ...safeProps, children: validChildren });
    case "option":
      return Option({ ...safeProps, children: validChildren });
    case "help":
      return Help({ ...safeProps, children: validChildren });
    case "example":
      return Example({ ...safeProps, children: validChildren });
    case "exit":
      return Exit3({ ...safeProps, children: validChildren });
    case "load-plugin":
      return LoadPlugin({ ...safeProps, children: validChildren });
    case "command-line-scope":
      return CommandLineScope({ ...safeProps, children: validChildren });
    case "command-line-help":
      return CommandLineHelp({ ...safeProps, children: validChildren });
    case "scope":
      return Scope3({ ...safeProps, children: validChildren });
    case "scope-content":
      return ScopeContent({ ...safeProps, children: validChildren });
    case "scope-fallback":
      return ScopeFallback({ ...safeProps, children: validChildren });
    default:
      debug4(`[RUNTIME] Unknown element type: ${type2}, creating text node`);
      return text(`[${type2}]`);
  }
}, Fragment = ({ children: children3 }) => {
  const childArray = Array.isArray(children3) ? children3 : [children3];
  const validChildren = childArray.filter((child) => child != null);
  if (validChildren.length === 0) {
    return text("");
  }
  if (validChildren.length === 1) {
    return validChildren[0];
  }
  return vstack(validChildren);
}, createElement, registerPlugin, registerCommand2, executeCommand2, getScopeManager;
var init_runtime3 = __esm(() => {
  init_view();
  init_config4();
  init_esm2();
  init_scope();
  init_module_registry();
  init_components5();
  init_components();
  DEBUG3 = process.env.TUIX_DEBUG === "true";
  registry = new JSXPluginRegistry;
  createElement = jsx;
  registerPlugin = registry.registerPlugin.bind(registry);
  registerCommand2 = registry.registerCommand.bind(registry);
  executeCommand2 = registry.executeCommand.bind(registry);
  getScopeManager = registry.getScopeManager.bind(registry);
});

// ../../src/jsx/index.ts
var init_jsx = __esm(() => {
  init_runtime3();
  init_app2();
  init_config_validator();
  init_render2();
  init_system();
  init_text_input();
});

// ../../src/index.ts
init_core3();
init_interactive();
init_services();
init_view();

// ../../src/reactivity/index.ts
init_runes();

// ../../src/index.ts
init_jsx();
init_components4();
init_styling();

// ../../src/layout/types.ts
var FlexDirection;
((FlexDirection2) => {
  FlexDirection2["Row"] = "row";
  FlexDirection2["Column"] = "column";
  FlexDirection2["RowReverse"] = "row-reverse";
  FlexDirection2["ColumnReverse"] = "column-reverse";
})(FlexDirection ||= {});
var JustifyContent;
((JustifyContent2) => {
  JustifyContent2["Start"] = "start";
  JustifyContent2["End"] = "end";
  JustifyContent2["Center"] = "center";
  JustifyContent2["SpaceBetween"] = "space-between";
  JustifyContent2["SpaceAround"] = "space-around";
  JustifyContent2["SpaceEvenly"] = "space-evenly";
})(JustifyContent ||= {});
var AlignItems;
((AlignItems2) => {
  AlignItems2["Start"] = "start";
  AlignItems2["End"] = "end";
  AlignItems2["Center"] = "center";
  AlignItems2["Stretch"] = "stretch";
  AlignItems2["Baseline"] = "baseline";
})(AlignItems ||= {});
var FlexWrap;
((FlexWrap2) => {
  FlexWrap2["NoWrap"] = "nowrap";
  FlexWrap2["Wrap"] = "wrap";
  FlexWrap2["WrapReverse"] = "wrap-reverse";
})(FlexWrap ||= {});
var DividerOrientation;
((DividerOrientation2) => {
  DividerOrientation2["Horizontal"] = "horizontal";
  DividerOrientation2["Vertical"] = "vertical";
})(DividerOrientation ||= {});
// ../../src/layout/flexbox.ts
init_esm2();
init_string_width();
var isRowDirection = (direction) => direction === "row" /* Row */ || direction === "row-reverse" /* RowReverse */;
var getMainAxisDimension = (direction, width, height) => isRowDirection(direction) ? width : height;
var getCrossAxisDimension = (direction, width, height) => isRowDirection(direction) ? height : width;
var getViewSize = (view) => {
  return {
    width: view.width || 0,
    height: view.height || 1
  };
};
var getMainAxisSize = (item, direction) => {
  const size23 = getViewSize(item.view);
  return getMainAxisDimension(direction, size23.width, size23.height);
};
var getCrossAxisSize = (item, direction) => {
  const size23 = getViewSize(item.view);
  return getCrossAxisDimension(direction, size23.width, size23.height);
};
var createBounds2 = (direction, mainPos, crossPos, mainSize, crossSize) => {
  return isRowDirection(direction) ? {
    x: mainPos,
    y: crossPos,
    width: mainSize,
    height: crossSize
  } : {
    x: crossPos,
    y: mainPos,
    width: crossSize,
    height: mainSize
  };
};
var calculateFlexBasis = (item, direction) => {
  if (item.basis === "auto" || item.basis === undefined) {
    return getMainAxisSize(item, direction);
  }
  return item.basis;
};
var calculateInitialPosition = (justifyContent, freeSpace, itemCount) => {
  switch (justifyContent) {
    case "center" /* Center */:
      return freeSpace / 2;
    case "end" /* End */:
      return freeSpace;
    case "space-around" /* SpaceAround */:
      return freeSpace / (itemCount * 2);
    case "space-evenly" /* SpaceEvenly */:
      return freeSpace / (itemCount + 1);
    default:
      return 0;
  }
};
var calculateJustifyGap = (justifyContent, freeSpace, itemCount) => {
  if (itemCount <= 1)
    return 0;
  switch (justifyContent) {
    case "space-between" /* SpaceBetween */:
      return freeSpace / (itemCount - 1);
    case "space-around" /* SpaceAround */:
      return freeSpace / itemCount;
    case "space-evenly" /* SpaceEvenly */:
      return freeSpace / (itemCount + 1);
    default:
      return 0;
  }
};
var calculateTotalGap = (itemCount, gap, direction, props) => {
  if (itemCount <= 1)
    return 0;
  const effectiveGap = isRowDirection(direction) ? props.columnGap ?? gap : props.rowGap ?? gap;
  return (itemCount - 1) * effectiveGap;
};
var calculateFlexLayout = (items, containerWidth, containerHeight, props) => {
  const direction = props.direction ?? "row" /* Row */;
  const justifyContent = props.justifyContent ?? "start" /* Start */;
  const alignItems = props.alignItems ?? "start" /* Start */;
  const wrap = props.wrap ?? "nowrap" /* NoWrap */;
  const gap = props.gap ?? 0;
  const padding = props.padding ?? {};
  const availableWidth = containerWidth - (padding.left ?? 0) - (padding.right ?? 0);
  const availableHeight = containerHeight - (padding.top ?? 0) - (padding.bottom ?? 0);
  const mainAxisSize = getMainAxisDimension(direction, availableWidth, availableHeight);
  const crossAxisSize = getCrossAxisDimension(direction, availableWidth, availableHeight);
  const flexBases = items.map((item) => calculateFlexBasis(item, direction));
  const totalFlexGrow = items.reduce((sum3, item) => sum3 + (item.grow ?? 0), 0);
  const totalFlexShrink = items.reduce((sum3, item) => sum3 + (item.shrink ?? 1), 0);
  const totalGap = calculateTotalGap(items.length, gap, direction, props);
  const totalBasisSize = flexBases.reduce((sum3, basis) => sum3 + basis, 0) + totalGap;
  const remainingSpace = mainAxisSize - totalBasisSize;
  const finalSizes = items.map((item, index) => {
    const basis = flexBases[index] ?? 0;
    let size23 = basis;
    if (remainingSpace > 0 && totalFlexGrow > 0) {
      const grow = item.grow ?? 0;
      size23 += remainingSpace * grow / totalFlexGrow;
    } else if (remainingSpace < 0 && totalFlexShrink > 0) {
      const shrink = item.shrink ?? 1;
      size23 += remainingSpace * shrink / totalFlexShrink;
    }
    return Math.max(0, Math.floor(size23));
  });
  const positions = [];
  let currentPos = isRowDirection(direction) ? padding.left ?? 0 : padding.top ?? 0;
  const totalItemSize = finalSizes.reduce((sum3, size23) => sum3 + size23, 0) + totalGap;
  const freeSpace = mainAxisSize - totalItemSize;
  currentPos += calculateInitialPosition(justifyContent, freeSpace, items.length);
  const justifyGap = calculateJustifyGap(justifyContent, freeSpace, items.length);
  items.forEach((_, index) => {
    positions.push(currentPos);
    currentPos += finalSizes[index] ?? 0;
    if (index < items.length - 1) {
      currentPos += gap + justifyGap;
    }
  });
  const crossPositions = items.map((item, index) => {
    const itemCrossSize = getCrossAxisSize(item, direction);
    const alignSelf = item.alignSelf ?? alignItems;
    switch (alignSelf) {
      case "center" /* Center */:
        return (crossAxisSize - itemCrossSize) / 2;
      case "end" /* End */:
        return crossAxisSize - itemCrossSize;
      case "stretch" /* Stretch */:
        return 0;
      default:
        return 0;
    }
  });
  const children3 = items.map((item, index) => {
    const mainPos = positions[index] ?? 0;
    const crossPos = (crossPositions[index] ?? 0) + (isRowDirection(direction) ? padding.top ?? 0 : padding.left ?? 0);
    const mainSize = finalSizes[index] ?? 0;
    const crossSize = item.alignSelf === "stretch" /* Stretch */ || alignItems === "stretch" /* Stretch */ ? crossAxisSize : getCrossAxisSize(item, direction);
    const bounds = createBounds2(direction, mainPos, crossPos, mainSize, crossSize);
    return { view: item.view, bounds };
  });
  return {
    bounds: {
      x: 0,
      y: 0,
      width: containerWidth,
      height: containerHeight
    },
    children: children3
  };
};
var calculateContainerDimensions = (flexItems, props) => {
  const padding = props.padding ?? {};
  const paddingH = (padding.left ?? 0) + (padding.right ?? 0);
  const paddingV = (padding.top ?? 0) + (padding.bottom ?? 0);
  const direction = props.direction ?? "row" /* Row */;
  const gap = props.gap ?? 0;
  if (isRowDirection(direction)) {
    const contentWidth = flexItems.reduce((sum3, item) => sum3 + getViewSize(item.view).width, 0);
    const totalGap = calculateTotalGap(flexItems.length, gap, direction, props);
    const contentHeight = Math.max(...flexItems.map((item) => getViewSize(item.view).height), 0);
    return {
      width: paddingH + contentWidth + totalGap,
      height: paddingV + contentHeight
    };
  } else {
    const contentHeight = flexItems.reduce((sum3, item) => sum3 + getViewSize(item.view).height, 0);
    const totalGap = calculateTotalGap(flexItems.length, gap, direction, props);
    const contentWidth = Math.max(...flexItems.map((item) => getViewSize(item.view).width), 0);
    return {
      width: paddingH + contentWidth,
      height: paddingV + contentHeight + totalGap
    };
  }
};
var renderChildToBuffer = (buffer4, content, bounds, bufferWidth, bufferHeight) => {
  const lines = content.split(`
`);
  for (let y = 0;y < lines.length && y < bounds.height; y++) {
    const line = lines[y] ?? "";
    const chars = [...line];
    for (let x = 0;x < chars.length && x < bounds.width; x++) {
      const bufferY = bounds.y + y;
      const bufferX = bounds.x + x;
      if (bufferY >= 0 && bufferY < bufferHeight && bufferX >= 0 && bufferX < bufferWidth && buffer4[bufferY] && chars[x]) {
        buffer4[bufferY][bufferX] = chars[x];
      }
    }
  }
};
var flexbox = (items, props = {}) => {
  const flexItems = items.map((item) => ("view" in item) ? item : { view: item });
  const { width: totalWidth, height: totalHeight } = calculateContainerDimensions(flexItems, props);
  return {
    render: () => exports_Effect.gen(function* (_) {
      const layout2 = calculateFlexLayout(flexItems, totalWidth, totalHeight, props);
      const buffer4 = Array(totalHeight).fill(null).map(() => Array(totalWidth).fill(" "));
      for (const child of layout2.children) {
        const content = yield* _(child.view.render());
        renderChildToBuffer(buffer4, content, child.bounds, totalWidth, totalHeight);
      }
      return buffer4.map((row) => row.join("")).join(`
`);
    }),
    width: totalWidth,
    height: totalHeight
  };
};
var hbox = (items, props = {}) => {
  return flexbox(items, { ...props, direction: "row" /* Row */ });
};
var vbox = (items, props = {}) => {
  return flexbox(items, { ...props, direction: "column" /* Column */ });
};
var center2 = (view, options) => {
  const width = options?.width || 80;
  const height = options?.height || 24;
  return {
    render: () => exports_Effect.gen(function* (_) {
      const content = yield* _(view.render());
      const lines = content.split(`
`);
      const contentHeight = lines.length;
      const contentWidth = Math.max(...lines.map((line) => stringWidth(line)), 0);
      const topPadding = Math.max(0, Math.floor((height - contentHeight) / 2));
      const leftPadding = Math.max(0, Math.floor((width - contentWidth) / 2));
      const centeredLines = [];
      for (let i = 0;i < topPadding; i++) {
        centeredLines.push(" ".repeat(width));
      }
      for (const line of lines) {
        const lineWidth = stringWidth(line);
        const linePadding = Math.max(0, Math.floor((width - lineWidth) / 2));
        const paddedLine = " ".repeat(linePadding) + line;
        centeredLines.push(paddedLine.padEnd(width));
      }
      while (centeredLines.length < height) {
        centeredLines.push(" ".repeat(width));
      }
      return centeredLines.slice(0, height).join(`
`);
    }),
    width,
    height
  };
};
var spread = (items, props = {}) => {
  return flexbox(items, {
    ...props,
    justifyContent: "space-between" /* SpaceBetween */
  });
};
// ../../src/layout/grid.ts
init_esm2();
var calculateAutoSize = (availableSize, totalFractions, fractionSize) => {
  return Math.max(fractionSize, 10);
};
var calculateMinContentSize = () => {
  return 5;
};
var calculateMaxContentSize = (availableSize) => {
  return Math.floor(availableSize * 0.3);
};
var generateAutoRows = (rowCount, availableHeight) => {
  const rowHeight = Math.max(3, Math.floor(availableHeight / rowCount));
  return Array(rowCount).fill(0).map(() => ({ type: "fixed", size: rowHeight }));
};
var calculateDefaultCellSizes = (items, template) => {
  const columnCount = template.columns.length;
  const hasFixedColumns = template.columns.some((col) => col.type === "fixed");
  return {
    cellWidth: hasFixedColumns ? 15 : 20,
    cellHeight: 3
  };
};
var calculateSpanDimensions = (bounds, columnSizes, rowSizes, columnGap, rowGap) => {
  let width = 0;
  for (let col = bounds.colStart;col < bounds.colEnd && col < columnSizes.length; col++) {
    width += columnSizes[col] ?? 0;
    if (col < bounds.colEnd - 1) {
      width += columnGap;
    }
  }
  let height = 0;
  for (let row = bounds.rowStart;row < bounds.rowEnd && row < rowSizes.length; row++) {
    height += rowSizes[row] ?? 0;
    if (row < bounds.rowEnd - 1) {
      height += rowGap;
    }
  }
  return { width, height };
};
var renderChildToGridBuffer = (buffer4, content, bounds, bufferWidth, bufferHeight) => {
  const lines = content.split(`
`);
  for (let y = 0;y < lines.length && y < bounds.height; y++) {
    const line = lines[y] ?? "";
    const chars = [...line];
    for (let x = 0;x < chars.length && x < bounds.width; x++) {
      const bufferY = bounds.y + y;
      const bufferX = bounds.x + x;
      if (bufferY >= 0 && bufferY < bufferHeight && bufferX >= 0 && bufferX < bufferWidth && buffer4[bufferY] && chars[x]) {
        buffer4[bufferY][bufferX] = chars[x] ?? " ";
      }
    }
  }
};
var parseTrackSize = (track2, availableSize, totalFractions, fractionSize) => {
  switch (track2.type) {
    case "fixed":
      return track2.size;
    case "fraction":
      return Math.floor(track2.fraction * fractionSize);
    case "auto":
      return calculateAutoSize(availableSize, totalFractions, fractionSize);
    case "min-content":
      return calculateMinContentSize();
    case "max-content":
      return calculateMaxContentSize(availableSize);
  }
};
var calculateTrackSizes = (tracks, availableSize, gap) => {
  const totalGap = Math.max(0, (tracks.length - 1) * gap);
  const availableForTracks = availableSize - totalGap;
  let fixedSize = 0;
  let totalFractions = 0;
  tracks.forEach((track2) => {
    if (track2.type === "fixed") {
      fixedSize += track2.size;
    } else if (track2.type === "fraction") {
      totalFractions += track2.fraction;
    } else if (track2.type === "auto") {
      totalFractions += 1;
    }
  });
  const remainingSize = Math.max(0, availableForTracks - fixedSize);
  const fractionSize = totalFractions > 0 ? remainingSize / totalFractions : 0;
  return tracks.map((track2) => parseTrackSize(track2, availableSize, totalFractions, fractionSize));
};
var calculateTrackPositions = (sizes, gap) => {
  const positions = [];
  let currentPos = 0;
  sizes.forEach((size23, index) => {
    positions.push(currentPos);
    currentPos += size23;
    if (index < sizes.length - 1) {
      currentPos += gap;
    }
  });
  return positions;
};
var getCellBounds = (placement, itemIndex, columnCount) => {
  if (!placement) {
    const row = Math.floor(itemIndex / columnCount);
    const col = itemIndex % columnCount;
    return {
      colStart: col,
      colEnd: col + 1,
      rowStart: row,
      rowEnd: row + 1
    };
  }
  let colStart = 0;
  let colEnd = 1;
  let rowStart = 0;
  let rowEnd = 1;
  if (placement.column !== undefined) {
    if (typeof placement.column === "number") {
      colStart = placement.column;
      colEnd = colStart + (placement.columnSpan ?? 1);
    } else {
      colStart = placement.column.start;
      colEnd = placement.column.end;
    }
  }
  if (placement.row !== undefined) {
    if (typeof placement.row === "number") {
      rowStart = placement.row;
      rowEnd = rowStart + (placement.rowSpan ?? 1);
    } else {
      rowStart = placement.row.start;
      rowEnd = placement.row.end;
    }
  }
  return { colStart, colEnd, rowStart, rowEnd };
};
var calculateGridLayout = (items, containerWidth, containerHeight, props) => {
  const template = props.template ?? {
    columns: [{ type: "fraction", fraction: 1 }],
    rows: [{ type: "auto" }]
  };
  const gap = props.gap ?? 0;
  const columnGap = props.columnGap ?? gap;
  const rowGap = props.rowGap ?? gap;
  const padding = props.padding ?? {};
  const availableWidth = containerWidth - (padding.left ?? 0) - (padding.right ?? 0);
  const availableHeight = containerHeight - (padding.top ?? 0) - (padding.bottom ?? 0);
  const columnSizes = calculateTrackSizes(template.columns, availableWidth, columnGap);
  const columnPositions = calculateTrackPositions(columnSizes, columnGap);
  const rowCount = Math.ceil(items.length / template.columns.length);
  const rows = template.rows.length > 0 ? template.rows : generateAutoRows(rowCount, availableHeight);
  const rowSizes = calculateTrackSizes(rows, availableHeight, rowGap);
  const rowPositions = calculateTrackPositions(rowSizes, rowGap);
  const children3 = items.map((item, index) => {
    const bounds = getCellBounds(item.placement, index, template.columns.length);
    const x = (padding.left ?? 0) + (columnPositions[bounds.colStart] ?? 0);
    const y = (padding.top ?? 0) + (rowPositions[bounds.rowStart] ?? 0);
    const { width, height } = calculateSpanDimensions(bounds, columnSizes, rowSizes, columnGap, rowGap);
    const cellBounds = { x, y, width, height };
    return { view: item.view, bounds: cellBounds };
  });
  return {
    bounds: {
      x: 0,
      y: 0,
      width: containerWidth,
      height: containerHeight
    },
    children: children3
  };
};
var grid = (items, props = {}) => {
  const gridItems = items.map((item) => ("view" in item) && ("placement" in item) ? item : { view: item });
  const template = props.template ?? {
    columns: [{ type: "fraction", fraction: 1 }],
    rows: [{ type: "auto" }]
  };
  const padding = props.padding ?? {};
  const paddingH = (padding.left ?? 0) + (padding.right ?? 0);
  const paddingV = (padding.top ?? 0) + (padding.bottom ?? 0);
  const columnCount = template.columns.length;
  const rowCount = Math.ceil(gridItems.length / columnCount);
  const { cellWidth, cellHeight } = calculateDefaultCellSizes(gridItems, template);
  const gap = props.gap ?? 0;
  const totalWidth = paddingH + cellWidth * columnCount + gap * (columnCount - 1);
  const totalHeight = paddingV + cellHeight * rowCount + gap * (rowCount - 1);
  return {
    render: () => exports_Effect.gen(function* (_) {
      const layout2 = calculateGridLayout(gridItems, totalWidth, totalHeight, props);
      const buffer4 = Array(totalHeight).fill(null).map(() => Array(totalWidth).fill(" "));
      for (const child of layout2.children) {
        const content = yield* _(child.view.render());
        renderChildToGridBuffer(buffer4, content, child.bounds, totalWidth, totalHeight);
      }
      return buffer4.map((row) => row.join("")).join(`
`);
    }),
    width: totalWidth,
    height: totalHeight
  };
};
var columns = (count6) => ({
  columns: Array(count6).fill({ type: "fraction", fraction: 1 }),
  rows: [{ type: "auto" }]
});
var template = (columnSpec, rowSpec) => {
  const parseSpec = (spec) => {
    return spec.split(/\s+/).map((part) => {
      if (part.endsWith("fr")) {
        const fraction = parseFloat(part);
        return { type: "fraction", fraction };
      } else if (part === "auto") {
        return { type: "auto" };
      } else {
        const size23 = parseInt(part);
        return { type: "fixed", size: size23 };
      }
    });
  };
  return {
    columns: parseSpec(columnSpec),
    rows: rowSpec ? parseSpec(rowSpec) : [{ type: "auto" }]
  };
};
var gridItem = (view, placement) => ({
  view,
  placement
});
var span4 = (view, columnSpan, rowSpan = 1) => ({
  view,
  placement: { columnSpan, rowSpan }
});
// ../../src/layout/spacer.ts
init_esm2();
init_styling();
var spacer = (props = {}) => {
  const size23 = props.size ?? 1;
  const flex2 = props.flex ?? 0;
  return {
    render: () => exports_Effect.succeed(" ".repeat(size23)),
    width: size23,
    height: 1,
    flex: flex2
  };
};
var hspace = (width) => {
  return {
    render: () => exports_Effect.succeed(" ".repeat(width)),
    width,
    height: 1
  };
};
var vspace = (height) => {
  return {
    render: () => exports_Effect.succeed(Array(height).fill("").join(`
`)),
    width: 1,
    height
  };
};
var flexSpacer = (flex2 = 1) => {
  return spacer({ flex: flex2 });
};
var divider = (props = {}) => {
  const orientation = props.orientation ?? "horizontal" /* Horizontal */;
  const char = props.char ?? (orientation === "horizontal" /* Horizontal */ ? "\u2500" : "\u2502");
  const dividerStyle = props.style ?? style();
  if (orientation === "horizontal" /* Horizontal */) {
    return {
      render: () => exports_Effect.gen(function* (_) {
        const width = 40;
        const line = char.repeat(width);
        return renderStyledSync(line, dividerStyle);
      }),
      width: 40,
      height: 1
    };
  } else {
    return {
      render: () => exports_Effect.gen(function* (_) {
        const height = 10;
        const lines = Array(height).fill(char);
        return lines.map((line) => renderStyledSync(line, dividerStyle)).join(`
`);
      }),
      width: 1,
      height: 10
    };
  }
};
var DIVIDER_STYLES = {
  solid: { horizontal: "\u2500", vertical: "\u2502" },
  dotted: { horizontal: "\xB7", vertical: "\u22EE" },
  dashed: { horizontal: "\u254C", vertical: "\u250A" },
  double: { horizontal: "\u2550", vertical: "\u2551" },
  thick: { horizontal: "\u2501", vertical: "\u2503" }
};
var createStyledDivider = (styleType, orientation = "horizontal" /* Horizontal */, style3) => {
  const chars = DIVIDER_STYLES[styleType];
  const char = orientation === "horizontal" /* Horizontal */ ? chars.horizontal : chars.vertical;
  return divider({ orientation, char, style: style3 });
};
var hdivider = (char, style3) => divider({ orientation: "horizontal" /* Horizontal */, char, style: style3 });
var vdivider = (char, style3) => divider({ orientation: "vertical" /* Vertical */, char, style: style3 });
var dottedDivider = (style3, orientation) => createStyledDivider("dotted", orientation, style3);
var dashedDivider = (style3, orientation) => createStyledDivider("dashed", orientation, style3);
var doubleDivider = (style3, orientation) => createStyledDivider("double", orientation, style3);
var thickDivider = (style3, orientation) => createStyledDivider("thick", orientation, style3);
var spaced3 = (views, spacing, orientation = "vertical") => {
  if (views.length <= 1)
    return views;
  const spacerView = orientation === "horizontal" ? hspace(spacing) : vspace(spacing);
  const result = [];
  views.forEach((view, index) => {
    result.push(view);
    if (index < views.length - 1) {
      result.push(spacerView);
    }
  });
  return result;
};
var separated = (views, dividerView = hdivider()) => {
  if (views.length <= 1)
    return views;
  const result = [];
  views.forEach((view, index) => {
    result.push(view);
    if (index < views.length - 1) {
      result.push(dividerView);
    }
  });
  return result;
};

// ../../src/layout/index.ts
init_box2();
init_join();

// ../../src/layout/dynamic-layout.ts
init_esm2();
var fixedSpacer = (options) => {
  const height = typeof options === "number" ? options : options.height;
  const char = typeof options === "object" ? options.char || " " : " ";
  const lines = Array(height).fill(char);
  return {
    render: () => exports_Effect.succeed(lines.join(`
`)),
    width: 1,
    height
  };
};
var conditionalSpacer = (options) => {
  if (!options.condition) {
    return {
      render: () => exports_Effect.succeed(""),
      width: 0,
      height: 0
    };
  }
  return fixedSpacer({ height: options.height, char: options.char });
};
var dynamicSpacer = (minHeight = 1, maxHeight = 5) => {
  const height = Math.floor((minHeight + maxHeight) / 2);
  return fixedSpacer(height);
};
var calculateDimensions = (lines) => ({
  height: lines.length,
  width: Math.max(...lines.map((line) => line.length), 0)
});
var applyAlignment = (lines, targetWidth, align) => {
  return lines.map((line) => {
    const padding = Math.max(0, targetWidth - line.length);
    switch (align) {
      case "center":
        const leftPad = Math.floor(padding / 2);
        const rightPad = padding - leftPad;
        return " ".repeat(leftPad) + line + " ".repeat(rightPad);
      case "right":
        return " ".repeat(padding) + line;
      default:
        return line + " ".repeat(padding);
    }
  });
};
var applyHeightConstraints = (lines, minHeight, maxHeight) => {
  const result = [...lines];
  while (result.length < minHeight) {
    result.push("");
  }
  if (result.length > maxHeight) {
    result.splice(maxHeight);
  }
  return result;
};
var processChildrenWithGaps = (renderedChildren, gap) => {
  const allLines = [];
  let maxWidth = 0;
  renderedChildren.forEach(({ rendered, index }, arrayIndex) => {
    if (rendered) {
      const lines = rendered.split(`
`);
      allLines.push(...lines);
      const { width } = calculateDimensions(lines);
      maxWidth = Math.max(maxWidth, width);
      if (arrayIndex < renderedChildren.length - 1 && gap > 0) {
        allLines.push(...Array(gap).fill(""));
      }
    }
  });
  return { lines: allLines, maxWidth };
};
var dynamicVBox = (children3, options) => {
  const gap = options?.gap ?? 0;
  const align = options?.align ?? "left";
  const minHeight = options?.minHeight ?? 0;
  const maxHeight = options?.maxHeight ?? Infinity;
  return {
    render: () => exports_Effect.gen(function* (_) {
      const renderedChildren = [];
      for (let i = 0;i < children3.length; i++) {
        const child = children3[i];
        if (child) {
          const rendered = yield* _(child.render());
          renderedChildren.push({ rendered, index: i });
        }
      }
      const { lines, maxWidth } = processChildrenWithGaps(renderedChildren, gap);
      const constrainedLines = applyHeightConstraints(lines, minHeight, maxHeight);
      const alignedLines = applyAlignment(constrainedLines, maxWidth, align);
      return alignedLines.join(`
`);
    }),
    width: 0,
    height: 0
  };
};
var heightAwareContainer = (content, onHeightChange) => {
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(content.render());
      const lines = rendered.split(`
`);
      const actualHeight = lines.length;
      if (onHeightChange) {
        onHeightChange(actualHeight);
      }
      return rendered;
    }),
    width: content.width,
    height: content.height
  };
};
var paddedContainer = (content, padding) => {
  const { top = 0, right: right3 = 0, bottom = 0, left: left3 = 0 } = padding;
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(content.render());
      const lines = rendered.split(`
`);
      const paddedLines = lines.map((line) => {
        const leftPad = " ".repeat(left3);
        const rightPad = " ".repeat(right3);
        return leftPad + line + rightPad;
      });
      const topPadding = Array(top).fill(" ".repeat(left3 + content.width + right3));
      const bottomPadding = Array(bottom).fill(" ".repeat(left3 + content.width + right3));
      return [...topPadding, ...paddedLines, ...bottomPadding].join(`
`);
    }),
    width: content.width + left3 + right3,
    height: content.height + top + bottom
  };
};
var responsiveLayout = (narrow, wide, breakpoint = 80) => {
  return {
    render: () => exports_Effect.gen(function* (_) {
      const terminalWidth = process.stdout.columns || 80;
      if (terminalWidth < breakpoint) {
        return yield* _(narrow.render());
      } else {
        return yield* _(wide.render());
      }
    }),
    width: 0,
    height: 0
  };
};
var scrollableView = (content, viewportHeight, scrollOffset = 0) => {
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(content.render());
      const lines = rendered.split(`
`);
      const visibleLines = lines.slice(scrollOffset, scrollOffset + viewportHeight);
      while (visibleLines.length < viewportHeight) {
        visibleLines.push("");
      }
      return visibleLines.join(`
`);
    }),
    width: content.width,
    height: viewportHeight
  };
};
var formField = (label, input2, error2, options) => {
  const labelGap = options?.labelGap ?? 0;
  const errorGap = options?.errorGap ?? 0;
  const views = [label];
  if (labelGap > 0) {
    views.push(fixedSpacer(labelGap));
  }
  views.push(input2);
  if (error2) {
    if (errorGap > 0) {
      views.push(fixedSpacer(errorGap));
    }
    views.push(error2);
  }
  return dynamicVBox(views);
};
var formSection = (fields, options) => {
  const gap = options?.gap ?? 1;
  const titleGap = options?.titleGap ?? 2;
  const views = [];
  if (options?.title) {
    views.push(options.title);
    if (titleGap > 0) {
      views.push(fixedSpacer(titleGap));
    }
  }
  for (let i = 0;i < fields.length; i++) {
    const field = fields[i];
    if (field) {
      views.push(field);
      if (i < fields.length - 1 && gap > 0) {
        views.push(fixedSpacer(gap));
      }
    }
  }
  return dynamicVBox(views);
};
// ../../src/layout/simple.ts
init_esm2();
init_string_width();
var simpleLayout = (content, options = {}) => {
  const { padding = 0, width, height, align = "left" } = options;
  return {
    render: () => exports_Effect.gen(function* (_) {
      const rendered = yield* _(content.render());
      const lines = rendered.split(`
`);
      if (padding > 0) {
        const paddedLines = lines.map((line) => " ".repeat(padding) + line + " ".repeat(padding));
        const emptyLine = " ".repeat((content.width || 0) + padding * 2);
        return [
          ...Array(padding).fill(emptyLine),
          ...paddedLines,
          ...Array(padding).fill(emptyLine)
        ].join(`
`);
      }
      if (width && width > (content.width || 0)) {
        const alignedLines = lines.map((line) => {
          const lineWidth = stringWidth(line);
          const space = width - lineWidth;
          switch (align) {
            case "center":
              const leftPad = Math.floor(space / 2);
              const rightPad = space - leftPad;
              return " ".repeat(leftPad) + line + " ".repeat(rightPad);
            case "right":
              return " ".repeat(space) + line;
            default:
              return line + " ".repeat(space);
          }
        });
        return alignedLines.join(`
`);
      }
      return rendered;
    }),
    width: width || (content.width || 0) + padding * 2,
    height: height || (content.height || 0) + padding * 2
  };
};
var layered = (layers, width, height) => {
  if (layers.length === 0) {
    return { render: () => exports_Effect.succeed(""), width, height };
  }
  return {
    render: () => exports_Effect.gen(function* (_) {
      const buffer4 = Array(height).fill(null).map(() => Array(width).fill(" "));
      for (const layer of layers) {
        const content = yield* _(layer.render());
        const lines = content.split(`
`);
        for (let y = 0;y < lines.length && y < height; y++) {
          const line = lines[y] ?? "";
          const chars = [...line];
          for (let x = 0;x < chars.length && x < width; x++) {
            const char = chars[x];
            if (char && char !== " " && buffer4[y]) {
              buffer4[y][x] = char;
            }
          }
        }
      }
      return buffer4.map((row) => row.join("")).join(`
`);
    }),
    width,
    height
  };
};
// ../../src/cli/index.ts
init_config5();
init_parser();
init_router();

// ../../src/cli/plugin.ts
function definePlugin(plugin) {
  if (!plugin.metadata?.name) {
    throw new Error("Plugin must have a name in metadata");
  }
  if (!plugin.metadata?.version) {
    throw new Error("Plugin must have a version in metadata");
  }
  if (plugin.commands) {
    for (const [name, command] of Object.entries(plugin.commands)) {
      if (command.handler && typeof command.handler !== "function") {
        throw new Error(`Command '${name}' handler must be a function`);
      }
    }
  }
  return plugin;
}
function createPlugin(options, metadata) {
  throw new Error(`createPlugin() has been removed. Please use one of the following methods instead:
` + `1. definePlugin() - Recommended for most use cases
` + `2. class MyPlugin extends BasePlugin - For complex plugins
` + `3. class MyPlugin implements PluginInterface - For full control
` + `4. JSX <Plugin> components - For declarative plugin definition

` + `Example migration:
` + `// Old:
` + `createPlugin({metadata: {...}, commands: {...}})
` + `// New:
` + "definePlugin({metadata: {...}, commands: {...}})");
}
function checkPluginCompatibility(plugin, cliVersion) {
  const requiredVersion = plugin.metadata.engines?.["cli-kit"];
  if (!requiredVersion) {
    return { compatible: true };
  }
  const [reqMajor] = requiredVersion.split(".");
  const [cliMajor] = cliVersion.split(".");
  if (reqMajor !== cliMajor) {
    return {
      compatible: false,
      reason: `Plugin requires CLI version ${requiredVersion}, but ${cliVersion} is installed`
    };
  }
  return { compatible: true };
}
function composePlugins(plugins, ...morePlugins) {
  const allPlugins = Array.isArray(plugins) ? plugins : [plugins, ...morePlugins];
  return {
    metadata: {
      name: "composed-plugin",
      version: "1.0.0",
      description: `Composed from: ${allPlugins.map((p) => p.metadata.name).join(", ")}`
    },
    commands: allPlugins.reduce((acc, plugin) => ({
      ...acc,
      ...plugin.commands
    }), {}),
    extensions: allPlugins.reduce((acc, plugin) => ({
      ...acc,
      ...plugin.extensions
    }), {}),
    install: async (context10) => {
      for (const plugin of allPlugins) {
        if (plugin.install) {
          await plugin.install(context10);
        }
      }
    }
  };
}
function validatePlugin(plugin) {
  const errors2 = [];
  if (!plugin || typeof plugin !== "object") {
    errors2.push("Plugin must be an object");
    return { valid: false, errors: errors2 };
  }
  if (!plugin.metadata) {
    errors2.push("Plugin must have metadata");
    return { valid: false, errors: errors2 };
  }
  if (!plugin.metadata.name || plugin.metadata.name.trim() === "") {
    errors2.push("Plugin must have a valid name");
  }
  if (!plugin.metadata.version) {
    errors2.push("Plugin must have a version in metadata");
  }
  if (plugin.metadata.version && !plugin.metadata.version.match(/^\d+\.\d+\.\d+/)) {
    errors2.push("Plugin version must be in semver format (e.g., 1.0.0)");
  }
  if (plugin.commands) {
    for (const [name, command] of Object.entries(plugin.commands)) {
      if (command.handler && typeof command.handler !== "function") {
        errors2.push(`Command '${name}' handler must be a function`);
      }
      if (command.args && (!("parse" in command.args) || typeof command.args.parse !== "function")) {
        errors2.push(`Command '${name}' args must be a valid Zod schema`);
      }
      if (command.options) {
        for (const [optName, schema] of Object.entries(command.options)) {
          if (!schema || !("parse" in schema) || typeof schema.parse !== "function") {
            errors2.push(`Command '${name}' option '${optName}' must be a valid Zod schema`);
          }
        }
      }
    }
  }
  return {
    valid: errors2.length === 0,
    errors: errors2
  };
}

class PluginManager {
  context;
  plugins = new Map;
  initialized = false;
  constructor(context10) {
    this.context = context10;
  }
  async load(plugin) {
    const validation = validatePlugin(plugin);
    if (!validation.valid) {
      throw new Error(`Invalid plugin: ${validation.errors?.join(", ")}`);
    }
    this.plugins.set(plugin.metadata.name, plugin);
    if (plugin.install) {
      await plugin.install(this.context);
    }
  }
  async register(plugin) {
    if (plugin.metadata.dependencies) {
      for (const [depName, depVersion] of Object.entries(plugin.metadata.dependencies)) {
        const dependency = this.plugins.get(depName);
        if (!dependency) {
          throw new Error(`Plugin ${plugin.metadata.name} requires ${depName}@${depVersion} but it is not loaded`);
        }
        if (dependency.metadata.dependencies?.[plugin.metadata.name]) {
          throw new Error(`Circular dependency detected between ${plugin.metadata.name} and ${depName}`);
        }
      }
    }
    await this.load(plugin);
  }
  async initialize(context10) {
    if (this.initialized)
      return true;
    const sortedPlugins = resolvePluginDependencies(Array.from(this.plugins.values()));
    this.plugins.clear();
    for (const plugin of sortedPlugins) {
      this.plugins.set(plugin.metadata.name, plugin);
    }
    this.initialized = true;
    return true;
  }
  async unload(pluginName) {
    const plugin = this.plugins.get(pluginName);
    if (!plugin)
      return;
    if (plugin.uninstall) {
      await plugin.uninstall(this.context);
    }
    this.plugins.delete(pluginName);
  }
  getPlugin(name) {
    return this.plugins.get(name);
  }
  getAllPlugins() {
    return Array.from(this.plugins.values());
  }
}
function createPluginManager(context10) {
  return new PluginManager(context10);
}
function resolvePluginDependencies(plugins) {
  const sorted = [];
  const visited = new Set;
  const visiting = new Set;
  function visit(plugin) {
    if (visited.has(plugin.metadata.name))
      return;
    if (visiting.has(plugin.metadata.name)) {
      throw new Error(`Circular dependency detected: ${plugin.metadata.name}`);
    }
    visiting.add(plugin.metadata.name);
    visiting.delete(plugin.metadata.name);
    visited.add(plugin.metadata.name);
    sorted.push(plugin);
  }
  for (const plugin of plugins) {
    visit(plugin);
  }
  return sorted;
}

class PluginBuilder {
  constructor() {
    throw new Error(`PluginBuilder has been removed. Please use one of the following methods instead:
` + `1. definePlugin() - Recommended for most use cases
` + `2. class MyPlugin extends BasePlugin - For complex plugins with lifecycle
` + `3. class MyPlugin implements PluginInterface - For full control
` + `4. JSX <Plugin> components - For declarative plugin definition

` + `Example migration:
` + `// Old:
` + `new PluginBuilder()
` + `  .metadata({name: "my-plugin"})
` + `  .command("hello", {...})
` + `  .build()
` + `// New:
` + `definePlugin({
` + `  metadata: {name: "my-plugin"},
` + `  commands: {hello: {...}}
` + "})");
  }
}
var PluginUtils = {
  async loadFromPath(path9) {
    const module = await import(path9);
    const plugin = module.default || module.plugin;
    if (!plugin) {
      throw new Error(`No default export or 'plugin' export found in ${path9}`);
    }
    return plugin;
  },
  async loadFromPackage(packageName) {
    try {
      const module = await import(packageName);
      return module.default || module.plugin;
    } catch (error2) {
      throw new Error(`Failed to load plugin from package '${packageName}': ${error2}`);
    }
  },
  commandPlugin(name, command, config4) {
    return definePlugin({
      metadata: { name, version: "1.0.0" },
      commands: { [command]: config4 }
    });
  }
};
// ../../src/cli/registry.ts
init_esm2();

class PluginRegistry {
  plugins = new Map;
  options;
  dependencyGraph = {
    nodes: new Map,
    edges: new Map
  };
  constructor(options = {}) {
    this.options = {
      autoEnable: options.autoEnable ?? true,
      validateDependencies: options.validateDependencies ?? true,
      allowDuplicates: options.allowDuplicates ?? false
    };
  }
  register(plugin, config4) {
    const name = plugin.metadata.name;
    if (this.plugins.has(name) && !this.options.allowDuplicates) {
      console.warn(`Plugin '${name}' is already registered`);
      return false;
    }
    const registered = {
      plugin,
      enabled: this.options.autoEnable,
      loadTime: new Date,
      dependencies: this.extractDependencies(plugin),
      dependents: [],
      config: config4
    };
    if (this.options.validateDependencies) {
      const missingDeps = this.getMissingDependencies(registered.dependencies);
      if (missingDeps.length > 0) {
        console.error(`Plugin '${name}' has missing dependencies: ${missingDeps.join(", ")}`);
        if (!this.options.autoEnable) {
          return false;
        }
        registered.enabled = false;
      }
    }
    this.plugins.set(name, registered);
    this.updateDependencyGraph(name, registered);
    if (registered.enabled && plugin.install) {
      const context10 = this.createPluginContext(name);
      try {
        const result = plugin.install(context10);
        if (result instanceof Promise) {
          result.catch((error2) => {
            console.error(`Plugin '${name}' install failed:`, error2);
            registered.enabled = false;
          });
        }
      } catch (error2) {
        console.error(`Plugin '${name}' install failed:`, error2);
        registered.enabled = false;
      }
    }
    return true;
  }
  async unregister(name) {
    const registered = this.plugins.get(name);
    if (!registered) {
      return false;
    }
    if (registered.dependents.length > 0) {
      console.warn(`Cannot unregister plugin '${name}' - required by: ${registered.dependents.join(", ")}`);
      return false;
    }
    if (registered.plugin.uninstall) {
      const context10 = this.createPluginContext(name);
      try {
        await registered.plugin.uninstall(context10);
      } catch (error2) {
        console.error(`Plugin '${name}' uninstall error:`, error2);
      }
    }
    this.plugins.delete(name);
    this.removeDependencyGraph(name);
    return true;
  }
  async enable(name) {
    const registered = this.plugins.get(name);
    if (!registered) {
      return false;
    }
    if (registered.enabled) {
      return true;
    }
    const missingDeps = this.getMissingDependencies(registered.dependencies);
    if (missingDeps.length > 0) {
      console.error(`Cannot enable plugin '${name}' - missing dependencies: ${missingDeps.join(", ")}`);
      return false;
    }
    if (registered.plugin.activate) {
      const context10 = this.createPluginContext(name);
      try {
        await registered.plugin.activate(context10);
      } catch (error2) {
        console.error(`Plugin '${name}' activation failed:`, error2);
        return false;
      }
    }
    registered.enabled = true;
    return true;
  }
  async disable(name) {
    const registered = this.plugins.get(name);
    if (!registered || !registered.enabled) {
      return false;
    }
    const activeDependents = registered.dependents.filter((dep) => this.plugins.get(dep)?.enabled);
    if (activeDependents.length > 0) {
      console.warn(`Cannot disable plugin '${name}' - required by active plugins: ${activeDependents.join(", ")}`);
      return false;
    }
    if (registered.plugin.deactivate) {
      const context10 = this.createPluginContext(name);
      try {
        await registered.plugin.deactivate(context10);
      } catch (error2) {
        console.error(`Plugin '${name}' deactivation error:`, error2);
      }
    }
    registered.enabled = false;
    return true;
  }
  getAll() {
    return Array.from(this.plugins.values());
  }
  getEnabled() {
    return Array.from(this.plugins.values()).filter((reg) => reg.enabled).map((reg) => reg.plugin);
  }
  get(name) {
    return this.plugins.get(name)?.plugin || null;
  }
  has(name) {
    return this.plugins.has(name);
  }
  isEnabled(name) {
    return this.plugins.get(name)?.enabled || false;
  }
  applyCLIConfig(config4) {
    const enabledPlugins = this.getEnabled();
    const modifiedConfig = JSON.parse(JSON.stringify(config4));
    for (const plugin of enabledPlugins) {
      if (plugin.commands) {
        Object.assign(modifiedConfig.commands || {}, plugin.commands);
      }
    }
    for (const plugin of enabledPlugins) {
      if (plugin.extensions) {
        for (const [commandPath, extension] of Object.entries(plugin.extensions)) {
          const command = this.findCommand(modifiedConfig, commandPath.split("."));
          if (command) {
            if (extension.options) {
              Object.assign(command.options || {}, extension.options);
            }
            if (extension.args) {
              Object.assign(command.args || {}, extension.args);
            }
            if (extension.wrapper && command.handler) {
              const originalHandler = command.handler;
              const pluginContext = this.createPluginContext(plugin.metadata.name);
              command.handler = extension.wrapper(originalHandler, pluginContext);
            }
          }
        }
      }
    }
    return modifiedConfig;
  }
  getHandlerWrappers() {
    return this.getEnabled().filter((plugin) => plugin.extensions).flatMap((plugin) => Object.values(plugin.extensions || {}).filter((ext) => ext.wrapper).map((ext) => ext.wrapper));
  }
  getServices() {
    const services = {};
    for (const plugin of this.getEnabled()) {
      if (plugin.services) {
        Object.assign(services, plugin.services);
      }
    }
    return services;
  }
  getDependencyOrder() {
    const visited = new Set;
    const order = [];
    const visit = (name) => {
      if (visited.has(name))
        return;
      visited.add(name);
      const registered = this.plugins.get(name);
      if (registered) {
        for (const dep of registered.dependencies) {
          visit(dep);
        }
        order.push(name);
      }
    };
    for (const name of this.plugins.keys()) {
      visit(name);
    }
    return order;
  }
  extractDependencies(plugin) {
    return Object.keys(plugin.metadata.dependencies || {}).concat(Object.keys(plugin.metadata.peerDependencies || {}));
  }
  getMissingDependencies(dependencies) {
    return dependencies.filter((dep) => !this.plugins.has(dep));
  }
  createPluginContext(name) {
    const registered = this.plugins.get(name);
    return {
      command: [],
      config: registered.config || {},
      plugins: this.getEnabled(),
      metadata: registered.plugin.metadata
    };
  }
  updateDependencyGraph(name, registered) {
    this.dependencyGraph.nodes.set(name, registered);
    this.dependencyGraph.edges.set(name, new Set(registered.dependencies));
    for (const dep of registered.dependencies) {
      const depRegistered = this.plugins.get(dep);
      if (depRegistered) {
        depRegistered.dependents.push(name);
      }
    }
  }
  removeDependencyGraph(name) {
    const registered = this.dependencyGraph.nodes.get(name);
    if (registered) {
      for (const dep of registered.dependencies) {
        const depRegistered = this.plugins.get(dep);
        if (depRegistered) {
          depRegistered.dependents = depRegistered.dependents.filter((d) => d !== name);
        }
      }
    }
    this.dependencyGraph.nodes.delete(name);
    this.dependencyGraph.edges.delete(name);
  }
  findCommand(config4, path9) {
    let commands = config4.commands || {};
    let command = null;
    for (const segment of path9) {
      command = commands[segment] || null;
      if (!command)
        return null;
      commands = command.commands || {};
    }
    return command;
  }
}
var createPluginRegistry = (options) => exports_Effect.sync(() => new PluginRegistry(options));

// ../../src/cli/index.ts
init_hooks2();

// ../../src/cli/help.ts
init_LargeText();
init_view();
init_styling();
init_box2();
init_borders();

class HelpGenerator {
  config;
  constructor(config4) {
    this.config = config4;
  }
  generateHelp(commandPath, options = {}) {
    const {
      showBranding = true,
      showExamples = true,
      colorize = true,
      width = 80
    } = options;
    if (!commandPath || commandPath.length === 0) {
      return this.generateGlobalHelp(options);
    }
    return this.generateCommandHelp(commandPath, options);
  }
  generateHelpComponent(commandPath) {
    if (!commandPath || commandPath.length === 0) {
      return this.generateGlobalHelpComponent();
    }
    return this.generateCommandHelpComponent(commandPath);
  }
  generateGlobalHelp(options) {
    const lines = [];
    lines.push(`${this.config.name} v${this.config.version}`);
    if (this.config.description) {
      lines.push(this.config.description);
    }
    lines.push("");
    lines.push("USAGE:");
    lines.push(`  ${this.config.name} [OPTIONS] <COMMAND>`);
    lines.push("");
    if (this.hasOptions(this.config.options)) {
      lines.push("OPTIONS:");
      this.addOptionsHelp(lines, this.config.options || {});
      lines.push("");
    }
    if (this.hasCommands(this.config.commands)) {
      lines.push("COMMANDS:");
      this.addCommandsHelp(lines, this.config.commands || {});
      lines.push("");
    }
    if (options.showExamples) {
      lines.push("EXAMPLES:");
      lines.push(`  ${this.config.name} --help        Show this help`);
      lines.push(`  ${this.config.name} --version     Show version`);
      const commands = Object.keys(this.config.commands || {});
      if (commands.length > 0) {
        lines.push(`  ${this.config.name} ${commands[0]} --help   Show command help`);
      }
      lines.push("");
    }
    return lines.join(`
`);
  }
  generateCommandHelp(commandPath, options) {
    const commandConfig = this.getCommandConfig(commandPath);
    if (!commandConfig) {
      return `Unknown command: ${commandPath.join(" ")}`;
    }
    const lines = [];
    lines.push(`${this.config.name} ${commandPath.join(" ")}`);
    if (commandConfig.description) {
      lines.push(commandConfig.description);
    }
    lines.push("");
    lines.push("USAGE:");
    const usage = [this.config.name, ...commandPath];
    if (this.hasOptions(commandConfig.options)) {
      usage.push("[OPTIONS]");
    }
    if (this.hasArgs(commandConfig.args)) {
      Object.keys(commandConfig.args || {}).forEach((arg) => {
        usage.push(`<${arg}>`);
      });
    }
    if (this.hasCommands(commandConfig.commands)) {
      usage.push("<COMMAND>");
    }
    lines.push(`  ${usage.join(" ")}`);
    lines.push("");
    if (this.hasArgs(commandConfig.args)) {
      lines.push("ARGUMENTS:");
      this.addArgsHelp(lines, commandConfig.args || {});
      lines.push("");
    }
    if (this.hasOptions(commandConfig.options)) {
      lines.push("OPTIONS:");
      this.addOptionsHelp(lines, commandConfig.options || {});
      lines.push("");
    }
    if (this.hasCommands(commandConfig.commands)) {
      lines.push("COMMANDS:");
      this.addCommandsHelp(lines, commandConfig.commands || {});
      lines.push("");
    }
    if (commandConfig.aliases && commandConfig.aliases.length > 0) {
      lines.push("ALIASES:");
      lines.push(`  ${commandConfig.aliases.join(", ")}`);
      lines.push("");
    }
    return lines.join(`
`);
  }
  generateGlobalHelpComponent() {
    const header = vstack(largeTextWithPalette(this.config.name, "neon", {
      font: "ansiShadow",
      mode: "outlined"
    }), text(""), styledText(this.config.description || "A CLI built with CLI-KIT", style().foreground(Colors.brightCyan).italic()), styledText(`v${this.config.version}`, style().foreground(Colors.gray)), text(""));
    const commandsSection = this.hasCommands(this.config.commands) ? styledBox(vstack(styledText("Available Commands", style().foreground(Colors.yellow).bold()), text(""), ...this.getCommandViews(this.config.commands || {})), {
      border: Borders.Rounded,
      padding: { top: 1, right: 2, bottom: 1, left: 2 },
      style: style().foreground(Colors.white)
    }) : text("");
    const optionsSection = this.hasOptions(this.config.options) ? styledBox(vstack(styledText("Global Options", style().foreground(Colors.yellow).bold()), text(""), ...this.getOptionViews(this.config.options || {})), {
      border: Borders.Rounded,
      padding: { top: 1, right: 2, bottom: 1, left: 2 },
      style: style().foreground(Colors.white)
    }) : text("");
    const footer = styledText("Use --help with any command for more information", style().foreground(Colors.gray).italic());
    return vstack(header, commandsSection, text(""), optionsSection, text(""), footer);
  }
  generateCommandHelpComponent(commandPath) {
    const commandConfig = this.getCommandConfig(commandPath);
    if (!commandConfig) {
      return styledText(`Unknown command: ${commandPath.join(" ")}`, style().foreground(Colors.red));
    }
    const header = vstack(styledText(`${this.config.name} ${commandPath.join(" ")}`, style().foreground(Colors.brightCyan).bold()), styledText(commandConfig.description || "", style().foreground(Colors.white)), text(""));
    const sections = [];
    if (this.hasArgs(commandConfig.args)) {
      sections.push(styledBox(vstack(styledText("Arguments", style().foreground(Colors.yellow).bold()), text(""), ...this.getArgViews(commandConfig.args || {})), {
        border: Borders.Rounded,
        padding: { top: 1, right: 2, bottom: 1, left: 2 }
      }));
    }
    if (this.hasOptions(commandConfig.options)) {
      sections.push(styledBox(vstack(styledText("Options", style().foreground(Colors.yellow).bold()), text(""), ...this.getOptionViews(commandConfig.options || {})), {
        border: Borders.Rounded,
        padding: { top: 1, right: 2, bottom: 1, left: 2 }
      }));
    }
    if (this.hasCommands(commandConfig.commands)) {
      sections.push(styledBox(vstack(styledText("Commands", style().foreground(Colors.yellow).bold()), text(""), ...this.getCommandViews(commandConfig.commands || {})), {
        border: Borders.Rounded,
        padding: { top: 1, right: 2, bottom: 1, left: 2 }
      }));
    }
    return vstack(header, ...sections.reduce((acc, section) => [...acc, section, text("")], []));
  }
  getSchemaDescription(schema) {
    if ("_def" in schema && typeof schema._def === "object" && schema._def && "description" in schema._def) {
      return String(schema._def.description || "");
    }
    return "";
  }
  hasOptions(options) {
    return Boolean(options && Object.keys(options).length > 0);
  }
  hasCommands(commands) {
    return Boolean(commands && Object.keys(commands).length > 0);
  }
  hasArgs(args2) {
    return Boolean(args2 && Object.keys(args2).length > 0);
  }
  addOptionsHelp(lines, options) {
    Object.entries(options).forEach(([name, schema]) => {
      const description = this.getSchemaDescription(schema);
      lines.push(`  --${name.padEnd(20)} ${description}`);
    });
  }
  addCommandsHelp(lines, commands) {
    Object.entries(commands).forEach(([name, config4]) => {
      if (!config4.hidden) {
        lines.push(`  ${name.padEnd(20)} ${config4.description || ""}`);
      }
    });
  }
  addArgsHelp(lines, args2) {
    Object.entries(args2).forEach(([name, schema]) => {
      const description = this.getSchemaDescription(schema);
      lines.push(`  ${name.padEnd(20)} ${description}`);
    });
  }
  getCommandViews(commands) {
    return Object.entries(commands).filter(([, config4]) => !config4.hidden).map(([name, config4]) => hstack(styledText(name.padEnd(20), style().foreground(Colors.cyan)), styledText(config4.description || "", style().foreground(Colors.white))));
  }
  getOptionViews(options) {
    return Object.entries(options).map(([name, schema]) => {
      const description = this.getSchemaDescription(schema);
      return hstack(styledText(`--${name}`.padEnd(20), style().foreground(Colors.yellow)), styledText(description, style().foreground(Colors.white)));
    });
  }
  getArgViews(args2) {
    return Object.entries(args2).map(([name, schema]) => {
      const description = this.getSchemaDescription(schema);
      return hstack(styledText(`<${name}>`.padEnd(20), style().foreground(Colors.green)), styledText(description, style().foreground(Colors.white)));
    });
  }
  getCommandConfig(commandPath) {
    let currentCommands = this.config.commands || {};
    let currentConfig = null;
    for (const command of commandPath) {
      currentConfig = currentCommands[command] || null;
      if (!currentConfig)
        return null;
      currentCommands = currentConfig.commands || {};
    }
    return currentConfig;
  }
}

// ../../src/cli/index.ts
init_runner();

// ../../src/cli/lazy.ts
function lazyLoad2(importFn, fallback) {
  let cached4;
  let loading;
  let loadError;
  const loader = async () => {
    if (cached4)
      return cached4;
    if (!loading) {
      loading = importFn().then((module) => {
        cached4 = module.default;
        loadError = undefined;
        return cached4;
      }).catch((error2) => {
        loadError = error2;
        loading = undefined;
        throw error2;
      });
    }
    return loading;
  };
  const lazyFunction = async () => {
    try {
      return await loader();
    } catch (error2) {
      console.error("Failed to load module:", error2);
      if (fallback) {
        console.warn("Using fallback component");
        return fallback;
      }
      throw error2;
    }
  };
  lazyFunction.preload = async () => {
    try {
      await loader();
    } catch (error2) {
      console.debug("Preload failed:", error2);
    }
  };
  Object.defineProperty(lazyFunction, "isLoaded", {
    get: () => !!cached4 && !loadError
  });
  return lazyFunction;
}
function lazyLoadCommand(path9, fallback) {
  return lazyLoad2(() => import(path9), fallback);
}
function lazyLoadPlugin(name) {
  return lazyLoad2(() => import(name));
}
class LazyCache {
  cache = new Map;
  loading = new Map;
  async get(key, importFn) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.loading.has(key)) {
      return await this.loading.get(key);
    }
    const loadingPromise = importFn().then((module) => {
      const result = module.default;
      this.cache.set(key, result);
      this.loading.delete(key);
      return result;
    }).catch((error2) => {
      this.loading.delete(key);
      throw error2;
    });
    this.loading.set(key, loadingPromise);
    return loadingPromise;
  }
  has(key) {
    return this.cache.has(key);
  }
  clear() {
    this.cache.clear();
    this.loading.clear();
  }
  size() {
    return this.cache.size;
  }
}
var globalLazyCache = new LazyCache;
// ../../src/cli/lazy-cache.ts
class LazyCache2 {
  cache = new Map;
  loading = new Map;
  maxSize = 100;
  maxAge = 60 * 60 * 1000;
  preloadQueue = new Set;
  constructor(options) {
    if (options?.maxSize)
      this.maxSize = options.maxSize;
    if (options?.maxAge)
      this.maxAge = options.maxAge;
  }
  async get(key, loader) {
    const cached4 = this.cache.get(key);
    if (cached4) {
      cached4.lastAccess = Date.now();
      cached4.accessCount++;
      return cached4.handler;
    }
    const loading = this.loading.get(key);
    if (loading) {
      const module = await loading;
      return this.extractHandler(module);
    }
    const loadPromise = this.load(key, loader);
    this.loading.set(key, loadPromise);
    try {
      const module = await loadPromise;
      const handler = this.extractHandler(module);
      this.cache.set(key, {
        module,
        handler,
        loadTime: Date.now(),
        lastAccess: Date.now(),
        accessCount: 1
      });
      this.loading.delete(key);
      this.evictIfNeeded();
      return handler;
    } catch (error2) {
      this.loading.delete(key);
      throw error2;
    }
  }
  preload(key, loader) {
    if (!this.cache.has(key) && !this.loading.has(key)) {
      this.preloadQueue.add(key);
      queueMicrotask(() => {
        if (this.preloadQueue.has(key)) {
          this.preloadQueue.delete(key);
          this.get(key, loader).catch(() => {});
        }
      });
    }
  }
  clear() {
    this.cache.clear();
    this.loading.clear();
    this.preloadQueue.clear();
  }
  getStats() {
    const entries4 = Array.from(this.cache.entries());
    const totalHits = entries4.reduce((sum3, [_, entry]) => sum3 + entry.accessCount, 0);
    const totalLoadTime = entries4.reduce((sum3, [_, entry]) => sum3 + entry.loadTime, 0);
    const mostUsed = entries4.sort((a, b) => b[1].accessCount - a[1].accessCount).slice(0, 5).map(([key]) => key);
    return {
      size: this.cache.size,
      hits: totalHits,
      misses: 0,
      avgLoadTime: entries4.length > 0 ? totalLoadTime / entries4.length : 0,
      mostUsed
    };
  }
  extractHandler(module) {
    if (typeof module === "function") {
      return module;
    }
    if (typeof module === "object" && module && "default" in module && typeof module.default === "function") {
      return module.default;
    }
    throw new Error("Invalid module: expected a function or object with default export");
  }
  async load(key, loader) {
    const startTime = performance.now();
    try {
      const module = await loader();
      const loadTime = performance.now() - startTime;
      if (loadTime > 100) {
        console.warn(`Slow module load: ${key} took ${loadTime.toFixed(2)}ms`);
      }
      return module;
    } catch (error2) {
      console.error(`Failed to load module: ${key}`, error2);
      throw error2;
    }
  }
  evictIfNeeded() {
    if (this.cache.size <= this.maxSize)
      return;
    const now2 = Date.now();
    const entries4 = Array.from(this.cache.entries());
    for (const [key, entry] of entries4) {
      if (now2 - entry.lastAccess > this.maxAge) {
        this.cache.delete(key);
      }
    }
    if (this.cache.size > this.maxSize) {
      const sorted = entries4.filter(([key]) => this.cache.has(key)).sort((a, b) => a[1].lastAccess - b[1].lastAccess);
      const toRemove = sorted.slice(0, this.cache.size - this.maxSize);
      for (const [key] of toRemove) {
        this.cache.delete(key);
      }
    }
  }
}
var globalLazyCache2 = new LazyCache2;
function createLazyHandler(importPath, loader) {
  const handler = async () => {
    return globalLazyCache2.get(importPath, loader);
  };
  handler.preload = () => {
    globalLazyCache2.preload(importPath, loader);
  };
  handler._cacheKey = importPath;
  handler._lazy = true;
  return handler;
}
// ../../src/cli/loader.ts
init_esm2();
import * as fs6 from "fs/promises";
import * as path9 from "path";
class PluginLoader {
  options;
  loadedPlugins = new Map;
  constructor(options = {}) {
    this.options = {
      pluginDirs: options.pluginDirs || [
        "./plugins",
        "~/.cli-kit/plugins",
        "/usr/local/lib/cli-kit/plugins"
      ],
      packagePrefixes: options.packagePrefixes || ["cli-kit-plugin-"],
      filePatterns: options.filePatterns || ["*.plugin.js", "*.plugin.ts"],
      loadFromNodeModules: options.loadFromNodeModules ?? true,
      cliVersion: options.cliVersion || "1.0.0",
      strictCompatibility: options.strictCompatibility ?? false
    };
  }
  async loadAll() {
    const results = [];
    for (const dir2 of this.options.pluginDirs) {
      const dirPlugins = await this.loadFromDirectory(dir2);
      results.push(...dirPlugins);
    }
    if (this.options.loadFromNodeModules) {
      const nodePlugins = await this.loadFromNodeModules();
      results.push(...nodePlugins);
    }
    return results;
  }
  async loadFromDirectory(directory) {
    const results = [];
    try {
      const dir2 = directory.replace(/^~/, process.env.HOME || "");
      try {
        await fs6.access(dir2);
      } catch {
        return results;
      }
      const entries4 = await fs6.readdir(dir2, { withFileTypes: true });
      for (const entry of entries4) {
        if (entry.isFile() && this.matchesPattern(entry.name)) {
          const filePath = path9.join(dir2, entry.name);
          const loaded = await this.loadFromFile(filePath);
          if (loaded) {
            results.push(loaded);
          }
        } else if (entry.isDirectory()) {
          const packagePath = path9.join(dir2, entry.name, "package.json");
          try {
            await fs6.access(packagePath);
            const loaded = await this.loadFromPackageDir(path9.join(dir2, entry.name));
            if (loaded) {
              results.push(loaded);
            }
          } catch {}
        }
      }
    } catch (error2) {
      console.error(`Error loading plugins from ${directory}:`, error2);
    }
    return results;
  }
  async loadFromNodeModules() {
    const results = [];
    try {
      const nodeModulesPath = path9.join(process.cwd(), "node_modules");
      const entries4 = await fs6.readdir(nodeModulesPath);
      for (const entry of entries4) {
        const matchesPrefix = this.options.packagePrefixes.some((prefix) => entry.startsWith(prefix));
        if (matchesPrefix) {
          const loaded = await this.loadFromPackageDir(path9.join(nodeModulesPath, entry));
          if (loaded) {
            results.push(loaded);
          }
        }
      }
    } catch (error2) {
      console.error("Error loading plugins from node_modules:", error2);
    }
    return results;
  }
  async loadFromFile(filePath) {
    const startTime = Date.now();
    try {
      const module = await import(filePath);
      const plugin = module.default || module.plugin;
      if (!plugin) {
        throw new Error(`No default export or 'plugin' export found`);
      }
      const compatibility = checkPluginCompatibility(plugin, this.options.cliVersion);
      if (!compatibility.compatible && this.options.strictCompatibility) {
        throw new Error(compatibility.reason);
      }
      const loaded = {
        plugin,
        source: filePath,
        loadTime: Date.now() - startTime
      };
      this.loadedPlugins.set(plugin.metadata.name, loaded);
      return loaded;
    } catch (error2) {
      console.error(`Failed to load plugin from ${filePath}:`, error2);
      return null;
    }
  }
  async loadFromPackageDir(packageDir) {
    try {
      const packageJsonPath = path9.join(packageDir, "package.json");
      const packageJson = JSON.parse(await fs6.readFile(packageJsonPath, "utf-8"));
      const entryPoint = packageJson.main || "index.js";
      const pluginPath = path9.join(packageDir, entryPoint);
      return await this.loadFromFile(pluginPath);
    } catch (error2) {
      console.error(`Failed to load plugin from package ${packageDir}:`, error2);
      return null;
    }
  }
  async loadByName(name) {
    if (this.loadedPlugins.has(name)) {
      return this.loadedPlugins.get(name);
    }
    try {
      const loaded = await this.loadFromFile(name);
      return loaded;
    } catch {
      for (const prefix of this.options.packagePrefixes) {
        try {
          const loaded = await this.loadFromFile(prefix + name);
          if (loaded)
            return loaded;
        } catch {}
      }
    }
    return null;
  }
  getLoadedPlugins() {
    return Array.from(this.loadedPlugins.values());
  }
  getPlugin(name) {
    return this.loadedPlugins.get(name)?.plugin || null;
  }
  async unloadPlugin(name) {
    const loaded = this.loadedPlugins.get(name);
    if (!loaded) {
      return false;
    }
    if (loaded.plugin.uninstall) {
      try {
        await loaded.plugin.uninstall({
          command: [],
          config: {},
          plugins: [],
          metadata: loaded.plugin.metadata
        });
      } catch (error2) {
        console.error(`Error uninstalling plugin ${name}:`, error2);
      }
    }
    this.loadedPlugins.delete(name);
    return true;
  }
  async reloadPlugin(name) {
    const existing = this.loadedPlugins.get(name);
    if (!existing) {
      return null;
    }
    await this.unloadPlugin(name);
    return await this.loadFromFile(existing.source);
  }
  matchesPattern(filename) {
    return this.options.filePatterns.some((pattern2) => {
      const regex = pattern2.replace(/\./g, "\\.").replace(/\*/g, ".*").replace(/\?/g, ".");
      return new RegExp(`^${regex}$`).test(filename);
    });
  }
}
var createPluginLoader = (options) => exports_Effect.sync(() => new PluginLoader(options));
var loadAllPlugins = (loader) => exports_Effect.tryPromise({
  try: () => loader.loadAll(),
  catch: (error2) => new Error(`Failed to load plugins: ${error2}`)
});
var loadPluginByName = (loader, name) => exports_Effect.tryPromise({
  try: () => loader.loadByName(name),
  catch: (error2) => new Error(`Failed to load plugin '${name}': ${error2}`)
});

// ../../src/cli/index.ts
init_components3();

// ../../src/index.ts
init_process_manager();
init_plugins();
init_logger3();
init_config4();
init_schemas();

// ../../src/core/type-utils.ts
function hasProperty2(obj, key) {
  return typeof obj === "object" && obj !== null && key in obj;
}
function isFunction3(value6) {
  return typeof value6 === "function";
}
function isAsyncFunction(value6) {
  return typeof value6 === "function" && value6.constructor.name === "AsyncFunction";
}
function isPlainObject(value6) {
  return typeof value6 === "object" && value6 !== null && !Array.isArray(value6);
}
function isArray2(value6) {
  return Array.isArray(value6);
}
function isString2(value6) {
  return typeof value6 === "string";
}
function isNumber2(value6) {
  return typeof value6 === "number" && !isNaN(value6);
}
function isBoolean2(value6) {
  return typeof value6 === "boolean";
}
function isNullish(value6) {
  return value6 === null || value6 === undefined;
}
function safeJsonParse(str) {
  try {
    return JSON.parse(str);
  } catch (error2) {
    return error2 instanceof Error ? error2 : new Error("Unknown JSON parse error");
  }
}
function getProperty(obj, key, defaultValue) {
  if (hasProperty2(obj, key)) {
    return obj[key];
  }
  return defaultValue;
}
function createEventEmitter() {
  const listeners = new Map;
  return {
    on(event, listener) {
      if (!listeners.has(event)) {
        listeners.set(event, []);
      }
      listeners.get(event).push(listener);
      return this;
    },
    off(event, listener) {
      const eventListeners = listeners.get(event);
      if (eventListeners) {
        const index = eventListeners.indexOf(listener);
        if (index !== -1) {
          eventListeners.splice(index, 1);
        }
      }
      return this;
    },
    emit(event, ...args2) {
      const eventListeners = listeners.get(event);
      if (eventListeners) {
        eventListeners.forEach((listener) => listener(...args2));
        return true;
      }
      return false;
    }
  };
}
function createRef(initial = null) {
  return { current: initial };
}
function memoize4(fn2, keyFn) {
  const cache = new Map;
  return (...args2) => {
    const key = keyFn ? keyFn(...args2) : JSON.stringify(args2);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn2(...args2);
    cache.set(key, result);
    return result;
  };
}

// ../../src/index.ts
var VERSION = "1.0.0-rc.3";
var FRAMEWORK_INFO = {
  name: "tuix",
  version: VERSION,
  description: "A performant TUI framework for Bun with JSX and reactive state management",
  repository: "https://github.com/cinderlink/tuix",
  license: "MIT",
  features: {
    zodValidation: true,
    typeSafety: true,
    jsxRuntime: true,
    reactiveState: true
  }
};
export {
  wrapComponent,
  withRecovery,
  withLoggerContext,
  withLifecycle,
  withErrorBoundary,
  watchFile,
  warningButton,
  vspace,
  viewport,
  vdivider,
  vbox,
  validateView,
  validateStyle,
  validateProcessConfig,
  validatePlugin,
  validateMouseEvent,
  validateKeyEvent,
  validateJSXElement,
  validateConfig,
  validateComponent,
  validateCLIConfig,
  untrack,
  toEnvFormat,
  toBindable,
  toAnsiSequence,
  timer2 as timer,
  tick3 as tick,
  thickDivider,
  textInput,
  textGradient,
  text2 as text,
  templates,
  template,
  sunsetGradient,
  successButton,
  styledBox,
  styleFrom,
  style,
  spread,
  spinner,
  span4 as span,
  spacer,
  spaced3 as spaced,
  simpleProgressBar,
  simpleLayout,
  setupManagedProcess,
  setValueByPath,
  setProgress,
  setGlobalLogger,
  setGlobalConfig,
  setExitHandler,
  separated,
  secondaryButton,
  scrollableView,
  scrollBox,
  savingSpinner,
  safeJsonParse,
  runJSXCLI,
  runCLI,
  runApp,
  reverseGradient,
  responsiveLayout,
  renderToTerminal,
  renderToString,
  renderStyledSync,
  renderStyled,
  renderBox,
  render3 as render,
  reactive,
  random4 as random,
  rainbowGradient,
  quickFilters,
  progressBar,
  processingSpinner,
  primaryButton,
  poll10 as poll,
  place,
  passwordInput,
  parseView,
  parseValue,
  parseStyle,
  parseProcessConfig,
  parseMouseEvent,
  parseKeyEvent,
  parseComponent,
  parseCLIConfig,
  paddedContainer,
  onMount,
  onDestroy,
  oceanGradient,
  numberInput,
  normalizeSpacing,
  mergeStyles,
  mergeDeep,
  mergeBorders,
  memoize4 as memoize,
  matchesFilter,
  matchKeyBinding,
  makeQueuedLoggerLayer,
  makeMouseAware,
  makeLoggerLayer,
  logUtils,
  log4 as log,
  loadingSpinner,
  loadingBar,
  loadPluginByName,
  loadConfig,
  loadAllPlugins,
  link,
  lighten,
  lazyLoadPlugin,
  lazyLoadCommand,
  lazyLoad,
  layered,
  largeTextWithPalette,
  largeText,
  largeGradientText,
  largeAnimatedTextWithPalette,
  largeAnimatedGradientText,
  keyBinding,
  jsx as jsxs,
  jsx as jsxDEV,
  jsxCommand,
  joinVertical,
  joinHorizontal,
  isVisible,
  isString2 as isString,
  isStateRune,
  isRune,
  isPlainObject,
  isNumber2 as isNumber,
  isNullish,
  isInheritable,
  isFunction3 as isFunction,
  isDerivedRune,
  isBoolean2 as isBoolean,
  isBindableRune,
  isAsyncFunction,
  isArray2 as isArray,
  infoButton,
  hspace,
  hoverHandler,
  help,
  heightAwareContainer,
  heading,
  hdivider,
  hbox,
  hasSide,
  hasProperty2 as hasProperty,
  gridItem,
  grid,
  gradientPresets,
  gradient,
  globalLazyCache2 as globalLazyCache,
  globalLazyCache as globalCommandCache,
  ghostButton,
  getValueByPath,
  getValue,
  getProperty,
  getGlobalLogger,
  getGlobalHooks,
  getGlobalConfig,
  getDefaultKeybindings,
  getConfigValues,
  getConfigValue,
  getConfigOptions,
  getConfig,
  getBorderChar,
  getAvailablePresets,
  generatePattern,
  generateHelpText,
  generateComponentId,
  functional,
  fromEventEmitter,
  fromArray,
  formatCell,
  formSection,
  formField,
  flexbox,
  flexSpacer,
  fixedSpacer,
  findConfigFile,
  fancyProgressBarStyle,
  fancyProgressBar,
  expandEnvVars,
  ensureConfig,
  emailInput,
  dynamicVBox,
  dynamicSpacer,
  dragHandler,
  doubleDivider,
  dottedDivider,
  divider,
  deleteValueByPath,
  definePlugin,
  defineJSXCommand,
  defineConfigSchema,
  defineCommand,
  defaultSerializers,
  defaultProgressBarStyle,
  dashedDivider,
  darken,
  dangerButton,
  createWaveText,
  createTypewriter,
  createTypedConfig,
  createTextContent,
  createStyledBorder,
  createStore,
  createShake,
  createRow,
  createRemoteLogger,
  createRef,
  createRainbowText,
  createPulse,
  createProductionLogger,
  createProcessManager,
  createPluginRegistry,
  createPluginManager,
  createPluginLoader,
  createPlugin,
  createNumberedContent,
  createNeonEffect,
  createMatrixEffect,
  createLazyHandler,
  createKeyMap,
  createJSXPlugin,
  createJSXConfigApp,
  createJSXApp,
  createInnerShadow,
  createHooks,
  createHookEvent,
  createHologramEffect,
  createHelpPanel,
  createHelpModal,
  createGridContent,
  createGradient,
  createGlow,
  createFilter,
  createEventEmitter,
  createElement,
  createDropShadow,
  createDevelopmentLogger,
  createDefaultStyles,
  createContextHelp,
  createConsoleLogger,
  createConfig,
  createComponent,
  createColumn,
  createCLILogger,
  createBounce,
  createBorder,
  containsExit,
  config3 as config,
  conditionalSpacer,
  composePlugins,
  commonOptions,
  commonArgs,
  combineSides,
  columns,
  colorPalettes,
  code,
  clickableHandler,
  cli,
  checkPluginCompatibility,
  centerBox,
  center2 as center,
  card,
  button,
  box2 as box,
  borderFromPattern,
  blend,
  beforeUpdate,
  batch,
  backgroundGradient,
  asciiProgressBarStyle,
  asciiProgressBar,
  applyPreset,
  applyPattern,
  applyLayerEffect,
  afterUpdate,
  YAMLLoader,
  WindowSizeSchema,
  Warning2 as Warning,
  ViewportSchema,
  Viewport,
  ViewTabs,
  ViewSchema,
  exports_view_cache as ViewCache,
  exports_view as View,
  VerticalAlignSchema,
  VerticalAlign,
  ValidationError,
  VERSION,
  TypeScriptLoader,
  TuixLogger,
  TuixConfigBuilder,
  TuixConfig,
  TransformComponent,
  Transform,
  Top,
  TextInput,
  Text,
  TerminalService,
  TerminalError,
  TerminalCapabilitiesSchema,
  Tabs,
  TableSelectionMode,
  Table,
  TUITransport,
  TOMLLoader,
  Success,
  SubmitCancelButtons,
  Styles,
  StyleSchema,
  Style,
  StreamTransport,
  StreamComponent,
  StreamBoxComponent,
  StreamBox,
  StorageService,
  StorageError,
  Stack,
  SpinnerWithMessage,
  Spinner,
  Spacer,
  SpaceBetween,
  SizeSchema,
  SingleSelectList,
  SimpleTabs,
  SimpleTable,
  Sidebar,
  SetConfig,
  ScrollableProcessList,
  ScrollableLogBox,
  ScrollableBox,
  exports_schemas as Schemas,
  exports_external as Schema,
  Runtime2 as Runtime,
  Row,
  Right2 as Right,
  RendererService,
  RenderError,
  exports_Ref as Ref,
  RecoveryStrategies,
  exports_Queue as Queue,
  ProcessStatusSchema,
  ProcessMonitor,
  ProcessManagerPlugin,
  ProcessManager,
  ProcessLogView,
  ProcessLogSchema,
  ProcessConfigSchema,
  PrettyLogEntry,
  PrettyFormatter,
  Position as PositionUtils,
  PositionSchema,
  PluginUtils,
  PluginRegistry,
  PluginManager,
  PluginLoader,
  PluginBuilder,
  PipeComponent,
  Pipe,
  PaddingSchema,
  PROCESS_FILTER_PRESETS,
  MultiSelectList,
  MouseEventTypeSchema,
  MouseEventSchema,
  MouseButtonSchema,
  Modal,
  MarkdownRenderer,
  LoggingPlugin,
  LoggerUtils,
  LoggerQueue,
  LoggerConfig,
  Logger,
  LogMetadata,
  LogMessage,
  LogLevels,
  LogLevelText,
  LogExplorer,
  LogError,
  LoadingOverlay,
  LoadingModal,
  LoadPlugin,
  LoadConfig,
  LiveLogDashboard,
  List,
  Link,
  Left2 as Left,
  LazyCache as LazyCommandCache,
  LazyCache2 as LazyCache,
  exports_Layer as Layer,
  Label,
  LOG_PRESETS,
  LOG_FILTER_PRESETS,
  LEVEL_EMOJIS2 as LEVEL_EMOJIS,
  LEVEL_COLORS3 as LEVEL_COLORS,
  LEVEL_ANSI,
  KeyUtils,
  KeyTypeSchema,
  KeyEventSchema,
  JustifyContent,
  TextInput as JSXTextInput,
  JSONLoader,
  JSONFormatter,
  InteractiveLogRenderer,
  InteractiveContextLive,
  Interactive,
  InputService,
  InputError,
  InfoModal,
  Info2 as Info,
  IPCChannelTypeSchema,
  INHERITABLE_PROPS,
  HttpTransport,
  HorizontalAlign,
  HelpGenerator,
  Heading,
  Header,
  Grid,
  Fragment,
  FlexWrap,
  FlexItem,
  FlexDirection,
  Flex,
  Flag,
  FilterableContent,
  FilterBox,
  FileTransport,
  FilePicker,
  FRAMEWORK_INFO,
  FIGLET_FONTS,
  Example,
  ErrorUtils,
  ErrorModal,
  ErrorCodeSchema,
  Error4 as Error,
  EnvLoader,
  exports_Effect as Effect,
  DividerOrientation,
  exports_Context as Context,
  ConsoleTransport,
  ConfirmModal,
  ConfigProvider,
  ConfigLayer,
  ConfigField,
  ConfigError,
  ConfigDefinition,
  Config,
  ComponentSchema,
  ComponentError,
  CompactFormatter,
  CommandSuggestions,
  Column,
  Colors,
  ColorSchema,
  ColorProfile,
  Code,
  CmdSchema,
  CLIRunner,
  CLIRouter,
  CLIParser,
  CLIOptionSchema,
  CLIFormatter,
  CLIConfigSchema,
  CLICommandSchema,
  CLI,
  ButtonGroup,
  Button,
  Box,
  BoundsSchema,
  Bottom,
  Borders,
  BorderSide,
  BorderCharactersSchema,
  ApplicationError,
  AppOptionsSchema,
  AppErrorSchema,
  App,
  AlignSchema,
  AlignItems,
  ANSI2 as ANSI,
  $throttled,
  $memo,
  $debounced,
  $bindable
};
