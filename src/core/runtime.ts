/**
 * Application Runtime - The heart of the TUIX framework
 * 
 * This module implements the complete application runtime system, coordinating
 * between input handling, state updates, and rendering cycles using Effect's
 * sophisticated fiber system for concurrent, composable operations.
 * 
 * ## Architecture Overview:
 * 
 * ### MVU Loop Implementation
 * - **Input Processing**: Keyboard, mouse, and system events
 * - **State Management**: Immutable state transitions via update functions
 * - **Command Execution**: Asynchronous side effects managed as fibers
 * - **Subscription Handling**: Continuous event streams (input, timers, etc.)
 * - **Rendering Pipeline**: Efficient view rendering with caching
 * 
 * ### Fiber-Based Concurrency
 * - Separate fibers for input, update, render, and command execution
 * - Graceful shutdown and resource cleanup
 * - Structured concurrency with automatic cancellation
 * - Error boundaries and recovery strategies
 * 
 * ### Performance Optimization
 * - Configurable frame rate limiting
 * - Efficient message queuing and batching
 * - Resource pooling and reuse
 * - Minimal allocation patterns
 * 
 * ### Service Integration
 * - Terminal operations (clear, write, cursor control)
 * - Input event processing (keyboard, mouse, resize)
 * - Rendering pipeline management
 * - Storage operations for persistence
 * 
 * @example
 * ```typescript
 * import { createRuntime, RuntimeConfig } from './runtime'
 * 
 * const config: RuntimeConfig = {
 *   fps: 60,
 *   enableMouse: true,
 *   fullscreen: true
 * }
 * 
 * const program = Effect.gen(function* (_) {
 *   const runtime = yield* _(createRuntime(config))
 *   yield* _(runtime.run(myComponent))
 * })
 * ```
 * 
 * @module core/runtime
 */

import { Effect, Fiber, Queue, Ref, Stream, Schedule, pipe, Scope, Exit } from "effect"
import type { 
  Component, 
  Cmd, 
  Sub,
  AppServices,
  KeyEvent,
  MouseEvent
} from "./types"
import { 
  TerminalService, 
  InputService, 
  RendererService, 
  StorageService,
  MouseRouterService 
} from "../services/index"
import { ApplicationError } from "./errors"

/**
 * System messages that the runtime can inject
 * 
 * These are messages generated by the runtime itself to communicate
 * system events to the application. They are automatically handled
 * by the runtime and forwarded to the component's update function.
 * 
 * @template Msg - User-defined message type
 * 
 * @example
 * ```typescript
 * type AppMsg = 
 *   | { _tag: 'UserAction', action: string }
 *   | SystemMsg<never> // Include system messages
 * ```
 */
export type SystemMsg<Msg> = 
  | { readonly _tag: "WindowResized"; readonly width: number; readonly height: number }
  | { readonly _tag: "KeyPressed"; readonly key: KeyEvent }
  | { readonly _tag: "MouseEvent"; readonly event: MouseEvent }
  | { readonly _tag: "Tick"; readonly time: number }
  | { readonly _tag: "UserMsg"; readonly msg: Msg }
  | { readonly _tag: "Quit" }

/**
 * Runtime configuration options
 * 
 * Configuration for the application runtime, controlling performance,
 * input handling, and terminal behavior. All options have sensible
 * defaults and can be omitted for typical use cases.
 * 
 * @example
 * ```typescript
 * const config: RuntimeConfig = {
 *   fps: 30, // Lower for better battery life
 *   enableMouse: true, // Enable mouse interactions
 *   fullscreen: false, // Don't use alternate screen
 *   quitOnCtrlC: true // Allow Ctrl+C to exit
 * }
 * ```
 */
export interface RuntimeConfig {
  /** Target frames per second for rendering (default: 60) */
  readonly fps?: number
  /** Enable debug logging for troubleshooting (default: false) */
  readonly debug?: boolean
  /** Quit application when ESC key is pressed (default: false) */
  readonly quitOnEscape?: boolean
  /** Quit application when Ctrl+C is pressed (default: true) */
  readonly quitOnCtrlC?: boolean
  /** Enable mouse event processing (default: false) */
  readonly enableMouse?: boolean
  /** Use alternate screen buffer for fullscreen apps (default: true) */
  readonly fullscreen?: boolean
}

/**
 * Runtime state for tracking application execution
 * 
 * Internal state maintained by the runtime to track the current
 * model, execution status, and performance metrics.
 * 
 * @template Model - Application state type
 * @template Msg - Application message type
 * 
 * @internal
 */
interface RuntimeState<Model, Msg> {
  /** Current application model/state */
  readonly model: Model
  /** Whether the application is still running */
  readonly running: boolean
  /** Timestamp of last render for FPS control */
  readonly lastRenderTime: number
  /** Total number of frames rendered for metrics */
  readonly frameCount: number
}

/**
 * The main application runtime
 * 
 * Orchestrates the complete application lifecycle including initialization,
 * the main event loop, and cleanup. Manages concurrent fibers for input
 * processing, state updates, rendering, and command execution.
 * 
 * @template Model - Application state type
 * @template Msg - Application message type
 * 
 * @example
 * ```typescript
 * const runtime = new Runtime(myComponent, {
 *   fps: 60,
 *   enableMouse: true
 * })
 * 
 * const program = runtime.run()
 * await Effect.runPromise(Effect.provide(program, services))
 * ```
 */
export class Runtime<Model, Msg> {
  /**
   * Create a new runtime instance
   * 
   * @param component - The root component to run
   * @param config - Runtime configuration options
   */
  constructor(
    private readonly component: Component<Model, Msg>,
    private readonly config: RuntimeConfig = {}
  ) {
    // Apply sensible defaults
    this.config = {
      fps: 60,
      debug: false,
      quitOnEscape: false,
      quitOnCtrlC: true,  // Default to true for safety
      enableMouse: false,
      fullscreen: true,
      ...config  // User config overrides defaults
    }
  }

  /**
   * Run the application
   * 
   * Starts the complete application runtime including terminal setup,
   * input processing, the main event loop, and rendering. This is the
   * main entry point for executing a TUIX application.
   * 
   * The runtime manages multiple concurrent fibers:
   * - Input processing fiber for keyboard/mouse events
   * - Update fiber for state transitions and command execution
   * - Render fiber for view generation and display
   * - Timer fiber for frame rate control and animations
   * 
   * @returns Effect that runs the complete application
   * 
   * @example
   * ```typescript\n * const program = runtime.run()\n * await Effect.runPromise(Effect.provide(program, services))\n * ```
   */
  readonly run = () => {
    const self = this
    return Effect.gen(function* (_) {
    
    // Get services from the context
    const terminal = yield* _(TerminalService)
    const input = yield* _(InputService)  
    const renderer = yield* _(RendererService)
    
    // Setup terminal
    yield* _(terminal.setRawMode(true))
    if (self.config.fullscreen ?? true) {
      yield* _(terminal.setAlternateScreen(true))
    }
    yield* _(terminal.hideCursor)
    yield* _(terminal.clear)
    
    // Enable mouse if configured
    if (self.config.enableMouse) {
      yield* _(input.enableMouse)
    }
    
    // Initialize component
    const [initialModel, initialCmds] = yield* _(self.component.init)
    
    // Create message queue
    const msgQueue = yield* _(Queue.unbounded<SystemMsg<Msg>>())
    
    // Create runtime state
    const state = yield* _(Ref.make<RuntimeState<Model, Msg>>({
      model: initialModel,
      running: true,
      lastRenderTime: Date.now(),
      frameCount: 0
    }))
    
    // Process initial commands
    yield* _(processCmds(initialCmds, msgQueue))
    
    // Setup signal handlers for graceful shutdown
    const signalHandlers = yield* _(setupSignalHandlers(msgQueue, terminal, self.config))
    
    // Start automatic quit key handling if enabled
    const quitFiber = (self.config.quitOnCtrlC || self.config.quitOnEscape) ? 
      yield* _(
        handleAutomaticQuitKeys(input, msgQueue, self.config).pipe(
          Effect.fork,
          Effect.interruptible
        )
      ) : null
    
    // Start subscription handling fiber
    const subFiber = yield* _(
      handleSubscriptions(self.component, state, msgQueue).pipe(
        Effect.fork,
        Effect.interruptible
      )
    )
    
    // Start render loop fiber
    const renderFiber = yield* _(
      renderLoop(self.component, renderer, state, self.config).pipe(
        Effect.fork,
        Effect.interruptible
      )
    )
    
    // Main update loop
    yield* _(
      Stream.fromQueue(msgQueue).pipe(
        Stream.takeWhile(msg => msg._tag !== "Quit"),
        Stream.runForEach(msg =>
          processMessage(self.component, state, msgQueue, msg, self.config)
        )
      )
    )
    
    // Cleanup
    yield* _(signalHandlers.cleanup)
    const fibersToInterrupt = quitFiber ? [quitFiber, subFiber, renderFiber] : [subFiber, renderFiber]
    yield* _(Fiber.interruptAll(fibersToInterrupt))
    yield* _(cleanup(terminal, self.config))
  }).pipe(
    Effect.scoped,
    Effect.catchAllDefect(defect =>
      Effect.gen(function* (_) {
        // Emergency cleanup on crash
        emergencyTerminalCleanup(self.config)
        const terminal = yield* _(TerminalService)
        yield* _(cleanup(terminal, self.config))
        yield* _(Effect.die(defect))
      })
    ),
    Effect.catchAll(error =>
      Effect.gen(function* (_) {
        // Emergency cleanup on any error
        emergencyTerminalCleanup(self.config)
        const terminal = yield* _(TerminalService)
        yield* _(cleanup(terminal, self.config))
        yield* _(Effect.fail(error))
      })
    )
  )
  }
}

/**
 * Process a single message through the update cycle
 */
const processMessage = <Model, Msg>(
  component: Component<Model, Msg>,
  state: Ref.Ref<RuntimeState<Model, Msg>>,
  msgQueue: Queue.Queue<SystemMsg<Msg>>,
  sysMsg: SystemMsg<Msg>,
  config: RuntimeConfig
) =>
  Effect.gen(function* (_) {
    const currentState = yield* _(Ref.get(state))
    
    // Handle system messages
    let msg: Msg
    switch (sysMsg._tag) {
      case "UserMsg":
        msg = sysMsg.msg
        break
      case "WindowResized":
        // If component handles resize, convert to user message
        // Otherwise ignore
        return
      case "KeyPressed":
        // Key events would be routed to focused component
        // For now, they're not processed at the system level
        return
        
      case "MouseEvent":
        // Route mouse event to component
        const mouseRouter = yield* _(MouseRouterService)
        const routingResult = yield* _(mouseRouter.routeMouseEvent(sysMsg.event))
        
        if (config.debug) {
          if (routingResult) {
            console.log(`Mouse routed to ${routingResult.componentId}: ${sysMsg.event.type} ${sysMsg.event.button} at (${sysMsg.event.x}, ${sysMsg.event.y})`)
          } else {
            console.log(`Mouse not routed: ${sysMsg.event.type} ${sysMsg.event.button} at (${sysMsg.event.x}, ${sysMsg.event.y})`)
          }
        }
        
        if (routingResult) {
          // Convert to user message and process
          yield* _(Queue.offer(msgQueue, { _tag: "UserMsg", msg: routingResult.message }))
        }
        return
      case "Tick":
        // These would be converted to user messages if component handles them
        return
      case "Quit":
        yield* _(Ref.update(state, s => ({ ...s, running: false })))
        return
    }
    
    // Run update
    const [newModel, cmds] = yield* _(
      component.update(msg, currentState.model)
    )
    
    // Update state
    yield* _(Ref.update(state, s => ({ ...s, model: newModel })))
    
    // Process commands
    yield* _(processCmds(cmds, msgQueue))
  })

/**
 * Process commands by converting them to messages
 */
const processCmds = <Msg>(
  cmds: ReadonlyArray<Cmd<Msg>>,
  msgQueue: Queue.Queue<SystemMsg<Msg>>
) =>
  Effect.forEach(cmds, cmd =>
    cmd.pipe(
      Effect.flatMap(msg => {
        // Check if this is a quit command
        if (typeof msg === 'object' && msg !== null && '_tag' in msg && msg._tag === 'Quit') {
          // Send system quit message
          return Queue.offer(msgQueue, { _tag: "Quit" })
        } else {
          // Regular user message
          return Queue.offer(msgQueue, { _tag: "UserMsg" as const, msg })
        }
      }),
      Effect.catchAll(() => Effect.void) // Ignore failed commands
    )
  )

/**
 * Emergency terminal cleanup - restores terminal state immediately
 */
const emergencyTerminalCleanup = (config: RuntimeConfig): void => {
  try {
    // Restore terminal state synchronously
    if (process.stdin.isTTY && 'setRawMode' in process.stdin) {
      process.stdin.setRawMode(false)
    }
    process.stdout.write('\x1b[?25h')  // Show cursor
    if (config.fullscreen ?? true) {
      process.stdout.write('\x1b[?1049l') // Exit alternate screen
    }
    process.stdout.write('\x1b[0m')     // Reset colors
    process.stdout.write('\x1b[2J')     // Clear screen  
    process.stdout.write('\x1b[H')      // Move to home
  } catch {
    // Ignore errors during emergency cleanup
  }
}

/**
 * Setup signal handlers for graceful shutdown
 */
const setupSignalHandlers = <Msg>(
  msgQueue: Queue.Queue<SystemMsg<Msg>>,
  terminal: TerminalService,
  config: RuntimeConfig
) =>
  Effect.gen(function* (_) {
    let isShuttingDown = false
    
    const handleGracefulShutdown = () => {
      if (isShuttingDown) return
      isShuttingDown = true
      
      // Send quit message to gracefully exit
      Effect.runSync(Queue.offer(msgQueue, { _tag: "Quit" }))
    }
    
    const handleEmergencyShutdown = (reason?: string) => {
      if (isShuttingDown) return
      isShuttingDown = true
      
      if (reason) {
        console.error('Emergency shutdown:', reason)
      }
      
      // Emergency cleanup - bypass the normal shutdown process
      emergencyTerminalCleanup(config)
      Effect.runSync(cleanup(terminal, config).pipe(
        Effect.catchAll(() => Effect.void)
      ))
      process.exit(1)
    }
    
    // Graceful shutdown signals
    process.on('SIGINT', handleGracefulShutdown)
    process.on('SIGTERM', handleGracefulShutdown)
    
    // Emergency shutdown events
    process.on('exit', () => emergencyTerminalCleanup(config))
    process.on('beforeExit', () => emergencyTerminalCleanup(config))
    
    process.on('uncaughtException', (error) => {
      handleEmergencyShutdown(`Uncaught exception: ${error.message}`)
    })
    
    process.on('unhandledRejection', (reason) => {
      handleEmergencyShutdown(`Unhandled rejection: ${reason}`)
    })
    
    return {
      cleanup: Effect.sync(() => {
        process.removeListener('SIGINT', handleGracefulShutdown)
        process.removeListener('SIGTERM', handleGracefulShutdown)
        process.removeListener('exit', emergencyTerminalCleanup)
        process.removeListener('beforeExit', emergencyTerminalCleanup)
        process.removeListener('uncaughtException', handleEmergencyShutdown)
        process.removeListener('unhandledRejection', handleEmergencyShutdown)
      })
    }
  })


/**
 * Handle automatic quit keys - this runs in parallel with component subscriptions
 * and ensures quit keys always work unless explicitly disabled
 * 
 * Monitors for configured quit key combinations (Ctrl+C, Escape) and
 * automatically sends quit messages to the application. This runs independently
 * of component subscriptions to ensure users can always exit the application.
 * 
 * @param input - Input service for key event monitoring
 * @param msgQueue - Queue for sending quit messages
 * @param config - Runtime configuration with quit key settings
 * @returns Effect that monitors for quit keys
 * 
 * @internal
 */
const handleAutomaticQuitKeys = <Msg>(
  input: InputService,
  msgQueue: Queue.Queue<SystemMsg<Msg>>,
  config: RuntimeConfig
) =>
  Effect.gen(function* (_) {
    // Create a separate subscription to handle quit keys
    // This doesn't conflict with component subscriptions because PubSub broadcasts to all subscribers
    yield* _(
      input.filterKeys(key => {
        const isQuit = (config.quitOnCtrlC && key.ctrl && key.key === 'ctrl+c') ||
                      (config.quitOnEscape && key.key === 'escape')
        return isQuit
      }).pipe(
        Stream.runForEach(() => Queue.offer(msgQueue, { _tag: "Quit" }))
      )
    )
  })

/**
 * Handle subscriptions - properly manages dynamic subscriptions that depend on model state
 * 
 * Manages component subscriptions that may change based on the current model state.
 * Automatically restarts subscriptions when the model changes to ensure they reflect
 * the current application state. Handles cleanup and interruption on shutdown.
 * 
 * @param component - Component with optional subscriptions
 * @param state - Ref to current runtime state
 * @param msgQueue - Queue for sending subscription messages
 * @returns Effect that manages subscription lifecycle
 * 
 * @internal
 */
const handleSubscriptions = <Model, Msg>(
  component: Component<Model, Msg>,
  state: Ref.Ref<RuntimeState<Model, Msg>>,
  msgQueue: Queue.Queue<SystemMsg<Msg>>
) =>
  Effect.gen(function* (_) {
    if (!component.subscriptions) return
    
    // Track current subscription fiber to restart when model changes
    let currentSubFiber: Fiber.Fiber<never, never> | null = null
    let lastModel: Model | null = null
    
    // Function to start/restart subscriptions
    const startSubscription = (model: Model) =>
      Effect.gen(function* (_) {
        // Interrupt existing subscription if running
        if (currentSubFiber) {
          yield* _(Fiber.interrupt(currentSubFiber))
        }
        
        // Create new subscription with current model
        if (!component.subscriptions) return
        const sub = yield* _(component.subscriptions(model))
        
        // Start new subscription fiber
        currentSubFiber = yield* _(
          sub.pipe(
            Stream.takeWhile(() => Effect.gen(function* (_) {
              const currentState = yield* _(Ref.get(state))
              return currentState.running
            })),
            Stream.runForEach(msg => 
              Queue.offer(msgQueue, { _tag: "UserMsg" as const, msg })
            )
          ).pipe(
            Effect.fork
          )
        )
        
        lastModel = model
      })
    
    // Start initial subscription
    const initialState = yield* _(Ref.get(state))
    yield* _(startSubscription(initialState.model))
    
    // Monitor state changes and restart subscriptions when model changes
    yield* _(
      Effect.repeat(
        Effect.gen(function* (_) {
          const currentState = yield* _(Ref.get(state))
          
          if (!currentState.running) {
            // App is shutting down, interrupt subscription and exit
            if (currentSubFiber) {
              yield* _(Fiber.interrupt(currentSubFiber))
            }
            return
          }
          
          // Check if model has changed (using referential equality for performance)
          if (currentState.model !== lastModel) {
            yield* _(startSubscription(currentState.model))
          }
          
          // Small delay to avoid busy waiting
          yield* _(Effect.sleep(16)) // ~60fps model checking
        }),
        Schedule.whileEffect(() => 
          Effect.gen(function* (_) {
            const currentState = yield* _(Ref.get(state))
            return currentState.running
          })
        )
      )
    )
  })

/**
 * Render loop - manages frame-rate controlled rendering
 * 
 * Executes the rendering pipeline at the configured frame rate, generating
 * views from the current model and sending them to the renderer. Includes
 * performance monitoring and frame time tracking.
 * 
 * @param component - Component providing view function
 * @param renderer - Renderer service for output
 * @param state - Ref to current runtime state
 * @param config - Runtime configuration with FPS settings
 * @returns Effect that manages the render loop
 * 
 * @internal
 */
const renderLoop = <Model, Msg>(
  component: Component<Model, Msg>,
  renderer: RendererService,
  state: Ref.Ref<RuntimeState<Model, Msg>>,
  config: RuntimeConfig
) =>
  Effect.gen(function* (_) {
    const targetFrameTime = 1000 / (config.fps || 60)
    
    yield* _(
      Effect.repeat(
        Effect.gen(function* (_) {
          const currentState = yield* _(Ref.get(state))
          if (!currentState.running) return
          
          const startTime = Date.now()
          
          // Get view from component
          const view = component.view(currentState.model)
          
          // Render the view
          yield* _(renderer.beginFrame)
          yield* _(renderer.render(view))
          yield* _(renderer.endFrame)
          
          // Update frame stats
          const endTime = Date.now()
          const frameTime = endTime - startTime
          
          yield* _(Ref.update(state, s => ({
            ...s,
            lastRenderTime: endTime,
            frameCount: s.frameCount + 1
          })))
          
          // Log if frame took too long
          if (config.debug && frameTime > targetFrameTime) {
            yield* _(Effect.logWarning(`Slow frame: ${frameTime}ms`))
          }
        }),
        Schedule.fixed(`${Math.floor(targetFrameTime)} millis`)
      )
    )
  })

/**
 * Cleanup terminal state
 * 
 * Restores the terminal to its original state after application shutdown.
 * Disables mouse support, shows cursor, exits raw mode, and clears the
 * alternate screen if it was used.
 * 
 * @param terminal - Terminal service for state management
 * @param config - Runtime configuration for determining what to cleanup
 * @returns Effect that performs terminal cleanup
 * 
 * @internal
 */
const cleanup = (terminal: TerminalService, config: RuntimeConfig) =>
  Effect.gen(function* (_) {
    // Disable mouse if it was enabled
    if (config.enableMouse) {
      const input = yield* _(InputService)
      yield* _(input.disableMouse)
    }
    
    // Reset terminal state to normal
    yield* _(terminal.write('\x1b[0m')) // Reset all styling
    yield* _(terminal.showCursor)
    yield* _(terminal.setRawMode(false))
    if (config.fullscreen ?? true) {
      yield* _(terminal.setAlternateScreen(false))
    }
    yield* _(terminal.clear)
  })

/**
 * Create and run an application
 * 
 * Convenience function that creates a Runtime instance and immediately
 * starts the application. This is the simplest way to run a TUIX application.
 * 
 * @param component - The root component to run
 * @param config - Optional runtime configuration
 * @returns Effect that runs the complete application
 * 
 * @example
 * ```typescript
 * const program = runApp(myComponent, {
 *   fps: 30,
 *   enableMouse: true,
 *   fullscreen: false
 * })
 * 
 * await Effect.runPromise(Effect.provide(program, services))
 * ```
 */
export const runApp = <Model, Msg>(
  component: Component<Model, Msg>,
  config?: RuntimeConfig
) => {
  const runtime = new Runtime(component, config)
  return runtime.run()
}